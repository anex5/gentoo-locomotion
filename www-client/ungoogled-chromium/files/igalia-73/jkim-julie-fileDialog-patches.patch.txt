From 76fc3d9601c926972d225d1e9450dd7d19643fc4 Mon Sep 17 00:00:00 2001
From: Damian Hobson-Garcia <dhobsong@igel.co.jp>
Date: Tue, 10 Oct 2017 11:34:22 +0900
Subject: [PATCH 02/32] Add support for V4L2VDA on Linux

This patch enables hardware assisted video decoding via the
Chromium V4L2VDA. Including changes when Linux is used. In
order to use this, use_linux_v4l2_only flag should be set
to true.

Signed-off-by: Ryo Kodama <ryo.kodama.vz@renesas.com>

fixup! avoid building not declared formats

"FRAME", "_SLICE",  "V4L2_PIX_FMT_VP9" are not defined in mainline
 Linux headers. This patch avoids building these formats.

Signed-off-by: Ryo Kodama <ryo.kodama.vz@renesas.com>

Issue #437
---
 media/gpu/BUILD.gn                            | 24 +++++++++++--------
 media/gpu/args.gni                            |  4 ++++
 .../gpu_jpeg_decode_accelerator_factory.cc    |  3 ++-
 .../gpu_video_decode_accelerator_factory.cc   |  8 +++++++
 .../gpu_video_decode_accelerator_factory.h    |  2 ++
 media/gpu/v4l2/generic_v4l2_device.cc         |  6 ++++-
 media/gpu/v4l2/v4l2_device.cc                 | 22 +++++++++++++++++
 .../gpu/v4l2/v4l2_video_decode_accelerator.cc |  6 ++++-
 8 files changed, 62 insertions(+), 13 deletions(-)

diff --git a/media/gpu/BUILD.gn b/media/gpu/BUILD.gn
index 1512ff16172b9..68647ada3b1dc 100644
--- a/media/gpu/BUILD.gn
+++ b/media/gpu/BUILD.gn
@@ -16,6 +16,7 @@ buildflag_header("buildflags") {
     "USE_VAAPI=$use_vaapi",
     "USE_V4L2_CODEC=$use_v4l2_codec",
     "USE_LIBV4L2=$use_v4lplugin",
+    "USE_LINUX_V4L2=$use_linux_v4l2_only",
   ]
 }
 
@@ -23,7 +24,7 @@ if (is_mac) {
   import("//build/config/mac/mac_sdk.gni")
 }
 
-if (is_chromeos && use_v4lplugin) {
+if (use_v4lplugin) {
   action("libv4l2_generate_stubs") {
     extra_header = "v4l2/v4l2_stub_header.fragment"
 
@@ -212,12 +213,11 @@ component("gpu") {
     }
   }
 
-  if (use_v4lplugin) {
-    sources += get_target_outputs(":libv4l2_generate_stubs")
-    deps += [ ":libv4l2_generate_stubs" ]
-  }
-
   if (use_v4l2_codec) {
+    if (use_v4lplugin) {
+      sources += get_target_outputs(":libv4l2_generate_stubs")
+      deps += [ ":libv4l2_generate_stubs" ]
+    }
     deps += [
       "//third_party/libyuv",
       "//ui/ozone",
@@ -229,15 +229,19 @@ component("gpu") {
       "v4l2/v4l2_device.h",
       "v4l2/v4l2_image_processor.cc",
       "v4l2/v4l2_image_processor.h",
-      "v4l2/v4l2_jpeg_decode_accelerator.cc",
-      "v4l2/v4l2_jpeg_decode_accelerator.h",
-      "v4l2/v4l2_slice_video_decode_accelerator.cc",
-      "v4l2/v4l2_slice_video_decode_accelerator.h",
       "v4l2/v4l2_video_decode_accelerator.cc",
       "v4l2/v4l2_video_decode_accelerator.h",
       "v4l2/v4l2_video_encode_accelerator.cc",
       "v4l2/v4l2_video_encode_accelerator.h",
     ]
+    if (!use_linux_v4l2_only) {
+      sources += [
+        "v4l2_jpeg_decode_accelerator.cc",
+        "v4l2_jpeg_decode_accelerator.h",
+        "v4l2_slice_video_decode_accelerator.cc",
+        "v4l2_slice_video_decode_accelerator.h",
+      ]
+    }
     libs = [
       "EGL",
       "GLESv2",
diff --git a/media/gpu/args.gni b/media/gpu/args.gni
index df4b0f980ba47..ac740ffeead49 100644
--- a/media/gpu/args.gni
+++ b/media/gpu/args.gni
@@ -10,6 +10,10 @@ declare_args() {
   # platforms which have v4l2 hardware encoder / decoder.
   use_v4l2_codec = false
 
+  # Indicates that only definitions available in the mainline linux kernel
+  # will be used.
+  use_linux_v4l2_only = false
+
   # Indicates if VA-API-based hardware acceleration is to be used. This
   # is typically the case on x86-based ChromeOS devices.
   use_vaapi = false
diff --git a/media/gpu/gpu_jpeg_decode_accelerator_factory.cc b/media/gpu/gpu_jpeg_decode_accelerator_factory.cc
index c0dfb52cc775a..1148e752fcf4c 100644
--- a/media/gpu/gpu_jpeg_decode_accelerator_factory.cc
+++ b/media/gpu/gpu_jpeg_decode_accelerator_factory.cc
@@ -13,7 +13,8 @@
 #include "media/gpu/buildflags.h"
 #include "media/gpu/fake_jpeg_decode_accelerator.h"
 
-#if BUILDFLAG(USE_V4L2_CODEC) && defined(ARCH_CPU_ARM_FAMILY)
+#if BUILDFLAG(USE_V4L2_CODEC) && defined(ARCH_CPU_ARM_FAMILY) && \
+    !BUILDFLAG(USE_LINUX_V4L2)
 #define USE_V4L2_JDA
 #endif
 
diff --git a/media/gpu/gpu_video_decode_accelerator_factory.cc b/media/gpu/gpu_video_decode_accelerator_factory.cc
index 85d2edb507e24..1dff7164fafa7 100644
--- a/media/gpu/gpu_video_decode_accelerator_factory.cc
+++ b/media/gpu/gpu_video_decode_accelerator_factory.cc
@@ -24,7 +24,9 @@
 #endif
 #if BUILDFLAG(USE_V4L2_CODEC)
 #include "media/gpu/v4l2/v4l2_device.h"
+#if !BUILDFLAG(USE_LINUX_V4L2)
 #include "media/gpu/v4l2/v4l2_slice_video_decode_accelerator.h"
+#endif
 #include "media/gpu/v4l2/v4l2_video_decode_accelerator.h"
 #include "ui/gl/gl_surface_egl.h"
 #endif
@@ -98,10 +100,12 @@ GpuVideoDecodeAcceleratorFactory::GetDecoderCapabilities(
   vda_profiles = V4L2VideoDecodeAccelerator::GetSupportedProfiles();
   GpuVideoAcceleratorUtil::InsertUniqueDecodeProfiles(
       vda_profiles, &capabilities.supported_profiles);
+#if !BUILDFLAG(USE_LINUX_V4L2)
   vda_profiles = V4L2SliceVideoDecodeAccelerator::GetSupportedProfiles();
   GpuVideoAcceleratorUtil::InsertUniqueDecodeProfiles(
       vda_profiles, &capabilities.supported_profiles);
 #endif
+#endif
 #if BUILDFLAG(USE_VAAPI)
   vda_profiles = VaapiVideoDecodeAccelerator::GetSupportedProfiles();
   GpuVideoAcceleratorUtil::InsertUniqueDecodeProfiles(
@@ -144,8 +148,10 @@ GpuVideoDecodeAcceleratorFactory::CreateVDA(
 #endif
 #if BUILDFLAG(USE_V4L2_CODEC)
     &GpuVideoDecodeAcceleratorFactory::CreateV4L2VDA,
+#if !BUILDFLAG(USE_LINUX_V4L2)
     &GpuVideoDecodeAcceleratorFactory::CreateV4L2SVDA,
 #endif
+#endif
 #if BUILDFLAG(USE_VAAPI)
     &GpuVideoDecodeAcceleratorFactory::CreateVaapiVDA,
 #endif
@@ -199,6 +205,7 @@ GpuVideoDecodeAcceleratorFactory::CreateV4L2VDA(
   return decoder;
 }
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
 std::unique_ptr<VideoDecodeAccelerator>
 GpuVideoDecodeAcceleratorFactory::CreateV4L2SVDA(
     const gpu::GpuDriverBugWorkarounds& workarounds,
@@ -214,6 +221,7 @@ GpuVideoDecodeAcceleratorFactory::CreateV4L2SVDA(
   return decoder;
 }
 #endif
+#endif
 
 #if BUILDFLAG(USE_VAAPI)
 std::unique_ptr<VideoDecodeAccelerator>
diff --git a/media/gpu/gpu_video_decode_accelerator_factory.h b/media/gpu/gpu_video_decode_accelerator_factory.h
index 3c94bdcdc45c2..e9127bf559645 100644
--- a/media/gpu/gpu_video_decode_accelerator_factory.h
+++ b/media/gpu/gpu_video_decode_accelerator_factory.h
@@ -108,11 +108,13 @@ class MEDIA_GPU_EXPORT GpuVideoDecodeAcceleratorFactory {
       const gpu::GpuDriverBugWorkarounds& workarounds,
       const gpu::GpuPreferences& gpu_preferences,
       MediaLog* media_log) const;
+#if !BUILDFLAG(USE_LINUX_V4L2)
   std::unique_ptr<VideoDecodeAccelerator> CreateV4L2SVDA(
       const gpu::GpuDriverBugWorkarounds& workarounds,
       const gpu::GpuPreferences& gpu_preferences,
       MediaLog* media_log) const;
 #endif
+#endif
 #if BUILDFLAG(USE_VAAPI)
   std::unique_ptr<VideoDecodeAccelerator> CreateVaapiVDA(
       const gpu::GpuDriverBugWorkarounds& workarounds,
diff --git a/media/gpu/v4l2/generic_v4l2_device.cc b/media/gpu/v4l2/generic_v4l2_device.cc
index 45220eb04f875..dd6ce7c71291e 100644
--- a/media/gpu/v4l2/generic_v4l2_device.cc
+++ b/media/gpu/v4l2/generic_v4l2_device.cc
@@ -474,9 +474,13 @@ bool GenericV4L2Device::OpenDevicePath(const std::string& path, Type type) {
     return false;
 
 #if BUILDFLAG(USE_LIBV4L2)
+#if BUILDFLAG(USE_LINUX_V4L2)
+  if (
+#else
   if (type == Type::kEncoder &&
+#endif
       HANDLE_EINTR(v4l2_fd_open(device_fd_.get(), V4L2_DISABLE_CONVERSION)) !=
-          -1) {
+      -1) {
     VLOGF(2) << "Using libv4l2 for " << path;
     use_libv4l2_ = true;
   }
diff --git a/media/gpu/v4l2/v4l2_device.cc b/media/gpu/v4l2/v4l2_device.cc
index 30dc1bd928732..510f23074d20f 100644
--- a/media/gpu/v4l2/v4l2_device.cc
+++ b/media/gpu/v4l2/v4l2_device.cc
@@ -93,6 +93,19 @@ uint32_t V4L2Device::VideoPixelFormatToV4L2PixFmt(VideoPixelFormat format) {
 }
 
 // static
+#if BUILDFLAG(USE_LINUX_V4L2)
+uint32_t V4L2Device::VideoCodecProfileToV4L2PixFmt(VideoCodecProfile profile,
+                                                   bool slice_based) {
+  if (profile >= H264PROFILE_MIN && profile <= H264PROFILE_MAX) {
+    return V4L2_PIX_FMT_H264;
+  } else if (profile >= VP8PROFILE_MIN && profile <= VP8PROFILE_MAX) {
+    return V4L2_PIX_FMT_VP8;
+  } else {
+    LOG(FATAL) << "Add more cases as needed";
+    return 0;
+  }
+}
+#else
 uint32_t V4L2Device::VideoCodecProfileToV4L2PixFmt(VideoCodecProfile profile,
                                                    bool slice_based) {
   if (profile >= H264PROFILE_MIN && profile <= H264PROFILE_MAX) {
@@ -115,6 +128,7 @@ uint32_t V4L2Device::VideoCodecProfileToV4L2PixFmt(VideoCodecProfile profile,
     return 0;
   }
 }
+#endif
 
 // static
 std::vector<VideoCodecProfile> V4L2Device::V4L2PixFmtToVideoCodecProfiles(
@@ -125,7 +139,9 @@ std::vector<VideoCodecProfile> V4L2Device::V4L2PixFmtToVideoCodecProfiles(
 
   switch (pix_fmt) {
     case V4L2_PIX_FMT_H264:
+#if !BUILDFLAG(USE_LINUX_V4L2)
     case V4L2_PIX_FMT_H264_SLICE:
+#endif
       if (is_encoder) {
         // TODO(posciak): need to query the device for supported H.264 profiles,
         // for now choose Main as a sensible default.
@@ -138,11 +154,14 @@ std::vector<VideoCodecProfile> V4L2Device::V4L2PixFmtToVideoCodecProfiles(
       break;
 
     case V4L2_PIX_FMT_VP8:
+#if !BUILDFLAG(USE_LINUX_V4L2)
     case V4L2_PIX_FMT_VP8_FRAME:
+#endif
       min_profile = VP8PROFILE_MIN;
       max_profile = VP8PROFILE_MAX;
       break;
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
     case V4L2_PIX_FMT_VP9:
     case V4L2_PIX_FMT_VP9_FRAME:
       // TODO(posciak): https://crbug.com/819930 Query supported profiles.
@@ -150,6 +169,7 @@ std::vector<VideoCodecProfile> V4L2Device::V4L2PixFmtToVideoCodecProfiles(
       min_profile = VP9PROFILE_PROFILE0;
       max_profile = VP9PROFILE_PROFILE0;
       break;
+#endif
 
     default:
       VLOGF(1) << "Unhandled pixelformat " << std::hex << "0x" << pix_fmt;
@@ -179,8 +199,10 @@ uint32_t V4L2Device::V4L2PixFmtToDrmFormat(uint32_t format) {
     case V4L2_PIX_FMT_RGB32:
       return DRM_FORMAT_ARGB8888;
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
     case V4L2_PIX_FMT_MT21:
       return DRM_FORMAT_MT21;
+#endif
 
     default:
       DVLOGF(1) << "Unrecognized format " << std::hex << "0x" << format;
diff --git a/media/gpu/v4l2/v4l2_video_decode_accelerator.cc b/media/gpu/v4l2/v4l2_video_decode_accelerator.cc
index 5308e95ed17d9..ea3fb1e8c05c4 100644
--- a/media/gpu/v4l2/v4l2_video_decode_accelerator.cc
+++ b/media/gpu/v4l2/v4l2_video_decode_accelerator.cc
@@ -25,6 +25,7 @@
 #include "media/base/media_switches.h"
 #include "media/base/scopedfd_helper.h"
 #include "media/base/unaligned_shared_memory.h"
+#include "media/gpu/features.h"
 #include "media/gpu/v4l2/v4l2_image_processor.h"
 #include "media/video/h264_parser.h"
 #include "ui/gfx/geometry/rect.h"
@@ -66,7 +67,10 @@ namespace media {
 
 // static
 const uint32_t V4L2VideoDecodeAccelerator::supported_input_fourccs_[] = {
-    V4L2_PIX_FMT_H264, V4L2_PIX_FMT_VP8, V4L2_PIX_FMT_VP9,
+    V4L2_PIX_FMT_H264, V4L2_PIX_FMT_VP8,
+#if !BUILDFLAG(USE_LINUX_V4L2)
+    V4L2_PIX_FMT_VP9,
+#endif
 };
 
 struct V4L2VideoDecodeAccelerator::BitstreamBufferRef {

From ccdb60af9fc800bd0ef4e30fdf36400cfdad62f5 Mon Sep 17 00:00:00 2001
From: Damian Hobson-Garcia <dhobsong@igel.co.jp>
Date: Wed, 21 Mar 2018 13:18:17 +0200
Subject: [PATCH 03/32] Add mmap via libv4l to generic_v4l2_device

Issue #437
---
 media/gpu/v4l2/generic_v4l2_device.cc | 10 ++++++++++
 media/gpu/v4l2/v4l2.sig               |  2 ++
 2 files changed, 12 insertions(+)

diff --git a/media/gpu/v4l2/generic_v4l2_device.cc b/media/gpu/v4l2/generic_v4l2_device.cc
index dd6ce7c71291e..6a6c847eeb22a 100644
--- a/media/gpu/v4l2/generic_v4l2_device.cc
+++ b/media/gpu/v4l2/generic_v4l2_device.cc
@@ -102,10 +102,20 @@ void* GenericV4L2Device::Mmap(void* addr,
                               int flags,
                               unsigned int offset) {
   DCHECK(device_fd_.is_valid());
+#if BUILDFLAG(USE_LIBV4L2)
+  if (use_libv4l2_)
+    return v4l2_mmap(addr, len, prot, flags, device_fd_.get(), offset);
+#endif
   return mmap(addr, len, prot, flags, device_fd_.get(), offset);
 }
 
 void GenericV4L2Device::Munmap(void* addr, unsigned int len) {
+#if BUILDFLAG(USE_LIBV4L2)
+  if (use_libv4l2_) {
+    v4l2_munmap(addr, len);
+    return;
+  }
+#endif
   munmap(addr, len);
 }
 
diff --git a/media/gpu/v4l2/v4l2.sig b/media/gpu/v4l2/v4l2.sig
index 4269fb48d592d..71b5b3787d566 100644
--- a/media/gpu/v4l2/v4l2.sig
+++ b/media/gpu/v4l2/v4l2.sig
@@ -8,3 +8,5 @@
 LIBV4L_PUBLIC int v4l2_close(int fd);
 LIBV4L_PUBLIC int v4l2_ioctl(int fd, unsigned long int request, ...);
 LIBV4L_PUBLIC int v4l2_fd_open(int fd, int v4l2_flags);
+LIBV4L_PUBLIC void *v4l2_mmap(void *start, size_t length, int prot, int flags, int fd, int64_t offset);
+LIBV4L_PUBLIC int v4l2_munmap(void *_start, size_t length);

From d9ee14071c22ad7e034b2167bc6a33b297553d8c Mon Sep 17 00:00:00 2001
From: Maksim Sisov <msisov@igalia.com>
Date: Tue, 8 May 2018 16:13:07 +0300
Subject: [PATCH 04/32] Make window interactions (move, resize, double click
 and etc) working

This cl fixes interactions with window's non client area.

WindowEventFilter is now set in DesktopWindowTreeHostPlatform,
and events are properly marked as non client to avoid mouse pressed
handler be kept until release event is sent (which isn't sent at all.
See wayland/x11 protocol documentation).

Basically, it's almost the same as we had with mus.

Issue: #419

fixup! [ozone/wayland/x11] Make window interactions (move, resize, double click and etc) working

Compilation fixes.

fixup! Make window interactions (move, resize, double click and etc) working

Make sure that compound event filter is destroyed properly.

It may happen that OnClosed is closed, which leads to
DesktopNativeWidgetAura destructions. There is also another path
when DesktopNativeWidgetAura can be destroyed - CloseNow. That is,
if OnClosed has not been closed, CloseNow proceeds and destructs
DesktopNativeWidgetAura.

This patch makes it sure that the non_client_event_filter_ is destroyed
in any case.

fixup! Make window interactions (move, resize, double click and etc) working

Compilation fixes.
---
 ui/ozone/platform/drm/host/drm_window_host.cc |  3 +
 ui/ozone/platform/drm/host/drm_window_host.h  |  2 +
 .../platform/wayland/wayland_connection.cc    |  5 ++
 .../platform/wayland/wayland_connection.h     |  7 ++
 ui/ozone/platform/wayland/wayland_pointer.cc  |  5 ++
 ui/ozone/platform/wayland/wayland_pointer.h   |  1 +
 ui/ozone/platform/wayland/wayland_window.cc   | 13 +++
 ui/ozone/platform/wayland/wayland_window.h    |  2 +
 .../wayland/xdg_surface_wrapper_v5.cc         | 58 +++++++++---
 .../wayland/xdg_surface_wrapper_v6.cc         | 67 +++++++++++---
 ui/platform_window/platform_window.h          |  5 ++
 ui/platform_window/stub/stub_window.cc        |  4 +
 ui/platform_window/stub/stub_window.h         |  2 +
 ui/platform_window/x11/x11_window_base.cc     | 88 ++++++++++++++++++-
 ui/platform_window/x11/x11_window_base.h      |  2 +
 .../desktop_aura/desktop_window_tree_host.h   |  5 ++
 .../desktop_window_tree_host_platform.cc      | 54 ++++++++++++
 .../desktop_window_tree_host_platform.h       |  8 ++
 .../desktop_aura/window_event_filter.cc       | 32 ++++++-
 19 files changed, 338 insertions(+), 25 deletions(-)

diff --git a/ui/ozone/platform/drm/host/drm_window_host.cc b/ui/ozone/platform/drm/host/drm_window_host.cc
index 66e8b55529071..4b9684fdf6fe7 100644
--- a/ui/ozone/platform/drm/host/drm_window_host.cc
+++ b/ui/ozone/platform/drm/host/drm_window_host.cc
@@ -146,6 +146,9 @@ gfx::Rect DrmWindowHost::GetRestoredBoundsInPixels() const {
   return gfx::Rect();
 }
 
+void DrmWindowHost::StartWindowMoveOrResize(int hittest,
+                                            gfx::Point pointer_location) {}
+
 bool DrmWindowHost::CanDispatchEvent(const PlatformEvent& event) {
   DCHECK(event);
 
diff --git a/ui/ozone/platform/drm/host/drm_window_host.h b/ui/ozone/platform/drm/host/drm_window_host.h
index 073a1ade8e835..636eb7170ea53 100644
--- a/ui/ozone/platform/drm/host/drm_window_host.h
+++ b/ui/ozone/platform/drm/host/drm_window_host.h
@@ -79,6 +79,8 @@ class DrmWindowHost : public PlatformWindow,
   PlatformImeController* GetPlatformImeController() override;
   void SetRestoredBoundsInPixels(const gfx::Rect& bounds) override;
   gfx::Rect GetRestoredBoundsInPixels() const override;
+  void StartWindowMoveOrResize(int hittest,
+                               gfx::Point pointer_location) override;
 
   // PlatformEventDispatcher:
   bool CanDispatchEvent(const PlatformEvent& event) override;
diff --git a/ui/ozone/platform/wayland/wayland_connection.cc b/ui/ozone/platform/wayland/wayland_connection.cc
index 4718cf2bb8c19..c755fb160e676 100644
--- a/ui/ozone/platform/wayland/wayland_connection.cc
+++ b/ui/ozone/platform/wayland/wayland_connection.cc
@@ -349,6 +349,11 @@ void WaylandConnection::SetTerminateGpuCallback(
   terminate_gpu_cb_ = std::move(terminate_callback);
 }
 
+void WaylandConnection::ResetPointerFlags() {
+  if (pointer_)
+    pointer_->ResetFlags();
+}
+
 void WaylandConnection::GetAvailableMimeTypes(
     ClipboardDelegate::GetMimeTypesClosure callback) {
   std::move(callback).Run(data_device_->GetAvailableMimeTypes());
diff --git a/ui/ozone/platform/wayland/wayland_connection.h b/ui/ozone/platform/wayland/wayland_connection.h
index ad3543d0feaf2..91a0277e4543d 100644
--- a/ui/ozone/platform/wayland/wayland_connection.h
+++ b/ui/ozone/platform/wayland/wayland_connection.h
@@ -125,6 +125,13 @@ class WaylandConnection : public PlatformEventSource,
   void SetTerminateGpuCallback(
       base::OnceCallback<void(std::string)> terminate_gpu_cb);
 
+  // Resets flags and keyboard modifiers.
+  //
+  // This method is specially handy for cases when the WaylandPointer state is
+  // modified by a POINTER_DOWN event, but the respective POINTER_UP event is
+  // not delivered.
+  void ResetPointerFlags();
+
  private:
   void Flush();
   void DispatchUiEvent(Event* event);
diff --git a/ui/ozone/platform/wayland/wayland_pointer.cc b/ui/ozone/platform/wayland/wayland_pointer.cc
index 8079524d6d930..42384c01bd4cf 100644
--- a/ui/ozone/platform/wayland/wayland_pointer.cc
+++ b/ui/ozone/platform/wayland/wayland_pointer.cc
@@ -216,4 +216,9 @@ int WaylandPointer::GetFlagsWithKeyboardModifiers() {
   return flags_;
 }
 
+void WaylandPointer::ResetFlags() {
+  flags_ = 0;
+  keyboard_modifiers_ = 0;
+}
+
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/wayland_pointer.h b/ui/ozone/platform/wayland/wayland_pointer.h
index 50f60f4a90310..0c398d19a83ee 100644
--- a/ui/ozone/platform/wayland/wayland_pointer.h
+++ b/ui/ozone/platform/wayland/wayland_pointer.h
@@ -27,6 +27,7 @@ class WaylandPointer {
   }
 
   int GetFlagsWithKeyboardModifiers();
+  void ResetFlags();
 
   WaylandCursor* cursor() { return cursor_.get(); }
 
diff --git a/ui/ozone/platform/wayland/wayland_window.cc b/ui/ozone/platform/wayland/wayland_window.cc
index c0d8847a028d8..53f5af663bab1 100644
--- a/ui/ozone/platform/wayland/wayland_window.cc
+++ b/ui/ozone/platform/wayland/wayland_window.cc
@@ -8,6 +8,7 @@
 
 #include "base/bind.h"
 #include "ui/base/cursor/ozone/bitmap_cursor_factory_ozone.h"
+#include "ui/base/hit_test.h"
 #include "ui/events/event.h"
 #include "ui/events/event_utils.h"
 #include "ui/events/ozone/events_ozone.h"
@@ -386,6 +387,18 @@ gfx::Rect WaylandWindow::GetRestoredBoundsInPixels() const {
   return restored_bounds_;
 }
 
+void WaylandWindow::StartWindowMoveOrResize(int hittest,
+                                            gfx::Point pointer_location) {
+  DCHECK(xdg_surface_);
+
+  connection_->ResetPointerFlags();
+
+  if (hittest == HTCAPTION)
+    xdg_surface_->SurfaceMove(connection_);
+  else
+    xdg_surface_->SurfaceResize(connection_, hittest);
+}
+
 bool WaylandWindow::CanDispatchEvent(const PlatformEvent& event) {
   // This window is a nested popup window, all the events must be forwarded
   // to the main popup window.
diff --git a/ui/ozone/platform/wayland/wayland_window.h b/ui/ozone/platform/wayland/wayland_window.h
index d652e896aef20..95e5e3caed6b3 100644
--- a/ui/ozone/platform/wayland/wayland_window.h
+++ b/ui/ozone/platform/wayland/wayland_window.h
@@ -88,6 +88,8 @@ class WaylandWindow : public PlatformWindow, public PlatformEventDispatcher {
   PlatformImeController* GetPlatformImeController() override;
   void SetRestoredBoundsInPixels(const gfx::Rect& bounds) override;
   gfx::Rect GetRestoredBoundsInPixels() const override;
+  void StartWindowMoveOrResize(int hittest,
+                               gfx::Point pointer_location) override;
 
   // PlatformEventDispatcher
   bool CanDispatchEvent(const PlatformEvent& event) override;
diff --git a/ui/ozone/platform/wayland/xdg_surface_wrapper_v5.cc b/ui/ozone/platform/wayland/xdg_surface_wrapper_v5.cc
index eb8f289f0193f..8cdf60d5bfc59 100644
--- a/ui/ozone/platform/wayland/xdg_surface_wrapper_v5.cc
+++ b/ui/ozone/platform/wayland/xdg_surface_wrapper_v5.cc
@@ -7,11 +7,52 @@
 #include <xdg-shell-unstable-v5-client-protocol.h>
 
 #include "base/strings/utf_string_conversions.h"
+#include "ui/base/hit_test.h"
 #include "ui/ozone/platform/wayland/wayland_connection.h"
 #include "ui/ozone/platform/wayland/wayland_window.h"
 
 namespace ui {
 
+namespace {
+
+// Identifies the direction of the "hittest" for Wayland.
+bool IdentifyDirection(int hittest, int* direction) {
+  DCHECK(direction);
+  *direction = -1;
+  switch (hittest) {
+    case HTBOTTOM:
+      *direction = xdg_surface_resize_edge::XDG_SURFACE_RESIZE_EDGE_BOTTOM;
+      break;
+    case HTBOTTOMLEFT:
+      *direction = xdg_surface_resize_edge::XDG_SURFACE_RESIZE_EDGE_BOTTOM_LEFT;
+      break;
+    case HTBOTTOMRIGHT:
+      *direction =
+          xdg_surface_resize_edge::XDG_SURFACE_RESIZE_EDGE_BOTTOM_RIGHT;
+      break;
+    case HTLEFT:
+      *direction = xdg_surface_resize_edge::XDG_SURFACE_RESIZE_EDGE_LEFT;
+      break;
+    case HTRIGHT:
+      *direction = xdg_surface_resize_edge::XDG_SURFACE_RESIZE_EDGE_RIGHT;
+      break;
+    case HTTOP:
+      *direction = xdg_surface_resize_edge::XDG_SURFACE_RESIZE_EDGE_TOP;
+      break;
+    case HTTOPLEFT:
+      *direction = xdg_surface_resize_edge::XDG_SURFACE_RESIZE_EDGE_TOP_LEFT;
+      break;
+    case HTTOPRIGHT:
+      *direction = xdg_surface_resize_edge::XDG_SURFACE_RESIZE_EDGE_TOP_RIGHT;
+      break;
+    default:
+      return false;
+  }
+  return true;
+}
+
+}  // namespace
+
 XDGSurfaceWrapperV5::XDGSurfaceWrapperV5(WaylandWindow* wayland_window)
     : wayland_window_(wayland_window) {}
 
@@ -53,20 +94,17 @@ void XDGSurfaceWrapperV5::SetMinimized() {
 }
 
 void XDGSurfaceWrapperV5::SurfaceMove(WaylandConnection* connection) {
-  NOTIMPLEMENTED();
+  xdg_surface_move(xdg_surface_.get(), connection->seat(),
+                   connection->serial());
 }
 
 void XDGSurfaceWrapperV5::SurfaceResize(WaylandConnection* connection,
                                         uint32_t hittest) {
-  // TODO(msisov): implement resizing.
-  /*
-   * int direction;
-   * if (!IdentifyDirection(hittest, &direction))
-   *   return;
-   * xdg_surface_resize(xdg_surface_.get(), connection->seat(),
-   *                    connection->serial(), direction);
-   */
-  NOTIMPLEMENTED();
+  int direction;
+  if (!IdentifyDirection(hittest, &direction))
+    return;
+  xdg_surface_resize(xdg_surface_.get(), connection->seat(),
+                     connection->serial(), direction);
 }
 
 void XDGSurfaceWrapperV5::SetTitle(const base::string16& title) {
diff --git a/ui/ozone/platform/wayland/xdg_surface_wrapper_v6.cc b/ui/ozone/platform/wayland/xdg_surface_wrapper_v6.cc
index 14ab84344cfba..59be9a51eb354 100644
--- a/ui/ozone/platform/wayland/xdg_surface_wrapper_v6.cc
+++ b/ui/ozone/platform/wayland/xdg_surface_wrapper_v6.cc
@@ -7,11 +7,59 @@
 #include <xdg-shell-unstable-v6-client-protocol.h>
 
 #include "base/strings/utf_string_conversions.h"
+#include "ui/base/hit_test.h"
 #include "ui/ozone/platform/wayland/wayland_connection.h"
 #include "ui/ozone/platform/wayland/wayland_window.h"
 
 namespace ui {
 
+namespace {
+
+// Identifies the direction of the "hittest" for Wayland.
+bool IdentifyDirection(int hittest, int* direction) {
+  DCHECK(direction);
+  *direction = -1;
+  switch (hittest) {
+    case HTBOTTOM:
+      *direction =
+          zxdg_toplevel_v6_resize_edge::ZXDG_TOPLEVEL_V6_RESIZE_EDGE_BOTTOM;
+      break;
+    case HTBOTTOMLEFT:
+      *direction = zxdg_toplevel_v6_resize_edge::
+          ZXDG_TOPLEVEL_V6_RESIZE_EDGE_BOTTOM_LEFT;
+      break;
+    case HTBOTTOMRIGHT:
+      *direction = zxdg_toplevel_v6_resize_edge::
+          ZXDG_TOPLEVEL_V6_RESIZE_EDGE_BOTTOM_RIGHT;
+      break;
+    case HTLEFT:
+      *direction =
+          zxdg_toplevel_v6_resize_edge::ZXDG_TOPLEVEL_V6_RESIZE_EDGE_LEFT;
+      break;
+    case HTRIGHT:
+      *direction =
+          zxdg_toplevel_v6_resize_edge::ZXDG_TOPLEVEL_V6_RESIZE_EDGE_RIGHT;
+      break;
+    case HTTOP:
+      *direction =
+          zxdg_toplevel_v6_resize_edge::ZXDG_TOPLEVEL_V6_RESIZE_EDGE_TOP;
+      break;
+    case HTTOPLEFT:
+      *direction =
+          zxdg_toplevel_v6_resize_edge::ZXDG_TOPLEVEL_V6_RESIZE_EDGE_TOP_LEFT;
+      break;
+    case HTTOPRIGHT:
+      *direction =
+          zxdg_toplevel_v6_resize_edge::ZXDG_TOPLEVEL_V6_RESIZE_EDGE_TOP_RIGHT;
+      break;
+    default:
+      return false;
+  }
+  return true;
+}
+
+}  // namespace
+
 XDGSurfaceWrapperV6::XDGSurfaceWrapperV6(WaylandWindow* wayland_window)
     : wayland_window_(wayland_window) {}
 
@@ -82,20 +130,19 @@ void XDGSurfaceWrapperV6::SetMinimized() {
 }
 
 void XDGSurfaceWrapperV6::SurfaceMove(WaylandConnection* connection) {
-  NOTIMPLEMENTED();
+  DCHECK(zxdg_toplevel_v6_);
+  zxdg_toplevel_v6_move(zxdg_toplevel_v6_.get(), connection->seat(),
+                        connection->serial());
 }
 
 void XDGSurfaceWrapperV6::SurfaceResize(WaylandConnection* connection,
                                         uint32_t hittest) {
-  // TODO(msisov): implement resizing.
-  /*
-   * int direction;
-   * if (!IdentifyDirection(hittest, &direction))
-   *   return;
-   * xdg_surface_resize(xdg_surface_.get(), connection->seat(),
-   *                    connection->serial(), direction);
-   */
-  NOTIMPLEMENTED();
+  int direction;
+  if (!IdentifyDirection(hittest, &direction))
+    return;
+  DCHECK(zxdg_toplevel_v6_);
+  zxdg_toplevel_v6_resize(zxdg_toplevel_v6_.get(), connection->seat(),
+                          connection->serial(), direction);
 }
 
 void XDGSurfaceWrapperV6::SetTitle(const base::string16& title) {
diff --git a/ui/platform_window/platform_window.h b/ui/platform_window/platform_window.h
index 181ad85fd7061..e8b3d11b64625 100644
--- a/ui/platform_window/platform_window.h
+++ b/ui/platform_window/platform_window.h
@@ -70,6 +70,11 @@ class PlatformWindow {
   // Sets and gets the restored bounds of the platform-window.
   virtual void SetRestoredBoundsInPixels(const gfx::Rect& bounds) = 0;
   virtual gfx::Rect GetRestoredBoundsInPixels() const = 0;
+
+  // The window manager starts interactive drag or resize of a window based on
+  // the |hittest|.
+  virtual void StartWindowMoveOrResize(int hittest,
+                                       gfx::Point pointer_location) = 0;
 };
 
 }  // namespace ui
diff --git a/ui/platform_window/stub/stub_window.cc b/ui/platform_window/stub/stub_window.cc
index 154d3e25248fd..23e8c4568da23 100644
--- a/ui/platform_window/stub/stub_window.cc
+++ b/ui/platform_window/stub/stub_window.cc
@@ -80,4 +80,8 @@ gfx::Rect StubWindow::GetRestoredBoundsInPixels() const {
   return gfx::Rect();
 }
 
+void StubWindow::StartWindowMoveOrResize(int hittest,
+                                         gfx::Point pointer_location) {}
+
+
 }  // namespace ui
diff --git a/ui/platform_window/stub/stub_window.h b/ui/platform_window/stub/stub_window.h
index f46c8aa955d11..31bf299511396 100644
--- a/ui/platform_window/stub/stub_window.h
+++ b/ui/platform_window/stub/stub_window.h
@@ -50,6 +50,8 @@ class STUB_WINDOW_EXPORT StubWindow : public PlatformWindow {
   PlatformImeController* GetPlatformImeController() override;
   void SetRestoredBoundsInPixels(const gfx::Rect& bounds) override;
   gfx::Rect GetRestoredBoundsInPixels() const override;
+  void StartWindowMoveOrResize(int hittest,
+                               gfx::Point pointer_location) override;
 
   PlatformWindowDelegate* delegate_;
   gfx::Rect bounds_;
diff --git a/ui/platform_window/x11/x11_window_base.cc b/ui/platform_window/x11/x11_window_base.cc
index bcbd46cf382e8..6e9b7995dd30f 100644
--- a/ui/platform_window/x11/x11_window_base.cc
+++ b/ui/platform_window/x11/x11_window_base.cc
@@ -7,6 +7,7 @@
 #include <string>
 
 #include "base/strings/utf_string_conversions.h"
+#include "ui/base/hit_test.h"
 #include "ui/base/platform_window_defaults.h"
 #include "ui/base/x/x11_util.h"
 #include "ui/base/x/x11_window_event_manager.h"
@@ -23,6 +24,56 @@ namespace ui {
 
 namespace {
 
+// These constants are defined in the Extended Window Manager Hints
+// standard...and aren't in any header that I can find.
+const int k_NET_WM_MOVERESIZE_SIZE_TOPLEFT = 0;
+const int k_NET_WM_MOVERESIZE_SIZE_TOP = 1;
+const int k_NET_WM_MOVERESIZE_SIZE_TOPRIGHT = 2;
+const int k_NET_WM_MOVERESIZE_SIZE_RIGHT = 3;
+const int k_NET_WM_MOVERESIZE_SIZE_BOTTOMRIGHT = 4;
+const int k_NET_WM_MOVERESIZE_SIZE_BOTTOM = 5;
+const int k_NET_WM_MOVERESIZE_SIZE_BOTTOMLEFT = 6;
+const int k_NET_WM_MOVERESIZE_SIZE_LEFT = 7;
+const int k_NET_WM_MOVERESIZE_MOVE = 8;
+
+// Identifies the direction of the "hittest" for X11.
+bool IdentifyDirection(int hittest, int* direction) {
+  DCHECK(direction);
+  *direction = -1;
+  switch (hittest) {
+    case HTBOTTOM:
+      *direction = k_NET_WM_MOVERESIZE_SIZE_BOTTOM;
+      break;
+    case HTBOTTOMLEFT:
+      *direction = k_NET_WM_MOVERESIZE_SIZE_BOTTOMLEFT;
+      break;
+    case HTBOTTOMRIGHT:
+      *direction = k_NET_WM_MOVERESIZE_SIZE_BOTTOMRIGHT;
+      break;
+    case HTCAPTION:
+      *direction = k_NET_WM_MOVERESIZE_MOVE;
+      break;
+    case HTLEFT:
+      *direction = k_NET_WM_MOVERESIZE_SIZE_LEFT;
+      break;
+    case HTRIGHT:
+      *direction = k_NET_WM_MOVERESIZE_SIZE_RIGHT;
+      break;
+    case HTTOP:
+      *direction = k_NET_WM_MOVERESIZE_SIZE_TOP;
+      break;
+    case HTTOPLEFT:
+      *direction = k_NET_WM_MOVERESIZE_SIZE_TOPLEFT;
+      break;
+    case HTTOPRIGHT:
+      *direction = k_NET_WM_MOVERESIZE_SIZE_TOPRIGHT;
+      break;
+    default:
+      return false;
+  }
+  return true;
+}
+
 XID FindXEventTarget(const XEvent& xev) {
   XID target = xev.xany.window;
   if (xev.type == GenericEvent)
@@ -82,10 +133,10 @@ void X11WindowBase::Create() {
 
   // Setup XInput event mask.
   long event_mask = ButtonPressMask | ButtonReleaseMask | FocusChangeMask |
-                    KeyPressMask | KeyReleaseMask | EnterWindowMask |
-                    LeaveWindowMask | ExposureMask | VisibilityChangeMask |
-                    StructureNotifyMask | PropertyChangeMask |
-                    PointerMotionMask;
+                    KeyPressMask | KeyReleaseMask | ExposureMask |
+                    VisibilityChangeMask | StructureNotifyMask |
+                    PropertyChangeMask | PointerMotionMask;
+
   xwindow_events_.reset(new ui::XScopedEventSelector(xwindow_, event_mask));
 
   // Setup XInput2 event mask.
@@ -310,6 +361,35 @@ gfx::Rect X11WindowBase::GetRestoredBoundsInPixels() const {
   return gfx::Rect();
 }
 
+void X11WindowBase::StartWindowMoveOrResize(int hittest,
+                                            gfx::Point pointer_location) {
+  int direction;
+  if (!IdentifyDirection(hittest, &direction))
+    return;
+
+  // We most likely have an implicit grab right here. We need to dump it
+  // because what we're about to do is tell the window manager
+  // that it's now responsible for moving the window around; it immediately
+  // grabs when it receives the event below.
+  XUngrabPointer(xdisplay_, x11::CurrentTime);
+
+  XEvent event;
+  memset(&event, 0, sizeof(event));
+  event.xclient.type = ClientMessage;
+  event.xclient.display = xdisplay_;
+  event.xclient.window = xwindow_;
+  event.xclient.message_type = gfx::GetAtom("_NET_WM_MOVERESIZE");
+  event.xclient.format = 32;
+  event.xclient.data.l[0] = pointer_location.x();
+  event.xclient.data.l[1] = pointer_location.y();
+  event.xclient.data.l[2] = direction;
+  event.xclient.data.l[3] = 0;
+  event.xclient.data.l[4] = 0;
+
+  XSendEvent(xdisplay_, xroot_window_, x11::False,
+             SubstructureRedirectMask | SubstructureNotifyMask, &event);
+}
+
 void X11WindowBase::UnConfineCursor() {
   if (!has_pointer_barriers_)
     return;
diff --git a/ui/platform_window/x11/x11_window_base.h b/ui/platform_window/x11/x11_window_base.h
index 10f6a818c332d..46cc446826b2c 100644
--- a/ui/platform_window/x11/x11_window_base.h
+++ b/ui/platform_window/x11/x11_window_base.h
@@ -50,6 +50,8 @@ class X11_WINDOW_EXPORT X11WindowBase : public PlatformWindow {
   PlatformImeController* GetPlatformImeController() override;
   void SetRestoredBoundsInPixels(const gfx::Rect& bounds) override;
   gfx::Rect GetRestoredBoundsInPixels() const override;
+  void StartWindowMoveOrResize(int hittest,
+                               gfx::Point pointer_location) override;
 
  protected:
   // Creates new underlying XWindow. Does not map XWindow.
diff --git a/ui/views/widget/desktop_aura/desktop_window_tree_host.h b/ui/views/widget/desktop_aura/desktop_window_tree_host.h
index 8a909991f7d23..c26762cab0c65 100644
--- a/ui/views/widget/desktop_aura/desktop_window_tree_host.h
+++ b/ui/views/widget/desktop_aura/desktop_window_tree_host.h
@@ -187,6 +187,11 @@ class VIEWS_EXPORT DesktopWindowTreeHost {
 
   // Returns whether a VisibilityController should be created.
   virtual bool ShouldCreateVisibilityController() const = 0;
+
+  // TODO(msisov, jkim): make this pure virtual when upstreaming.
+  // Starts moving or resizing native window based on hittests.
+  virtual void StartWindowMoveOrResize(int hittest,
+                                       gfx::Point pointer_location) {}
 };
 
 }  // namespace views
diff --git a/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.cc b/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.cc
index dcf1d7d40c203..bf6f44cae74ad 100644
--- a/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.cc
+++ b/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.cc
@@ -6,6 +6,7 @@
 
 #include "ui/aura/client/drag_drop_client.h"
 #include "ui/aura/client/transient_window_client.h"
+#include "ui/base/hit_test.h"
 #include "ui/display/display.h"
 #include "ui/display/screen.h"
 #include "ui/gfx/geometry/dip_util.h"
@@ -13,6 +14,7 @@
 #include "ui/platform_window/platform_window_init_properties.h"
 #include "ui/views/corewm/tooltip_aura.h"
 #include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
+#include "ui/views/widget/desktop_aura/window_event_filter.h"
 #include "ui/views/widget/widget_aura_utils.h"
 #include "ui/views/window/native_frame_view.h"
 #include "ui/wm/core/window_util.h"
@@ -91,6 +93,16 @@ void DesktopWindowTreeHostPlatform::Init(const Widget::InitParams& params) {
 void DesktopWindowTreeHostPlatform::OnNativeWidgetCreated(
     const Widget::InitParams& params) {
   native_widget_delegate_->OnNativeWidgetCreated(true);
+
+  // Setup a non_client_window_event_filter, which handles resize/move, double
+  // click and other events.
+  std::unique_ptr<ui::EventHandler> handler(new WindowEventFilter(this));
+  wm::CompoundEventFilter* compound_event_filter =
+      desktop_native_widget_aura_->root_window_event_filter();
+  if (non_client_window_event_filter_)
+    compound_event_filter->RemoveHandler(handler.get());
+  compound_event_filter->AddHandler(handler.get());
+  non_client_window_event_filter_ = std::move(handler);
 }
 
 void DesktopWindowTreeHostPlatform::OnWidgetInitDone() {}
@@ -137,6 +149,9 @@ void DesktopWindowTreeHostPlatform::CloseNow() {
 
   native_widget_delegate_->OnNativeWidgetDestroying();
 
+  if (non_client_window_event_filter_)
+    RemoveNonClientEventFilter();
+
   got_on_closed_ = true;
   desktop_native_widget_aura_->OnHostClosed();
 }
@@ -449,7 +464,38 @@ bool DesktopWindowTreeHostPlatform::ShouldCreateVisibilityController() const {
   return true;
 }
 
+void DesktopWindowTreeHostPlatform::StartWindowMoveOrResize(
+    int hittest,
+    gfx::Point pointer_location) {
+  platform_window()->StartWindowMoveOrResize(hittest, pointer_location);
+}
+
+void DesktopWindowTreeHostPlatform::DispatchEvent(ui::Event* event) {
+  // We need to make sure it is appropriately marked as non-client if it's in
+  // the non client area, or otherwise, we can get into a state where the a
+  // window is set as the |mouse_pressed_handler_| in window_event_dispatcher.cc
+  // despite the mouse button being released. X11 also does the same.
+  //
+  // See comment in DesktopWindowTreeHostX11::DispatchMouseEvent for details.
+  aura::Window* content_window = desktop_native_widget_aura_->content_window();
+  if (content_window && content_window->delegate()) {
+    if (event->IsMouseEvent()) {
+      ui::MouseEvent* mouse_event = event->AsMouseEvent();
+      int flags = mouse_event->flags();
+      int hit_test_code = content_window->delegate()->GetNonClientComponent(
+          mouse_event->location());
+      if (hit_test_code != HTCLIENT && hit_test_code != HTNOWHERE)
+        flags |= ui::EF_IS_NON_CLIENT;
+      mouse_event->set_flags(flags);
+    }
+  }
+
+  WindowTreeHostPlatform::DispatchEvent(event);
+}
+
 void DesktopWindowTreeHostPlatform::OnClosed() {
+  RemoveNonClientEventFilter();
+
   got_on_closed_ = true;
   desktop_native_widget_aura_->OnHostClosed();
 }
@@ -492,6 +538,14 @@ void DesktopWindowTreeHostPlatform::Relayout() {
   widget->GetRootView()->Layout();
 }
 
+void DesktopWindowTreeHostPlatform::RemoveNonClientEventFilter() {
+  // Remove the event listeners we've installed. We need to remove these
+  // because otherwise we get assert during ~WindowEventDispatcher().
+  desktop_native_widget_aura_->root_window_event_filter()->RemoveHandler(
+      non_client_window_event_filter_.get());
+  non_client_window_event_filter_.reset();
+}
+
 Widget* DesktopWindowTreeHostPlatform::GetWidget() {
   return native_widget_delegate_->AsWidget();
 }
diff --git a/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.h b/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.h
index b6219dd00a75d..8af0ce17833b6 100644
--- a/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.h
+++ b/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.h
@@ -88,8 +88,11 @@ class VIEWS_EXPORT DesktopWindowTreeHostPlatform
   bool ShouldUpdateWindowTransparency() const override;
   bool ShouldUseDesktopNativeCursorManager() const override;
   bool ShouldCreateVisibilityController() const override;
+  void StartWindowMoveOrResize(int hittest,
+                               gfx::Point pointer_location) override;
 
   // WindowTreeHostPlatform:
+  void DispatchEvent(ui::Event* event) override;
   void OnClosed() override;
   void OnWindowStateChanged(ui::PlatformWindowState new_state) override;
   void OnCloseRequest() override;
@@ -98,6 +101,8 @@ class VIEWS_EXPORT DesktopWindowTreeHostPlatform
  private:
   void Relayout();
 
+  void RemoveNonClientEventFilter();
+
   Widget* GetWidget();
 
   gfx::Rect ToDIPRect(const gfx::Rect& rect_in_pixels) const;
@@ -113,6 +118,9 @@ class VIEWS_EXPORT DesktopWindowTreeHostPlatform
 
   bool is_active_ = false;
 
+  // A handler for events inteded for non client area.
+  std::unique_ptr<ui::EventHandler> non_client_window_event_filter_;
+
   base::WeakPtrFactory<DesktopWindowTreeHostPlatform> weak_factory_{this};
 
   DISALLOW_COPY_AND_ASSIGN(DesktopWindowTreeHostPlatform);
diff --git a/ui/views/widget/desktop_aura/window_event_filter.cc b/ui/views/widget/desktop_aura/window_event_filter.cc
index 530b079289b70..013fdb7cdcfe9 100644
--- a/ui/views/widget/desktop_aura/window_event_filter.cc
+++ b/ui/views/widget/desktop_aura/window_event_filter.cc
@@ -21,6 +21,28 @@
 
 namespace views {
 
+namespace {
+
+bool CanPerformDragOrResize(int hittest) {
+  switch (hittest) {
+    case HTBOTTOM:
+    case HTBOTTOMLEFT:
+    case HTBOTTOMRIGHT:
+    case HTCAPTION:
+    case HTLEFT:
+    case HTRIGHT:
+    case HTTOP:
+    case HTTOPLEFT:
+    case HTTOPRIGHT:
+      break;
+    default:
+      return false;
+  }
+  return true;
+}
+
+}  // namespace
+
 WindowEventFilter::WindowEventFilter(DesktopWindowTreeHost* window_tree_host)
     : window_tree_host_(window_tree_host), click_component_(HTNOWHERE) {}
 
@@ -149,6 +171,14 @@ void WindowEventFilter::LowerWindow() {}
 
 void WindowEventFilter::MaybeDispatchHostWindowDragMovement(
     int hittest,
-    ui::MouseEvent* event) {}
+    ui::MouseEvent* event) {
+  auto* target = static_cast<aura::Window*>(event->target());
+  if (!event->IsLeftMouseButton() ||
+      target->GetHost() != window_tree_host_->AsWindowTreeHost() ||
+      !CanPerformDragOrResize(hittest))
+    return;
+  window_tree_host_->StartWindowMoveOrResize(hittest, event->location());
+  event->StopPropagation();
+}
 
 }  // namespace views

From 8c2d8853390af967816a838e4890db924f6af5d0 Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Wed, 9 May 2018 04:28:22 +0200
Subject: [PATCH 05/32] First attempt to remove decorations from small windows

This patch sets XSetWindowAttributes::override_redirect to
True, which removes different properties from windows.
At this stage, all windows with width() less than 600 are treated
as menus and override_redirect is set to True.

It's almost same as we had with mus except services.

Issue #38
Issue #417
---
 ui/platform_window/x11/x11_window_base.cc | 30 +++++++++++++++++++++++
 1 file changed, 30 insertions(+)

diff --git a/ui/platform_window/x11/x11_window_base.cc b/ui/platform_window/x11/x11_window_base.cc
index 6e9b7995dd30f..dc5578a596861 100644
--- a/ui/platform_window/x11/x11_window_base.cc
+++ b/ui/platform_window/x11/x11_window_base.cc
@@ -19,6 +19,7 @@
 #include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/x/x11_atom_cache.h"
 #include "ui/platform_window/platform_window_delegate.h"
+#include "ui/platform_window/platform_window_init_properties.h"
 
 namespace ui {
 
@@ -122,6 +123,24 @@ void X11WindowBase::Create() {
   swa.background_pixmap = x11::None;
   swa.bit_gravity = NorthWestGravity;
   swa.override_redirect = UseTestConfigForPlatformWindows();
+
+  ::Atom window_type;
+  // There is now default initialization for this type. Initialize it
+  // to ::WINDOW here. It will be changed by delelgate if it know the
+  // type of the window.
+  ui::PlatformWindowType ui_window_type = ui::PlatformWindowType::kWindow;
+  // TODO(msisov, jkim): pass PlatformWindowInitProperties here.
+  if (ui_window_type != ui::PlatformWindowType::PLATFORM_WINDOW_TYPE_WINDOW) {
+    // Setting this to True, doesn't allow X server to set different
+    // properties, e.g. decorations.
+    // TODO(msisov): Investigate further.
+    // https://tronche.com/gui/x/xlib/window/attributes/override-redirect.html
+    swa.override_redirect = x11::True;
+    window_type = gfx::GetAtom("_NET_WM_WINDOW_TYPE_MENU");
+  } else {
+    window_type = gfx::GetAtom("_NET_WM_WINDOW_TYPE_NORMAL");
+  }
+
   xwindow_ =
       XCreateWindow(xdisplay_, xroot_window_, bounds_.x(), bounds_.y(),
                     bounds_.width(), bounds_.height(),
@@ -131,6 +150,10 @@ void X11WindowBase::Create() {
                     CopyFromParent,  // visual
                     CWBackPixmap | CWBitGravity | CWOverrideRedirect, &swa);
 
+  XChangeProperty(xdisplay_, xwindow_, gfx::GetAtom("_NET_WM_WINDOW_TYPE"),
+                  XA_ATOM, 32, PropModeReplace,
+                  reinterpret_cast<unsigned char*>(&window_type), 1);
+
   // Setup XInput event mask.
   long event_mask = ButtonPressMask | ButtonReleaseMask | FocusChangeMask |
                     KeyPressMask | KeyReleaseMask | ExposureMask |
@@ -189,6 +212,13 @@ void X11WindowBase::Create() {
   size_hints.win_gravity = StaticGravity;
   XSetWMNormalHints(xdisplay_, xwindow_, &size_hints);
 
+// Disable native frame by default in non-ChromeOS builds for now.
+// TODO(msisov, tonikitoo): check if native frame should be used by checking
+// Widget::InitParams::remove_standard_frame.
+#if !defined(OS_CHROMEOS)
+  ui::SetUseOSWindowFrame(xwindow_, false);
+#endif
+
   delegate_->OnAcceleratedWidgetAvailable(xwindow_);
 }
 

From c79ba48504c236c551f927705ee1c75a67b061e4 Mon Sep 17 00:00:00 2001
From: Maksim Sisov <msisov@igalia.com>
Date: Tue, 29 Aug 2017 14:23:33 +0300
Subject: [PATCH 06/32] [ozone/x11] Add popup window type support.

This commit adds a popup window type to ozone windows.
Popup windows are drop down windows, for example.

Issue #417

fixup! Add popup window type support.

It added case handling on WindowTreeHostPlatform::GetWindowType().
---
 ui/platform_window/x11/x11_window_base.cc | 21 ++++++++++++---------
 1 file changed, 12 insertions(+), 9 deletions(-)

diff --git a/ui/platform_window/x11/x11_window_base.cc b/ui/platform_window/x11/x11_window_base.cc
index dc5578a596861..6bd255bab8b27 100644
--- a/ui/platform_window/x11/x11_window_base.cc
+++ b/ui/platform_window/x11/x11_window_base.cc
@@ -130,15 +130,18 @@ void X11WindowBase::Create() {
   // type of the window.
   ui::PlatformWindowType ui_window_type = ui::PlatformWindowType::kWindow;
   // TODO(msisov, jkim): pass PlatformWindowInitProperties here.
-  if (ui_window_type != ui::PlatformWindowType::PLATFORM_WINDOW_TYPE_WINDOW) {
-    // Setting this to True, doesn't allow X server to set different
-    // properties, e.g. decorations.
-    // TODO(msisov): Investigate further.
-    // https://tronche.com/gui/x/xlib/window/attributes/override-redirect.html
-    swa.override_redirect = x11::True;
-    window_type = gfx::GetAtom("_NET_WM_WINDOW_TYPE_MENU");
-  } else {
-    window_type = gfx::GetAtom("_NET_WM_WINDOW_TYPE_NORMAL");
+   switch (ui_window_type) {
+    case ui::PlatformWindowType::kMenu:
+      window_type = gfx::GetAtom("_NET_WM_WINDOW_TYPE_MENU");
+      swa.override_redirect = x11::True;
+      break;
+    case ui::PlatformWindowType::kPopup:
+      swa.override_redirect = x11::True;
+      window_type = gfx::GetAtom("_NET_WM_WINDOW_TYPE_NOTIFICATION");
+      break;
+    default:
+      window_type = gfx::GetAtom("_NET_WM_WINDOW_TYPE_NORMAL");
+      break;
   }
 
   xwindow_ =

From 96cb3db2f3add2861af09f21f3a13b5170493dd2 Mon Sep 17 00:00:00 2001
From: Antonio Gomes <tonikitoo@igalia.com>
Date: Wed, 6 Sep 2017 12:12:44 -0400
Subject: [PATCH 07/32] Use ui::EventTimeForNow for pointer and keyboard events

This fixes the following wheel scroll event crash on Weston:

FATAL:latency_tracker.cc(196)] Check failed:
gpu_swap_begin_component.last_event_time >=
original_component.first_event_time (42321552294 bogo-microseconds vs.
3419125241000 bogo-microseconds)

It also pairs us up with Intel's Ozone/Wayland implementation.

TBR=msisov

Issue #179
---
 ui/ozone/platform/wayland/wayland_pointer.cc | 12 +++++-------
 1 file changed, 5 insertions(+), 7 deletions(-)

diff --git a/ui/ozone/platform/wayland/wayland_pointer.cc b/ui/ozone/platform/wayland/wayland_pointer.cc
index 42384c01bd4cf..5faf2c961c862 100644
--- a/ui/ozone/platform/wayland/wayland_pointer.cc
+++ b/ui/ozone/platform/wayland/wayland_pointer.cc
@@ -94,8 +94,8 @@ void WaylandPointer::Motion(void* data,
   pointer->location_.SetPoint(wl_fixed_to_double(surface_x),
                               wl_fixed_to_double(surface_y));
   MouseEvent event(ET_MOUSE_MOVED, gfx::Point(), gfx::Point(),
-                   base::TimeTicks() + base::TimeDelta::FromMilliseconds(time),
-                   pointer->GetFlagsWithKeyboardModifiers(), 0);
+                   EventTimeForNow(), pointer->GetFlagsWithKeyboardModifiers(),
+                   0);
   event.set_location_f(pointer->location_);
   event.set_root_location_f(pointer->location_);
   pointer->callback_.Run(&event);
@@ -147,9 +147,7 @@ void WaylandPointer::Button(void* data,
   // MouseEvent's flags should contain the button that was released too.
   const int flags = pointer->GetFlagsWithKeyboardModifiers() | changed_button;
   MouseEvent event(type, gfx::Point(), gfx::Point(),
-                   base::TimeTicks() + base::TimeDelta::FromMilliseconds(time),
-                   flags, changed_button);
-
+                   EventTimeForNow(), flags, changed_button);
   event.set_location_f(pointer->location_);
   event.set_root_location_f(pointer->location_);
 
@@ -189,8 +187,8 @@ void WaylandPointer::Axis(void* data,
     return;
   MouseWheelEvent event(
       offset, gfx::Point(), gfx::Point(),
-      base::TimeTicks() + base::TimeDelta::FromMilliseconds(time),
-      pointer->GetFlagsWithKeyboardModifiers(), 0);
+      EventTimeForNow(), pointer->GetFlagsWithKeyboardModifiers(),
+      0);
   event.set_location_f(pointer->location_);
   event.set_root_location_f(pointer->location_);
   pointer->callback_.Run(&event);

From bb22d833edb8d47e5ca63ecd3067218c6b9e3aad Mon Sep 17 00:00:00 2001
From: Antonio Gomes <tonikitoo@igalia.com>
Date: Thu, 23 Nov 2017 09:03:21 -0400
Subject: [PATCH 08/32] Reset Cursor type when pointer exits

If user places the pointer/mouse on any end of a browser window, cursor
type changes accordingly, to indicated a possible interactive resize operation.

If the user crosses the browser window bounds through the same end, the mouse
type stored in ui::CursorManager isn't reset. If pointer reenters the
window through the same end, Aura tries to set the cursor type to the
same as previously (to indicate it is over the same end). During the
call chain, CursorManager::SetCursor compares the last Cursor stored
and the new one and updates the cursor instance if they differ.

In case of regular Chrome/x11 builds, the check passes because
CursorData is set to the Cursor instance, and values always differ
from the CursorData cached by CursorManager.
In case of Linux/Ozone builds, CursorData is only set on Ozone side,
so the call bail out and cursor is not updated.

Patch fixes it by resetting the cursor type whenever pointer leaves
the browser window. This ensures, when reentering from the same end, the
comparison in CursorManager::SetCursor passes, and cursor gets updated.

Issue #317
Issue #435
---
 ui/wm/core/compound_event_filter.cc | 19 +++++++++++++++++--
 1 file changed, 17 insertions(+), 2 deletions(-)

diff --git a/ui/wm/core/compound_event_filter.cc b/ui/wm/core/compound_event_filter.cc
index dcb640d3ba13a..d8b76a607a2f0 100644
--- a/ui/wm/core/compound_event_filter.cc
+++ b/ui/wm/core/compound_event_filter.cc
@@ -122,6 +122,18 @@ void CompoundEventFilter::UpdateCursor(aura::Window* target,
   aura::client::CursorClient* cursor_client =
       aura::client::GetCursorClient(root_window);
   if (cursor_client) {
+    // In some configurations, notably Linux/Ozone, cursor data are only
+    // set in Ozone side. This makes the check in CursorManager::SetCursor
+    // unreliable and fail in some circumstances where it passes on regular
+    // Linux/X11 builds.
+    // To make sure, cursor is properly set when it reenters a browser window
+    // through the same end, we reset it when it exits, otherwise the check in
+    // CursorManager::SetCursor will comparent Cursors of the same type.
+    if (event->type() == ui::ET_MOUSE_EXITED) {
+      cursor_client->SetCursor(ui::CursorType::kPointer);
+      return;
+    }
+
     gfx::NativeCursor cursor = target->GetCursor(event->location());
     if ((event->flags() & ui::EF_IS_NON_CLIENT)) {
       if (target->delegate()) {
@@ -221,11 +233,14 @@ void CompoundEventFilter::OnMouseEvent(ui::MouseEvent* event) {
   // on Desktop for testing, or a bug in pointer barrier).
   if (!(event->flags() & ui::EF_FROM_TOUCH) &&
        (event->type() == ui::ET_MOUSE_ENTERED ||
+        event->type() == ui::ET_MOUSE_EXITED ||
         event->type() == ui::ET_MOUSE_MOVED ||
         event->type() == ui::ET_MOUSE_PRESSED ||
         event->type() == ui::ET_MOUSEWHEEL)) {
-    SetMouseEventsEnableStateOnEvent(window, event, true);
-    SetCursorVisibilityOnEvent(window, event, true);
+    if (event->type() != ui::ET_MOUSE_EXITED) {
+      SetMouseEventsEnableStateOnEvent(window, event, true);
+      SetCursorVisibilityOnEvent(window, event, true);
+    }
     UpdateCursor(window, event);
   }
 

From 989da76f904fc0eb076e7051c0917fd9ad636940 Mon Sep 17 00:00:00 2001
From: Maksim Sisov <msisov@igalia.com>
Date: Tue, 17 Oct 2017 15:13:32 +0300
Subject: [PATCH 09/32] Add inital support for a tab drag window.

This patch adds an initial support to start a move loop and create
a new window by dragging a tab. To start with, this commit
extends WindowTree::PerformWindowMove, which calls
WindowServer::StartMoveLoop -> PlatformWindow::RunMoveLoop.

X11 Ozone implementation of PlatformWindow uses
WindowMoveLoopClient, which instantiates the move loop and
WholeScreenMoveLoop, which creates an invisible window
and intercepts all the events from it. Then the system screen
location is taken and sent to WindowMoveLoopClient, which
updates actual bounds of X11WindowBase.

The way it works is precisly the same as in stock X11, but
further work to share the code is needed, because there are
some difference between stock x11 and ozone x11 event
handlings, bounds set and etc.

Issue #264

fixup! [ozone/wayland] Add inital support for a tab drag window.

adapt to
https://crrev.com/c/774778

CanDispatchEvent is modified in such a way that it also tests if
the client in a move loop right now. If so, it must dispatch events
further once whole_screen_move_loop processes them in order to update
mouse locations on aura side.

fixup! [ozone/wayland] Add inital support for a tab drag window.

It removed changes at services from previous change to make it
available without mus and made WindowFinder with ozone work without
mus with creating GetLocalProcessWindowAtPointOzone to
get gfx::NativeWindow at input position.

Issue #430

fixup! Add inital support for a tab drag window.
---
 .../ui/views/tabs/window_finder_ozone.cc      |   3 +
 ui/ozone/platform/drm/host/drm_window_host.cc |   6 +
 ui/ozone/platform/drm/host/drm_window_host.h  |   2 +
 ui/ozone/platform/wayland/wayland_window.cc   |   6 +
 ui/ozone/platform/wayland/wayland_window.h    |   2 +
 ui/ozone/platform/x11/x11_window_ozone.cc     |  33 ++-
 ui/ozone/platform/x11/x11_window_ozone.h      |   9 +
 ui/platform_window/platform_window.h          |   5 +
 ui/platform_window/stub/stub_window.cc        |   5 +
 ui/platform_window/stub/stub_window.h         |   2 +
 ui/platform_window/x11/BUILD.gn               |  13 +-
 .../x11/whole_screen_move_loop.cc             | 228 ++++++++++++++++++
 .../x11/whole_screen_move_loop.h              |  90 +++++++
 .../x11/window_move_loop_client.cc            |  62 +++++
 .../x11/window_move_loop_client.h             |  56 +++++
 ui/platform_window/x11/x11_window_base.cc     |  15 +-
 ui/platform_window/x11/x11_window_base.h      |   3 +
 .../desktop_window_tree_host_platform.cc      |   7 +-
 .../desktop_aura/x11_move_loop_delegate.h     |   2 +
 19 files changed, 540 insertions(+), 9 deletions(-)
 create mode 100644 ui/platform_window/x11/whole_screen_move_loop.cc
 create mode 100644 ui/platform_window/x11/whole_screen_move_loop.h
 create mode 100644 ui/platform_window/x11/window_move_loop_client.cc
 create mode 100644 ui/platform_window/x11/window_move_loop_client.h

diff --git a/chrome/browser/ui/views/tabs/window_finder_ozone.cc b/chrome/browser/ui/views/tabs/window_finder_ozone.cc
index bb904744b6bdb..2e56be1564e26 100644
--- a/chrome/browser/ui/views/tabs/window_finder_ozone.cc
+++ b/chrome/browser/ui/views/tabs/window_finder_ozone.cc
@@ -2,7 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "chrome/browser/ui/browser_list.h"
+#include "chrome/browser/ui/browser_window.h"
 #include "chrome/browser/ui/views/tabs/window_finder.h"
+#include "ui/views/widget/widget.h"
 
 gfx::NativeWindow WindowFinder::GetLocalProcessWindowAtPoint(
     const gfx::Point& screen_point,
diff --git a/ui/ozone/platform/drm/host/drm_window_host.cc b/ui/ozone/platform/drm/host/drm_window_host.cc
index 4b9684fdf6fe7..4874fce4c8c5e 100644
--- a/ui/ozone/platform/drm/host/drm_window_host.cc
+++ b/ui/ozone/platform/drm/host/drm_window_host.cc
@@ -149,6 +149,12 @@ gfx::Rect DrmWindowHost::GetRestoredBoundsInPixels() const {
 void DrmWindowHost::StartWindowMoveOrResize(int hittest,
                                             gfx::Point pointer_location) {}
 
+bool DrmWindowHost::RunMoveLoop(const gfx::Vector2d& drag_offset) {
+  return false;
+}
+
+void DrmWindowHost::StopMoveLoop() {}
+
 bool DrmWindowHost::CanDispatchEvent(const PlatformEvent& event) {
   DCHECK(event);
 
diff --git a/ui/ozone/platform/drm/host/drm_window_host.h b/ui/ozone/platform/drm/host/drm_window_host.h
index 636eb7170ea53..57d53e224e77b 100644
--- a/ui/ozone/platform/drm/host/drm_window_host.h
+++ b/ui/ozone/platform/drm/host/drm_window_host.h
@@ -81,6 +81,8 @@ class DrmWindowHost : public PlatformWindow,
   gfx::Rect GetRestoredBoundsInPixels() const override;
   void StartWindowMoveOrResize(int hittest,
                                gfx::Point pointer_location) override;
+  bool RunMoveLoop(const gfx::Vector2d& drag_offset) override;
+  void StopMoveLoop() override;
 
   // PlatformEventDispatcher:
   bool CanDispatchEvent(const PlatformEvent& event) override;
diff --git a/ui/ozone/platform/wayland/wayland_window.cc b/ui/ozone/platform/wayland/wayland_window.cc
index 53f5af663bab1..f1c9a782eaeae 100644
--- a/ui/ozone/platform/wayland/wayland_window.cc
+++ b/ui/ozone/platform/wayland/wayland_window.cc
@@ -399,6 +399,12 @@ void WaylandWindow::StartWindowMoveOrResize(int hittest,
     xdg_surface_->SurfaceResize(connection_, hittest);
 }
 
+bool WaylandWindow::RunMoveLoop(const gfx::Vector2d& drag_offset) {
+  return true;
+}
+
+void WaylandWindow::StopMoveLoop() {}
+
 bool WaylandWindow::CanDispatchEvent(const PlatformEvent& event) {
   // This window is a nested popup window, all the events must be forwarded
   // to the main popup window.
diff --git a/ui/ozone/platform/wayland/wayland_window.h b/ui/ozone/platform/wayland/wayland_window.h
index 95e5e3caed6b3..d56c650dd13ee 100644
--- a/ui/ozone/platform/wayland/wayland_window.h
+++ b/ui/ozone/platform/wayland/wayland_window.h
@@ -90,6 +90,8 @@ class WaylandWindow : public PlatformWindow, public PlatformEventDispatcher {
   gfx::Rect GetRestoredBoundsInPixels() const override;
   void StartWindowMoveOrResize(int hittest,
                                gfx::Point pointer_location) override;
+  bool RunMoveLoop(const gfx::Vector2d& drag_offset) override;
+  void StopMoveLoop() override;
 
   // PlatformEventDispatcher
   bool CanDispatchEvent(const PlatformEvent& event) override;
diff --git a/ui/ozone/platform/x11/x11_window_ozone.cc b/ui/ozone/platform/x11/x11_window_ozone.cc
index c3f17315009ef..9c312abdad9d1 100644
--- a/ui/ozone/platform/x11/x11_window_ozone.cc
+++ b/ui/ozone/platform/x11/x11_window_ozone.cc
@@ -24,6 +24,11 @@ X11WindowOzone::X11WindowOzone(X11WindowManagerOzone* window_manager,
   auto* event_source = X11EventSourceLibevent::GetInstance();
   if (event_source)
     event_source->AddXEventDispatcher(this);
+
+// TODO(msisov, tonikitoo): Add a dummy implementation for chromeos.
+#if !defined(OS_CHROMEOS)
+  move_loop_client_.reset(new WindowMoveLoopClient());
+#endif
 }
 
 X11WindowOzone::~X11WindowOzone() {
@@ -49,6 +54,24 @@ void X11WindowOzone::SetCursor(PlatformCursor cursor) {
   XDefineCursor(xdisplay(), xwindow(), cursor_ozone->xcursor());
 }
 
+bool X11WindowOzone::RunMoveLoop(const gfx::Vector2d& drag_offset) {
+// TODO(msisov, tonikitoo): Add a dummy implementation for chromeos.
+#if !defined(OS_CHROMEOS)
+  DCHECK(move_loop_client_);
+  ReleaseCapture();
+  return move_loop_client_->RunMoveLoop(this, drag_offset);
+#endif
+  return true;
+}
+
+void X11WindowOzone::StopMoveLoop() {
+// TODO(msisov, tonikitoo): Add a dummy implementation for chromeos.
+#if !defined(OS_CHROMEOS)
+  ReleaseCapture();
+  move_loop_client_->EndMoveLoop();
+#endif
+}
+
 void X11WindowOzone::CheckCanDispatchNextPlatformEvent(XEvent* xev) {
   handle_next_event_ = xwindow() == x11::None ? false : IsEventForXWindow(*xev);
 }
@@ -69,8 +92,14 @@ bool X11WindowOzone::DispatchXEvent(XEvent* xev) {
   return true;
 }
 
-bool X11WindowOzone::CanDispatchEvent(const PlatformEvent& event) {
-  return handle_next_event_;
+bool X11WindowOzone::CanDispatchEvent(const PlatformEvent& platform_event) {
+  bool in_move_loop =
+#if !defined(OS_CHROMEOS)
+      move_loop_client_->IsInMoveLoop();
+#else
+      false;
+#endif
+  return handle_next_event_ || in_move_loop;
 }
 
 uint32_t X11WindowOzone::DispatchEvent(const PlatformEvent& event) {
diff --git a/ui/ozone/platform/x11/x11_window_ozone.h b/ui/ozone/platform/x11/x11_window_ozone.h
index e1586341f19d2..6be3f747549df 100644
--- a/ui/ozone/platform/x11/x11_window_ozone.h
+++ b/ui/ozone/platform/x11/x11_window_ozone.h
@@ -8,6 +8,7 @@
 #include "base/macros.h"
 #include "ui/events/platform/platform_event_dispatcher.h"
 #include "ui/events/platform/x11/x11_event_source_libevent.h"
+#include "ui/platform_window/x11/window_move_loop_client.h"
 #include "ui/platform_window/x11/x11_window_base.h"
 
 namespace ui {
@@ -30,8 +31,11 @@ class X11WindowOzone : public X11WindowBase,
   // PlatformWindow:
   void PrepareForShutdown() override;
   void SetCapture() override;
+
   void ReleaseCapture() override;
   void SetCursor(PlatformCursor cursor) override;
+  bool RunMoveLoop(const gfx::Vector2d& drag_offset) override;
+  void StopMoveLoop() override;
 
   // XEventDispatcher:
   void CheckCanDispatchNextPlatformEvent(XEvent* xev) override;
@@ -46,6 +50,11 @@ class X11WindowOzone : public X11WindowBase,
 
   X11WindowManagerOzone* window_manager_;
 
+// TODO(msisov, tonikitoo): Add a dummy implementation for chromeos.
+#if !defined(OS_CHROMEOS)
+  std::unique_ptr<WindowMoveLoopClient> move_loop_client_;
+#endif
+
   // Tells if this dispatcher can process next translated event based on a
   // previous check in ::CheckCanDispatchNextPlatformEvent based on a XID
   // target.
diff --git a/ui/platform_window/platform_window.h b/ui/platform_window/platform_window.h
index e8b3d11b64625..c5f7ed9fc7808 100644
--- a/ui/platform_window/platform_window.h
+++ b/ui/platform_window/platform_window.h
@@ -75,6 +75,11 @@ class PlatformWindow {
   // the |hittest|.
   virtual void StartWindowMoveOrResize(int hittest,
                                        gfx::Point pointer_location) = 0;
+
+  // Asks to window move client to start move loop.
+  virtual bool RunMoveLoop(const gfx::Vector2d& drag_offset) = 0;
+
+  virtual void StopMoveLoop() = 0;
 };
 
 }  // namespace ui
diff --git a/ui/platform_window/stub/stub_window.cc b/ui/platform_window/stub/stub_window.cc
index 23e8c4568da23..2fea73e2f74cb 100644
--- a/ui/platform_window/stub/stub_window.cc
+++ b/ui/platform_window/stub/stub_window.cc
@@ -83,5 +83,10 @@ gfx::Rect StubWindow::GetRestoredBoundsInPixels() const {
 void StubWindow::StartWindowMoveOrResize(int hittest,
                                          gfx::Point pointer_location) {}
 
+bool StubWindow::RunMoveLoop(const gfx::Vector2d& drag_offset) {
+  return false;
+}
+
+void StubWindow::StopMoveLoop() {}
 
 }  // namespace ui
diff --git a/ui/platform_window/stub/stub_window.h b/ui/platform_window/stub/stub_window.h
index 31bf299511396..6c81baa267322 100644
--- a/ui/platform_window/stub/stub_window.h
+++ b/ui/platform_window/stub/stub_window.h
@@ -52,6 +52,8 @@ class STUB_WINDOW_EXPORT StubWindow : public PlatformWindow {
   gfx::Rect GetRestoredBoundsInPixels() const override;
   void StartWindowMoveOrResize(int hittest,
                                gfx::Point pointer_location) override;
+  bool RunMoveLoop(const gfx::Vector2d& drag_offset) override;
+  void StopMoveLoop() override;
 
   PlatformWindowDelegate* delegate_;
   gfx::Rect bounds_;
diff --git a/ui/platform_window/x11/BUILD.gn b/ui/platform_window/x11/BUILD.gn
index 3e46e8c94c96b..0f737c7c2c1c9 100644
--- a/ui/platform_window/x11/BUILD.gn
+++ b/ui/platform_window/x11/BUILD.gn
@@ -34,7 +34,18 @@ jumbo_component("x11") {
     "x11_window_export.h",
   ]
 
-  if (use_x11) {
+  if (ozone_platform_x11) {
+    sources += [
+      "whole_screen_move_loop.cc",
+      "whole_screen_move_loop.h",
+      "window_move_loop_client.cc",
+      "window_move_loop_client.h",
+    ]
+    deps += [
+      "//ui/base",
+      "//ui/base/x",
+    ]
+  } else if (use_x11) {
     sources += [
       "x11_window.cc",
       "x11_window.h",
diff --git a/ui/platform_window/x11/whole_screen_move_loop.cc b/ui/platform_window/x11/whole_screen_move_loop.cc
new file mode 100644
index 0000000000000..1c5fb1fd409aa
--- /dev/null
+++ b/ui/platform_window/x11/whole_screen_move_loop.cc
@@ -0,0 +1,228 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/platform_window/x11/whole_screen_move_loop.h"
+
+#include <stddef.h>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/logging.h"
+#include "base/macros.h"
+#include "base/message_loop/message_loop.h"
+#include "base/run_loop.h"
+#include "base/single_thread_task_runner.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "ui/aura/client/capture_client.h"
+#include "ui/aura/env.h"
+#include "ui/aura/window.h"
+#include "ui/aura/window_event_dispatcher.h"
+#include "ui/aura/window_tree_host.h"
+#include "ui/base/x/x11_pointer_grab.h"
+#include "ui/base/x/x11_util.h"
+#include "ui/base/x/x11_window_event_manager.h"
+#include "ui/events/event.h"
+#include "ui/events/event_utils.h"
+#include "ui/events/keycodes/keyboard_code_conversion_x.h"
+#include "ui/events/ozone/events_ozone.h"
+#include "ui/events/platform/platform_event_source.h"
+#include "ui/events/platform/scoped_event_dispatcher.h"
+#include "ui/events/platform/x11/x11_event_source.h"
+#include "ui/events/platform/x11/x11_event_source_libevent.h"
+#include "ui/gfx/x/x11.h"
+#include "ui/platform_window/platform_window_delegate.h"
+
+namespace ui {
+
+// XGrabKey requires the modifier mask to explicitly be specified.
+const unsigned int kModifiersMasks[] = {0,         // No additional modifier.
+                                        Mod2Mask,  // Num lock
+                                        LockMask,  // Caps lock
+                                        Mod5Mask,  // Scroll lock
+                                        Mod2Mask | LockMask,
+                                        Mod2Mask | Mod5Mask,
+                                        LockMask | Mod5Mask,
+                                        Mod2Mask | LockMask | Mod5Mask};
+
+WholeScreenMoveLoop::WholeScreenMoveLoop(views::X11MoveLoopDelegate* delegate)
+    : delegate_(delegate),
+      in_move_loop_(false),
+      grab_input_window_(x11::None),
+      grabbed_pointer_(false),
+      canceled_(false),
+      weak_factory_(this) {}
+
+WholeScreenMoveLoop::~WholeScreenMoveLoop() {}
+
+void WholeScreenMoveLoop::DispatchMouseMovement() {
+  if (!last_motion_in_screen_ && !last_motion_in_screen_->IsLocatedEvent())
+    return;
+  delegate_->OnMouseMovement(
+      last_motion_in_screen_->AsLocatedEvent()->location(),
+      last_motion_in_screen_->flags(), last_motion_in_screen_->time_stamp());
+  last_motion_in_screen_.reset();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopWindowTreeHostLinux, ui::PlatformEventDispatcher implementation:
+
+bool WholeScreenMoveLoop::CanDispatchEvent(const ui::PlatformEvent& event) {
+  return in_move_loop_;
+}
+
+uint32_t WholeScreenMoveLoop::DispatchEvent(
+    const ui::PlatformEvent& platform_event) {
+  DCHECK(base::MessageLoopForUI::IsCurrent());
+
+  // This method processes all events while the move loop is active.
+  if (!in_move_loop_)
+    return ui::POST_DISPATCH_PERFORM_DEFAULT;
+
+  auto* event = static_cast<ui::Event*>(platform_event);
+  switch (event->type()) {
+    case ui::ET_MOUSE_MOVED:
+    case ui::ET_MOUSE_DRAGGED: {
+      bool can_send = !last_motion_in_screen_.get();
+
+      ui::MouseEvent* mouse_event = event->AsMouseEvent();
+      gfx::Point root_location = mouse_event->root_location();
+      mouse_event->set_location(root_location);
+
+      last_motion_in_screen_ = ui::Event::Clone(*event);
+      DCHECK(last_motion_in_screen_->IsMouseEvent());
+
+      if (can_send)
+        DispatchMouseMovement();
+      return ui::POST_DISPATCH_PERFORM_DEFAULT;
+    }
+    case ui::ET_MOUSE_RELEASED: {
+      ui::MouseEvent* mouse_event = event->AsMouseEvent();
+      gfx::Point root_location = mouse_event->root_location();
+      mouse_event->set_location(root_location);
+
+      last_motion_in_screen_ = ui::Event::Clone(*event);
+      DCHECK(last_motion_in_screen_->IsMouseEvent());
+
+      EndMoveLoop();
+      return ui::POST_DISPATCH_PERFORM_DEFAULT;
+    }
+    case ui::ET_KEY_PRESSED:
+      canceled_ = true;
+      EndMoveLoop();
+      return ui::POST_DISPATCH_NONE;
+    default:
+      break;
+  }
+  return ui::POST_DISPATCH_PERFORM_DEFAULT;
+}
+
+bool WholeScreenMoveLoop::RunMoveLoop() {
+  DCHECK(!in_move_loop_);  // Can only handle one nested loop at a time.
+
+  CreateDragInputWindow(gfx::GetXDisplay());
+
+  if (!GrabPointer()) {
+    XDestroyWindow(gfx::GetXDisplay(), grab_input_window_);
+    CHECK(false) << "failed to grab pointer";
+    return false;
+  }
+
+  GrabEscKey();
+
+  std::unique_ptr<ui::ScopedEventDispatcher> old_dispatcher =
+      std::move(nested_dispatcher_);
+  nested_dispatcher_ =
+      ui::PlatformEventSource::GetInstance()->OverrideDispatcher(this);
+
+  base::WeakPtr<WholeScreenMoveLoop> alive(weak_factory_.GetWeakPtr());
+
+  in_move_loop_ = true;
+  canceled_ = false;
+  base::MessageLoop::ScopedNestableTaskAllower allow_nested;
+  base::RunLoop run_loop;
+  quit_closure_ = run_loop.QuitClosure();
+  run_loop.Run();
+
+  if (!alive)
+    return false;
+
+  nested_dispatcher_ = std::move(old_dispatcher);
+  return !canceled_;
+}
+
+void WholeScreenMoveLoop::UpdateCursor() {}
+
+void WholeScreenMoveLoop::EndMoveLoop() {
+  if (!in_move_loop_)
+    return;
+
+  // Prevent DispatchMouseMovement from dispatching any posted motion event.
+  last_motion_in_screen_.reset();
+
+  // TODO(erg): Is this ungrab the cause of having to click to give input focus
+  // on drawn out windows? Not ungrabbing here screws the X server until I kill
+  // the chrome process.
+
+  // Ungrab before we let go of the window.
+  if (grabbed_pointer_)
+    ui::UngrabPointer();
+  else
+    UpdateCursor();
+
+  XDisplay* display = gfx::GetXDisplay();
+  unsigned int esc_keycode = XKeysymToKeycode(display, XK_Escape);
+  for (size_t i = 0; i < arraysize(kModifiersMasks); ++i) {
+    XUngrabKey(display, esc_keycode, kModifiersMasks[i], grab_input_window_);
+  }
+
+  // Restore the previous dispatcher.
+  nested_dispatcher_.reset();
+  grab_input_window_events_.reset();
+  XDestroyWindow(display, grab_input_window_);
+  grab_input_window_ = x11::None;
+  in_move_loop_ = false;
+  quit_closure_.Run();
+}
+
+bool WholeScreenMoveLoop::GrabPointer() {
+  XDisplay* display = gfx::GetXDisplay();
+
+  // Pass "owner_events" as false so that X sends all mouse events to
+  // |grab_input_window_|.
+  int ret = ui::GrabPointer(grab_input_window_, false, x11::None);
+  if (ret != GrabSuccess) {
+    DLOG(ERROR) << "Grabbing pointer for dragging failed: "
+                << ui::GetX11ErrorString(display, ret);
+  }
+  XFlush(display);
+  return ret == GrabSuccess;
+}
+
+void WholeScreenMoveLoop::GrabEscKey() {
+  XDisplay* display = gfx::GetXDisplay();
+  unsigned int esc_keycode = XKeysymToKeycode(display, XK_Escape);
+  for (size_t i = 0; i < arraysize(kModifiersMasks); ++i) {
+    XGrabKey(display, esc_keycode, kModifiersMasks[i], grab_input_window_,
+             x11::False, GrabModeAsync, GrabModeAsync);
+  }
+}
+
+void WholeScreenMoveLoop::CreateDragInputWindow(XDisplay* display) {
+  unsigned long attribute_mask = CWEventMask | CWOverrideRedirect;
+  XSetWindowAttributes swa;
+  memset(&swa, 0, sizeof(swa));
+  swa.override_redirect = x11::True;
+  grab_input_window_ = XCreateWindow(display, DefaultRootWindow(display), -100,
+                                     -100, 10, 10, 0, CopyFromParent, InputOnly,
+                                     CopyFromParent, attribute_mask, &swa);
+  uint32_t event_mask = ButtonPressMask | ButtonReleaseMask |
+                        PointerMotionMask | KeyPressMask | KeyReleaseMask |
+                        StructureNotifyMask;
+  grab_input_window_events_.reset(
+      new ui::XScopedEventSelector(grab_input_window_, event_mask));
+
+  XMapRaised(display, grab_input_window_);
+}
+
+}  // namespace ui
diff --git a/ui/platform_window/x11/whole_screen_move_loop.h b/ui/platform_window/x11/whole_screen_move_loop.h
new file mode 100644
index 0000000000000..4a18fe908a1d7
--- /dev/null
+++ b/ui/platform_window/x11/whole_screen_move_loop.h
@@ -0,0 +1,90 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_PLATFORM_WINDOW_X11_WHOLE_SCREEN_MOVE_LOOP_H_
+#define UI_PLATFORM_WINDOW_X11_WHOLE_SCREEN_MOVE_LOOP_H_
+
+#include <stdint.h>
+
+#include "base/callback.h"
+#include "base/compiler_specific.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "ui/base/cursor/cursor.h"
+#include "ui/events/platform/platform_event_dispatcher.h"
+#include "ui/gfx/geometry/vector2d_f.h"
+#include "ui/gfx/image/image_skia.h"
+#include "ui/gfx/native_widget_types.h"
+#include "ui/gfx/x/x11_types.h"
+#include "ui/views/widget/desktop_aura/x11_move_loop.h"
+#include "ui/views/widget/desktop_aura/x11_move_loop_delegate.h"
+
+namespace ui {
+class MouseEvent;
+class ScopedEventDispatcher;
+class XScopedEventSelector;
+class PlatformWindowDelegate;
+
+// Runs a nested run loop and grabs the mouse. This is used to implement
+// dragging.
+class WholeScreenMoveLoop : public ui::PlatformEventDispatcher {
+ public:
+  explicit WholeScreenMoveLoop(views::X11MoveLoopDelegate* delegate);
+  ~WholeScreenMoveLoop() override;
+
+  // ui:::PlatformEventDispatcher:
+  bool CanDispatchEvent(const ui::PlatformEvent& event) override;
+  uint32_t DispatchEvent(const ui::PlatformEvent& platform_event) override;
+
+  // X11MoveLoop:
+  bool RunMoveLoop();
+  void UpdateCursor();
+  void EndMoveLoop();
+
+  bool in_move_loop() { return in_move_loop_; }
+
+ private:
+  // Grabs the pointer, setting the mouse cursor to |cursor|. Returns true if
+  // successful.
+  bool GrabPointer();
+
+  void GrabEscKey();
+
+  // Creates an input-only window to be used during the drag.
+  void CreateDragInputWindow(XDisplay* display);
+
+  // Dispatch mouse movement event to |delegate_| in a posted task.
+  void DispatchMouseMovement();
+
+  views::X11MoveLoopDelegate* delegate_;
+
+  // Are we running a nested run loop from RunMoveLoop()?
+  bool in_move_loop_;
+  std::unique_ptr<ui::ScopedEventDispatcher> nested_dispatcher_;
+
+  // An invisible InputOnly window. Keyboard grab and sometimes mouse grab
+  // are set on this window.
+  XID grab_input_window_;
+
+  // Events selected on |grab_input_window_|.
+  std::unique_ptr<ui::XScopedEventSelector> grab_input_window_events_;
+
+  // Whether the pointer was grabbed on |grab_input_window_|.
+  bool grabbed_pointer_;
+
+  base::Closure quit_closure_;
+
+  // Keeps track of whether the move-loop is cancled by the user (e.g. by
+  // pressing escape).
+  bool canceled_;
+
+  std::unique_ptr<ui::Event> last_motion_in_screen_;
+  base::WeakPtrFactory<WholeScreenMoveLoop> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(WholeScreenMoveLoop);
+};
+
+}  // namespace ui
+
+#endif  // UI_PLATFORM_WINDOW_X11_WHOLE_SCREEN_MOVE_LOOP_H_
diff --git a/ui/platform_window/x11/window_move_loop_client.cc b/ui/platform_window/x11/window_move_loop_client.cc
new file mode 100644
index 0000000000000..cbfe515ddeef3
--- /dev/null
+++ b/ui/platform_window/x11/window_move_loop_client.cc
@@ -0,0 +1,62 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/platform_window/x11/window_move_loop_client.h"
+
+#include <X11/Xlib.h>
+
+#include "base/debug/stack_trace.h"
+#include "base/message_loop/message_loop.h"
+#include "base/run_loop.h"
+#include "ui/aura/env.h"
+#include "ui/aura/window.h"
+#include "ui/aura/window_tree_host.h"
+#include "ui/base/x/x11_util.h"
+#include "ui/events/event.h"
+
+#include "ui/platform_window/platform_window.h"
+
+namespace ui {
+
+WindowMoveLoopClient::WindowMoveLoopClient()
+    : move_loop_(this), window_(nullptr) {}
+
+WindowMoveLoopClient::~WindowMoveLoopClient() {}
+
+void WindowMoveLoopClient::OnMouseMovement(const gfx::Point& screen_point,
+                                           int flags,
+                                           base::TimeTicks event_time) {
+  gfx::Point system_loc = screen_point - window_offset_;
+  window_->SetBounds(gfx::Rect(system_loc, gfx::Size()));
+}
+
+void WindowMoveLoopClient::OnMouseReleased() {
+  EndMoveLoop();
+}
+
+void WindowMoveLoopClient::OnMoveLoopEnded() {
+  window_ = nullptr;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopWindowTreeHostLinux, wm::WindowMoveClient implementation:
+
+bool WindowMoveLoopClient::RunMoveLoop(PlatformWindow* window,
+                                       const gfx::Vector2d& drag_offset) {
+  window_offset_ = drag_offset;
+  window_ = window;
+  window_->SetCapture();
+  return move_loop_.RunMoveLoop();
+}
+
+void WindowMoveLoopClient::EndMoveLoop() {
+  window_->ReleaseCapture();
+  move_loop_.EndMoveLoop();
+}
+
+bool WindowMoveLoopClient::IsInMoveLoop() {
+  return move_loop_.in_move_loop();
+}
+
+}  // namespace ui
diff --git a/ui/platform_window/x11/window_move_loop_client.h b/ui/platform_window/x11/window_move_loop_client.h
new file mode 100644
index 0000000000000..2e191f87dc289
--- /dev/null
+++ b/ui/platform_window/x11/window_move_loop_client.h
@@ -0,0 +1,56 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_PLATFORM_WINDOW_X11_WINDOW_MOVE_LOOP_CLIENT_H_
+#define UI_PLATFORM_WINDOW_X11_WINDOW_MOVE_LOOP_CLIENT_H_
+
+#include <X11/Xlib.h>
+
+#include "base/callback.h"
+#include "base/compiler_specific.h"
+#include "base/message_loop/message_loop.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/platform_window/x11/whole_screen_move_loop.h"
+#include "ui/platform_window/x11/x11_window_export.h"
+#include "ui/views/views_export.h"
+#include "ui/wm/public/window_move_client.h"
+
+namespace ui {
+
+class PlatformWindow;
+
+// When we're dragging tabs, we need to manually position our window.
+class X11_WINDOW_EXPORT WindowMoveLoopClient : public views::X11MoveLoopDelegate {
+ public:
+  WindowMoveLoopClient();
+  ~WindowMoveLoopClient() override;
+
+  // Overridden from X11MoveLoopDelegate:
+  void OnMouseMovement(const gfx::Point& screen_point,
+                       int flags,
+                       base::TimeTicks event_time) override;
+  void OnMouseReleased() override;
+  void OnMoveLoopEnded() override;
+
+  bool RunMoveLoop(PlatformWindow* window, const gfx::Vector2d& drag_offset);
+  void EndMoveLoop();
+
+  bool IsInMoveLoop();
+
+ private:
+  WholeScreenMoveLoop move_loop_;
+
+  // We need to keep track of this so we can actually move it when reacting to
+  // mouse events.
+  PlatformWindow* window_;
+
+  // Our cursor offset from the top left window origin when the drag
+  // started. Used to calculate the window's new bounds relative to the current
+  // location of the cursor.
+  gfx::Vector2d window_offset_;
+};
+
+}  // namespace ui
+
+#endif  // UI_PLATFORM_WINDOW_X11_WINDOW_MOVE_LOOP_CLIENT_H_
diff --git a/ui/platform_window/x11/x11_window_base.cc b/ui/platform_window/x11/x11_window_base.cc
index 6bd255bab8b27..a4b81a7a87cdd 100644
--- a/ui/platform_window/x11/x11_window_base.cc
+++ b/ui/platform_window/x11/x11_window_base.cc
@@ -254,7 +254,7 @@ void X11WindowBase::SetBounds(const gfx::Rect& bounds) {
     XWindowChanges changes = {0};
     unsigned value_mask = 0;
 
-    if (bounds_.size() != bounds.size()) {
+    if (!bounds.size().IsEmpty() && bounds_.size() != bounds.size()) {
       changes.width = bounds.width();
       changes.height = bounds.height();
       value_mask |= CWHeight | CWWidth;
@@ -274,8 +274,13 @@ void X11WindowBase::SetBounds(const gfx::Rect& bounds) {
   // case if we're running without a window manager.  If there's a window
   // manager, it can modify or ignore the request, but (per ICCCM) we'll get a
   // (possibly synthetic) ConfigureNotify about the actual size and correct
-  // |bounds_| later.
+  // |bounds_| later. If |bounds| came with zero size, use the previous size
+  // of |bounds_|.
+  gfx::Size size = bounds_.size();
+  if (!bounds.size().IsEmpty())
+    size = bounds_.size();
   bounds_ = bounds;
+  bounds_.set_size(size);
 
   // Even if the pixel bounds didn't change this call to the delegate should
   // still happen. The device scale factor may have changed which effectively
@@ -423,6 +428,12 @@ void X11WindowBase::StartWindowMoveOrResize(int hittest,
              SubstructureRedirectMask | SubstructureNotifyMask, &event);
 }
 
+bool X11WindowBase::RunMoveLoop(const gfx::Vector2d& drag_offset) {
+  return false;
+}
+
+void X11WindowBase::StopMoveLoop() {}
+
 void X11WindowBase::UnConfineCursor() {
   if (!has_pointer_barriers_)
     return;
diff --git a/ui/platform_window/x11/x11_window_base.h b/ui/platform_window/x11/x11_window_base.h
index 46cc446826b2c..a8298c43ef3ab 100644
--- a/ui/platform_window/x11/x11_window_base.h
+++ b/ui/platform_window/x11/x11_window_base.h
@@ -52,6 +52,8 @@ class X11_WINDOW_EXPORT X11WindowBase : public PlatformWindow {
   gfx::Rect GetRestoredBoundsInPixels() const override;
   void StartWindowMoveOrResize(int hittest,
                                gfx::Point pointer_location) override;
+  bool RunMoveLoop(const gfx::Vector2d& drag_offset) override;
+  void StopMoveLoop() override;
 
  protected:
   // Creates new underlying XWindow. Does not map XWindow.
@@ -60,6 +62,7 @@ class X11_WINDOW_EXPORT X11WindowBase : public PlatformWindow {
   void Destroy();
 
   PlatformWindowDelegate* delegate() { return delegate_; }
+
   XDisplay* xdisplay() { return xdisplay_; }
   XID xwindow() const { return xwindow_; }
 
diff --git a/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.cc b/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.cc
index bf6f44cae74ad..563b015411ab8 100644
--- a/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.cc
+++ b/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.cc
@@ -370,14 +370,13 @@ Widget::MoveLoopResult DesktopWindowTreeHostPlatform::RunMoveLoop(
     const gfx::Vector2d& drag_offset,
     Widget::MoveLoopSource source,
     Widget::MoveLoopEscapeBehavior escape_behavior) {
-  // TODO: needs PlatformWindow support.
-  NOTIMPLEMENTED_LOG_ONCE();
+  if (platform_window()->RunMoveLoop(drag_offset))
+    return Widget::MOVE_LOOP_SUCCESSFUL;
   return Widget::MOVE_LOOP_CANCELED;
 }
 
 void DesktopWindowTreeHostPlatform::EndMoveLoop() {
-  // TODO: needs PlatformWindow support.
-  NOTIMPLEMENTED_LOG_ONCE();
+  platform_window()->StopMoveLoop();
 }
 
 void DesktopWindowTreeHostPlatform::SetVisibilityChangedAnimationsEnabled(
diff --git a/ui/views/widget/desktop_aura/x11_move_loop_delegate.h b/ui/views/widget/desktop_aura/x11_move_loop_delegate.h
index b5eee9b72572e..874468aa43783 100644
--- a/ui/views/widget/desktop_aura/x11_move_loop_delegate.h
+++ b/ui/views/widget/desktop_aura/x11_move_loop_delegate.h
@@ -14,6 +14,8 @@ namespace views {
 // Receives mouse events while the X11MoveLoop is tracking a drag.
 class X11MoveLoopDelegate {
  public:
+  virtual ~X11MoveLoopDelegate() {}
+
   // Called when we receive a mouse move event.
   virtual void OnMouseMovement(const gfx::Point& screen_point,
                                int flags,

From f6d0cf2c46dcc64f527300c597684c2bb470c6c9 Mon Sep 17 00:00:00 2001
From: Maksim Sisov <msisov@igalia.com>
Date: Tue, 15 May 2018 13:49:49 +0300
Subject: [PATCH 10/32] [ozone/x11] Add initial display data fetching
 mechanism.

This is a work-in-progress, which allows to fetch display data
and unblock start of ozone/x11, which crashes now.

Idieally, X11NativeDisplayDelegate should communicate with
DesktopScreenX11 (to be copied and modified and renamed to
X11DesktopScreenOzone).

fixup! [ozone/x11] Add initial display data fetching mechanism.

Compilation fixes.
---
 ui/ozone/platform/x11/BUILD.gn                |   2 +
 ui/ozone/platform/x11/ozone_platform_x11.cc   |   4 +-
 .../x11/x11_native_display_delegate.cc        | 109 ++++++++++++++++++
 .../x11/x11_native_display_delegate.h         |  56 +++++++++
 4 files changed, 169 insertions(+), 2 deletions(-)
 create mode 100644 ui/ozone/platform/x11/x11_native_display_delegate.cc
 create mode 100644 ui/ozone/platform/x11/x11_native_display_delegate.h

diff --git a/ui/ozone/platform/x11/BUILD.gn b/ui/ozone/platform/x11/BUILD.gn
index 5de8d7166c17a..0319ce89575aa 100644
--- a/ui/ozone/platform/x11/BUILD.gn
+++ b/ui/ozone/platform/x11/BUILD.gn
@@ -30,6 +30,8 @@ source_set("x11") {
     "x11_window_manager_ozone.h",
     "x11_window_ozone.cc",
     "x11_window_ozone.h",
+    "x11_native_display_delegate.h",
+    "x11_native_display_delegate.cc",
   ]
 
   deps = [
diff --git a/ui/ozone/platform/x11/ozone_platform_x11.cc b/ui/ozone/platform/x11/ozone_platform_x11.cc
index 944206ff68f22..3b65fd4d020bb 100644
--- a/ui/ozone/platform/x11/ozone_platform_x11.cc
+++ b/ui/ozone/platform/x11/ozone_platform_x11.cc
@@ -10,12 +10,12 @@
 #include "base/message_loop/message_loop.h"
 #include "base/strings/utf_string_conversions.h"
 #include "ui/base/x/x11_util.h"
-#include "ui/display/manager/fake_display_delegate.h"
 #include "ui/events/devices/x11/touch_factory_x11.h"
 #include "ui/events/platform/x11/x11_event_source_libevent.h"
 #include "ui/events/system_input_injector.h"
 #include "ui/gfx/x/x11.h"
 #include "ui/ozone/common/stub_overlay_manager.h"
+#include "ui/ozone/platform/x11/x11_native_display_delegate.h"
 #include "ui/ozone/platform/x11/x11_cursor_factory_ozone.h"
 #include "ui/ozone/platform/x11/x11_surface_factory.h"
 #include "ui/ozone/platform/x11/x11_window_manager_ozone.h"
@@ -73,7 +73,7 @@ class OzonePlatformX11 : public OzonePlatform {
 
   std::unique_ptr<display::NativeDisplayDelegate> CreateNativeDisplayDelegate()
       override {
-    return std::make_unique<display::FakeDisplayDelegate>();
+    return std::make_unique<X11NativeDisplayDelegate>();
   }
 
   void InitializeUI(const InitParams& params) override {
diff --git a/ui/ozone/platform/x11/x11_native_display_delegate.cc b/ui/ozone/platform/x11/x11_native_display_delegate.cc
new file mode 100644
index 0000000000000..58464ae289242
--- /dev/null
+++ b/ui/ozone/platform/x11/x11_native_display_delegate.cc
@@ -0,0 +1,109 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/ozone/platform/x11/x11_native_display_delegate.h"
+
+#include "ui/display/types/display_snapshot.h"
+#include "ui/display/types/native_display_observer.h"
+#include "ui/gfx/x/x11.h"
+#include "ui/gfx/x/x11_types.h"
+
+namespace ui {
+
+X11NativeDisplayDelegate::X11NativeDisplayDelegate() = default;
+
+X11NativeDisplayDelegate::~X11NativeDisplayDelegate() = default;
+
+void X11NativeDisplayDelegate::Initialize() {
+  // This shouldn't be called twice.
+  DCHECK(!current_snapshot_);
+
+  XDisplay* display = gfx::GetXDisplay();
+  Screen* screen = DefaultScreenOfDisplay(display);
+  current_snapshot_.reset(new display::DisplaySnapshot(
+      XScreenNumberOfScreen(screen), gfx::Point(0, 0),
+      gfx::Size(WidthOfScreen(screen), HeightOfScreen(screen)),
+      display::DisplayConnectionType::DISPLAY_CONNECTION_TYPE_NONE, false,
+      false, false, gfx::ColorSpace(), "", base::FilePath(),
+      display::DisplaySnapshot::DisplayModeList(), std::vector<uint8_t>(),
+      nullptr, nullptr, 0, 0, gfx::Size()));
+  const int default_refresh = 60;
+  current_mode_.reset(new display::DisplayMode(
+      gfx::Size(WidthOfScreen(screen), HeightOfScreen(screen)), false,
+      default_refresh));
+  current_snapshot_->set_current_mode(current_mode_.get());
+
+  for (display::NativeDisplayObserver& observer : observers_)
+    observer.OnConfigurationChanged();
+}
+
+void X11NativeDisplayDelegate::TakeDisplayControl(
+    display::DisplayControlCallback callback) {
+  NOTREACHED();
+}
+
+void X11NativeDisplayDelegate::RelinquishDisplayControl(
+    display::DisplayControlCallback callback) {
+  NOTREACHED();
+}
+
+void X11NativeDisplayDelegate::GetDisplays(
+    display::GetDisplaysCallback callback) {
+  // TODO(msisov): Add support for multiple displays and dynamic display data
+  // change.
+  std::vector<display::DisplaySnapshot*> snapshot;
+  snapshot.push_back(current_snapshot_.get());
+  std::move(callback).Run(snapshot);
+}
+
+void X11NativeDisplayDelegate::Configure(const display::DisplaySnapshot& output,
+                                         const display::DisplayMode* mode,
+                                         const gfx::Point& origin,
+                                         display::ConfigureCallback callback) {
+  NOTREACHED();
+}
+
+void X11NativeDisplayDelegate::GetHDCPState(
+    const display::DisplaySnapshot& output,
+    display::GetHDCPStateCallback callback) {
+  NOTREACHED();
+}
+
+void X11NativeDisplayDelegate::SetHDCPState(
+    const display::DisplaySnapshot& output,
+    display::HDCPState state,
+    display::SetHDCPStateCallback callback) {
+  NOTREACHED();
+}
+
+bool X11NativeDisplayDelegate::SetColorMatrix(int64_t display_id,
+                    const std::vector<float>& color_matrix) {
+  NOTREACHED();
+  return false;
+}
+
+bool X11NativeDisplayDelegate::SetGammaCorrection(
+    int64_t display_id,
+    const std::vector<display::GammaRampRGBEntry>& degamma_lut,
+    const std::vector<display::GammaRampRGBEntry>& gamma_lut) {
+  NOTREACHED();
+  return false;
+}
+
+void X11NativeDisplayDelegate::AddObserver(
+    display::NativeDisplayObserver* observer) {
+  observers_.AddObserver(observer);
+}
+
+void X11NativeDisplayDelegate::RemoveObserver(
+    display::NativeDisplayObserver* observer) {
+  observers_.RemoveObserver(observer);
+}
+
+display::FakeDisplayController*
+X11NativeDisplayDelegate::GetFakeDisplayController() {
+  return nullptr;
+}
+
+}  // namespace ui
diff --git a/ui/ozone/platform/x11/x11_native_display_delegate.h b/ui/ozone/platform/x11/x11_native_display_delegate.h
new file mode 100644
index 0000000000000..b0cdda69ac2fd
--- /dev/null
+++ b/ui/ozone/platform/x11/x11_native_display_delegate.h
@@ -0,0 +1,56 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PLATFORM_X11_X11_NATIVE_DISPLAY_DELEGATE_H_
+#define UI_OZONE_PLATFORM_X11_X11_NATIVE_DISPLAY_DELEGATE_H_
+
+#include "base/macros.h"
+#include "base/observer_list.h"
+#include "ui/display/types/native_display_delegate.h"
+#include "ui/display/types/display_snapshot.h"
+
+namespace ui {
+
+class X11NativeDisplayDelegate : public display::NativeDisplayDelegate {
+ public:
+  X11NativeDisplayDelegate();
+  ~X11NativeDisplayDelegate() override;
+
+  // display::NativeDisplayDelegate overrides:
+  void Initialize() override;
+  void TakeDisplayControl(display::DisplayControlCallback callback) override;
+  void RelinquishDisplayControl(
+      display::DisplayControlCallback callback) override;
+  void GetDisplays(display::GetDisplaysCallback callback) override;
+  void Configure(const display::DisplaySnapshot& output,
+                 const display::DisplayMode* mode,
+                 const gfx::Point& origin,
+                 display::ConfigureCallback callback) override;
+  void GetHDCPState(const display::DisplaySnapshot& output,
+                    display::GetHDCPStateCallback callback) override;
+  void SetHDCPState(const display::DisplaySnapshot& output,
+                    display::HDCPState state,
+                    display::SetHDCPStateCallback callback) override;
+  bool SetColorMatrix(int64_t display_id,
+                      const std::vector<float>& color_matrix) override;
+  bool SetGammaCorrection(
+      int64_t display_id,
+      const std::vector<display::GammaRampRGBEntry>& degamma_lut,
+      const std::vector<display::GammaRampRGBEntry>& gamma_lut) override;
+  void AddObserver(display::NativeDisplayObserver* observer) override;
+  void RemoveObserver(display::NativeDisplayObserver* observer) override;
+  display::FakeDisplayController* GetFakeDisplayController() override;
+
+ private:
+  std::unique_ptr<display::DisplaySnapshot> current_snapshot_;
+  std::unique_ptr<display::DisplayMode> current_mode_;
+ 
+  base::ObserverList<display::NativeDisplayObserver> observers_;
+
+  DISALLOW_COPY_AND_ASSIGN(X11NativeDisplayDelegate);
+};
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_X11_X11_NATIVE_DISPLAY_DELEGATE_H_

From 9935306d411dc9f346ff93b0aff23386c64adf32 Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Tue, 5 Jun 2018 15:44:19 +0900
Subject: [PATCH 11/32] Add X11DisplayManager to get display information

X11NativeDisplayDelegate owns X11DisplayManager and it's
registered as an X11DisplayManager's observer and it starts to
communicate with it. When X11DisplayManager is created, it
gathers display information and create DisplaySnapshot.
DesktopScreenOzone gets updated display through
DesktopScreenOzone::OnConfigurationChanged,
X11NativeDisplayDelegate::GetDisplays and
DesktopScreenOzone::OnHostDisplaysReady.

fixup! Add X11DisplayManager to get display information

This patch removed OwnedDisplaySnapshot because it doesn't need to
own DisplayMode. DisplaySnapshot is created with
DisplaySnapshot::DisplayModeList, which is the list has DisplayModes.
Whenever DisplayMode is added to the list, it's cloned and kept in
the list and every DisplayMode should be in the list.
---
 ui/base/x/x11_util.cc                         |  32 +++
 ui/base/x/x11_util.h                          |   4 +
 ui/display/util/BUILD.gn                      |   3 +-
 ui/ozone/platform/x11/BUILD.gn                |   7 +-
 .../platform/x11/x11_display_manager_ozone.cc | 233 ++++++++++++++++++
 .../platform/x11/x11_display_manager_ozone.h  |  73 ++++++
 .../x11/x11_native_display_delegate.cc        |  41 ++-
 .../x11/x11_native_display_delegate.h         |  23 +-
 .../widget/desktop_aura/desktop_screen_x11.cc |  33 +--
 9 files changed, 384 insertions(+), 65 deletions(-)
 create mode 100644 ui/ozone/platform/x11/x11_display_manager_ozone.cc
 create mode 100644 ui/ozone/platform/x11/x11_display_manager_ozone.h

diff --git a/ui/base/x/x11_util.cc b/ui/base/x/x11_util.cc
index 3b3048818852d..845193745b642 100644
--- a/ui/base/x/x11_util.cc
+++ b/ui/base/x/x11_util.cc
@@ -19,6 +19,7 @@
 #include <vector>
 
 #include "base/bind.h"
+#include "base/command_line.h"
 #include "base/location.h"
 #include "base/logging.h"
 #include "base/macros.h"
@@ -54,6 +55,7 @@
 #include "ui/gfx/image/image_skia.h"
 #include "ui/gfx/image/image_skia_rep.h"
 #include "ui/gfx/skia_util.h"
+#include "ui/gfx/switches.h"
 #include "ui/gfx/x/x11.h"
 #include "ui/gfx/x/x11_atom_cache.h"
 #include "ui/gfx/x/x11_error_tracker.h"
@@ -1268,6 +1270,36 @@ bool WmSupportsHint(XAtom atom) {
   return base::ContainsValue(supported_atoms, atom);
 }
 
+gfx::ICCProfile GetICCProfileForMonitor(int monitor) {
+  gfx::ICCProfile icc_profile;
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kHeadless))
+    return icc_profile;
+  std::string atom_name;
+  if (monitor == 0) {
+    atom_name = "_ICC_PROFILE";
+  } else {
+    atom_name = base::StringPrintf("_ICC_PROFILE_%d", monitor);
+  }
+  Atom property = gfx::GetAtom(atom_name.c_str());
+  if (property != x11::None) {
+    Atom prop_type = x11::None;
+    int prop_format = 0;
+    unsigned long nitems = 0;
+    unsigned long nbytes = 0;
+    char* property_data = NULL;
+    if (XGetWindowProperty(
+            gfx::GetXDisplay(), DefaultRootWindow(gfx::GetXDisplay()), property,
+            0, 0x1FFFFFFF /* MAXINT32 / 4 */, x11::False, AnyPropertyType,
+            &prop_type, &prop_format, &nitems, &nbytes,
+            reinterpret_cast<unsigned char**>(&property_data)) ==
+        x11::Success) {
+      icc_profile = gfx::ICCProfile::FromData(property_data, nitems);
+      XFree(property_data);
+    }
+  }
+  return icc_profile;
+}
+
 XRefcountedMemory::XRefcountedMemory(unsigned char* x11_data, size_t length)
     : x11_data_(length ? x11_data : nullptr), length_(length) {
 }
diff --git a/ui/base/x/x11_util.h b/ui/base/x/x11_util.h
index e7942b9809026..2405941e79f37 100644
--- a/ui/base/x/x11_util.h
+++ b/ui/base/x/x11_util.h
@@ -23,6 +23,7 @@
 #include "ui/events/event_constants.h"
 #include "ui/events/keycodes/keyboard_codes.h"
 #include "ui/events/platform_event.h"
+#include "ui/gfx/icc_profile.h"
 #include "ui/gfx/x/x11_types.h"
 
 typedef unsigned long XSharedMemoryId;  // ShmSeg in the X headers.
@@ -297,6 +298,9 @@ UI_BASE_X_EXPORT bool IsX11WindowFullScreen(XID window);
 // Returns true if the window manager supports the given hint.
 UI_BASE_X_EXPORT bool WmSupportsHint(XAtom atom);
 
+// Return the ICCProfile corresponding to |monitor| using XGetWindowProperty.
+UI_BASE_X_EXPORT gfx::ICCProfile GetICCProfileForMonitor(int monitor);
+
 // Manages a piece of X11 allocated memory as a RefCountedMemory segment. This
 // object takes ownership over the passed in memory and will free it with the
 // X11 allocator when done.
diff --git a/ui/display/util/BUILD.gn b/ui/display/util/BUILD.gn
index e7870883a117e..d4ee6f5c8080d 100644
--- a/ui/display/util/BUILD.gn
+++ b/ui/display/util/BUILD.gn
@@ -5,6 +5,7 @@
 import("//build/config/jumbo.gni")
 import("//build/config/ui.gni")
 import("//testing/libfuzzer/fuzzer_test.gni")
+import("//ui/ozone/ozone.gni")
 
 jumbo_component("util") {
   output_name = "display_util"
@@ -25,7 +26,7 @@ jumbo_component("util") {
     "//ui/gfx/geometry",
   ]
 
-  if (use_x11) {
+  if (use_x11 || ozone_platform_x11) {
     sources += [
       "x11/edid_parser_x11.cc",
       "x11/edid_parser_x11.h",
diff --git a/ui/ozone/platform/x11/BUILD.gn b/ui/ozone/platform/x11/BUILD.gn
index 0319ce89575aa..8748ffc5fc52a 100644
--- a/ui/ozone/platform/x11/BUILD.gn
+++ b/ui/ozone/platform/x11/BUILD.gn
@@ -32,6 +32,8 @@ source_set("x11") {
     "x11_window_ozone.h",
     "x11_native_display_delegate.h",
     "x11_native_display_delegate.cc",
+    "x11_display_manager_ozone.h",
+    "x11_display_manager_ozone.cc",
   ]
 
   deps = [
@@ -61,7 +63,10 @@ source_set("x11") {
     deps += [ "//gpu/vulkan/x" ]
   }
 
-  configs += [ "//build/config/linux:x11" ]
+  configs += [
+    "//build/config/linux:x11",
+    "//build/config/linux:xrandr"
+  ]
 
   public_configs = [ "//third_party/khronos:khronos_headers" ]
 }
diff --git a/ui/ozone/platform/x11/x11_display_manager_ozone.cc b/ui/ozone/platform/x11/x11_display_manager_ozone.cc
new file mode 100644
index 0000000000000..ec1ba9016c529
--- /dev/null
+++ b/ui/ozone/platform/x11/x11_display_manager_ozone.cc
@@ -0,0 +1,233 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/ozone/platform/x11/x11_display_manager_ozone.h"
+
+#include "base/logging.h"
+#include "base/memory/protected_memory_cfi.h"
+#include "ui/base/x/x11_util.h"
+#include "ui/display/display.h"
+#include "ui/display/types/display_snapshot.h"
+#include "ui/display/util/display_util.h"
+#include "ui/display/util/x11/edid_parser_x11.h"
+#include "ui/events/platform/platform_event_source.h"
+#include "ui/gfx/x/x11.h"
+#include "ui/gfx/x/x11_atom_cache.h"
+#include "ui/gfx/x/x11_types.h"
+
+#include <dlfcn.h>
+
+namespace ui {
+
+namespace {
+
+constexpr int default_refresh = 60;
+
+std::unique_ptr<display::DisplaySnapshot> CreateSnapshot(
+    int64_t display_id,
+    gfx::Rect bounds,
+    gfx::ColorSpace color_space) {
+  display::DisplaySnapshot::DisplayModeList modes;
+  std::unique_ptr<display::DisplayMode> display_mode =
+      std::make_unique<display::DisplayMode>(
+          gfx::Size(bounds.width(), bounds.height()), false, default_refresh);
+  modes.push_back(std::move(display_mode));
+  const display::DisplayMode* mode = modes.back().get();
+
+  return std::make_unique<display::DisplaySnapshot>(
+      display_id, gfx::Point(bounds.x(), bounds.y()),
+      gfx::Size(bounds.width(), bounds.height()),
+      display::DisplayConnectionType::DISPLAY_CONNECTION_TYPE_NONE, false,
+      false, false, false, color_space, "", base::FilePath(), std::move(modes),
+      std::vector<uint8_t>(), mode, mode, 0, 0, gfx::Size());
+}
+
+std::vector<std::unique_ptr<display::DisplaySnapshot>>
+BuildFallbackDisplayList() {
+  std::vector<std::unique_ptr<display::DisplaySnapshot>> snapshots;
+  ::XDisplay* display = gfx::GetXDisplay();
+  ::Screen* screen = DefaultScreenOfDisplay(display);
+  int width = WidthOfScreen(screen);
+  int height = HeightOfScreen(screen);
+  int64_t display_id = 0;
+  gfx::Rect bounds(0, 0, width, height);
+  std::unique_ptr<display::DisplaySnapshot> snapshot =
+      CreateSnapshot(display_id, bounds, gfx::ColorSpace());
+  snapshots.push_back(std::move(snapshot));
+  return snapshots;
+}
+
+}  // namespace
+
+////////////////////////////////////////////////////////////////////////////////
+// X11DisplayManagerOzone, public:
+
+X11DisplayManagerOzone::X11DisplayManagerOzone()
+    : xdisplay_(gfx::GetXDisplay()),
+      x_root_window_(DefaultRootWindow(xdisplay_)),
+      xrandr_version_(0),
+      xrandr_event_base_(0) {
+  // We only support 1.3+. There were library changes before this and we should
+  // use the new interface instead of the 1.2 one.
+  int randr_version_major = 0;
+  int randr_version_minor = 0;
+  if (XRRQueryVersion(xdisplay_, &randr_version_major, &randr_version_minor)) {
+    xrandr_version_ = randr_version_major * 100 + randr_version_minor;
+  }
+  // Need at least xrandr version 1.3.
+  if (xrandr_version_ < 103) {
+    snapshots_ = BuildFallbackDisplayList();
+    return;
+  }
+
+  int error_base_ignored = 0;
+  XRRQueryExtension(xdisplay_, &xrandr_event_base_, &error_base_ignored);
+
+  if (ui::PlatformEventSource::GetInstance())
+    ui::PlatformEventSource::GetInstance()->AddPlatformEventDispatcher(this);
+  XRRSelectInput(xdisplay_, x_root_window_,
+                 RRScreenChangeNotifyMask | RROutputChangeNotifyMask |
+                     RRCrtcChangeNotifyMask);
+  BuildDisplaysFromXRandRInfo();
+  return;
+}
+
+X11DisplayManagerOzone::~X11DisplayManagerOzone() {
+  if (xrandr_version_ >= 103 && ui::PlatformEventSource::GetInstance())
+    ui::PlatformEventSource::GetInstance()->RemovePlatformEventDispatcher(this);
+}
+
+void X11DisplayManagerOzone::SetObserver(Observer* observer) {
+  observer_ = observer;
+  if (snapshots_.size() > 0)
+    observer_->OnOutputReadyForUse();
+}
+
+void X11DisplayManagerOzone::GetDisplaysSnapshot(
+    display::GetDisplaysCallback callback) {
+  std::vector<display::DisplaySnapshot*> snapshots;
+  for (const auto& snapshot : snapshots_)
+    snapshots.push_back(snapshot.get());
+  std::move(callback).Run(snapshots);
+}
+
+bool X11DisplayManagerOzone::CanDispatchEvent(const ui::PlatformEvent& event) {
+  // TODO(msisov, jkim): implement this.
+  NOTIMPLEMENTED_LOG_ONCE();
+  return false;
+}
+
+uint32_t X11DisplayManagerOzone::DispatchEvent(const ui::PlatformEvent& event) {
+  // TODO(msisov, jkim): implement this.
+  NOTIMPLEMENTED_LOG_ONCE();
+  return ui::POST_DISPATCH_NONE;
+}
+
+typedef XRRMonitorInfo* (*XRRGetMonitors)(::Display*, Window, bool, int*);
+typedef void (*XRRFreeMonitors)(XRRMonitorInfo*);
+
+PROTECTED_MEMORY_SECTION base::ProtectedMemory<XRRGetMonitors>
+    g_XRRGetMonitors_ptr;
+PROTECTED_MEMORY_SECTION base::ProtectedMemory<XRRFreeMonitors>
+    g_XRRFreeMonitors_ptr;
+
+void X11DisplayManagerOzone::BuildDisplaysFromXRandRInfo() {
+  DCHECK(xrandr_version_ >= 103);
+  gfx::XScopedPtr<
+      XRRScreenResources,
+      gfx::XObjectDeleter<XRRScreenResources, void, XRRFreeScreenResources>>
+      resources(XRRGetScreenResourcesCurrent(xdisplay_, x_root_window_));
+  if (!resources) {
+    LOG(ERROR) << "XRandR returned no displays. Falling back to Root Window.";
+    snapshots_ = BuildFallbackDisplayList();
+    return;
+  }
+
+  std::map<RROutput, int> output_to_monitor;
+  if (xrandr_version_ >= 105) {
+    void* xrandr_lib = dlopen(NULL, RTLD_NOW);
+    if (xrandr_lib) {
+      static base::ProtectedMemory<XRRGetMonitors>::Initializer get_init(
+          &g_XRRGetMonitors_ptr, reinterpret_cast<XRRGetMonitors>(
+                                     dlsym(xrandr_lib, "XRRGetMonitors")));
+      static base::ProtectedMemory<XRRFreeMonitors>::Initializer free_init(
+          &g_XRRFreeMonitors_ptr, reinterpret_cast<XRRFreeMonitors>(
+                                      dlsym(xrandr_lib, "XRRFreeMonitors")));
+      if (*g_XRRGetMonitors_ptr && *g_XRRFreeMonitors_ptr) {
+        int nmonitors = 0;
+        XRRMonitorInfo* monitors = base::UnsanitizedCfiCall(
+            g_XRRGetMonitors_ptr)(xdisplay_, x_root_window_, false, &nmonitors);
+        for (int monitor = 0; monitor < nmonitors; monitor++) {
+          for (int j = 0; j < monitors[monitor].noutput; j++) {
+            output_to_monitor[monitors[monitor].outputs[j]] = monitor;
+          }
+        }
+        base::UnsanitizedCfiCall(g_XRRFreeMonitors_ptr)(monitors);
+      }
+    }
+  }
+
+  primary_display_index_ = 0;
+  RROutput primary_display_id = XRRGetOutputPrimary(xdisplay_, x_root_window_);
+
+  int explicit_primary_display_index = -1;
+  int monitor_order_primary_display_index = -1;
+
+  for (int i = 0; i < resources->noutput; ++i) {
+    RROutput output_id = resources->outputs[i];
+    gfx::XScopedPtr<XRROutputInfo,
+                    gfx::XObjectDeleter<XRROutputInfo, void, XRRFreeOutputInfo>>
+        output_info(XRRGetOutputInfo(xdisplay_, resources.get(), output_id));
+
+    bool is_connected = (output_info->connection == RR_Connected);
+    if (!is_connected)
+      continue;
+
+    bool is_primary_display = output_id == primary_display_id;
+
+    if (output_info->crtc) {
+      gfx::XScopedPtr<XRRCrtcInfo,
+                      gfx::XObjectDeleter<XRRCrtcInfo, void, XRRFreeCrtcInfo>>
+          crtc(XRRGetCrtcInfo(xdisplay_, resources.get(), output_info->crtc));
+
+      int64_t display_id = -1;
+      if (!display::EDIDParserX11(output_id).GetDisplayId(
+              static_cast<uint8_t>(i), &display_id)) {
+        // It isn't ideal, but if we can't parse the EDID data, fallback on the
+        // display number.
+        display_id = i;
+      }
+
+      gfx::Rect crtc_bounds(crtc->x, crtc->y, crtc->width, crtc->height);
+      if (is_primary_display)
+        explicit_primary_display_index = display_id;
+
+      auto monitor_iter = output_to_monitor.find(output_id);
+      if (monitor_iter != output_to_monitor.end() && monitor_iter->second == 0)
+        monitor_order_primary_display_index = display_id;
+
+      gfx::ColorSpace color_space;
+      if (!display::Display::HasForceColorProfile()) {
+        gfx::ICCProfile icc_profile = ui::GetICCProfileForMonitor(
+            monitor_iter == output_to_monitor.end() ? 0 : monitor_iter->second);
+        icc_profile.HistogramDisplay(display_id);
+        color_space = icc_profile.GetColorSpace();
+      } else {
+        color_space = display::Display::GetForcedColorProfile();
+      }
+
+      std::unique_ptr<display::DisplaySnapshot> snapshot =
+          CreateSnapshot(display_id, crtc_bounds, color_space);
+      snapshots_.push_back(std::move(snapshot));
+    }
+  }
+
+  if (explicit_primary_display_index != -1) {
+    primary_display_index_ = explicit_primary_display_index;
+  } else if (monitor_order_primary_display_index != -1) {
+    primary_display_index_ = monitor_order_primary_display_index;
+  }
+}
+
+}  // namespace ui
diff --git a/ui/ozone/platform/x11/x11_display_manager_ozone.h b/ui/ozone/platform/x11/x11_display_manager_ozone.h
new file mode 100644
index 0000000000000..78319da483597
--- /dev/null
+++ b/ui/ozone/platform/x11/x11_display_manager_ozone.h
@@ -0,0 +1,73 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PLATFORM_X11_X11_DISPLAY_MANAGER_OZONE_H_
+#define UI_OZONE_PLATFORM_X11_X11_DISPLAY_MANAGER_OZONE_H_
+
+#include <stdint.h>
+
+#include "ui/display/types/native_display_delegate.h"
+#include "ui/events/platform/platform_event_dispatcher.h"
+
+typedef unsigned long XID;
+typedef XID Window;
+typedef struct _XDisplay Display;
+
+namespace display {
+class DisplayMode;
+class DisplaySnapshot;
+}  // namespace display
+
+namespace ui {
+
+// X11DisplayManagerOzone talks to xrandr.
+class X11DisplayManagerOzone : public ui::PlatformEventDispatcher {
+ public:
+  class Observer {
+   public:
+    // Will be called when X11DisplayManagerOzone is available.
+    virtual void OnOutputReadyForUse() = 0;
+  };
+
+  X11DisplayManagerOzone();
+  ~X11DisplayManagerOzone() override;
+
+  void SetObserver(Observer* observer);
+  Observer* observer() { return observer_; }
+
+  void GetDisplaysSnapshot(display::GetDisplaysCallback callback);
+
+  // ui::PlatformEventDispatcher:
+  bool CanDispatchEvent(const ui::PlatformEvent& event) override;
+  uint32_t DispatchEvent(const ui::PlatformEvent& event) override;
+
+ private:
+  // Builds a list of displays from the current screen information offered by
+  // the X server.
+  void BuildDisplaysFromXRandRInfo();
+
+  ::Display* xdisplay_;
+  ::Window x_root_window_;
+
+  // XRandR version. MAJOR * 100 + MINOR. Zero if no xrandr is present.
+  int xrandr_version_;
+
+  // The base of the event numbers used to represent XRandr events used in
+  // decoding events regarding output add/remove.
+  int xrandr_event_base_;
+
+  // The display objects we present to chrome.
+  std::vector<std::unique_ptr<display::DisplaySnapshot>> snapshots_;
+
+  // The index into displays_ that represents the primary display.
+  size_t primary_display_index_;
+
+  Observer* observer_;
+
+  DISALLOW_COPY_AND_ASSIGN(X11DisplayManagerOzone);
+};
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_X11_X11_DISPLAY_MANAGER_OZONE_H_
diff --git a/ui/ozone/platform/x11/x11_native_display_delegate.cc b/ui/ozone/platform/x11/x11_native_display_delegate.cc
index 58464ae289242..2551b6ed3996e 100644
--- a/ui/ozone/platform/x11/x11_native_display_delegate.cc
+++ b/ui/ozone/platform/x11/x11_native_display_delegate.cc
@@ -16,26 +16,8 @@ X11NativeDisplayDelegate::X11NativeDisplayDelegate() = default;
 X11NativeDisplayDelegate::~X11NativeDisplayDelegate() = default;
 
 void X11NativeDisplayDelegate::Initialize() {
-  // This shouldn't be called twice.
-  DCHECK(!current_snapshot_);
-
-  XDisplay* display = gfx::GetXDisplay();
-  Screen* screen = DefaultScreenOfDisplay(display);
-  current_snapshot_.reset(new display::DisplaySnapshot(
-      XScreenNumberOfScreen(screen), gfx::Point(0, 0),
-      gfx::Size(WidthOfScreen(screen), HeightOfScreen(screen)),
-      display::DisplayConnectionType::DISPLAY_CONNECTION_TYPE_NONE, false,
-      false, false, gfx::ColorSpace(), "", base::FilePath(),
-      display::DisplaySnapshot::DisplayModeList(), std::vector<uint8_t>(),
-      nullptr, nullptr, 0, 0, gfx::Size()));
-  const int default_refresh = 60;
-  current_mode_.reset(new display::DisplayMode(
-      gfx::Size(WidthOfScreen(screen), HeightOfScreen(screen)), false,
-      default_refresh));
-  current_snapshot_->set_current_mode(current_mode_.get());
-
-  for (display::NativeDisplayObserver& observer : observers_)
-    observer.OnConfigurationChanged();
+  display_manager_ = std::make_unique<X11DisplayManagerOzone>();
+  display_manager_->SetObserver(this);
 }
 
 void X11NativeDisplayDelegate::TakeDisplayControl(
@@ -52,16 +34,20 @@ void X11NativeDisplayDelegate::GetDisplays(
     display::GetDisplaysCallback callback) {
   // TODO(msisov): Add support for multiple displays and dynamic display data
   // change.
-  std::vector<display::DisplaySnapshot*> snapshot;
-  snapshot.push_back(current_snapshot_.get());
-  std::move(callback).Run(snapshot);
+  if (displays_ready_)
+    display_manager_->GetDisplaysSnapshot(std::move(callback));
 }
 
 void X11NativeDisplayDelegate::Configure(const display::DisplaySnapshot& output,
                                          const display::DisplayMode* mode,
                                          const gfx::Point& origin,
                                          display::ConfigureCallback callback) {
-  NOTREACHED();
+  NOTIMPLEMENTED();
+
+  // It should call |callback| after configuration.
+  // Even if we don't have implementation, it calls |callback| to finish the
+  // logic. otherwise, several tests from views_mus_unittests don't work.
+  std::move(callback).Run(true);
 }
 
 void X11NativeDisplayDelegate::GetHDCPState(
@@ -106,4 +92,11 @@ X11NativeDisplayDelegate::GetFakeDisplayController() {
   return nullptr;
 }
 
+void X11NativeDisplayDelegate::OnOutputReadyForUse() {
+  if (!displays_ready_)
+    displays_ready_ = true;
+
+  for (display::NativeDisplayObserver& observer : observers_)
+    observer.OnConfigurationChanged();
+}
 }  // namespace ui
diff --git a/ui/ozone/platform/x11/x11_native_display_delegate.h b/ui/ozone/platform/x11/x11_native_display_delegate.h
index b0cdda69ac2fd..8d9542225e477 100644
--- a/ui/ozone/platform/x11/x11_native_display_delegate.h
+++ b/ui/ozone/platform/x11/x11_native_display_delegate.h
@@ -5,14 +5,19 @@
 #ifndef UI_OZONE_PLATFORM_X11_X11_NATIVE_DISPLAY_DELEGATE_H_
 #define UI_OZONE_PLATFORM_X11_X11_NATIVE_DISPLAY_DELEGATE_H_
 
-#include "base/macros.h"
 #include "base/observer_list.h"
 #include "ui/display/types/native_display_delegate.h"
-#include "ui/display/types/display_snapshot.h"
+#include "ui/ozone/platform/x11/x11_display_manager_ozone.h"
+
+namespace display {
+class DisplayMode;
+class DisplaySnapshot;
+}  // namespace display
 
 namespace ui {
 
-class X11NativeDisplayDelegate : public display::NativeDisplayDelegate {
+class X11NativeDisplayDelegate : public display::NativeDisplayDelegate,
+                                 public X11DisplayManagerOzone::Observer {
  public:
   X11NativeDisplayDelegate();
   ~X11NativeDisplayDelegate() override;
@@ -42,11 +47,15 @@ class X11NativeDisplayDelegate : public display::NativeDisplayDelegate {
   void RemoveObserver(display::NativeDisplayObserver* observer) override;
   display::FakeDisplayController* GetFakeDisplayController() override;
 
+  // X11DisplayManagerOzone::Observer overrides:
+  void OnOutputReadyForUse() override;
+
  private:
-  std::unique_ptr<display::DisplaySnapshot> current_snapshot_;
-  std::unique_ptr<display::DisplayMode> current_mode_;
- 
-  base::ObserverList<display::NativeDisplayObserver> observers_;
+  bool displays_ready_ = false;
+
+  std::unique_ptr<X11DisplayManagerOzone> display_manager_;
+
+  base::ObserverList<display::NativeDisplayObserver>::Unchecked observers_;
 
   DISALLOW_COPY_AND_ASSIGN(X11NativeDisplayDelegate);
 };
diff --git a/ui/views/widget/desktop_aura/desktop_screen_x11.cc b/ui/views/widget/desktop_aura/desktop_screen_x11.cc
index e90710c2c39c4..7f10d5e82e930 100644
--- a/ui/views/widget/desktop_aura/desktop_screen_x11.cc
+++ b/ui/views/widget/desktop_aura/desktop_screen_x11.cc
@@ -39,37 +39,6 @@
 
 namespace {
 
-// static
-gfx::ICCProfile GetICCProfileForMonitor(int monitor) {
-  gfx::ICCProfile icc_profile;
-  if (base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kHeadless))
-    return icc_profile;
-  std::string atom_name;
-  if (monitor == 0) {
-    atom_name = "_ICC_PROFILE";
-  } else {
-    atom_name = base::StringPrintf("_ICC_PROFILE_%d", monitor);
-  }
-  Atom property = gfx::GetAtom(atom_name.c_str());
-  if (property != x11::None) {
-    Atom prop_type = x11::None;
-    int prop_format = 0;
-    unsigned long nitems = 0;
-    unsigned long nbytes = 0;
-    char* property_data = NULL;
-    if (XGetWindowProperty(
-            gfx::GetXDisplay(), DefaultRootWindow(gfx::GetXDisplay()), property,
-            0, 0x1FFFFFFF /* MAXINT32 / 4 */, x11::False, AnyPropertyType,
-            &prop_type, &prop_format, &nitems, &nbytes,
-            reinterpret_cast<unsigned char**>(&property_data)) ==
-        x11::Success) {
-      icc_profile = gfx::ICCProfile::FromData(property_data, nitems);
-      XFree(property_data);
-    }
-  }
-  return icc_profile;
-}
-
 double GetDeviceScaleFactor() {
   float device_scale_factor = 1.0f;
   if (views::LinuxUI::instance()) {
@@ -451,7 +420,7 @@ std::vector<display::Display> DesktopScreenX11::BuildDisplaysFromXRandRInfo() {
         monitor_order_primary_display_index = displays.size();
 
       if (!display::Display::HasForceColorProfile()) {
-        gfx::ICCProfile icc_profile = GetICCProfileForMonitor(
+        gfx::ICCProfile icc_profile = ui::GetICCProfileForMonitor(
             monitor_iter == output_to_monitor.end() ? 0 : monitor_iter->second);
         icc_profile.HistogramDisplay(display.id());
         display.set_color_space(icc_profile.GetColorSpace());

From 56a3597720cd6d334164440f0d6ccf52672ba824 Mon Sep 17 00:00:00 2001
From: Maksim Sisov <msisov@igalia.com>
Date: Tue, 31 Jul 2018 09:49:03 +0300
Subject: [PATCH 12/32] Ensure default scale value of cursors is not 0.0f but
 1.0f.

This patches fixes a pointer offset issues, which usually happens
with Ozone/Wayland (and can happen with Ozone/X11).

That is, on certain occasions, the pointer bitmap can have an offset,
which results in wrong visual location of the pointer. This makes
it hard to press ui elements in Chromium.

The reason of that behaviour is that default scale value of the
Cursor class was 0.0f (when it is not explicitly set to something
else), but the SearchTable (cursors_aura) method checks for the
bitmap hotpoints based on the lowest possible scale value, which
is 1.0f. Thus, there was an inconsitancy between the scale value
and the hotpoints. When the cursor had a scale value implicitly
set to 0.0f (in the ctor), 2x hotpoints were used.

Unit tests have also been added.

TEST: CursorTest.EnsureHotspotValuesWithoutScale and
CursorTest.EnsureHotspotValuesWithScale
---
 ui/base/BUILD.gn                  |  4 ++
 ui/base/cursor/cursor.cc          | 12 ++++-
 ui/base/cursor/cursor_unittest.cc | 89 +++++++++++++++++++++++++++++++
 3 files changed, 103 insertions(+), 2 deletions(-)
 create mode 100644 ui/base/cursor/cursor_unittest.cc

diff --git a/ui/base/BUILD.gn b/ui/base/BUILD.gn
index 38c708684f226..c6af8f7dcd995 100644
--- a/ui/base/BUILD.gn
+++ b/ui/base/BUILD.gn
@@ -1019,6 +1019,10 @@ test("ui_base_unittests") {
     ]
   }
 
+  if (use_aura) {
+    sources += [ "cursor/cursor_unittest.cc" ]
+  }
+
   if (use_x11) {
     sources += [
       "dragdrop/os_exchange_data_provider_aurax11_unittest.cc",
diff --git a/ui/base/cursor/cursor.cc b/ui/base/cursor/cursor.cc
index 89bafae8df21f..f6ef462d98a39 100644
--- a/ui/base/cursor/cursor.cc
+++ b/ui/base/cursor/cursor.cc
@@ -6,13 +6,21 @@
 
 namespace ui {
 
+namespace {
+
+constexpr float kDefaultDeviceScaleFactor = 1.0f;
+
+}  // namespace
+
 Cursor::Cursor()
     : native_type_(CursorType::kNull),
       platform_cursor_(0),
-      device_scale_factor_(0.0f) {}
+      device_scale_factor_(kDefaultDeviceScaleFactor) {}
 
 Cursor::Cursor(CursorType type)
-    : native_type_(type), platform_cursor_(0), device_scale_factor_(0.0f) {}
+    : native_type_(type),
+      platform_cursor_(0),
+      device_scale_factor_(kDefaultDeviceScaleFactor) {}
 
 Cursor::Cursor(const Cursor& cursor)
     : native_type_(cursor.native_type_),
diff --git a/ui/base/cursor/cursor_unittest.cc b/ui/base/cursor/cursor_unittest.cc
new file mode 100644
index 0000000000000..0bf9b43287062
--- /dev/null
+++ b/ui/base/cursor/cursor_unittest.cc
@@ -0,0 +1,89 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/cursor/cursor.h"
+
+#include "base/logging.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "ui/base/cursor/cursor_type.h"
+#include "ui/base/resource/data_pack.h"
+#include "ui/base/resource/resource_bundle.h"
+
+namespace ui {
+
+namespace {
+
+// Cursor hotspot for the kPointer type is taken from
+// ui/base/cursor/cursors_aura.cc kNormalCursors.
+constexpr gfx::Point kPointerHotspot1x = gfx::Point(4, 4);
+constexpr gfx::Point kPointerHotspot2x = gfx::Point(7, 7);
+
+const char kSamplePakContentsV4[] = {
+    0x04, 0x00, 0x00, 0x00,              // header(version
+    0x04, 0x00, 0x00, 0x00,              //        no. entries
+    0x01,                                //        encoding)
+    0x01, 0x00, 0x27, 0x00, 0x00, 0x00,  // index entry 1
+    0x04, 0x00, 0x27, 0x00, 0x00, 0x00,  // index entry 4
+    0x06, 0x00, 0x33, 0x00, 0x00, 0x00,  // index entry 6
+    0x0a, 0x00, 0x3f, 0x00, 0x00, 0x00,  // index entry 10
+    0x00, 0x00, 0x3f, 0x00, 0x00, 0x00,  // extra entry for the size of last
+    't',  'h',  'i',  's',  ' ',  'i',  's', ' ', 'i', 'd', ' ', '4',
+    't',  'h',  'i',  's',  ' ',  'i',  's', ' ', 'i', 'd', ' ', '6'};
+
+const size_t kSamplePakSizeV4 = sizeof(kSamplePakContentsV4);
+
+void AddScaleFactorToResourceBundle(ScaleFactor scale_factor) {
+  ui::ResourceBundle::GetSharedInstance().CleanupSharedInstance();
+
+  std::unique_ptr<DataPack> data_pack =
+      std::make_unique<DataPack>(ScaleFactor::SCALE_FACTOR_200P);
+  // Load sample pak contents, otherwise CheckForDuplicateResources
+  // fails (called by AddDataPack). Unfortunetaly, all these steps
+  // are needed to properly identify hotpoints of cursors, which
+  // depend on the scale factor and SCALE_FACTOR_200P availability
+  // from the ResourceBundle.
+  ASSERT_TRUE(data_pack->LoadFromBuffer(
+      base::StringPiece(kSamplePakContentsV4, kSamplePakSizeV4)));
+
+  ui::ResourceBundle::InitSharedInstanceWithPakPath(base::FilePath());
+  ui::ResourceBundle::GetSharedInstance().AddDataPack(std::move(data_pack));
+}
+
+}  // namespace
+
+// Checks that default scale value of cursor is 1.0f and
+// hotpoints correspond to that value regradless of availability of
+// 200p resources.
+TEST(CursorTest, EnsureHotspotValuesWithoutScale) {
+  Cursor cursor(CursorType::kPointer);
+
+  EXPECT_EQ(1.0f, cursor.device_scale_factor());
+  EXPECT_EQ(kPointerHotspot1x, cursor.GetHotspot());
+
+  // 1.0f scale hotpoints must be used when the device scale factor is set to
+  // 1.0f regardless of the availability of 200P scale factor in the resource
+  // bundle. Check SearchTable in the ui/base/cursor/cursors_aura.cc to
+  // understand this better.
+  AddScaleFactorToResourceBundle(ScaleFactor::SCALE_FACTOR_200P);
+  EXPECT_EQ(kPointerHotspot1x, cursor.GetHotspot());
+}
+
+// Checks that explicitly set device scale value of the cursor always results
+// in 2.0F hotpoints.
+TEST(CursorTest, EnsureHotspotValuesWithScale) {
+  Cursor cursor(CursorType::kPointer);
+  cursor.set_device_scale_factor(2.0f);
+
+  EXPECT_EQ(2.0f, cursor.device_scale_factor());
+
+  // If device scale factor is 2.0f, hotpoints with 2x scale factor must be
+  // used.
+  EXPECT_EQ(kPointerHotspot2x, cursor.GetHotspot());
+
+  // Nothing must change ones the resource bundle has max scale of 200p.
+  AddScaleFactorToResourceBundle(ScaleFactor::SCALE_FACTOR_200P);
+  EXPECT_EQ(kPointerHotspot2x, cursor.GetHotspot());
+}
+
+}  // namespace ui

From 21265e4b8381d017635ca5f339dd91f3b3c1149f Mon Sep 17 00:00:00 2001
From: Jani Hautakangas <jani.hautakangas@lge.com>
Date: Mon, 15 Jan 2018 22:15:10 +0200
Subject: [PATCH 13/32] IME for Platform integration: remove chromeos deps

- Groups ui/base/ime common types into their own GN component
  (ime_types) to break a dependency cycle on ChromeOS that
  this CL would cause otherwise.
- Move chromeos source files under is_chromeos flag to avoid
  depending them when chromeos is not used, but ime is needed.
---
 ui/base/ime/BUILD.gn                   | 98 ++++++++++++++++----------
 ui/base/ime/candidate_window.h         |  8 +--
 ui/base/ime/composition_text.h         |  4 +-
 ui/base/ime/ime_text_span.h            |  4 +-
 ui/base/ime/infolist_entry.h           |  4 +-
 ui/base/ime/ui_base_ime_types_export.h | 34 +++++++++
 6 files changed, 104 insertions(+), 48 deletions(-)
 create mode 100644 ui/base/ime/ui_base_ime_types_export.h

diff --git a/ui/base/ime/BUILD.gn b/ui/base/ime/BUILD.gn
index 33698eedf5652..edaf7b55bb15c 100644
--- a/ui/base/ime/BUILD.gn
+++ b/ui/base/ime/BUILD.gn
@@ -15,51 +15,39 @@ source_set("text_input_types") {
   ]
 }
 
-jumbo_component("ime") {
-  output_name = "ui_base_ime"
+jumbo_component("ime_types") {
+  output_name = "ui_base_ime_types"
   sources = [
     "candidate_window.cc",
     "candidate_window.h",
-    "chromeos/character_composer.cc",
-    "chromeos/character_composer.h",
-    "chromeos/component_extension_ime_manager.cc",
-    "chromeos/component_extension_ime_manager.h",
-    "chromeos/extension_ime_util.cc",
-    "chromeos/extension_ime_util.h",
-    "chromeos/fake_ime_keyboard.cc",
-    "chromeos/fake_ime_keyboard.h",
-    "chromeos/fake_input_method_delegate.cc",
-    "chromeos/fake_input_method_delegate.h",
-    "chromeos/ime_candidate_window_handler_interface.h",
-    "chromeos/ime_keyboard.cc",
-    "chromeos/ime_keyboard.h",
-    "chromeos/ime_keymap.cc",
-    "chromeos/ime_keymap.h",
-    "chromeos/input_method_delegate.h",
-    "chromeos/input_method_descriptor.cc",
-    "chromeos/input_method_descriptor.h",
-    "chromeos/input_method_manager.cc",
-    "chromeos/input_method_manager.h",
-    "chromeos/input_method_util.cc",
-    "chromeos/input_method_util.h",
-    "chromeos/mock_component_extension_ime_manager.cc",
-    "chromeos/mock_component_extension_ime_manager.h",
-    "chromeos/mock_component_extension_ime_manager_delegate.cc",
-    "chromeos/mock_component_extension_ime_manager_delegate.h",
-    "chromeos/mock_ime_candidate_window_handler.cc",
-    "chromeos/mock_ime_candidate_window_handler.h",
-    "chromeos/mock_ime_engine_handler.cc",
-    "chromeos/mock_ime_engine_handler.h",
     "composition_text.cc",
     "composition_text.h",
-    "ime_bridge.cc",
-    "ime_bridge.h",
-    "ime_engine_handler_interface.h",
-    "ime_input_context_handler_interface.h",
     "ime_text_span.cc",
     "ime_text_span.h",
     "infolist_entry.cc",
     "infolist_entry.h",
+    "ui_base_ime_types_export.h",
+  ]
+
+  defines = [ "UI_BASE_IME_TYPES_IMPLEMENTATION" ]
+
+  deps = [
+    "//base",
+  ]
+
+  public_deps = [
+    ":text_input_types",
+    "//skia",
+  ]
+}
+
+jumbo_component("ime") {
+  output_name = "ui_base_ime"
+  sources = [
+    "ime_bridge.cc",
+    "ime_bridge.h",
+    "ime_engine_handler_interface.h",
+    "ime_input_context_handler_interface.h",
     "input_method.h",
     "input_method_base.cc",
     "input_method_base.h",
@@ -110,6 +98,41 @@ jumbo_component("ime") {
     "win/tsf_text_store.h",
   ]
 
+  if (is_chromeos) {
+    sources += [
+      "chromeos/character_composer.cc",
+      "chromeos/character_composer.h",
+      "chromeos/component_extension_ime_manager.cc",
+      "chromeos/component_extension_ime_manager.h",
+      "chromeos/extension_ime_util.cc",
+      "chromeos/extension_ime_util.h",
+      "chromeos/fake_ime_keyboard.cc",
+      "chromeos/fake_ime_keyboard.h",
+      "chromeos/fake_input_method_delegate.cc",
+      "chromeos/fake_input_method_delegate.h",
+      "chromeos/ime_candidate_window_handler_interface.h",
+      "chromeos/ime_keyboard.cc",
+      "chromeos/ime_keyboard.h",
+      "chromeos/ime_keymap.cc",
+      "chromeos/ime_keymap.h",
+      "chromeos/input_method_delegate.h",
+      "chromeos/input_method_descriptor.cc",
+      "chromeos/input_method_descriptor.h",
+      "chromeos/input_method_manager.cc",
+      "chromeos/input_method_manager.h",
+      "chromeos/input_method_util.cc",
+      "chromeos/input_method_util.h",
+      "chromeos/mock_component_extension_ime_manager.cc",
+      "chromeos/mock_component_extension_ime_manager.h",
+      "chromeos/mock_component_extension_ime_manager_delegate.cc",
+      "chromeos/mock_component_extension_ime_manager_delegate.h",
+      "chromeos/mock_ime_candidate_window_handler.cc",
+      "chromeos/mock_ime_candidate_window_handler.h",
+      "chromeos/mock_ime_engine_handler.cc",
+      "chromeos/mock_ime_engine_handler.h",
+    ]
+  }
+
   # TODO(jschuh): crbug.com/167187 fix size_t to int truncations.
   configs += [ "//build/config/compiler:no_size_t_to_int_warning" ]
 
@@ -132,8 +155,7 @@ jumbo_component("ime") {
   ]
 
   public_deps = [
-    ":text_input_types",
-    "//skia",
+    ":ime_types",
   ]
 
   if (is_desktop_linux) {
diff --git a/ui/base/ime/candidate_window.h b/ui/base/ime/candidate_window.h
index f27bfe29b702e..60b8f68e409dc 100644
--- a/ui/base/ime/candidate_window.h
+++ b/ui/base/ime/candidate_window.h
@@ -13,19 +13,19 @@
 
 #include "base/macros.h"
 #include "ui/base/ime/infolist_entry.h"
-#include "ui/base/ime/ui_base_ime_export.h"
+#include "ui/base/ime/ui_base_ime_types_export.h"
 
 namespace ui {
 
 // CandidateWindow represents the structure of candidates generated from IME.
-class UI_BASE_IME_EXPORT CandidateWindow {
+class UI_BASE_IME_TYPES_EXPORT CandidateWindow {
  public:
   enum Orientation {
     HORIZONTAL = 0,
     VERTICAL = 1,
   };
 
-  struct UI_BASE_IME_EXPORT CandidateWindowProperty {
+  struct UI_BASE_IME_TYPES_EXPORT CandidateWindowProperty {
     CandidateWindowProperty();
     virtual ~CandidateWindowProperty();
     int page_size;
@@ -41,7 +41,7 @@ class UI_BASE_IME_EXPORT CandidateWindow {
   };
 
   // Represents a candidate entry.
-  struct UI_BASE_IME_EXPORT Entry {
+  struct UI_BASE_IME_TYPES_EXPORT Entry {
     Entry();
     Entry(const Entry& other);
     virtual ~Entry();
diff --git a/ui/base/ime/composition_text.h b/ui/base/ime/composition_text.h
index 272535ba3e66f..6d05f15bce54a 100644
--- a/ui/base/ime/composition_text.h
+++ b/ui/base/ime/composition_text.h
@@ -9,13 +9,13 @@
 
 #include "base/strings/string16.h"
 #include "ui/base/ime/ime_text_span.h"
-#include "ui/base/ime/ui_base_ime_export.h"
+#include "ui/base/ime/ui_base_ime_types_export.h"
 #include "ui/gfx/range/range.h"
 
 namespace ui {
 
 // A struct represents the status of an ongoing composition text.
-struct UI_BASE_IME_EXPORT CompositionText {
+struct UI_BASE_IME_TYPES_EXPORT CompositionText {
   CompositionText();
   CompositionText(const CompositionText& other);
   ~CompositionText();
diff --git a/ui/base/ime/ime_text_span.h b/ui/base/ime/ime_text_span.h
index e47064a1a63c5..52011f3c06758 100644
--- a/ui/base/ime/ime_text_span.h
+++ b/ui/base/ime/ime_text_span.h
@@ -11,14 +11,14 @@
 #include <vector>
 
 #include "third_party/skia/include/core/SkColor.h"
-#include "ui/base/ime/ui_base_ime_export.h"
+#include "ui/base/ime/ui_base_ime_types_export.h"
 
 namespace ui {
 
 // Intentionally keep sync with blink::WebImeTextSpan defined in:
 // third_party/WebKit/public/web/WebImeTextSpan.h
 
-struct UI_BASE_IME_EXPORT ImeTextSpan {
+struct UI_BASE_IME_TYPES_EXPORT ImeTextSpan {
   enum class Type {
     // Creates a composition marker.
     kComposition,
diff --git a/ui/base/ime/infolist_entry.h b/ui/base/ime/infolist_entry.h
index a19d85410771e..1e16e5e938f2f 100644
--- a/ui/base/ime/infolist_entry.h
+++ b/ui/base/ime/infolist_entry.h
@@ -6,12 +6,12 @@
 #define UI_BASE_IME_INFOLIST_ENTRY_H_
 
 #include "base/strings/string16.h"
-#include "ui/base/ime/ui_base_ime_export.h"
+#include "ui/base/ime/ui_base_ime_types_export.h"
 
 namespace ui {
 
 // The data model of infolist window.
-struct UI_BASE_IME_EXPORT InfolistEntry {
+struct UI_BASE_IME_TYPES_EXPORT InfolistEntry {
   base::string16 title;
   base::string16 body;
   bool highlighted;
diff --git a/ui/base/ime/ui_base_ime_types_export.h b/ui/base/ime/ui_base_ime_types_export.h
new file mode 100644
index 0000000000000..354a8adc3f06f
--- /dev/null
+++ b/ui/base/ime/ui_base_ime_types_export.h
@@ -0,0 +1,34 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_IME_UI_BASE_IME_TYPES_EXPORT_H_
+#define UI_BASE_IME_UI_BASE_IME_TYPES_EXPORT_H_
+
+#if defined(COMPONENT_BUILD)
+
+#if defined(WIN32)
+
+#if defined(UI_BASE_IME_TYPES_IMPLEMENTATION)
+#define UI_BASE_IME_TYPES_EXPORT __declspec(dllexport)
+#else
+#define UI_BASE_IME_TYPES_EXPORT __declspec(dllimport)
+#endif
+
+#else  // !defined(WIN32)
+
+#if defined(UI_BASE_IME_TYPES_IMPLEMENTATION)
+#define UI_BASE_IME_TYPES_EXPORT __attribute__((visibility("default")))
+#else
+#define UI_BASE_IME_TYPES_EXPORT
+#endif
+
+#endif
+
+#else  // !defined(COMPONENT_BUILD)
+
+#define UI_BASE_IME_TYPES_EXPORT
+
+#endif
+
+#endif  // UI_BASE_IME_UI_BASE_IME_TYPES_EXPORT_H_

From 53109e87b0dfe91d67dc75c12e705eae9b7fe57d Mon Sep 17 00:00:00 2001
From: Jani Hautakangas <jani.hautakangas@lge.com>
Date: Wed, 17 Jan 2018 00:19:44 +0200
Subject: [PATCH 14/32] IME for Wayland: Ozone Wayland IME integration

Introduce Ozone Wayland IME integration.

This CL:
- Implements Ozone wayland specific Linux input method
  context service interface and integrates it with
  zwp_text_input_v1 protocol.
- Introduces new runtime flag --enable-wayland-ime to
  enable this feature (by default false).
- Fixes surrounding text deletion.
- Makes Wayland IME working with InputMethodAuraLinux

fixup! IME for Wayland: Ozone Wayland IME integration

Added condition before setting WaylandInputMethodContextFactory.
---
 ui/base/ime/input_method_auralinux.cc         |  21 ++
 ui/base/ime/input_method_auralinux.h          |   1 +
 ui/base/ime/input_method_factory.cc           |   4 +-
 .../ime/linux/linux_input_method_context.h    |  12 +-
 ui/ozone/platform/wayland/BUILD.gn            |  12 ++
 ui/ozone/platform/wayland/fake_server.cc      |  99 +++++++++
 ui/ozone/platform/wayland/fake_server.h       |  34 +++
 .../wayland/ozone_platform_wayland.cc         |   8 +
 .../platform/wayland/wayland_connection.cc    |  18 ++
 .../platform/wayland/wayland_connection.h     |   7 +-
 .../wayland/wayland_input_method_context.cc   | 139 ++++++++++++
 .../wayland/wayland_input_method_context.h    |  56 +++++
 .../wayland_input_method_context_factory.cc   |  30 +++
 .../wayland_input_method_context_factory.h    |  32 +++
 .../wayland_input_method_context_unittest.cc  | 138 ++++++++++++
 ui/ozone/platform/wayland/wayland_object.cc   |  11 +
 ui/ozone/platform/wayland/wayland_object.h    |  14 ++
 ui/ozone/platform/wayland/wayland_window.cc   |   3 +
 ui/ozone/platform/wayland/wayland_window.h    |   2 +
 .../platform/wayland/zwp_text_input_wrapper.h |  56 +++++
 .../wayland/zwp_text_input_wrapper_v1.cc      | 200 ++++++++++++++++++
 .../wayland/zwp_text_input_wrapper_v1.h       | 106 ++++++++++
 ui/ozone/public/ozone_switches.cc             |   3 +
 ui/ozone/public/ozone_switches.h              |   2 +
 24 files changed, 1004 insertions(+), 4 deletions(-)
 create mode 100644 ui/ozone/platform/wayland/wayland_input_method_context.cc
 create mode 100644 ui/ozone/platform/wayland/wayland_input_method_context.h
 create mode 100644 ui/ozone/platform/wayland/wayland_input_method_context_factory.cc
 create mode 100644 ui/ozone/platform/wayland/wayland_input_method_context_factory.h
 create mode 100644 ui/ozone/platform/wayland/wayland_input_method_context_unittest.cc
 create mode 100644 ui/ozone/platform/wayland/zwp_text_input_wrapper.h
 create mode 100644 ui/ozone/platform/wayland/zwp_text_input_wrapper_v1.cc
 create mode 100644 ui/ozone/platform/wayland/zwp_text_input_wrapper_v1.h

diff --git a/ui/base/ime/input_method_auralinux.cc b/ui/base/ime/input_method_auralinux.cc
index 699792009be0a..51e0640050701 100644
--- a/ui/base/ime/input_method_auralinux.cc
+++ b/ui/base/ime/input_method_auralinux.cc
@@ -274,6 +274,15 @@ void InputMethodAuraLinux::OnCaretBoundsChanged(const TextInputClient* client) {
     return;
   NotifyTextInputCaretBoundsChanged(client);
   context_->SetCursorLocation(GetTextInputClient()->GetCaretBounds());
+#if defined(USE_OZONE)
+  gfx::Range text_range, selection_range;
+  base::string16 text;
+  if (client->GetTextRange(&text_range) &&
+      client->GetTextFromRange(text_range, &text) &&
+      client->GetSelectionRange(&selection_range)) {
+    context_->SetSurroundingText(text, selection_range);
+  }
+#endif
 
   if (!IsTextInputTypeNone() && text_input_type_ != TEXT_INPUT_TYPE_PASSWORD &&
       GetEngine())
@@ -309,10 +318,12 @@ void InputMethodAuraLinux::ResetContext() {
 
   // Some input methods may not honour the reset call. Focusing out/in the
   // |context_| to make sure it gets reset correctly.
+#if !defined(USE_OZONE)
   if (text_input_type_ != TEXT_INPUT_TYPE_NONE) {
     context_->Blur();
     context_->Focus();
   }
+#endif
 
   composition_ = CompositionText();
   result_text_.clear();
@@ -353,6 +364,16 @@ void InputMethodAuraLinux::OnCommit(const base::string16& text) {
   }
 }
 
+void InputMethodAuraLinux::OnDeleteSurroundingText(int32_t index,
+                                                   uint32_t length) {
+  if (!composition_.text.empty())
+    return;
+  if (GetTextInputClient()) {
+    uint32_t before = index >= 0 ? 0U : static_cast<uint32_t>(-1 * index);
+    GetTextInputClient()->ExtendSelectionAndDelete(before, length - before);
+  }
+}
+
 void InputMethodAuraLinux::OnPreeditChanged(
     const CompositionText& composition_text) {
   if (IgnoringNonKeyInput() || IsTextInputTypeNone())
diff --git a/ui/base/ime/input_method_auralinux.h b/ui/base/ime/input_method_auralinux.h
index ef4985b95c688..8963ab945ad85 100644
--- a/ui/base/ime/input_method_auralinux.h
+++ b/ui/base/ime/input_method_auralinux.h
@@ -35,6 +35,7 @@ class UI_BASE_IME_EXPORT InputMethodAuraLinux
 
   // Overriden from ui::LinuxInputMethodContextDelegate
   void OnCommit(const base::string16& text) override;
+  void OnDeleteSurroundingText(int32_t index, uint32_t length) override;
   void OnPreeditChanged(const CompositionText& composition_text) override;
   void OnPreeditEnd() override;
   void OnPreeditStart() override {}
diff --git a/ui/base/ime/input_method_factory.cc b/ui/base/ime/input_method_factory.cc
index 45546b353fa43..250c1015cdc21 100644
--- a/ui/base/ime/input_method_factory.cc
+++ b/ui/base/ime/input_method_factory.cc
@@ -18,7 +18,7 @@
 #include "ui/base/ime/input_method_win_tsf.h"
 #elif defined(OS_MACOSX)
 #include "ui/base/ime/input_method_mac.h"
-#elif defined(USE_AURA) && defined(USE_X11)
+#elif defined(USE_AURA) && (defined(USE_X11) || defined(USE_OZONE))
 #include "ui/base/ime/input_method_auralinux.h"
 #else
 #include "ui/base/ime/input_method_minimal.h"
@@ -62,7 +62,7 @@ std::unique_ptr<InputMethod> CreateInputMethod(
   return std::make_unique<InputMethodWinImm32>(delegate, widget);
 #elif defined(OS_MACOSX)
   return std::make_unique<InputMethodMac>(delegate);
-#elif defined(USE_AURA) && defined(USE_X11)
+#elif defined(USE_AURA) && (defined(USE_X11) || defined(USE_OZONE))
   return std::make_unique<InputMethodAuraLinux>(delegate);
 #else
   return std::make_unique<InputMethodMinimal>(delegate);
diff --git a/ui/base/ime/linux/linux_input_method_context.h b/ui/base/ime/linux/linux_input_method_context.h
index 4611501d06293..a0f581dca11b3 100644
--- a/ui/base/ime/linux/linux_input_method_context.h
+++ b/ui/base/ime/linux/linux_input_method_context.h
@@ -11,7 +11,8 @@
 
 namespace gfx {
 class Rect;
-}
+class Range;
+}  // namespace gfx
 
 namespace ui {
 
@@ -33,6 +34,11 @@ class UI_BASE_IME_EXPORT LinuxInputMethodContext {
   // client window rect.
   virtual void SetCursorLocation(const gfx::Rect& rect) = 0;
 
+  // Tells the system IME the surrounding text around the cursor location.
+  // TODO(jani, msisov): make it pure virtual when upstreaming.
+  virtual void SetSurroundingText(const base::string16& text,
+                                  const gfx::Range& selection_range) {}
+
   // Resets the context.  A client needs to call OnTextInputTypeChanged() again
   // before calling DispatchKeyEvent().
   virtual void Reset() = 0;
@@ -52,6 +58,10 @@ class UI_BASE_IME_EXPORT LinuxInputMethodContextDelegate {
   // Commits the |text| to the text input client.
   virtual void OnCommit(const base::string16& text) = 0;
 
+  // Deletes the surrounding text at |index| for given |length|.
+  // TODO(jani, msisov): make it pure virtual when upstreaming.
+  virtual void OnDeleteSurroundingText(int32_t index, uint32_t length) {}
+
   // Sets the composition text to the text input client.
   virtual void OnPreeditChanged(const CompositionText& composition_text) = 0;
 
diff --git a/ui/ozone/platform/wayland/BUILD.gn b/ui/ozone/platform/wayland/BUILD.gn
index 1fb9713742d2d..7e4b923e28b22 100644
--- a/ui/ozone/platform/wayland/BUILD.gn
+++ b/ui/ozone/platform/wayland/BUILD.gn
@@ -35,6 +35,10 @@ source_set("wayland") {
     "wayland_data_offer.h",
     "wayland_data_source.cc",
     "wayland_data_source.h",
+    "wayland_input_method_context.cc",
+    "wayland_input_method_context.h",
+    "wayland_input_method_context_factory.cc",
+    "wayland_input_method_context_factory.h",
     "wayland_keyboard.cc",
     "wayland_keyboard.h",
     "wayland_native_display_delegate.cc",
@@ -64,6 +68,9 @@ source_set("wayland") {
     "xdg_surface_wrapper_v5.h",
     "xdg_surface_wrapper_v6.cc",
     "xdg_surface_wrapper_v6.h",
+    "zwp_text_input_wrapper.h",
+    "zwp_text_input_wrapper_v1.cc",
+    "zwp_text_input_wrapper_v1.h",
   ]
 
   import("//ui/base/ui_features.gni")
@@ -83,12 +90,16 @@ source_set("wayland") {
     "//third_party/minigbm",
     "//third_party/wayland:wayland_client",
     "//third_party/wayland-protocols:linux_dmabuf_protocol",
+    "//third_party/wayland-protocols:text_input_protocol",
     "//third_party/wayland-protocols:xdg_shell_protocol",
     "//ui/base",
     "//ui/base:ui_features",
+    "//ui/base/ime:ime",
+    "//ui/base/ime:ime_types",
     "//ui/display/manager",
     "//ui/events",
     "//ui/events:dom_keycode_converter",
+    "//ui/events/keycodes:xkb",
     "//ui/events/ozone:events_ozone",
     "//ui/events/ozone:events_ozone_evdev",
     "//ui/events/ozone:events_ozone_layout",
@@ -140,6 +151,7 @@ source_set("wayland_unittests") {
     "fake_server.h",
     "wayland_connection_unittest.cc",
     "wayland_data_device_unittest.cc",
+    "wayland_input_method_context_unittest.cc",
     "wayland_keyboard_unittest.cc",
     "wayland_pointer_unittest.cc",
     "wayland_surface_factory_unittest.cc",
diff --git a/ui/ozone/platform/wayland/fake_server.cc b/ui/ozone/platform/wayland/fake_server.cc
index 6a63f3a7cf67b..db447fbf1ee94 100644
--- a/ui/ozone/platform/wayland/fake_server.cc
+++ b/ui/ozone/platform/wayland/fake_server.cc
@@ -3,7 +3,9 @@
 // found in the LICENSE file.
 
 #include "ui/ozone/platform/wayland/fake_server.h"
+
 #include <sys/socket.h>
+#include <text-input-unstable-v1-server-protocol.h>
 #include <wayland-server.h>
 #include <xdg-shell-unstable-v5-server-protocol.h>
 #include <xdg-shell-unstable-v6-server-protocol.h>
@@ -26,6 +28,7 @@ const uint32_t kOutputVersion = 2;
 const uint32_t kDataDeviceManagerVersion = 3;
 const uint32_t kSeatVersion = 4;
 const uint32_t kXdgShellVersion = 1;
+const uint32_t kTextInputManagerVersion = 1;
 
 bool ResourceHasImplementation(wl_resource* resource,
                                const wl_interface* interface,
@@ -440,6 +443,84 @@ const struct wl_touch_interface touch_impl = {
     &DestroyResource,  // release
 };
 
+// zwp_text_input_v1
+
+void TextInputV1Activate(wl_client* client,
+                         wl_resource* resource,
+                         wl_resource* seat,
+                         wl_resource* surface) {
+  static_cast<MockZwpTextInput*>(wl_resource_get_user_data(resource))
+      ->Activate(surface);
+}
+
+void TextInputV1Deactivate(wl_client* client,
+                           wl_resource* resource,
+                           wl_resource* seat) {
+  static_cast<MockZwpTextInput*>(wl_resource_get_user_data(resource))
+      ->Deactivate();
+}
+
+void TextInputV1ShowInputPanel(wl_client* client, wl_resource* resource) {
+  static_cast<MockZwpTextInput*>(wl_resource_get_user_data(resource))
+      ->ShowInputPanel();
+}
+
+void TextInputV1HideInputPanel(wl_client* client, wl_resource* resource) {
+  static_cast<MockZwpTextInput*>(wl_resource_get_user_data(resource))
+      ->HideInputPanel();
+}
+
+void TextInputV1Reset(wl_client* client, wl_resource* resource) {
+  static_cast<MockZwpTextInput*>(wl_resource_get_user_data(resource))->Reset();
+}
+
+void TextInputV1SetCursorRectangle(wl_client* client,
+                                   wl_resource* resource,
+                                   int32_t x,
+                                   int32_t y,
+                                   int32_t width,
+                                   int32_t height) {
+  static_cast<MockZwpTextInput*>(wl_resource_get_user_data(resource))
+      ->SetCursorRect(x, y, width, height);
+}
+
+const struct zwp_text_input_v1_interface zwp_text_input_v1_impl = {
+    &TextInputV1Activate,            // activate
+    &TextInputV1Deactivate,          // deactivate
+    &TextInputV1ShowInputPanel,      // show_input_panel
+    &TextInputV1HideInputPanel,      // hide_input_panel
+    &TextInputV1Reset,               // reset
+    nullptr,                         // set_surrounding_text
+    nullptr,                         // set_content_type
+    &TextInputV1SetCursorRectangle,  // set_cursor_rectangle
+    nullptr,                         // set_preferred_language
+    nullptr,                         // commit_state
+    nullptr,                         // invoke_action
+};
+
+// zwp_text_input_manager_v1
+
+void CreateTextInput(struct wl_client* client,
+                     struct wl_resource* resource,
+                     uint32_t id) {
+  auto* im =
+      static_cast<MockTextInputManagerV1*>(wl_resource_get_user_data(resource));
+  wl_resource* text_resource =
+      wl_resource_create(client, &zwp_text_input_v1_interface,
+                         wl_resource_get_version(resource), id);
+  if (!text_resource) {
+    wl_client_post_no_memory(client);
+    return;
+  }
+  im->text_input.reset(
+      new MockZwpTextInput(text_resource, &zwp_text_input_v1_impl));
+}
+
+const struct zwp_text_input_manager_v1_interface
+    zwp_text_input_manager_v1_impl = {
+        &CreateTextInput,  // create_text_input
+};
+
 // xdg_surface, zxdg_surface_v6 and zxdg_toplevel shared methods.
 
 void SetTitle(wl_client* client, wl_resource* resource, const char* title) {
@@ -769,6 +850,15 @@ MockTouch::MockTouch(wl_resource* resource) : ServerObject(resource) {
 
 MockTouch::~MockTouch() {}
 
+MockZwpTextInput::MockZwpTextInput(wl_resource* resource,
+                                   const void* implementation)
+    : ServerObject(resource) {
+  wl_resource_set_implementation(resource, implementation, this,
+                                 &ServerObject::OnResourceDestroyed);
+}
+
+MockZwpTextInput::~MockZwpTextInput() {}
+
 MockDataOffer::MockDataOffer(wl_resource* resource)
     : ServerObject(resource),
       io_thread_("Worker thread"),
@@ -949,6 +1039,13 @@ MockXdgShellV6::MockXdgShellV6()
 
 MockXdgShellV6::~MockXdgShellV6() {}
 
+MockTextInputManagerV1::MockTextInputManagerV1()
+    : Global(&zwp_text_input_manager_v1_interface,
+             &zwp_text_input_manager_v1_impl,
+             kTextInputManagerVersion) {}
+
+MockTextInputManagerV1::~MockTextInputManagerV1() {}
+
 void DisplayDeleter::operator()(wl_display* display) {
   wl_display_destroy(display);
 }
@@ -995,6 +1092,8 @@ bool FakeServer::Start(uint32_t shell_version) {
     if (!zxdg_shell_v6_.Initialize(display_.get()))
       return false;
   }
+  if (!zwp_text_input_manager_v1_.Initialize(display_.get()))
+    return false;
 
   client_ = wl_client_create(display_.get(), server_fd.get());
   if (!client_)
diff --git a/ui/ozone/platform/wayland/fake_server.h b/ui/ozone/platform/wayland/fake_server.h
index 7739e6d62f26f..03de5c0d6cfb5 100644
--- a/ui/ozone/platform/wayland/fake_server.h
+++ b/ui/ozone/platform/wayland/fake_server.h
@@ -179,6 +179,24 @@ class MockTouch : public ServerObject {
   DISALLOW_COPY_AND_ASSIGN(MockTouch);
 };
 
+// Manage zwp_text_input_v1.
+class MockZwpTextInput : public ServerObject {
+ public:
+  MockZwpTextInput(wl_resource* resource, const void* implementation);
+  ~MockZwpTextInput() override;
+
+  MOCK_METHOD0(Reset, void());
+  MOCK_METHOD1(Activate, void(wl_resource* window));
+  MOCK_METHOD0(Deactivate, void());
+  MOCK_METHOD0(ShowInputPanel, void());
+  MOCK_METHOD0(HideInputPanel, void());
+  MOCK_METHOD4(SetCursorRect,
+               void(int32_t x, int32_t y, int32_t width, int32_t height));
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(MockZwpTextInput);
+};
+
 class MockDataOffer : public ServerObject {
  public:
   explicit MockDataOffer(wl_resource* resource);
@@ -381,6 +399,18 @@ class MockXdgShellV6 : public Global {
   DISALLOW_COPY_AND_ASSIGN(MockXdgShellV6);
 };
 
+// Manage zwp_text_input_manager_v1 object.
+class MockTextInputManagerV1 : public Global {
+ public:
+  MockTextInputManagerV1();
+  ~MockTextInputManagerV1() override;
+
+  std::unique_ptr<MockZwpTextInput> text_input;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(MockTextInputManagerV1);
+};
+
 struct DisplayDeleter {
   void operator()(wl_display* display);
 };
@@ -414,6 +444,9 @@ class FakeServer : public base::Thread, base::MessagePumpLibevent::FdWatcher {
   MockSeat* seat() { return &seat_; }
   MockXdgShell* xdg_shell() { return &xdg_shell_; }
   MockOutput* output() { return &output_; }
+  MockTextInputManagerV1* text_input_manager_v1() {
+    return &zwp_text_input_manager_v1_;
+  }
 
  private:
   void DoPause();
@@ -438,6 +471,7 @@ class FakeServer : public base::Thread, base::MessagePumpLibevent::FdWatcher {
   MockSeat seat_;
   MockXdgShell xdg_shell_;
   MockXdgShellV6 zxdg_shell_v6_;
+  MockTextInputManagerV1 zwp_text_input_manager_v1_;
 
   base::MessagePumpLibevent::FdWatchController controller_;
 
diff --git a/ui/ozone/platform/wayland/ozone_platform_wayland.cc b/ui/ozone/platform/wayland/ozone_platform_wayland.cc
index 44763577a5cf3..c242ad4e95c4c 100644
--- a/ui/ozone/platform/wayland/ozone_platform_wayland.cc
+++ b/ui/ozone/platform/wayland/ozone_platform_wayland.cc
@@ -14,6 +14,7 @@
 #include "ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h"
 #include "ui/ozone/platform/wayland/wayland_connection.h"
 #include "ui/ozone/platform/wayland/wayland_connection_connector.h"
+#include "ui/ozone/platform/wayland/wayland_input_method_context_factory.h"
 #include "ui/ozone/platform/wayland/wayland_native_display_delegate.h"
 #include "ui/ozone/platform/wayland/wayland_surface_factory.h"
 #include "ui/ozone/platform/wayland/wayland_window.h"
@@ -113,6 +114,11 @@ class OzonePlatformWayland : public OzonePlatform {
     overlay_manager_.reset(new StubOverlayManager);
     input_controller_ = CreateStubInputController();
     gpu_platform_support_host_.reset(CreateStubGpuPlatformSupportHost());
+
+    if (LinuxInputMethodContextFactory::instance())
+      return;
+    wayland_input_method_context_factory_.reset(
+        new WaylandInputMethodContextFactory(connection_.get()));
   }
 
   void InitializeGPU(const InitParams& args) override {
@@ -168,6 +174,8 @@ class OzonePlatformWayland : public OzonePlatform {
   std::unique_ptr<StubOverlayManager> overlay_manager_;
   std::unique_ptr<InputController> input_controller_;
   std::unique_ptr<GpuPlatformSupportHost> gpu_platform_support_host_;
+  std::unique_ptr<WaylandInputMethodContextFactory>
+      wayland_input_method_context_factory_;
 
 #if BUILDFLAG(USE_XKBCOMMON)
   XkbEvdevCodes xkb_evdev_code_converter_;
diff --git a/ui/ozone/platform/wayland/wayland_connection.cc b/ui/ozone/platform/wayland/wayland_connection.cc
index c755fb160e676..af20842dca037 100644
--- a/ui/ozone/platform/wayland/wayland_connection.cc
+++ b/ui/ozone/platform/wayland/wayland_connection.cc
@@ -31,6 +31,7 @@ const uint32_t kMaxLinuxDmabufVersion = 1;
 const uint32_t kMaxSeatVersion = 4;
 const uint32_t kMaxShmVersion = 1;
 const uint32_t kMaxXdgShellVersion = 1;
+const uint32_t kMaxTextInputManagerVersion = 1;
 }  // namespace
 
 WaylandConnection::WaylandConnection()
@@ -124,6 +125,15 @@ WaylandWindow* WaylandConnection::GetCurrentFocusedWindow() {
   return nullptr;
 }
 
+WaylandWindow* WaylandConnection::GetCurrentKeyboardFocusedWindow() {
+  for (auto entry : window_map_) {
+    WaylandWindow* window = entry.second;
+    if (window->has_keyboard_focus())
+      return window;
+  }
+  return nullptr;
+}
+
 void WaylandConnection::AddWindow(gfx::AcceleratedWidget widget,
                                   WaylandWindow* window) {
   window_map_[widget] = window;
@@ -592,6 +602,14 @@ void WaylandConnection::Global(void* data,
     // A roundtrip after binding guarantees that the client has received all
     // supported formats.
     wl_display_roundtrip(connection->display_.get());
+  } else if (!connection->text_input_manager_v1_ &&
+             strcmp(interface, "zwp_text_input_manager_v1") == 0) {
+    connection->text_input_manager_v1_ = wl::Bind<zwp_text_input_manager_v1>(
+        registry, name, std::min(version, kMaxTextInputManagerVersion));
+    if (!connection->text_input_manager_v1_) {
+      LOG(ERROR) << "Failed to bind to zwp_text_input_manager_v1 global";
+      return;
+    }
   }
 
   connection->ScheduleFlush();
diff --git a/ui/ozone/platform/wayland/wayland_connection.h b/ui/ozone/platform/wayland/wayland_connection.h
index 91a0277e4543d..ea025a242285c 100644
--- a/ui/ozone/platform/wayland/wayland_connection.h
+++ b/ui/ozone/platform/wayland/wayland_connection.h
@@ -78,9 +78,13 @@ class WaylandConnection : public PlatformEventSource,
   wl_seat* seat() { return seat_.get(); }
   wl_data_device* data_device() { return data_device_->data_device(); }
   zwp_linux_dmabuf_v1* zwp_linux_dmabuf() { return zwp_linux_dmabuf_.get(); }
+  zwp_text_input_manager_v1* text_input_manager_v1() {
+    return text_input_manager_v1_.get();
+  }
 
   WaylandWindow* GetWindow(gfx::AcceleratedWidget widget);
   WaylandWindow* GetCurrentFocusedWindow();
+  WaylandWindow* GetCurrentKeyboardFocusedWindow();
   void AddWindow(gfx::AcceleratedWidget widget, WaylandWindow* window);
   void RemoveWindow(gfx::AcceleratedWidget widget);
 
@@ -95,6 +99,7 @@ class WaylandConnection : public PlatformEventSource,
                        const gfx::Point& location);
 
   int GetKeyboardModifiers();
+  void DispatchUiEvent(Event* event);
 
   // Returns the current pointer, which may be null.
   WaylandPointer* pointer() { return pointer_.get(); }
@@ -134,7 +139,6 @@ class WaylandConnection : public PlatformEventSource,
 
  private:
   void Flush();
-  void DispatchUiEvent(Event* event);
 
   // PlatformEventSource
   void OnDispatcherListChanged() override;
@@ -204,6 +208,7 @@ class WaylandConnection : public PlatformEventSource,
   wl::Object<xdg_shell> shell_;
   wl::Object<zwp_linux_dmabuf_v1> zwp_linux_dmabuf_;
   wl::Object<zxdg_shell_v6> shell_v6_;
+  wl::Object<zwp_text_input_manager_v1> text_input_manager_v1_;
 
   // Stores a wl_buffer and it's id provided by the GbmBuffer object on the
   // GPU process side.
diff --git a/ui/ozone/platform/wayland/wayland_input_method_context.cc b/ui/ozone/platform/wayland/wayland_input_method_context.cc
new file mode 100644
index 0000000000000..79832444245e5
--- /dev/null
+++ b/ui/ozone/platform/wayland/wayland_input_method_context.cc
@@ -0,0 +1,139 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/ozone/platform/wayland/wayland_input_method_context.h"
+
+#include "base/bind.h"
+#include "base/command_line.h"
+#include "base/memory/ptr_util.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "ui/base/ime/composition_text.h"
+#include "ui/events/base_event_utils.h"
+#include "ui/events/event.h"
+#include "ui/events/keycodes/dom/dom_code.h"
+#include "ui/events/keycodes/dom/keycode_converter.h"
+#include "ui/events/keycodes/keyboard_code_conversion.h"
+#include "ui/events/keycodes/keyboard_code_conversion_xkb.h"
+#include "ui/events/ozone/layout/keyboard_layout_engine.h"
+#include "ui/events/ozone/layout/keyboard_layout_engine_manager.h"
+#include "ui/gfx/range/range.h"
+#include "ui/ozone/platform/wayland/wayland_connection.h"
+#include "ui/ozone/platform/wayland/zwp_text_input_wrapper_v1.h"
+#include "ui/ozone/public/ozone_switches.h"
+
+namespace ui {
+
+namespace {
+
+constexpr int kXkbKeycodeOffset = 8;
+
+}  // namespace
+
+WaylandInputMethodContext::WaylandInputMethodContext(
+    WaylandConnection* connection,
+    LinuxInputMethodContextDelegate* delegate,
+    bool is_simple)
+    : connection_(connection), text_input_(nullptr), delegate_(delegate) {
+  use_ozone_wayland_vkb_ = getenv("ENABLE_WAYLAND_IME") ||
+                           base::CommandLine::ForCurrentProcess()->HasSwitch(
+                               switches::kEnableWaylandIme);
+  if (use_ozone_wayland_vkb_ && !is_simple &&
+      connection_->text_input_manager_v1()) {
+    text_input_ = std::make_unique<ZWPTextInputWrapperV1>(
+        connection_->text_input_manager_v1());
+    text_input_->Initialize(connection_, this);
+  }
+}
+
+WaylandInputMethodContext::~WaylandInputMethodContext() {
+  if (text_input_) {
+    text_input_->Deactivate();
+    text_input_->HideInputPanel();
+  }
+}
+
+bool WaylandInputMethodContext::DispatchKeyEvent(
+    const ui::KeyEvent& key_event) {
+  return false;
+}
+
+void WaylandInputMethodContext::Reset() {
+  if (text_input_)
+    text_input_->Reset();
+}
+
+void WaylandInputMethodContext::Focus() {
+  WaylandWindow* window = connection_->GetCurrentKeyboardFocusedWindow();
+  if (!text_input_ || !window)
+    return;
+
+  text_input_->Activate(window);
+  text_input_->ShowInputPanel();
+}
+
+void WaylandInputMethodContext::Blur() {
+  if (text_input_) {
+    text_input_->Deactivate();
+    text_input_->HideInputPanel();
+  }
+}
+
+void WaylandInputMethodContext::SetCursorLocation(const gfx::Rect& rect) {
+  if (text_input_)
+    text_input_->SetCursorRect(rect);
+}
+
+void WaylandInputMethodContext::SetSurroundingText(
+    const base::string16& text,
+    const gfx::Range& selection_range) {
+  if (text_input_)
+    text_input_->SetSurroundingText(text, selection_range);
+}
+
+void WaylandInputMethodContext::OnPreeditString(const std::string& text,
+                                                int preedit_cursor) {
+  gfx::Range selection_range = gfx::Range::InvalidRange();
+
+  // TODO(jani): Handle selection range
+
+  if (!selection_range.IsValid()) {
+    int cursor_pos = (preedit_cursor) ? text.length() : preedit_cursor;
+    selection_range.set_start(cursor_pos);
+    selection_range.set_end(cursor_pos);
+  }
+
+  ui::CompositionText composition_text;
+  composition_text.text = base::UTF8ToUTF16(text);
+  composition_text.selection = selection_range;
+  delegate_->OnPreeditChanged(composition_text);
+}
+
+void WaylandInputMethodContext::OnCommitString(const std::string& text) {
+  delegate_->OnCommit(base::UTF8ToUTF16(text));
+}
+
+void WaylandInputMethodContext::OnDeleteSurroundingText(int32_t index,
+                                                        uint32_t length) {
+  delegate_->OnDeleteSurroundingText(index, length);
+}
+
+void WaylandInputMethodContext::OnKeysym(uint32_t key,
+                                         uint32_t state,
+                                         uint32_t modifiers) {
+  uint8_t flags = 0;  // for now ignore modifiers
+  DomKey dom_key = NonPrintableXKeySymToDomKey(key);
+  KeyboardCode key_code = NonPrintableDomKeyToKeyboardCode(dom_key);
+  DomCode dom_code =
+      KeycodeConverter::NativeKeycodeToDomCode(key_code + kXkbKeycodeOffset);
+  if (dom_code == ui::DomCode::NONE)
+    return;
+
+  bool down = state == WL_KEYBOARD_KEY_STATE_PRESSED;
+  ui::KeyEvent event(down ? ET_KEY_PRESSED : ET_KEY_RELEASED, key_code,
+                     dom_code, flags, dom_key, EventTimeForNow());
+  connection_->DispatchUiEvent(&event);
+}
+
+}  // namespace ui
diff --git a/ui/ozone/platform/wayland/wayland_input_method_context.h b/ui/ozone/platform/wayland/wayland_input_method_context.h
new file mode 100644
index 0000000000000..525b5cf235476
--- /dev/null
+++ b/ui/ozone/platform/wayland/wayland_input_method_context.h
@@ -0,0 +1,56 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PLATFORM_WAYLAND_WAYLAND_INPUT_METHOD_CONTEXT_H_
+#define UI_OZONE_PLATFORM_WAYLAND_WAYLAND_INPUT_METHOD_CONTEXT_H_
+
+#include "base/macros.h"
+#include "ui/base/ime/linux/linux_input_method_context.h"
+#include "ui/events/ozone/evdev/event_dispatch_callback.h"
+#include "ui/ozone/platform/wayland/zwp_text_input_wrapper.h"
+
+namespace ui {
+
+class WaylandConnection;
+class WaylandWindow;
+class ZWPTextInputWrapper;
+
+class WaylandInputMethodContext : public LinuxInputMethodContext,
+                                  public ZWPTextInputWrapperClient {
+ public:
+  WaylandInputMethodContext(WaylandConnection* connection,
+                            LinuxInputMethodContextDelegate* delegate,
+                            bool is_simple);
+  ~WaylandInputMethodContext() override;
+
+  // LinuxInputMethodContext overrides:
+  bool DispatchKeyEvent(const ui::KeyEvent& key_event) override;
+  void SetCursorLocation(const gfx::Rect& rect) override;
+  void SetSurroundingText(const base::string16& text,
+                          const gfx::Range& selection_range) override;
+  void Reset() override;
+  void Focus() override;
+  void Blur() override;
+
+  // ui::ZWPTextInputWrapperClient
+  void OnPreeditString(const std::string& text, int preedit_cursor) override;
+  void OnCommitString(const std::string& text) override;
+  void OnDeleteSurroundingText(int32_t index, uint32_t length) override;
+  void OnKeysym(uint32_t key, uint32_t state, uint32_t modifiers) override;
+
+ private:
+  WaylandConnection* connection_ = nullptr;
+  bool use_ozone_wayland_vkb_;
+
+  std::unique_ptr<ZWPTextInputWrapper> text_input_;
+
+  // Delegate interface back to IME code in ui.
+  LinuxInputMethodContextDelegate* delegate_;
+
+  DISALLOW_COPY_AND_ASSIGN(WaylandInputMethodContext);
+};
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_WAYLAND_WAYLAND_INPUT_METHOD_CONTEXT_H_
diff --git a/ui/ozone/platform/wayland/wayland_input_method_context_factory.cc b/ui/ozone/platform/wayland/wayland_input_method_context_factory.cc
new file mode 100644
index 0000000000000..431749ce1bc9b
--- /dev/null
+++ b/ui/ozone/platform/wayland/wayland_input_method_context_factory.cc
@@ -0,0 +1,30 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/ozone/platform/wayland/wayland_input_method_context_factory.h"
+
+#include "ui/ozone/platform/wayland/wayland_input_method_context.h"
+
+namespace ui {
+
+WaylandInputMethodContextFactory::WaylandInputMethodContextFactory(
+    WaylandConnection* connection)
+    : connection_(connection) {
+  LinuxInputMethodContextFactory::SetInstance(this);
+}
+
+WaylandInputMethodContextFactory::~WaylandInputMethodContextFactory() {
+  LinuxInputMethodContextFactory::SetInstance(nullptr);
+}
+
+std::unique_ptr<LinuxInputMethodContext>
+WaylandInputMethodContextFactory::CreateInputMethodContext(
+    LinuxInputMethodContextDelegate* delegate,
+    bool is_simple) const {
+  auto context = std::make_unique<WaylandInputMethodContext>(
+      connection_, delegate, is_simple);
+  return std::move(context);
+}
+
+}  // namespace ui
diff --git a/ui/ozone/platform/wayland/wayland_input_method_context_factory.h b/ui/ozone/platform/wayland/wayland_input_method_context_factory.h
new file mode 100644
index 0000000000000..d5ee7d4c7a61d
--- /dev/null
+++ b/ui/ozone/platform/wayland/wayland_input_method_context_factory.h
@@ -0,0 +1,32 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PLATFORM_WAYLAND_WAYLAND_INPUT_METHOD_CONTEXT_FACTORY_H_
+#define UI_OZONE_PLATFORM_WAYLAND_WAYLAND_INPUT_METHOD_CONTEXT_FACTORY_H_
+
+#include "base/macros.h"
+#include "ui/base/ime/linux/linux_input_method_context_factory.h"
+
+namespace ui {
+
+class WaylandConnection;
+
+class WaylandInputMethodContextFactory : public LinuxInputMethodContextFactory {
+ public:
+  explicit WaylandInputMethodContextFactory(WaylandConnection* connection);
+  ~WaylandInputMethodContextFactory() override;
+
+  std::unique_ptr<LinuxInputMethodContext> CreateInputMethodContext(
+      ui::LinuxInputMethodContextDelegate* delegate,
+      bool is_simple) const override;
+
+ private:
+  WaylandConnection* connection_;
+
+  DISALLOW_COPY_AND_ASSIGN(WaylandInputMethodContextFactory);
+};
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_WAYLAND_WAYLAND_INPUT_METHOD_CONTEXT_FACTORY_H_
diff --git a/ui/ozone/platform/wayland/wayland_input_method_context_unittest.cc b/ui/ozone/platform/wayland/wayland_input_method_context_unittest.cc
new file mode 100644
index 0000000000000..e398fe7709f64
--- /dev/null
+++ b/ui/ozone/platform/wayland/wayland_input_method_context_unittest.cc
@@ -0,0 +1,138 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <text-input-unstable-v1-server-protocol.h>
+#include <wayland-server.h>
+
+#include "mojo/public/cpp/bindings/binding.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "ui/base/ime/linux/linux_input_method_context.h"
+#include "ui/events/event.h"
+#include "ui/ozone/platform/wayland/fake_server.h"
+#include "ui/ozone/platform/wayland/wayland_input_method_context.h"
+#include "ui/ozone/platform/wayland/wayland_test.h"
+#include "ui/ozone/platform/wayland/wayland_window.h"
+
+using ::testing::SaveArg;
+using ::testing::_;
+
+namespace ui {
+
+class TestInputMethodContextDelegate : public LinuxInputMethodContextDelegate {
+ public:
+  TestInputMethodContextDelegate() {}
+  ~TestInputMethodContextDelegate() override {}
+
+  void OnCommit(const base::string16& text) override {
+    was_on_commit_called_ = true;
+  }
+  void OnPreeditChanged(const ui::CompositionText& composition_text) override {
+    was_on_preedit_changed_called_ = true;
+  }
+  void OnPreeditEnd() override {}
+  void OnPreeditStart() override {}
+
+  bool was_on_commit_called() { return was_on_commit_called_; }
+
+  bool was_on_preedit_changed_called() {
+    return was_on_preedit_changed_called_;
+  }
+
+ private:
+  bool was_on_commit_called_ = false;
+  bool was_on_preedit_changed_called_ = false;
+
+  DISALLOW_COPY_AND_ASSIGN(TestInputMethodContextDelegate);
+};
+
+class WaylandInputMethodContextTest : public WaylandTest {
+ public:
+  WaylandInputMethodContextTest() {}
+
+  void SetUp() override {
+    WaylandTest::SetUp();
+
+    Sync();
+
+    setenv("ENABLE_WAYLAND_IME", "true", 0);
+
+    input_method_context_delegate_ =
+        std::make_unique<TestInputMethodContextDelegate>();
+
+    input_method_context_ = std::make_unique<WaylandInputMethodContext>(
+        connection_.get(), input_method_context_delegate_.get(), false);
+    connection_->ScheduleFlush();
+
+    Sync();
+
+    zwp_text_input_ = server_.text_input_manager_v1()->text_input.get();
+    window_->set_keyboard_focus(true);
+
+    ASSERT_TRUE(connection_->text_input_manager_v1());
+    ASSERT_TRUE(zwp_text_input_);
+  }
+
+ protected:
+  std::unique_ptr<TestInputMethodContextDelegate>
+      input_method_context_delegate_;
+  std::unique_ptr<WaylandInputMethodContext> input_method_context_;
+  wl::MockZwpTextInput* zwp_text_input_ = nullptr;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(WaylandInputMethodContextTest);
+};
+
+TEST_P(WaylandInputMethodContextTest, Focus) {
+  EXPECT_CALL(*zwp_text_input_, Activate(surface_->resource()));
+  EXPECT_CALL(*zwp_text_input_, ShowInputPanel());
+  input_method_context_->Focus();
+  connection_->ScheduleFlush();
+  Sync();
+}
+
+TEST_P(WaylandInputMethodContextTest, Blur) {
+  EXPECT_CALL(*zwp_text_input_, Deactivate());
+  EXPECT_CALL(*zwp_text_input_, HideInputPanel());
+  input_method_context_->Blur();
+  connection_->ScheduleFlush();
+  Sync();
+}
+
+TEST_P(WaylandInputMethodContextTest, Reset) {
+  EXPECT_CALL(*zwp_text_input_, Reset());
+  input_method_context_->Reset();
+  connection_->ScheduleFlush();
+  Sync();
+}
+
+TEST_P(WaylandInputMethodContextTest, SetCursorLocation) {
+  EXPECT_CALL(*zwp_text_input_, SetCursorRect(50, 0, 1, 1));
+  input_method_context_->SetCursorLocation(gfx::Rect(50, 0, 1, 1));
+  connection_->ScheduleFlush();
+  Sync();
+}
+
+TEST_P(WaylandInputMethodContextTest, OnPreeditChanged) {
+  zwp_text_input_v1_send_preedit_string(zwp_text_input_->resource(), 0,
+                                        "PreeditString", "");
+  Sync();
+  EXPECT_TRUE(input_method_context_delegate_->was_on_preedit_changed_called());
+}
+
+TEST_P(WaylandInputMethodContextTest, OnCommit) {
+  zwp_text_input_v1_send_commit_string(zwp_text_input_->resource(), 0,
+                                       "CommitString");
+  Sync();
+  EXPECT_TRUE(input_method_context_delegate_->was_on_commit_called());
+}
+
+INSTANTIATE_TEST_CASE_P(XdgVersionV5Test,
+                        WaylandInputMethodContextTest,
+                        ::testing::Values(kXdgShellV5));
+INSTANTIATE_TEST_CASE_P(XdgVersionV6Test,
+                        WaylandInputMethodContextTest,
+                        ::testing::Values(kXdgShellV6));
+
+}  // namespace ui
diff --git a/ui/ozone/platform/wayland/wayland_object.cc b/ui/ozone/platform/wayland/wayland_object.cc
index ec41d326824e0..9292a279cd1fb 100644
--- a/ui/ozone/platform/wayland/wayland_object.cc
+++ b/ui/ozone/platform/wayland/wayland_object.cc
@@ -5,6 +5,7 @@
 #include "ui/ozone/platform/wayland/wayland_object.h"
 
 #include <linux-dmabuf-unstable-v1-client-protocol.h>
+#include <text-input-unstable-v1-client-protocol.h>
 #include <wayland-client.h>
 #include <xdg-shell-unstable-v5-client-protocol.h>
 #include <xdg-shell-unstable-v6-client-protocol.h>
@@ -157,4 +158,14 @@ const wl_interface* ObjectTraits<zxdg_positioner_v6>::interface =
 void (*ObjectTraits<zxdg_positioner_v6>::deleter)(zxdg_positioner_v6*) =
     &zxdg_positioner_v6_destroy;
 
+const wl_interface* ObjectTraits<zwp_text_input_manager_v1>::interface =
+    &zwp_text_input_manager_v1_interface;
+void (*ObjectTraits<zwp_text_input_manager_v1>::deleter)(
+    zwp_text_input_manager_v1*) = &zwp_text_input_manager_v1_destroy;
+
+const wl_interface* ObjectTraits<zwp_text_input_v1>::interface =
+    &zwp_text_input_v1_interface;
+void (*ObjectTraits<zwp_text_input_v1>::deleter)(zwp_text_input_v1*) =
+    &zwp_text_input_v1_destroy;
+
 }  // namespace wl
diff --git a/ui/ozone/platform/wayland/wayland_object.h b/ui/ozone/platform/wayland/wayland_object.h
index df3f16e62f34b..7dfc968bd4f21 100644
--- a/ui/ozone/platform/wayland/wayland_object.h
+++ b/ui/ozone/platform/wayland/wayland_object.h
@@ -36,6 +36,8 @@ struct zxdg_surface_v6;
 struct zxdg_toplevel_v6;
 struct zxdg_popup_v6;
 struct zxdg_positioner_v6;
+struct zwp_text_input_manager_v1;
+struct zwp_text_input_v1;
 
 namespace wl {
 
@@ -210,6 +212,18 @@ struct ObjectTraits<zxdg_positioner_v6> {
   static void (*deleter)(zxdg_positioner_v6*);
 };
 
+template <>
+struct ObjectTraits<zwp_text_input_manager_v1> {
+  static const wl_interface* interface;
+  static void (*deleter)(zwp_text_input_manager_v1*);
+};
+
+template <>
+struct ObjectTraits<zwp_text_input_v1> {
+  static const wl_interface* interface;
+  static void (*deleter)(zwp_text_input_v1*);
+};
+
 struct Deleter {
   template <typename T>
   void operator()(T* obj) {
diff --git a/ui/ozone/platform/wayland/wayland_window.cc b/ui/ozone/platform/wayland/wayland_window.cc
index f1c9a782eaeae..990d3cb90a20d 100644
--- a/ui/ozone/platform/wayland/wayland_window.cc
+++ b/ui/ozone/platform/wayland/wayland_window.cc
@@ -196,6 +196,9 @@ void WaylandWindow::ApplyPendingBounds() {
 }
 
 void WaylandWindow::Show() {
+  if (!is_tooltip_)
+    set_keyboard_focus(true);
+
   if (xdg_surface_)
     return;
   if (is_tooltip_) {
diff --git a/ui/ozone/platform/wayland/wayland_window.h b/ui/ozone/platform/wayland/wayland_window.h
index d56c650dd13ee..77b83f62c6f18 100644
--- a/ui/ozone/platform/wayland/wayland_window.h
+++ b/ui/ozone/platform/wayland/wayland_window.h
@@ -52,6 +52,8 @@ class WaylandWindow : public PlatformWindow, public PlatformEventDispatcher {
   // Set whether this window has keyboard focus and should dispatch key events.
   void set_keyboard_focus(bool focus) { has_keyboard_focus_ = focus; }
 
+  bool has_keyboard_focus() { return has_keyboard_focus_; }
+
   // Set whether this window has touch focus and should dispatch touch events.
   void set_touch_focus(bool focus) { has_touch_focus_ = focus; }
 
diff --git a/ui/ozone/platform/wayland/zwp_text_input_wrapper.h b/ui/ozone/platform/wayland/zwp_text_input_wrapper.h
new file mode 100644
index 0000000000000..b81d6a6025048
--- /dev/null
+++ b/ui/ozone/platform/wayland/zwp_text_input_wrapper.h
@@ -0,0 +1,56 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PLATFORM_WAYLAND_ZWP_TEXT_INPUT_WRAPPER_H_
+#define UI_OZONE_PLATFORM_WAYLAND_ZWP_TEXT_INPUT_WRAPPER_H_
+
+#include "ui/ozone/platform/wayland/wayland_object.h"
+
+#include "base/strings/string16.h"
+
+namespace gfx {
+class Rect;
+class Range;
+}  // namespace gfx
+
+namespace ui {
+
+class WaylandConnection;
+class WaylandWindow;
+
+class ZWPTextInputWrapperClient {
+ public:
+  virtual ~ZWPTextInputWrapperClient() {}
+
+  virtual void OnPreeditString(const std::string& text,
+                               int32_t preedit_cursor) = 0;
+  virtual void OnCommitString(const std::string& text) = 0;
+  virtual void OnDeleteSurroundingText(int32_t index, uint32_t length) = 0;
+  virtual void OnKeysym(uint32_t key, uint32_t state, uint32_t modifiers) = 0;
+};
+
+// A wrapper around different versions of zwp text inputs.
+class ZWPTextInputWrapper {
+ public:
+  virtual ~ZWPTextInputWrapper() {}
+
+  virtual void Initialize(WaylandConnection* connection,
+                          ZWPTextInputWrapperClient* client) = 0;
+
+  virtual void Reset() = 0;
+
+  virtual void Activate(WaylandWindow* window) = 0;
+  virtual void Deactivate() = 0;
+
+  virtual void ShowInputPanel() = 0;
+  virtual void HideInputPanel() = 0;
+
+  virtual void SetCursorRect(const gfx::Rect& rect) = 0;
+  virtual void SetSurroundingText(const base::string16& text,
+                                  const gfx::Range& selection_range) = 0;
+};
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_WAYLAND_ZWP_TEXT_INPUT_WRAPPER_H_
diff --git a/ui/ozone/platform/wayland/zwp_text_input_wrapper_v1.cc b/ui/ozone/platform/wayland/zwp_text_input_wrapper_v1.cc
new file mode 100644
index 0000000000000..30aacea574104
--- /dev/null
+++ b/ui/ozone/platform/wayland/zwp_text_input_wrapper_v1.cc
@@ -0,0 +1,200 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/ozone/platform/wayland/zwp_text_input_wrapper_v1.h"
+
+#include "base/memory/ptr_util.h"
+#include "base/strings/string16.h"
+#include "base/strings/utf_string_conversions.h"
+#include "ui/gfx/range/range.h"
+#include "ui/ozone/platform/wayland/wayland_connection.h"
+#include "ui/ozone/platform/wayland/wayland_window.h"
+
+namespace ui {
+
+ZWPTextInputWrapperV1::ZWPTextInputWrapperV1(
+    zwp_text_input_manager_v1* text_input_manager)
+    : client_(0) {
+  static const zwp_text_input_v1_listener text_input_listener = {
+      &ZWPTextInputWrapperV1::OnEnter,         // text_input_enter,
+      &ZWPTextInputWrapperV1::OnLeave,         // text_input_leave,
+      &ZWPTextInputWrapperV1::OnModifiersMap,  // text_input_modifiers_map,
+      &ZWPTextInputWrapperV1::
+          OnInputPanelState,                    // text_input_input_panel_state,
+      &ZWPTextInputWrapperV1::OnPreeditString,  // text_input_preedit_string,
+      &ZWPTextInputWrapperV1::OnPreeditStyling,  // text_input_preedit_styling,
+      &ZWPTextInputWrapperV1::OnPreeditCursor,   // text_input_preedit_cursor,
+      &ZWPTextInputWrapperV1::OnCommitString,    // text_input_commit_string,
+      &ZWPTextInputWrapperV1::OnCursorPosition,  // text_input_cursor_position,
+      &ZWPTextInputWrapperV1::
+          OnDeleteSurroundingText,       // text_input_delete_surrounding_text,
+      &ZWPTextInputWrapperV1::OnKeysym,  // text_input_keysym,
+      &ZWPTextInputWrapperV1::OnLanguage,       // text_input_language,
+      &ZWPTextInputWrapperV1::OnTextDirection,  // text_input_text_direction
+  };
+  ResetInputEventState();
+
+  zwp_text_input_v1* text_input =
+      zwp_text_input_manager_v1_create_text_input(text_input_manager);
+  obj_ = wl::Object<zwp_text_input_v1>(text_input);
+
+  zwp_text_input_v1_add_listener(text_input, &text_input_listener, this);
+}
+
+ZWPTextInputWrapperV1::~ZWPTextInputWrapperV1() {}
+
+void ZWPTextInputWrapperV1::Initialize(WaylandConnection* connection,
+                                       ZWPTextInputWrapperClient* client) {
+  connection_ = connection;
+  client_ = client;
+}
+
+void ZWPTextInputWrapperV1::Reset() {
+  ResetInputEventState();
+  zwp_text_input_v1_reset(obj_.get());
+}
+
+void ZWPTextInputWrapperV1::Activate(WaylandWindow* window) {
+  zwp_text_input_v1_activate(obj_.get(), connection_->seat(),
+                             window->surface());
+}
+
+void ZWPTextInputWrapperV1::Deactivate() {
+  zwp_text_input_v1_deactivate(obj_.get(), connection_->seat());
+}
+
+void ZWPTextInputWrapperV1::ShowInputPanel() {
+  zwp_text_input_v1_show_input_panel(obj_.get());
+}
+
+void ZWPTextInputWrapperV1::HideInputPanel() {
+  zwp_text_input_v1_hide_input_panel(obj_.get());
+}
+
+void ZWPTextInputWrapperV1::SetCursorRect(const gfx::Rect& rect) {
+  zwp_text_input_v1_set_cursor_rectangle(obj_.get(), rect.x(), rect.y(),
+                                         rect.width(), rect.height());
+}
+
+void ZWPTextInputWrapperV1::SetSurroundingText(
+    const base::string16& text,
+    const gfx::Range& selection_range) {
+  const std::string text_utf8 = base::UTF16ToUTF8(text);
+  zwp_text_input_v1_set_surrounding_text(obj_.get(), text_utf8.c_str(),
+                                         selection_range.start(),
+                                         selection_range.end());
+}
+
+void ZWPTextInputWrapperV1::ResetInputEventState() {
+  preedit_cursor_ = -1;
+}
+
+// zwp_text_input_v1_listener
+
+void ZWPTextInputWrapperV1::OnEnter(void* data,
+                                    struct zwp_text_input_v1* text_input,
+                                    struct wl_surface* surface) {
+  NOTIMPLEMENTED_LOG_ONCE();
+}
+
+void ZWPTextInputWrapperV1::OnLeave(void* data,
+                                    struct zwp_text_input_v1* text_input) {
+  NOTIMPLEMENTED_LOG_ONCE();
+}
+
+void ZWPTextInputWrapperV1::OnModifiersMap(void* data,
+                                           struct zwp_text_input_v1* text_input,
+                                           struct wl_array* map) {
+  NOTIMPLEMENTED_LOG_ONCE();
+}
+
+void ZWPTextInputWrapperV1::OnInputPanelState(
+    void* data,
+    struct zwp_text_input_v1* text_input,
+    uint32_t state) {
+  NOTIMPLEMENTED_LOG_ONCE();
+}
+
+void ZWPTextInputWrapperV1::OnPreeditString(
+    void* data,
+    struct zwp_text_input_v1* text_input,
+    uint32_t serial,
+    const char* text,
+    const char* commit) {
+  ZWPTextInputWrapperV1* wti = static_cast<ZWPTextInputWrapperV1*>(data);
+  wti->ResetInputEventState();
+  wti->client_->OnPreeditString(std::string(text), wti->preedit_cursor_);
+}
+
+void ZWPTextInputWrapperV1::OnPreeditStyling(
+    void* data,
+
+    struct zwp_text_input_v1* text_input,
+    uint32_t index,
+    uint32_t length,
+    uint32_t style) {
+  NOTIMPLEMENTED_LOG_ONCE();
+}
+
+void ZWPTextInputWrapperV1::OnPreeditCursor(
+    void* data,
+    struct zwp_text_input_v1* text_input,
+    int32_t index) {
+  ZWPTextInputWrapperV1* wti = static_cast<ZWPTextInputWrapperV1*>(data);
+  wti->preedit_cursor_ = index;
+}
+
+void ZWPTextInputWrapperV1::OnCommitString(void* data,
+                                           struct zwp_text_input_v1* text_input,
+                                           uint32_t serial,
+                                           const char* text) {
+  ZWPTextInputWrapperV1* wti = static_cast<ZWPTextInputWrapperV1*>(data);
+  wti->ResetInputEventState();
+  wti->client_->OnCommitString(std::string(text));
+}
+
+void ZWPTextInputWrapperV1::OnCursorPosition(
+    void* data,
+    struct zwp_text_input_v1* text_input,
+    int32_t index,
+    int32_t anchor) {
+  NOTIMPLEMENTED_LOG_ONCE();
+}
+
+void ZWPTextInputWrapperV1::OnDeleteSurroundingText(
+    void* data,
+    struct zwp_text_input_v1* text_input,
+    int32_t index,
+    uint32_t length) {
+  ZWPTextInputWrapperV1* wti = static_cast<ZWPTextInputWrapperV1*>(data);
+  wti->client_->OnDeleteSurroundingText(index, length);
+}
+
+void ZWPTextInputWrapperV1::OnKeysym(void* data,
+                                     struct zwp_text_input_v1* text_input,
+                                     uint32_t serial,
+                                     uint32_t time,
+                                     uint32_t key,
+                                     uint32_t state,
+                                     uint32_t modifiers) {
+  ZWPTextInputWrapperV1* wti = static_cast<ZWPTextInputWrapperV1*>(data);
+  wti->client_->OnKeysym(key, state, modifiers);
+}
+
+void ZWPTextInputWrapperV1::OnLanguage(void* data,
+                                       struct zwp_text_input_v1* text_input,
+                                       uint32_t serial,
+                                       const char* language) {
+  NOTIMPLEMENTED_LOG_ONCE();
+}
+
+void ZWPTextInputWrapperV1::OnTextDirection(
+    void* data,
+    struct zwp_text_input_v1* text_input,
+    uint32_t serial,
+    uint32_t direction) {
+  // Not implemented
+}
+
+}  // namespace ui
diff --git a/ui/ozone/platform/wayland/zwp_text_input_wrapper_v1.h b/ui/ozone/platform/wayland/zwp_text_input_wrapper_v1.h
new file mode 100644
index 0000000000000..33c6a287141cd
--- /dev/null
+++ b/ui/ozone/platform/wayland/zwp_text_input_wrapper_v1.h
@@ -0,0 +1,106 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PLATFORM_WAYLAND_ZWP_TEXT_INPUT_WRAPPER_V1_H_
+#define UI_OZONE_PLATFORM_WAYLAND_ZWP_TEXT_INPUT_WRAPPER_V1_H_
+
+#include <text-input-unstable-v1-client-protocol.h>
+#include <string>
+
+#include "ui/ozone/platform/wayland/zwp_text_input_wrapper.h"
+
+namespace gfx {
+class Rect;
+}
+
+namespace ui {
+
+class WaylandConnection;
+class WaylandWindow;
+
+class ZWPTextInputWrapperV1 : public ZWPTextInputWrapper {
+ public:
+  ZWPTextInputWrapperV1(zwp_text_input_manager_v1* text_input_manager);
+  ~ZWPTextInputWrapperV1() override;
+
+  void Initialize(WaylandConnection* connection,
+                  ZWPTextInputWrapperClient* client) override;
+
+  void Reset() override;
+
+  void Activate(WaylandWindow* window) override;
+  void Deactivate() override;
+
+  void ShowInputPanel() override;
+  void HideInputPanel() override;
+
+  void SetCursorRect(const gfx::Rect& rect) override;
+  void SetSurroundingText(const base::string16& text,
+                          const gfx::Range& selection_range) override;
+
+ private:
+  void ResetInputEventState();
+
+  // zwp_text_input_v1_listener
+  static void OnEnter(void* data,
+                      struct zwp_text_input_v1* text_input,
+                      struct wl_surface* surface);
+  static void OnLeave(void* data, struct zwp_text_input_v1* text_input);
+  static void OnModifiersMap(void* data,
+                             struct zwp_text_input_v1* text_input,
+                             struct wl_array* map);
+  static void OnInputPanelState(void* data,
+                                struct zwp_text_input_v1* text_input,
+                                uint32_t state);
+  static void OnPreeditString(void* data,
+                              struct zwp_text_input_v1* text_input,
+                              uint32_t serial,
+                              const char* text,
+                              const char* commit);
+  static void OnPreeditStyling(void* data,
+                               struct zwp_text_input_v1* text_input,
+                               uint32_t index,
+                               uint32_t length,
+                               uint32_t style);
+  static void OnPreeditCursor(void* data,
+                              struct zwp_text_input_v1* text_input,
+                              int32_t index);
+  static void OnCommitString(void* data,
+                             struct zwp_text_input_v1* text_input,
+                             uint32_t serial,
+                             const char* text);
+  static void OnCursorPosition(void* data,
+                               struct zwp_text_input_v1* text_input,
+                               int32_t index,
+                               int32_t anchor);
+  static void OnDeleteSurroundingText(void* data,
+                                      struct zwp_text_input_v1* text_input,
+                                      int32_t index,
+                                      uint32_t length);
+  static void OnKeysym(void* data,
+                       struct zwp_text_input_v1* text_input,
+                       uint32_t serial,
+                       uint32_t time,
+                       uint32_t key,
+                       uint32_t state,
+                       uint32_t modifiers);
+  static void OnLanguage(void* data,
+                         struct zwp_text_input_v1* text_input,
+                         uint32_t serial,
+                         const char* language);
+  static void OnTextDirection(void* data,
+                              struct zwp_text_input_v1* text_input,
+                              uint32_t serial,
+                              uint32_t direction);
+
+  WaylandConnection* connection_ = nullptr;
+  wl::Object<zwp_text_input_v1> obj_;
+  ZWPTextInputWrapperClient* client_;
+
+  int32_t preedit_cursor_;
+};
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_WAYLAND_ZWP_TEXT_INPUT_WRAPPER_V1_H_
diff --git a/ui/ozone/public/ozone_switches.cc b/ui/ozone/public/ozone_switches.cc
index 0a9b3ab32a04d..7bec0b7ef22c0 100644
--- a/ui/ozone/public/ozone_switches.cc
+++ b/ui/ozone/public/ozone_switches.cc
@@ -12,4 +12,7 @@ const char kOzonePlatform[] = "ozone-platform";
 // Specify location for image dumps.
 const char kOzoneDumpFile[] = "ozone-dump-file";
 
+// Try to enable wayland input method editor.
+const char kEnableWaylandIme[] = "enable-wayland-ime";
+
 }  // namespace switches
diff --git a/ui/ozone/public/ozone_switches.h b/ui/ozone/public/ozone_switches.h
index b062e67fcfb2d..d7e7d8a9256ae 100644
--- a/ui/ozone/public/ozone_switches.h
+++ b/ui/ozone/public/ozone_switches.h
@@ -14,6 +14,8 @@ OZONE_BASE_EXPORT extern const char kOzonePlatform[];
 
 OZONE_BASE_EXPORT extern const char kOzoneDumpFile[];
 
+OZONE_BASE_EXPORT extern const char kEnableWaylandIme[];
+
 }  // namespace switches
 
 #endif  // UI_OZONE_PUBLIC_OZONE_SWITCHES_H_

From bc00e2934bff08ca90a56676e90aa1f6b160fe23 Mon Sep 17 00:00:00 2001
From: Maksim Sisov <msisov@igalia.com>
Date: Fri, 10 Aug 2018 09:26:12 +0300
Subject: [PATCH 15/32] [ozone/x11/headless] Use FakeInputMethodContextFactory
 to avoid crashing.

That is, after we've added ime imeplementation for Wayland, other
ozone platforms started to crash. To avoid this, use fake factory.

fixup! [ozone/x11/headless] Use FakeInputMethodContextFactory to avoid crashing.

Added condition before setting LinuxInputMethodContextFactory.

fixup! [ozone/x11/headless] Use FakeInputMethodContextFactory to avoid crashing.

It needs to skip DCHEK at InitializeInputMethodForTesting() as
LinuxInputMethodContextFactory's already set at
OzonePlatform::InitializeUI().
---
 ui/base/ime/input_method_initializer.cc               |  2 ++
 .../ime/linux/fake_input_method_context_factory.cc    |  4 +++-
 ui/base/ime/linux/fake_input_method_context_factory.h |  5 ++++-
 ui/ozone/platform/headless/BUILD.gn                   |  1 +
 ui/ozone/platform/headless/ozone_platform_headless.cc |  9 +++++++++
 ui/ozone/platform/x11/BUILD.gn                        | 11 ++++++-----
 ui/ozone/platform/x11/DEPS                            |  1 +
 ui/ozone/platform/x11/ozone_platform_x11.cc           | 11 +++++++++--
 8 files changed, 35 insertions(+), 9 deletions(-)

diff --git a/ui/base/ime/input_method_initializer.cc b/ui/base/ime/input_method_initializer.cc
index b64f362a5d851..6dd0a9347de0d 100644
--- a/ui/base/ime/input_method_initializer.cc
+++ b/ui/base/ime/input_method_initializer.cc
@@ -50,11 +50,13 @@ void InitializeInputMethodForTesting() {
   if (!g_linux_input_method_context_factory_for_testing)
     g_linux_input_method_context_factory_for_testing =
         new FakeInputMethodContextFactory();
+#if !defined(USE_OZONE)
   const LinuxInputMethodContextFactory* factory =
       LinuxInputMethodContextFactory::instance();
   CHECK(!factory || factory == g_linux_input_method_context_factory_for_testing)
       << "LinuxInputMethodContextFactory was already initialized somewhere "
       << "else.";
+#endif
   LinuxInputMethodContextFactory::SetInstance(
       g_linux_input_method_context_factory_for_testing);
 #elif defined(OS_WIN)
diff --git a/ui/base/ime/linux/fake_input_method_context_factory.cc b/ui/base/ime/linux/fake_input_method_context_factory.cc
index f8d3102ee4863..aba2f76ed3047 100644
--- a/ui/base/ime/linux/fake_input_method_context_factory.cc
+++ b/ui/base/ime/linux/fake_input_method_context_factory.cc
@@ -8,7 +8,9 @@
 
 namespace ui {
 
-FakeInputMethodContextFactory::FakeInputMethodContextFactory() {}
+FakeInputMethodContextFactory::FakeInputMethodContextFactory() = default;
+
+FakeInputMethodContextFactory::~FakeInputMethodContextFactory() = default;
 
 std::unique_ptr<LinuxInputMethodContext>
 FakeInputMethodContextFactory::CreateInputMethodContext(
diff --git a/ui/base/ime/linux/fake_input_method_context_factory.h b/ui/base/ime/linux/fake_input_method_context_factory.h
index 4d57b96f79e85..57bf40ff3f1e8 100644
--- a/ui/base/ime/linux/fake_input_method_context_factory.h
+++ b/ui/base/ime/linux/fake_input_method_context_factory.h
@@ -7,14 +7,17 @@
 
 #include "base/macros.h"
 #include "ui/base/ime/linux/linux_input_method_context_factory.h"
+#include "ui/base/ime/ui_base_ime_export.h"
 
 namespace ui {
 
 // An implementation of LinuxInputMethodContextFactory, which creates and
 // returns FakeInputMethodContext's.
-class FakeInputMethodContextFactory : public LinuxInputMethodContextFactory {
+class UI_BASE_IME_EXPORT FakeInputMethodContextFactory
+    : public LinuxInputMethodContextFactory {
  public:
   FakeInputMethodContextFactory();
+  ~FakeInputMethodContextFactory() override;
 
   // LinuxInputMethodContextFactory:
   std::unique_ptr<LinuxInputMethodContext> CreateInputMethodContext(
diff --git a/ui/ozone/platform/headless/BUILD.gn b/ui/ozone/platform/headless/BUILD.gn
index 046dec9b9b3cf..8fa5fa97bf0db 100644
--- a/ui/ozone/platform/headless/BUILD.gn
+++ b/ui/ozone/platform/headless/BUILD.gn
@@ -26,6 +26,7 @@ source_set("headless") {
     "//base",
     "//skia",
     "//ui/base",
+    "//ui/base/ime",
     "//ui/display/manager",
     "//ui/events",
     "//ui/events/ozone:events_ozone_layout",
diff --git a/ui/ozone/platform/headless/ozone_platform_headless.cc b/ui/ozone/platform/headless/ozone_platform_headless.cc
index 3e22233d1ec60..2bed591e6bc88 100644
--- a/ui/ozone/platform/headless/ozone_platform_headless.cc
+++ b/ui/ozone/platform/headless/ozone_platform_headless.cc
@@ -8,6 +8,7 @@
 #include "base/files/file_path.h"
 #include "base/macros.h"
 #include "ui/base/cursor/ozone/bitmap_cursor_factory_ozone.h"
+#include "ui/base/ime/linux/fake_input_method_context_factory.h"
 #include "ui/events/ozone/layout/keyboard_layout_engine_manager.h"
 #include "ui/events/ozone/layout/stub/stub_keyboard_layout_engine.h"
 #include "ui/events/platform/platform_event_source.h"
@@ -90,6 +91,13 @@ class OzonePlatformHeadless : public OzonePlatform {
     input_controller_ = CreateStubInputController();
     cursor_factory_ozone_ = std::make_unique<BitmapCursorFactoryOzone>();
     gpu_platform_support_host_.reset(CreateStubGpuPlatformSupportHost());
+
+    if (LinuxInputMethodContextFactory::instance())
+      return;
+    fake_input_method_factory_ =
+        std::make_unique<FakeInputMethodContextFactory>();
+    LinuxInputMethodContextFactory::SetInstance(
+        fake_input_method_factory_.get());
   }
 
   void InitializeGPU(const InitParams& params) override {
@@ -105,6 +113,7 @@ class OzonePlatformHeadless : public OzonePlatform {
   std::unique_ptr<InputController> input_controller_;
   std::unique_ptr<GpuPlatformSupportHost> gpu_platform_support_host_;
   std::unique_ptr<OverlayManagerOzone> overlay_manager_;
+  std::unique_ptr<FakeInputMethodContextFactory> fake_input_method_factory_;
   base::FilePath file_path_;
 
   DISALLOW_COPY_AND_ASSIGN(OzonePlatformHeadless);
diff --git a/ui/ozone/platform/x11/BUILD.gn b/ui/ozone/platform/x11/BUILD.gn
index 8748ffc5fc52a..f0655fb8227c8 100644
--- a/ui/ozone/platform/x11/BUILD.gn
+++ b/ui/ozone/platform/x11/BUILD.gn
@@ -24,16 +24,16 @@ source_set("x11") {
     "x11_cursor_factory_ozone.h",
     "x11_cursor_ozone.cc",
     "x11_cursor_ozone.h",
+    "x11_display_manager_ozone.cc",
+    "x11_display_manager_ozone.h",
+    "x11_native_display_delegate.cc",
+    "x11_native_display_delegate.h",
     "x11_surface_factory.cc",
     "x11_surface_factory.h",
     "x11_window_manager_ozone.cc",
     "x11_window_manager_ozone.h",
     "x11_window_ozone.cc",
     "x11_window_ozone.h",
-    "x11_native_display_delegate.h",
-    "x11_native_display_delegate.cc",
-    "x11_display_manager_ozone.h",
-    "x11_display_manager_ozone.cc",
   ]
 
   deps = [
@@ -41,6 +41,7 @@ source_set("x11") {
     "//gpu/vulkan:buildflags",
     "//skia",
     "//ui/base",
+    "//ui/base/ime",
     "//ui/base/x",
     "//ui/display/manager",
     "//ui/events",
@@ -65,7 +66,7 @@ source_set("x11") {
 
   configs += [
     "//build/config/linux:x11",
-    "//build/config/linux:xrandr"
+    "//build/config/linux:xrandr",
   ]
 
   public_configs = [ "//third_party/khronos:khronos_headers" ]
diff --git a/ui/ozone/platform/x11/DEPS b/ui/ozone/platform/x11/DEPS
index 8d590992a5c1a..db1d9fe859da4 100644
--- a/ui/ozone/platform/x11/DEPS
+++ b/ui/ozone/platform/x11/DEPS
@@ -1,3 +1,4 @@
 include_rules = [
   "+ui/base/x",
+  "+ui/base/ime",
 ]
diff --git a/ui/ozone/platform/x11/ozone_platform_x11.cc b/ui/ozone/platform/x11/ozone_platform_x11.cc
index 3b65fd4d020bb..1edd3483f864a 100644
--- a/ui/ozone/platform/x11/ozone_platform_x11.cc
+++ b/ui/ozone/platform/x11/ozone_platform_x11.cc
@@ -9,14 +9,15 @@
 
 #include "base/message_loop/message_loop.h"
 #include "base/strings/utf_string_conversions.h"
+#include "ui/base/ime/linux/fake_input_method_context_factory.h"
 #include "ui/base/x/x11_util.h"
 #include "ui/events/devices/x11/touch_factory_x11.h"
 #include "ui/events/platform/x11/x11_event_source_libevent.h"
 #include "ui/events/system_input_injector.h"
 #include "ui/gfx/x/x11.h"
 #include "ui/ozone/common/stub_overlay_manager.h"
-#include "ui/ozone/platform/x11/x11_native_display_delegate.h"
 #include "ui/ozone/platform/x11/x11_cursor_factory_ozone.h"
+#include "ui/ozone/platform/x11/x11_native_display_delegate.h"
 #include "ui/ozone/platform/x11/x11_surface_factory.h"
 #include "ui/ozone/platform/x11/x11_window_manager_ozone.h"
 #include "ui/ozone/platform/x11/x11_window_ozone.h"
@@ -84,8 +85,13 @@ class OzonePlatformX11 : public OzonePlatform {
     input_controller_ = CreateStubInputController();
     cursor_factory_ozone_ = std::make_unique<X11CursorFactoryOzone>();
     gpu_platform_support_host_.reset(CreateStubGpuPlatformSupportHost());
-
     TouchFactory::SetTouchDeviceListFromCommandLine();
+
+    if (LinuxInputMethodContextFactory::instance())
+      return;
+    fake_input_method_factory_ =
+        std::make_unique<FakeInputMethodContextFactory>();
+    LinuxInputMethodContextFactory::SetInstance(fake_input_method_factory_.get());
   }
 
   void InitializeGPU(const InitParams& params) override {
@@ -142,6 +148,7 @@ class OzonePlatformX11 : public OzonePlatform {
   std::unique_ptr<InputController> input_controller_;
   std::unique_ptr<X11CursorFactoryOzone> cursor_factory_ozone_;
   std::unique_ptr<GpuPlatformSupportHost> gpu_platform_support_host_;
+  std::unique_ptr<FakeInputMethodContextFactory> fake_input_method_factory_;
 
   // Objects in the GPU process.
   std::unique_ptr<X11SurfaceFactory> surface_factory_ozone_;

From fd64bcadb4b8a9f33371feb7600cc7cc3370e6e7 Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Wed, 8 Aug 2018 21:50:40 +0900
Subject: [PATCH 16/32] Implements Drag and Drop for Ozone/Wayland

It introduces DesktopDragDropClientOzone and some APIs related to DnD
to PlatformWindowDelegate to deliver DnD status from platform and
system. OnDragEnter/OnDragMotion/OnDragDrop/OnDragLeave reports DnD
status with information based on the status. OnDragDataReceived is
called when it gets dragged data from system, OnDragDataRequest is
called when system requests dragged data and OnCloseDrag is called
when DnD is canceled or performed. These APIs are connected to
DesktopDragDropClientOzone.

It exteneds WaylandDataDevice, WaylandDataSource and WaylandDataOffer
for DnD on Wayland.

The working sequence is blow.
1) When it gets dragging.
WaylandDataDevice gets OnEnter() and DesktopDragDropClientOzone set
dragged data if it has |source_data_|. It means dragging is started
internally. After that, it continously gets Motion and Drop events.
When it gets OnDragDrop, it tries to read dragged data if it doesn't
have yet. As OnDragLeave event comes right after OnDragDrop, it
defers OnDragLeave event handling. After finishing it, it calls
callback and OnDragLeave is handled. The reason that it reads
dragged data on OnDragDrop event, it's blocked if |fd| offered by
|drag_offer_| doesn't have data yet.

2) When it sends dragging.
It calls 'wl_data_device_start_drag' through
'DesktopDragDropClientOzone::StartDragAndDrop'. After getting
OnDragEnter/Motion, it gets WaylandDataSource::OnSend() and fills
|fd| with the dragged data. If Drop is performed without problem,
it gets OnDnDDropPerformed() and OnDnDFinished(). Otherwise,
it gets OnCancel().

fixup! Implements Drag and Drop for Ozone/Wayland

It fixes conflicts based on crrev/com/c/1179505 and
crrev.com/com/c/1179487.

fixup! Implements Drag and Drop for Ozone/Wayland

It fixes compilation error with content_browsertests with adding
OnDragMotion() at StubPlatformWindowDelegate.
---
 chrome/browser/ui/views/tabs/tab_strip.cc     |   1 +
 ui/aura/window_tree_host.cc                   |  10 +-
 ui/aura/window_tree_host.h                    |   4 +
 ui/aura/window_tree_host_platform.cc          |  34 ++
 ui/aura/window_tree_host_platform.h           |  16 +
 .../test/test_compositor_host_ozone.cc        |   6 +
 ui/ozone/platform/wayland/fake_server.cc      |  73 +++-
 ui/ozone/platform/wayland/fake_server.h       |  11 +
 .../platform/wayland/wayland_connection.cc    |  46 ++-
 .../platform/wayland/wayland_connection.h     |  19 +
 .../platform/wayland/wayland_data_device.cc   | 358 +++++++++++++++++-
 .../platform/wayland/wayland_data_device.h    | 107 +++++-
 .../wayland/wayland_data_device_unittest.cc   |  61 +++
 .../platform/wayland/wayland_data_offer.cc    |  52 ++-
 .../platform/wayland/wayland_data_offer.h     |  18 +-
 .../platform/wayland/wayland_data_source.cc   |  98 ++++-
 .../platform/wayland/wayland_data_source.h    |  20 +-
 ui/ozone/platform/wayland/wayland_object.cc   |  11 +-
 ui/ozone/platform/wayland/wayland_window.cc   |  32 ++
 ui/ozone/platform/wayland/wayland_window.h    |  12 +
 .../test/mock_platform_window_delegate.cc     |   7 +
 ui/ozone/test/mock_platform_window_delegate.h |  16 +
 ui/platform_window/platform_window.h          |   7 +
 ui/platform_window/platform_window_delegate.h |  35 ++
 ui/views/BUILD.gn                             |  10 +-
 .../desktop_drag_drop_client_ozone.cc         | 258 +++++++++++++
 .../desktop_drag_drop_client_ozone.h          | 114 ++++++
 .../desktop_window_tree_host_platform.cc      |  42 +-
 .../desktop_window_tree_host_platform.h       |  17 +
 29 files changed, 1446 insertions(+), 49 deletions(-)
 create mode 100644 ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone.cc
 create mode 100644 ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone.h

diff --git a/chrome/browser/ui/views/tabs/tab_strip.cc b/chrome/browser/ui/views/tabs/tab_strip.cc
index 6a8192c351907..b607b100b316d 100644
--- a/chrome/browser/ui/views/tabs/tab_strip.cc
+++ b/chrome/browser/ui/views/tabs/tab_strip.cc
@@ -2286,6 +2286,7 @@ TabStrip::DropArrow::DropArrow(const BrowserRootView::DropIndex& index,
   params.accept_events = false;
   params.bounds = gfx::Rect(drop_indicator_width, drop_indicator_height);
   params.context = context->GetNativeWindow();
+  params.parent = context->GetNativeWindow();
   arrow_window->Init(params);
   arrow_window->SetContentsView(arrow_view);
 }
diff --git a/ui/aura/window_tree_host.cc b/ui/aura/window_tree_host.cc
index 64d0817c3e8b6..8ddcfd089d3dd 100644
--- a/ui/aura/window_tree_host.cc
+++ b/ui/aura/window_tree_host.cc
@@ -179,9 +179,15 @@ void WindowTreeHost::ConvertScreenInPixelsToDIP(gfx::Point* point) const {
 }
 
 void WindowTreeHost::ConvertDIPToPixels(gfx::Point* point) const {
-  auto point_3f = gfx::Point3F(gfx::PointF(*point));
+  gfx::PointF pointf = gfx::PointF(*point);
+  ConvertDIPToPixels(&pointf);
+  *point = gfx::ToFlooredPoint(pointf);
+}
+
+void WindowTreeHost::ConvertDIPToPixels(gfx::PointF* point) const {
+  auto point_3f = gfx::Point3F(*point);
   GetRootTransform().TransformPoint(&point_3f);
-  *point = gfx::ToFlooredPoint(point_3f.AsPointF());
+  *point = point_3f.AsPointF();
 }
 
 void WindowTreeHost::ConvertPixelsToDIP(gfx::Point* point) const {
diff --git a/ui/aura/window_tree_host.h b/ui/aura/window_tree_host.h
index 41339eba3335a..3f15af232c316 100644
--- a/ui/aura/window_tree_host.h
+++ b/ui/aura/window_tree_host.h
@@ -120,6 +120,10 @@ class AURA_EXPORT WindowTreeHost : public ui::internal::InputMethodDelegate,
   // host window's.
   virtual void ConvertDIPToPixels(gfx::Point* point) const;
 
+  // Converts |pointf| from the root window's coordinate system to the
+  // host window's.
+  virtual void ConvertDIPToPixels(gfx::PointF* pointf) const;
+
   // Converts |point| from the host window's coordinate system to the
   // root window's.
   virtual void ConvertPixelsToDIP(gfx::Point* point) const;
diff --git a/ui/aura/window_tree_host_platform.cc b/ui/aura/window_tree_host_platform.cc
index 76865a51750d7..b2d2da20781cd 100644
--- a/ui/aura/window_tree_host_platform.cc
+++ b/ui/aura/window_tree_host_platform.cc
@@ -256,4 +256,38 @@ void WindowTreeHostPlatform::OnActivationChanged(bool active) {
     OnHostActivated();
 }
 
+void WindowTreeHostPlatform::OnDragEnter(
+    ui::PlatformWindow* window,
+    const gfx::PointF& point,
+    std::unique_ptr<ui::OSExchangeData> data,
+    int operation) {
+  NOTIMPLEMENTED();
+}
+
+int WindowTreeHostPlatform::OnDragMotion(const gfx::PointF& point,
+                                         uint32_t time,
+                                         int operation,
+                                         gfx::AcceleratedWidget* widget) {
+  NOTIMPLEMENTED();
+  return 0;
+}
+
+void WindowTreeHostPlatform::OnDragDrop(
+    std::unique_ptr<ui::OSExchangeData> data) {
+  NOTIMPLEMENTED();
+}
+
+void WindowTreeHostPlatform::OnDragLeave() {
+  NOTIMPLEMENTED();
+}
+
+void WindowTreeHostPlatform::OnMouseMoved(const gfx::Point& point,
+                                          gfx::AcceleratedWidget* widget) {
+  NOTIMPLEMENTED();
+}
+
+void WindowTreeHostPlatform::OnDragSessionClose(int operation) {
+  NOTIMPLEMENTED();
+}
+
 }  // namespace aura
diff --git a/ui/aura/window_tree_host_platform.h b/ui/aura/window_tree_host_platform.h
index 5ea1727398f82..0017f723f65c6 100644
--- a/ui/aura/window_tree_host_platform.h
+++ b/ui/aura/window_tree_host_platform.h
@@ -23,6 +23,9 @@ class KeyboardHook;
 struct PlatformWindowInitProperties;
 }  // namespace ui
 
+namespace gfx {
+class PointF;
+}
 namespace aura {
 
 // The unified WindowTreeHost implementation for platforms
@@ -76,6 +79,19 @@ class AURA_EXPORT WindowTreeHostPlatform : public WindowTreeHost,
   void OnAcceleratedWidgetAvailable(gfx::AcceleratedWidget widget) override;
   void OnAcceleratedWidgetDestroyed() override;
   void OnActivationChanged(bool active) override;
+  void OnDragEnter(ui::PlatformWindow* window,
+                   const gfx::PointF& point,
+                   std::unique_ptr<ui::OSExchangeData> data,
+                   int operation) override;
+  int OnDragMotion(const gfx::PointF& point,
+                   uint32_t time,
+                   int operation,
+                   gfx::AcceleratedWidget* widget) override;
+  void OnDragDrop(std::unique_ptr<ui::OSExchangeData> data) override;
+  void OnDragLeave() override;
+  void OnMouseMoved(const gfx::Point& point,
+                    gfx::AcceleratedWidget* widget) override;
+  void OnDragSessionClose(int operation) override;
 
   // Overridden from aura::WindowTreeHost:
   bool CaptureSystemKeyEventsImpl(
diff --git a/ui/compositor/test/test_compositor_host_ozone.cc b/ui/compositor/test/test_compositor_host_ozone.cc
index 38d067327fd38..2cbe33d1cb65b 100644
--- a/ui/compositor/test/test_compositor_host_ozone.cc
+++ b/ui/compositor/test/test_compositor_host_ozone.cc
@@ -48,6 +48,12 @@ class StubPlatformWindowDelegate : public PlatformWindowDelegate {
     widget_ = gfx::kNullAcceleratedWidget;
   }
   void OnActivationChanged(bool active) override {}
+  int OnDragMotion(const gfx::PointF& point,
+                   uint32_t time,
+                   int operation,
+                   gfx::AcceleratedWidget* widget) override {
+    return 0;
+  }
 
  private:
   gfx::AcceleratedWidget widget_ = gfx::kNullAcceleratedWidget;
diff --git a/ui/ozone/platform/wayland/fake_server.cc b/ui/ozone/platform/wayland/fake_server.cc
index db447fbf1ee94..04493f5cf9889 100644
--- a/ui/ozone/platform/wayland/fake_server.cc
+++ b/ui/ozone/platform/wayland/fake_server.cc
@@ -293,6 +293,15 @@ const struct zxdg_positioner_v6_interface zxdg_positioner_v6_impl = {
 
 // wl_data_device
 
+void DataDeviceStartDrag(wl_client* client,
+                         wl_resource* resource,
+                         wl_resource* source,
+                         wl_resource* origin,
+                         wl_resource* icon,
+                         uint32_t serial) {
+  NOTIMPLEMENTED();
+}
+
 void DataDeviceSetSelection(wl_client* client,
                             wl_resource* resource,
                             wl_resource* data_source,
@@ -307,8 +316,7 @@ void DataDeviceRelease(wl_client* client, wl_resource* resource) {
 }
 
 const struct wl_data_device_interface data_device_impl = {
-    nullptr /*data_device_start_drag*/, &DataDeviceSetSelection,
-    &DataDeviceRelease};
+    &DataDeviceStartDrag, &DataDeviceSetSelection, &DataDeviceRelease};
 
 // wl_data_device_manager
 
@@ -350,6 +358,13 @@ const struct wl_data_device_manager_interface data_device_manager_impl = {
 
 // wl_data_offer
 
+void DataOfferAccept(wl_client* client,
+                     wl_resource* resource,
+                     uint32_t serial,
+                     const char* mime_type) {
+  NOTIMPLEMENTED();
+}
+
 void DataOfferReceive(wl_client* client,
                       wl_resource* resource,
                       const char* mime_type,
@@ -362,10 +377,20 @@ void DataOfferDestroy(wl_client* client, wl_resource* resource) {
   wl_resource_destroy(resource);
 }
 
+void DataOfferFinish(wl_client* client, wl_resource* resource) {
+  NOTIMPLEMENTED();
+}
+
+void DataOfferSetActions(wl_client* client,
+                         wl_resource* resource,
+                         uint32_t dnd_actions,
+                         uint32_t preferred_action) {
+  NOTIMPLEMENTED();
+}
+
 const struct wl_data_offer_interface data_offer_impl = {
-    nullptr /* data_offer_accept*/, DataOfferReceive,
-    nullptr /*data_offer_finish*/, DataOfferDestroy,
-    nullptr /*data_offer_set_actions*/};
+    DataOfferAccept, DataOfferReceive, DataOfferDestroy, DataOfferFinish,
+    DataOfferSetActions};
 
 // wl_data_source
 
@@ -379,8 +404,14 @@ void DataSourceDestroy(wl_client* client, wl_resource* resource) {
   wl_resource_destroy(resource);
 }
 
+void SetActions(wl_client* client,
+                wl_resource* resource,
+                uint32_t dnd_actions) {
+  NOTIMPLEMENTED();
+}
+
 const struct wl_data_source_interface data_source_impl = {
-    DataSourceOffer, DataSourceDestroy, nullptr /*data_source_set_actions*/};
+    DataSourceOffer, DataSourceDestroy, SetActions};
 
 // wl_seat
 
@@ -874,10 +905,15 @@ MockDataOffer::~MockDataOffer() {}
 
 void MockDataOffer::Receive(const std::string& mime_type, base::ScopedFD fd) {
   DCHECK(fd.is_valid());
-  std::string text_utf8(kSampleClipboardText);
+  std::string text_data;
+  if (mime_type == kTextMimeTypeUtf8)
+    text_data = kSampleClipboardText;
+  else if (mime_type == kTextMimeTypeText)
+    text_data = kSampleTextForDragAndDrop;
+
   io_thread_.task_runner()->PostTask(
       FROM_HERE,
-      base::BindOnce(&WriteDataOnWorkerThread, std::move(fd), text_utf8));
+      base::BindOnce(&WriteDataOnWorkerThread, std::move(fd), text_data));
 }
 
 void MockDataOffer::OnOffer(const std::string& mime_type) {
@@ -906,6 +942,27 @@ MockDataOffer* MockDataDevice::OnDataOffer() {
   return GetUserDataAs<MockDataOffer>(data_offer_resource);
 }
 
+void MockDataDevice::OnEnter(uint32_t serial,
+                             wl_resource* surface,
+                             wl_fixed_t x,
+                             wl_fixed_t y,
+                             MockDataOffer& data_offer) {
+  wl_data_device_send_enter(resource(), serial, surface, x, y,
+                            data_offer.resource());
+}
+
+void MockDataDevice::OnLeave() {
+  wl_data_device_send_leave(resource());
+}
+
+void MockDataDevice::OnMotion(uint32_t time, wl_fixed_t x, wl_fixed_t y) {
+  wl_data_device_send_motion(resource(), time, x, y);
+}
+
+void MockDataDevice::OnDrop() {
+  wl_data_device_send_drop(resource());
+}
+
 void MockDataDevice::OnSelection(MockDataOffer& data_offer) {
   wl_data_device_send_selection(resource(), data_offer.resource());
 }
diff --git a/ui/ozone/platform/wayland/fake_server.h b/ui/ozone/platform/wayland/fake_server.h
index 03de5c0d6cfb5..14832b8fe0888 100644
--- a/ui/ozone/platform/wayland/fake_server.h
+++ b/ui/ozone/platform/wayland/fake_server.h
@@ -24,7 +24,10 @@ struct wl_resource;
 namespace wl {
 
 constexpr char kTextMimeTypeUtf8[] = "text/plain;charset=utf-8";
+constexpr char kTextMimeTypeText[] = "text/plain";
 constexpr char kSampleClipboardText[] = "This is a sample text for clipboard.";
+constexpr char kSampleTextForDragAndDrop[] =
+    "This is a sample text for Drag and Drop.";
 
 // Base class for managing the life cycle of server objects.
 class ServerObject {
@@ -240,6 +243,14 @@ class MockDataDevice : public ServerObject {
   void SetSelection(MockDataSource* data_source, uint32_t serial);
 
   MockDataOffer* OnDataOffer();
+  void OnEnter(uint32_t serial,
+               wl_resource* surface,
+               wl_fixed_t x,
+               wl_fixed_t y,
+               MockDataOffer& data_offer);
+  void OnLeave();
+  void OnMotion(uint32_t time, wl_fixed_t x, wl_fixed_t y);
+  void OnDrop();
   void OnSelection(MockDataOffer& data_offer);
 
  private:
diff --git a/ui/ozone/platform/wayland/wayland_connection.cc b/ui/ozone/platform/wayland/wayland_connection.cc
index af20842dca037..b4a4de5525d45 100644
--- a/ui/ozone/platform/wayland/wayland_connection.cc
+++ b/ui/ozone/platform/wayland/wayland_connection.cc
@@ -32,6 +32,15 @@ const uint32_t kMaxSeatVersion = 4;
 const uint32_t kMaxShmVersion = 1;
 const uint32_t kMaxXdgShellVersion = 1;
 const uint32_t kMaxTextInputManagerVersion = 1;
+const uint32_t kMaxDeviceManagerVersion = 3;
+
+std::unique_ptr<WaylandDataSource> CreateWaylandDataSource(
+    WaylandDataDeviceManager* data_device_manager,
+    WaylandConnection* connection) {
+  wl_data_source* data_source = data_device_manager->CreateSource();
+  return std::make_unique<WaylandDataSource>(data_source, connection);
+}
+
 }  // namespace
 
 WaylandConnection::WaylandConnection()
@@ -317,9 +326,7 @@ void WaylandConnection::OfferClipboardData(
     const ClipboardDelegate::DataMap& data_map,
     ClipboardDelegate::OfferDataClosure callback) {
   if (!data_source_) {
-    wl_data_source* data_source = data_device_manager_->CreateSource();
-    data_source_.reset(new WaylandDataSource(data_source));
-    data_source_->set_connection(this);
+    data_source_ = CreateWaylandDataSource(data_device_manager_.get(), this);
     data_source_->WriteToClipboard(data_map);
   }
   data_source_->UpdataDataMap(data_map);
@@ -341,6 +348,36 @@ bool WaylandConnection::IsSelectionOwner() {
   return !!data_source_;
 }
 
+void WaylandConnection::StartDrag(const ui::OSExchangeData& data,
+                                  const int operation) {
+  if (!drag_data_source_) {
+    drag_data_source_ =
+        CreateWaylandDataSource(data_device_manager_.get(), this);
+  }
+  drag_data_source_->Offer(data);
+  drag_data_source_->SetAction(operation);
+  data_device_->StartDrag(drag_data_source_->data_source(), data);
+}
+
+void WaylandConnection::FinishDragSession(uint32_t dnd_action,
+                                          WaylandWindow* source_window) {
+  if (source_window)
+    source_window->OnDragSessionClose(dnd_action);
+  data_device_->ResetSourceData();
+  drag_data_source_.reset();
+}
+
+void WaylandConnection::GetDragData(const std::string& mime_type,
+                                    std::string* buffer) {
+  data_device_->GetDragData(mime_type, buffer);
+}
+
+void WaylandConnection::RequestDragData(
+    const std::string& mime_type,
+    base::OnceCallback<void(const std::string&)> callback) {
+  data_device_->RequestDragData(mime_type, std::move(callback));
+}
+
 ozone::mojom::WaylandConnectionPtr WaylandConnection::BindInterface() {
   // This mustn't be called twice or when the zwp_linux_dmabuf interface is not
   // available.
@@ -585,7 +622,8 @@ void WaylandConnection::Global(void* data,
   } else if (!connection->data_device_manager_ &&
              strcmp(interface, "wl_data_device_manager") == 0) {
     wl::Object<wl_data_device_manager> data_device_manager =
-        wl::Bind<wl_data_device_manager>(registry, name, 1);
+        wl::Bind<wl_data_device_manager>(
+            registry, name, std::min(version, kMaxDeviceManagerVersion));
     if (!data_device_manager) {
       LOG(ERROR) << "Failed to bind to wl_data_device_manager global";
       return;
diff --git a/ui/ozone/platform/wayland/wayland_connection.h b/ui/ozone/platform/wayland/wayland_connection.h
index ea025a242285c..7c2327948afd3 100644
--- a/ui/ozone/platform/wayland/wayland_connection.h
+++ b/ui/ozone/platform/wayland/wayland_connection.h
@@ -104,6 +104,8 @@ class WaylandConnection : public PlatformEventSource,
   // Returns the current pointer, which may be null.
   WaylandPointer* pointer() { return pointer_.get(); }
 
+  WaylandDataSource* drag_data_source() const { return drag_data_source_.get(); }
+
   // Clipboard implementation.
   ClipboardDelegate* GetClipboardDelegate();
   void DataSourceCancelled();
@@ -122,6 +124,22 @@ class WaylandConnection : public PlatformEventSource,
       ClipboardDelegate::GetMimeTypesClosure callback) override;
   bool IsSelectionOwner() override;
 
+  // Starts Drag with |data| to be delivered, |operation| supported by the
+  // source side.
+  void StartDrag(const ui::OSExchangeData& data, const int operation);
+  // Finishes drag and drop session. it happens when WaylandDataSource gets
+  // 'OnDnDFinished' or 'OnCancel'.
+  void FinishDragSession(uint32_t dnd_action, WaylandWindow* source_window);
+  // Gets the data which Chromium has when it is a source for Drag and Drop.
+  // |buffer| is an output parameter and it should be filled with the data
+  // corresponding to mime_type.
+  void GetDragData(const std::string& mime_type, std::string* buffer);
+  // Requests the data to platform when Chromium is a client for Drag and Drop.
+  // Once reading data from platform is done, |callback| should be called with
+  // the data.
+  void RequestDragData(const std::string& mime_type,
+                       base::OnceCallback<void(const std::string&)> callback);
+
   // Returns bound pointer to own mojo interface.
   ozone::mojom::WaylandConnectionPtr BindInterface();
 
@@ -227,6 +245,7 @@ class WaylandConnection : public PlatformEventSource,
   std::unique_ptr<WaylandDataDeviceManager> data_device_manager_;
   std::unique_ptr<WaylandDataDevice> data_device_;
   std::unique_ptr<WaylandDataSource> data_source_;
+  std::unique_ptr<WaylandDataSource> drag_data_source_;
   std::unique_ptr<WaylandPointer> pointer_;
   std::unique_ptr<WaylandKeyboard> keyboard_;
   std::unique_ptr<WaylandTouch> touch_;
diff --git a/ui/ozone/platform/wayland/wayland_data_device.cc b/ui/ozone/platform/wayland/wayland_data_device.cc
index f0f144c479e97..4e5871a3bb563 100644
--- a/ui/ozone/platform/wayland/wayland_data_device.cc
+++ b/ui/ozone/platform/wayland/wayland_data_device.cc
@@ -5,10 +5,66 @@
 #include "ui/ozone/platform/wayland/wayland_data_device.h"
 
 #include "base/bind.h"
+#include "base/memory/shared_memory.h"
+#include "base/strings/string16.h"
+#include "base/strings/utf_string_conversions.h"
+#include "third_party/skia/include/core/SkCanvas.h"
+#include "ui/base/dragdrop/drag_drop_types.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/base/dragdrop/os_exchange_data_provider_aura.h"
 #include "ui/ozone/platform/wayland/wayland_connection.h"
+#include "ui/ozone/platform/wayland/wayland_util.h"
+#include "ui/ozone/platform/wayland/wayland_window.h"
 
 namespace ui {
 
+namespace {
+
+constexpr char kMimeTypeText[] = "text/plain";
+constexpr char kMimeTypeTextUTF8[] = "text/plain;charset=utf-8";
+
+int GetOperation(uint32_t source_actions, uint32_t dnd_action) {
+  uint32_t action = dnd_action != WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE
+                        ? dnd_action
+                        : source_actions;
+
+  int operation = DragDropTypes::DRAG_NONE;
+  if (action & WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY)
+    operation |= DragDropTypes::DRAG_COPY;
+  if (action & WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE)
+    operation |= DragDropTypes::DRAG_MOVE;
+  // TODO(jkim): Implement branch for WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK
+  if (action & WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK)
+    operation |= DragDropTypes::DRAG_COPY;
+  return operation;
+}
+
+void AddStringToOSExchangeData(const std::string& data,
+                               OSExchangeData* os_exchange_data) {
+  DCHECK(os_exchange_data);
+  if (data.empty())
+    return;
+
+  base::string16 string16 = base::UTF8ToUTF16(data);
+  os_exchange_data->SetString(string16);
+}
+
+void AddToOSExchangeData(const std::string& data,
+                         const std::string& mime_type,
+                         OSExchangeData* os_exchange_data) {
+  DCHECK(os_exchange_data);
+  if ((mime_type == kMimeTypeText || mime_type == kMimeTypeTextUTF8)) {
+    DCHECK(!os_exchange_data->HasString());
+    AddStringToOSExchangeData(data, os_exchange_data);
+    return;
+  }
+
+  // TODO(jkim): Handle other mime types as well.
+  NOTREACHED();
+}
+
+}  // namespace
+
 // static
 const wl_callback_listener WaylandDataDevice::callback_listener_ = {
     WaylandDataDevice::SyncCallback,
@@ -16,18 +72,25 @@ const wl_callback_listener WaylandDataDevice::callback_listener_ = {
 
 WaylandDataDevice::WaylandDataDevice(WaylandConnection* connection,
                                      wl_data_device* data_device)
-    : data_device_(data_device), connection_(connection) {
+    : data_device_(data_device),
+      connection_(connection),
+      shared_memory_(new base::SharedMemory()),
+      buffer_(nullptr),
+      icon_surface_(nullptr),
+      icon_buffer_size_(gfx::Size()) {
   static const struct wl_data_device_listener kDataDeviceListener = {
-      WaylandDataDevice::OnDataOffer,
-      nullptr /*OnEnter*/,
-      nullptr /*OnLeave*/,
-      nullptr /*OnMotion*/,
-      nullptr /*OnDrop*/,
-      WaylandDataDevice::OnSelection};
+      WaylandDataDevice::OnDataOffer, WaylandDataDevice::OnEnter,
+      WaylandDataDevice::OnLeave,     WaylandDataDevice::OnMotion,
+      WaylandDataDevice::OnDrop,      WaylandDataDevice::OnSelection};
   wl_data_device_add_listener(data_device_.get(), &kDataDeviceListener, this);
 }
 
-WaylandDataDevice::~WaylandDataDevice() {}
+WaylandDataDevice::~WaylandDataDevice() {
+  if (!shared_memory_->handle().GetHandle())
+    return;
+  shared_memory_->Unmap();
+  shared_memory_->Close();
+}
 
 void WaylandDataDevice::RequestSelectionData(const std::string& mime_type) {
   base::ScopedFD fd = selection_offer_->Receive(mime_type);
@@ -67,6 +130,74 @@ void WaylandDataDevice::ReadDataFromFD(base::ScopedFD fd,
     contents->append(buffer, length);
 }
 
+void WaylandDataDevice::RequestDragData(
+    const std::string& mime_type,
+    base::OnceCallback<void(const std::string&)> callback) {
+  base::ScopedFD fd = drag_offer_->Receive(mime_type);
+  if (!fd.is_valid()) {
+    LOG(ERROR) << "Failed to open file descriptor.";
+    return;
+  }
+
+  // Ensure there is not pending operation to be performed by the compositor,
+  // otherwise read(..) can block awaiting data to be sent to pipe.
+  read_from_fd_closure_ =
+      base::BindOnce(&WaylandDataDevice::ReadDragDataFromFD, base::Unretained(this),
+                     std::move(fd), std::move(callback));
+  RegisterSyncCallback();
+}
+
+void WaylandDataDevice::GetDragData(const std::string& mime_type,
+                                    std::string* buffer) {
+  DCHECK(buffer);
+  DCHECK(source_data_);
+
+  if (mime_type != kMimeTypeText && mime_type != kMimeTypeTextUTF8)
+    return;
+
+  const OSExchangeData::FilenameToURLPolicy policy =
+      OSExchangeData::FilenameToURLPolicy::DO_NOT_CONVERT_FILENAMES;
+  // TODO(jkim): Handle other data format as well.
+  if (source_data_->HasURL(policy)) {
+    GURL url;
+    base::string16 title;
+    source_data_->GetURLAndTitle(policy, &url, &title);
+    buffer->append(url.spec());
+    return;
+  }
+
+  if (source_data_->HasString()) {
+    base::string16 data;
+    source_data_->GetString(&data);
+    buffer->append(base::UTF16ToUTF8(data));
+    return;
+  }
+}
+
+void WaylandDataDevice::StartDrag(const wl_data_source* data_source,
+                                  const ui::OSExchangeData& data) {
+  WaylandWindow* window = connection_->GetCurrentFocusedWindow();
+  if (!window) {
+    LOG(ERROR) << "Failed to get focused window.";
+    return;
+  }
+
+  wl_surface* surface = window->surface();
+  const SkBitmap* icon = data.provider().GetDragImage().bitmap();
+  if (icon && !icon->empty())
+    CreateDragImage(icon);
+
+  source_data_ = std::make_unique<ui::OSExchangeData>(data.provider().Clone());
+  wl_data_device_start_drag(data_device_.get(),
+                            const_cast<wl_data_source*>(data_source), surface,
+                            icon_surface_.get(), connection_->serial());
+  connection_->ScheduleFlush();
+}
+
+void WaylandDataDevice::ResetSourceData() {
+  source_data_.reset();
+}
+
 std::vector<std::string> WaylandDataDevice::GetAvailableMimeTypes() {
   if (selection_offer_)
     return selection_offer_->GetAvailableMimeTypes();
@@ -74,6 +205,21 @@ std::vector<std::string> WaylandDataDevice::GetAvailableMimeTypes() {
   return std::vector<std::string>();
 }
 
+void WaylandDataDevice::ReadDragDataFromFD(
+    base::ScopedFD fd,
+    base::OnceCallback<void(const std::string&)> callback) {
+  std::string contents;
+  ReadDataFromFD(std::move(fd), &contents);
+  std::move(callback).Run(contents);
+}
+
+void WaylandDataDevice::HandleDeferredLeaveIfNeeded() {
+  if (!is_leaving_)
+    return;
+
+  OnLeave(this, data_device_.get());
+}
+
 // static
 void WaylandDataDevice::OnDataOffer(void* data,
                                     wl_data_device* data_device,
@@ -84,6 +230,116 @@ void WaylandDataDevice::OnDataOffer(void* data,
   self->new_offer_.reset(new WaylandDataOffer(offer));
 }
 
+void WaylandDataDevice::OnEnter(void* data,
+                                wl_data_device* data_device,
+                                uint32_t serial,
+                                wl_surface* surface,
+                                wl_fixed_t x,
+                                wl_fixed_t y,
+                                wl_data_offer* offer) {
+  WaylandWindow* window =
+      static_cast<WaylandWindow*>(wl_surface_get_user_data(surface));
+  if (!window) {
+    LOG(ERROR) << "Failed to get window.";
+    return;
+  }
+
+  auto* self = static_cast<WaylandDataDevice*>(data);
+  DCHECK(self->new_offer_);
+  DCHECK(!self->drag_offer_);
+  self->drag_offer_ = std::move(self->new_offer_);
+  self->window_ = window;
+
+  // TODO(jkim): Set mime type the client can accept. Now it sets all mime types
+  // offered because current implementation doesn't decide action based on mime
+  // type.
+  const std::vector<std::string>& mime_types =
+      self->drag_offer_->GetAvailableMimeTypes();
+  for (auto mime : mime_types)
+    self->drag_offer_->Accept(serial, mime);
+
+  std::copy(mime_types.begin(), mime_types.end(),
+            std::insert_iterator<std::list<std::string>>(
+                self->unprocessed_mime_types_,
+                self->unprocessed_mime_types_.begin()));
+
+  int operation = GetOperation(self->drag_offer_->source_actions(),
+                               self->drag_offer_->dnd_action());
+  gfx::PointF point(wl_fixed_to_double(x), wl_fixed_to_double(y));
+
+  // If it has |source_data_|, it means that the dragging is started from the
+  // same window and it doesn't need to read the data through Wayland.
+  if (self->source_data_) {
+    std::unique_ptr<OSExchangeData> data = std::make_unique<OSExchangeData>(
+        self->source_data_->provider().Clone());
+    self->window_->OnDragEnter(point, std::move(data), operation);
+    return;
+  }
+
+  self->window_->OnDragEnter(point, nullptr, operation);
+}
+
+void WaylandDataDevice::OnMotion(void* data,
+                                 wl_data_device* data_device,
+                                 uint32_t time,
+                                 wl_fixed_t x,
+                                 wl_fixed_t y) {
+  auto* self = static_cast<WaylandDataDevice*>(data);
+  if (!self->window_) {
+    LOG(ERROR) << "Failed to get window.";
+    return;
+  }
+
+  int operation = GetOperation(self->drag_offer_->source_actions(),
+                               self->drag_offer_->dnd_action());
+  gfx::PointF point(wl_fixed_to_double(x), wl_fixed_to_double(y));
+  int client_operation = self->window_->OnDragMotion(point, time, operation);
+  self->SetOperation(client_operation);
+}
+
+void WaylandDataDevice::OnDrop(void* data, wl_data_device* data_device) {
+  auto* self = static_cast<WaylandDataDevice*>(data);
+  if (!self->window_) {
+    LOG(ERROR) << "Failed to get window.";
+    return;
+  }
+
+  // Creates buffer to receive data from Wayland.
+  self->received_data_ = std::make_unique<OSExchangeData>(
+      std::make_unique<OSExchangeDataProviderAura>());
+
+  // Starts to read the data on Drop event because read(..) API blocks
+  // awaiting data to be sent to pipe if we try to read the data on OnEnter.
+  // 'Weston' also reads data on OnDrop event and other examples do as well.
+  self->HandleNextMimeType();
+
+  // In order to guarantee all data received, it sets
+  // |is_handling_dropped_data_| and defers OnLeave event handling if it gets
+  // OnLeave event before completing to read the data.
+  self->is_handling_dropped_data_ = true;
+}
+
+void WaylandDataDevice::OnLeave(void* data, wl_data_device* data_device) {
+  // While reading data, it could get OnLeave event. We don't handle OnLeave
+  // event directly if |is_handling_dropped_data_| is set.
+  auto* self = static_cast<WaylandDataDevice*>(data);
+  if (!self->window_) {
+    LOG(ERROR) << "Failed to get window.";
+    return;
+  }
+
+  if (self->is_handling_dropped_data_) {
+    self->is_leaving_ = true;
+    return;
+  }
+
+  self->window_->OnDragLeave();
+  self->window_ = nullptr;
+  self->drag_offer_.reset();
+  self->is_handling_dropped_data_ = false;
+  self->is_leaving_ = false;
+}
+
 // static
 void WaylandDataDevice::OnSelection(void* data,
                                     wl_data_device* data_device,
@@ -118,4 +374,90 @@ void WaylandDataDevice::SyncCallback(void* data,
   data_device->sync_callback_.reset();
 }
 
+void WaylandDataDevice::CreateDragImage(const SkBitmap* bitmap) {
+  DCHECK(bitmap);
+  gfx::Size size(bitmap->width(), bitmap->height());
+  if (!wl::CreateSHMBuffer(size, shared_memory_.get(), connection_->shm()))
+    return;
+
+  if (size != icon_buffer_size_) {
+    wl_buffer* buffer = wl::CreateSHMBuffer(size, shared_memory_.get(), connection_->shm());
+    if (!buffer) {
+      LOG(ERROR) << "Failed to create SHM buffer for the drag icon.";
+      return;
+    }
+    buffer_.reset(buffer);
+    icon_buffer_size_ = size;
+  }
+  wl::DrawBitmapToSHMB(icon_buffer_size_, *shared_memory_, *bitmap);
+
+  icon_surface_.reset(wl_compositor_create_surface(connection_->compositor()));
+  wl_surface_attach(icon_surface_.get(), buffer_.get(), 0, 0);
+  wl_surface_damage(icon_surface_.get(), 0, 0, icon_buffer_size_.width(),
+                    icon_buffer_size_.height());
+  wl_surface_commit(icon_surface_.get());
+}
+
+void WaylandDataDevice::OnDragDataReceived(const std::string& contents) {
+  if (!contents.empty()) {
+    AddToOSExchangeData(contents, unprocessed_mime_types_.front(),
+                        received_data_.get());
+  }
+
+  unprocessed_mime_types_.erase(unprocessed_mime_types_.begin());
+
+  // Read next data corresponding to the mime type.
+  HandleNextMimeType();
+}
+
+void WaylandDataDevice::OnDragDataCollected() {
+  unprocessed_mime_types_.clear();
+  window_->OnDragDrop(std::move(received_data_));
+  drag_offer_->FinishOffer();
+  is_handling_dropped_data_ = false;
+
+  HandleDeferredLeaveIfNeeded();
+}
+
+std::string WaylandDataDevice::SelectNextMimeType() {
+  while (!unprocessed_mime_types_.empty()) {
+    std::string& mime_type = unprocessed_mime_types_.front();
+    if ((mime_type == kMimeTypeText || mime_type == kMimeTypeTextUTF8) &&
+        !received_data_->HasString()) {
+      return mime_type;
+    }
+    // TODO(jkim): Handle other mime types as well.
+    unprocessed_mime_types_.erase(unprocessed_mime_types_.begin());
+  }
+  return std::string();
+}
+
+void WaylandDataDevice::HandleNextMimeType() {
+  std::string mime_type = SelectNextMimeType();
+  if (!mime_type.empty()) {
+    RequestDragData(mime_type,
+                    base::BindOnce(&WaylandDataDevice::OnDragDataReceived,
+                                   base::Unretained(this)));
+  } else {
+    OnDragDataCollected();
+  }
+}
+
+void WaylandDataDevice::SetOperation(const int operation) {
+  uint32_t dnd_actions = WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE;
+  uint32_t preferred_action = WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE;
+
+  if (operation & DragDropTypes::DRAG_COPY) {
+    dnd_actions |= WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY;
+    preferred_action = WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY;
+  }
+
+  if (operation & DragDropTypes::DRAG_MOVE) {
+    dnd_actions |= WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE;
+    if (preferred_action == WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE)
+      preferred_action = WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE;
+  }
+  drag_offer_->SetAction(dnd_actions, preferred_action);
+}
+
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/wayland_data_device.h b/ui/ozone/platform/wayland/wayland_data_device.h
index 3d1eecde15bf6..6563745d9921e 100644
--- a/ui/ozone/platform/wayland/wayland_data_device.h
+++ b/ui/ozone/platform/wayland/wayland_data_device.h
@@ -6,23 +6,36 @@
 #define UI_OZONE_PLATFORM_WAYLAND_WAYLAND_DATA_DEVICE_H_
 
 #include <wayland-client.h>
+#include <list>
 #include <string>
 
 #include "base/callback.h"
 #include "base/files/scoped_file.h"
 #include "base/macros.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "third_party/skia/include/core/SkSurface.h"
+#include "ui/gfx/geometry/size.h"
 #include "ui/ozone/platform/wayland/wayland_data_offer.h"
 #include "ui/ozone/platform/wayland/wayland_object.h"
 
+namespace base {
+class SharedMemory;
+}
+
+namespace gfx {
+class Point;
+}
+
 namespace ui {
 
+class OSExchangeData;
+class OSExchangeDataProviderAura;
 class WaylandDataOffer;
 class WaylandConnection;
+class WaylandWindow;
 
 // This class provides access to inter-client data transfer mechanisms
 // such as copy-and-paste and drag-and-drop mechanisms.
-//
-// TODO(tonikitoo,msisov): Add drag&drop support.
 class WaylandDataDevice {
  public:
   WaylandDataDevice(WaylandConnection* connection, wl_data_device* data_device);
@@ -30,16 +43,44 @@ class WaylandDataDevice {
 
   void RequestSelectionData(const std::string& mime_type);
 
-  wl_data_device* data_device() { return data_device_.get(); }
+  // Requests the data to platform when Chromium is a client for Drag and Drop.
+  // Once reading data from platform is done, |callback| should be called with
+  // the data.
+  void RequestDragData(const std::string& mime_type,
+                       base::OnceCallback<void(const std::string&)> callback);
+  // Gets the data which Chromium has when it is a source for Drag and Drop.
+  // |buffer| is an output parameter and it should be filled with the data
+  // corresponding to mime_type.
+  void GetDragData(const std::string& mime_type, std::string* buffer);
+  // Starts Drag with |data| to be delivered, |operation| supported by the
+  // source side client.
+  void StartDrag(const wl_data_source* data_source,
+                 const ui::OSExchangeData& data);
+  // Resets |source_data_| when the dragging is finished.
+  void ResetSourceData();
 
   std::vector<std::string> GetAvailableMimeTypes();
 
+  wl_data_device* data_device() { return data_device_.get(); }
+
  private:
   void ReadClipboardDataFromFD(base::ScopedFD fd, const std::string& mime_type);
 
   // Registers display sync callback. Once it's called, it's reset.
   void RegisterSyncCallback();
 
+  // Helper function to read data from fd.
+  void ReadDataFromFD(std::string* contents,
+                      base::ScopedFD fd,
+                      const std::string& mime_type);
+
+  void ReadDragDataFromFD(base::ScopedFD fd,
+                    base::OnceCallback<void(const std::string&)> callback);
+
+  // If OnLeave event occurs while it's reading drag data, it defers handling
+  // it. Once reading data is completed, it's handled.
+  void HandleDeferredLeaveIfNeeded();
+
   // Helper function to read data from fd.
   void ReadDataFromFD(base::ScopedFD fd, std::string* contents);
 
@@ -47,6 +88,25 @@ class WaylandDataDevice {
   static void OnDataOffer(void* data,
                           wl_data_device* data_device,
                           wl_data_offer* id);
+
+  static void OnEnter(void* data,
+                      wl_data_device* data_device,
+                      uint32_t serial,
+                      wl_surface* surface,
+                      wl_fixed_t x,
+                      wl_fixed_t y,
+                      wl_data_offer* offer);
+
+  static void OnMotion(void* data,
+                       struct wl_data_device* data_device,
+                       uint32_t time,
+                       wl_fixed_t x,
+                       wl_fixed_t y);
+
+  static void OnDrop(void* data, struct wl_data_device* data_device);
+
+  static void OnLeave(void* data, struct wl_data_device* data_device);
+
   // Called by the compositor when the window gets pointer or keyboard focus,
   // or clipboard content changes behind the scenes.
   //
@@ -57,6 +117,22 @@ class WaylandDataDevice {
 
   static void SyncCallback(void* data, struct wl_callback* cb, uint32_t time);
 
+  bool CreateSHMBuffer(const gfx::Size& size);
+  void CreateDragImage(const SkBitmap* bitmap);
+
+  void OnDragDataReceived(const std::string& contents);
+  void OnDragDataCollected();
+
+  // Returns the next MIME type to be received from the source process, or an
+  // empty string if there are no more interesting MIME types left to process.
+  std::string SelectNextMimeType();
+  // If it has |unprocessed_mime_types_|, it takes the mime type in front and
+  // requests the data corresponding to the mime type to wayland.
+  void HandleNextMimeType();
+
+  // Set drag operation decided by client.
+  void SetOperation(const int operation);
+
   // The wl_data_device wrapped by this WaylandDataDevice.
   wl::Object<wl_data_device> data_device_;
 
@@ -75,11 +151,36 @@ class WaylandDataDevice {
   // clipboard data is available.
   std::unique_ptr<WaylandDataOffer> selection_offer_;
 
+  // Offer to receive data from another process via drag-and-drop, or null if no
+  // drag-and-drop from another process is in progress.
+  std::unique_ptr<WaylandDataOffer> drag_offer_;
+
+  WaylandWindow* window_ = nullptr;
+
   // Make sure server has written data on the pipe, before block on read().
   static const wl_callback_listener callback_listener_;
   base::OnceClosure read_from_fd_closure_;
   wl::Object<wl_callback> sync_callback_;
 
+  bool is_handling_dropped_data_ = false;
+  bool is_leaving_ = false;
+
+  std::unique_ptr<base::SharedMemory> shared_memory_;
+
+  wl::Object<wl_buffer> buffer_;
+  wl::Object<wl_surface> icon_surface_;
+  gfx::Size icon_buffer_size_;
+
+  // Mime types to be handled.
+  std::list<std::string> unprocessed_mime_types_;
+
+  // The data delivered from Wayland
+  std::unique_ptr<ui::OSExchangeData> received_data_;
+
+  // When Dragging is started from Chromium, |source_data_| is forwarded to
+  // Wayland when they are ready to get the data.
+  std::unique_ptr<ui::OSExchangeData> source_data_;
+
   DISALLOW_COPY_AND_ASSIGN(WaylandDataDevice);
 };
 
diff --git a/ui/ozone/platform/wayland/wayland_data_device_unittest.cc b/ui/ozone/platform/wayland/wayland_data_device_unittest.cc
index 03c567e1bc4e1..7129f21b629a8 100644
--- a/ui/ozone/platform/wayland/wayland_data_device_unittest.cc
+++ b/ui/ozone/platform/wayland/wayland_data_device_unittest.cc
@@ -5,6 +5,9 @@
 #include <wayland-server.h>
 
 #include "testing/gtest/include/gtest/gtest.h"
+#include "ui/base/dragdrop/drag_drop_types.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/events/base_event_utils.h"
 #include "ui/ozone/platform/wayland/fake_server.h"
 #include "ui/ozone/platform/wayland/wayland_test.h"
 #include "ui/ozone/public/clipboard_delegate.h"
@@ -131,6 +134,64 @@ TEST_P(WaylandDataDeviceManagerTest, IsSelectionOwner) {
   ASSERT_FALSE(clipboard_client_->IsSelectionOwner());
 }
 
+TEST_P(WaylandDataDeviceManagerTest, StartDrag) {
+  bool restored_focus = window_->has_pointer_focus();
+  window_->set_pointer_focus(true);
+
+  // The client starts dragging.
+  std::unique_ptr<OSExchangeData> os_exchange_data =
+      std::make_unique<OSExchangeData>();
+  int operation = DragDropTypes::DRAG_COPY | DragDropTypes::DRAG_MOVE;
+  connection_->StartDrag(*(os_exchange_data.get()), operation);
+
+  WaylandDataSource::DragDataMap data;
+  data[wl::kTextMimeTypeText] = wl::kSampleTextForDragAndDrop;
+  connection_->drag_data_source()->SetDragData(data);
+
+  Sync();
+  // The server reads the data and the callback gets it.
+  data_device_manager_->data_source()->ReadData(
+      base::BindOnce([](const std::vector<uint8_t>& data) {
+        std::string string_data(data.begin(), data.end());
+        EXPECT_EQ(wl::kSampleTextForDragAndDrop, string_data);
+      }));
+
+  window_->set_pointer_focus(restored_focus);
+}
+
+TEST_P(WaylandDataDeviceManagerTest, ReceiveDrag) {
+  auto* data_offer = data_device_manager_->data_device()->OnDataOffer();
+  data_offer->OnOffer(wl::kTextMimeTypeText);
+
+  gfx::Point entered_point(10, 10);
+  // The server sends an enter event.
+  data_device_manager_->data_device()->OnEnter(
+      1002, surface_->resource(), wl_fixed_from_int(entered_point.x()),
+      wl_fixed_from_int(entered_point.y()), *data_offer);
+
+  int64_t time =
+      (ui::EventTimeForNow() - base::TimeTicks()).InMilliseconds() & UINT32_MAX;
+  gfx::Point motion_point(11, 11);
+
+  // The server sends an motion event.
+  data_device_manager_->data_device()->OnMotion(
+      time, wl_fixed_from_int(motion_point.x()),
+      wl_fixed_from_int(motion_point.y()));
+
+  Sync();
+
+  auto callback = base::BindOnce([](const std::string& contents) {
+    EXPECT_EQ(wl::kSampleTextForDragAndDrop, contents);
+  });
+
+  // The client requests the data and gets callback with it.
+  connection_->RequestDragData(wl::kTextMimeTypeText, std::move(callback));
+  Sync();
+
+  EXPECT_CALL(delegate_, OnDragLeave());
+  data_device_manager_->data_device()->OnLeave();
+}
+
 INSTANTIATE_TEST_CASE_P(XdgVersionV5Test,
                         WaylandDataDeviceManagerTest,
                         ::testing::Values(kXdgShellV5));
diff --git a/ui/ozone/platform/wayland/wayland_data_offer.cc b/ui/ozone/platform/wayland/wayland_data_offer.cc
index 01e7c660c4778..33fabce8f87b3 100644
--- a/ui/ozone/platform/wayland/wayland_data_offer.cc
+++ b/ui/ozone/platform/wayland/wayland_data_offer.cc
@@ -29,9 +29,12 @@ void CreatePipe(base::ScopedFD* read_pipe, base::ScopedFD* write_pipe) {
 }  // namespace
 
 WaylandDataOffer::WaylandDataOffer(wl_data_offer* data_offer)
-    : data_offer_(data_offer) {
+    : data_offer_(data_offer),
+      source_actions_(WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE),
+      dnd_action_(WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE) {
   static const struct wl_data_offer_listener kDataOfferListener = {
-      WaylandDataOffer::OnOffer};
+      WaylandDataOffer::OnOffer, WaylandDataOffer::OnSourceAction,
+      WaylandDataOffer::OnAction};
   wl_data_offer_add_listener(data_offer, &kDataOfferListener, this);
 }
 
@@ -39,6 +42,23 @@ WaylandDataOffer::~WaylandDataOffer() {
   data_offer_.reset();
 }
 
+void WaylandDataOffer::SetAction(uint32_t dnd_actions,
+                                 uint32_t preferred_action) {
+  if (wl_data_offer_get_version(data_offer_.get()) >=
+      WL_DATA_OFFER_SET_ACTIONS_SINCE_VERSION) {
+    wl_data_offer_set_actions(data_offer_.get(), dnd_actions, preferred_action);
+  }
+}
+
+void WaylandDataOffer::Accept(uint32_t serial, const std::string& mime_type) {
+  wl_data_offer_accept(data_offer_.get(), serial, mime_type.c_str());
+}
+
+void WaylandDataOffer::Reject(uint32_t serial) {
+  // Passing a null MIME type means "reject."
+  wl_data_offer_accept(data_offer_.get(), serial, nullptr);
+}
+
 void WaylandDataOffer::EnsureTextMimeTypeIfNeeded() {
   if (std::find(mime_types_.begin(), mime_types_.end(), kTextPlain) !=
       mime_types_.end())
@@ -77,6 +97,20 @@ base::ScopedFD WaylandDataOffer::Receive(const std::string& mime_type) {
   return read_fd;
 }
 
+void WaylandDataOffer::FinishOffer() {
+  if (wl_data_offer_get_version(data_offer_.get()) >=
+      WL_DATA_OFFER_FINISH_SINCE_VERSION)
+    wl_data_offer_finish(data_offer_.get());
+}
+
+uint32_t WaylandDataOffer::source_actions() {
+  return source_actions_;
+}
+
+uint32_t WaylandDataOffer::dnd_action() {
+  return dnd_action_;
+}
+
 // static
 void WaylandDataOffer::OnOffer(void* data,
                                wl_data_offer* data_offer,
@@ -85,4 +119,18 @@ void WaylandDataOffer::OnOffer(void* data,
   self->mime_types_.push_back(mime_type);
 }
 
+void WaylandDataOffer::OnSourceAction(void* data,
+                                      wl_data_offer* offer,
+                                      uint32_t source_actions) {
+  auto* self = static_cast<WaylandDataOffer*>(data);
+  self->source_actions_ = source_actions;
+}
+
+void WaylandDataOffer::OnAction(void* data,
+                                wl_data_offer* offer,
+                                uint32_t dnd_action) {
+  auto* self = static_cast<WaylandDataOffer*>(data);
+  self->dnd_action_ = dnd_action;
+}
+
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/wayland_data_offer.h b/ui/ozone/platform/wayland/wayland_data_offer.h
index 3b9e06f23c207..ac575995d9f8d 100644
--- a/ui/ozone/platform/wayland/wayland_data_offer.h
+++ b/ui/ozone/platform/wayland/wayland_data_offer.h
@@ -23,8 +23,6 @@ namespace ui {
 // The offer describes the different mime types that the data can be
 // converted to and provides the mechanism for transferring the data
 // directly from the source client.
-//
-// TODO(tonikitoo,msisov): Add drag&drop support.
 class WaylandDataOffer {
  public:
   // Takes ownership of data_offer.
@@ -42,20 +40,36 @@ class WaylandDataOffer {
   // list of provided mime types so that Chrome clipboard's machinery
   // works fine.
   void EnsureTextMimeTypeIfNeeded();
+  void SetAction(uint32_t dnd_actions, uint32_t preferred_action);
+  void Accept(uint32_t serial, const std::string& mime_type);
+  void Reject(uint32_t serial);
 
   // Creates a pipe (read & write FDs), passing the write-end of to pipe
   // to the compositor (via wl_data_offer_receive) and returning the
   // read-end to the pipe.
   base::ScopedFD Receive(const std::string& mime_type);
+  void FinishOffer();
+  uint32_t source_actions();
+  uint32_t dnd_action();
 
  private:
   // wl_data_offer_listener callbacks.
   static void OnOffer(void* data,
                       wl_data_offer* data_offer,
                       const char* mime_type);
+  // Notifies the source-side available actions
+  static void OnSourceAction(void* data,
+                             wl_data_offer* offer,
+                             uint32_t source_actions);
+  // Notifies the selected action
+  static void OnAction(void* data, wl_data_offer* offer, uint32_t dnd_action);
 
   wl::Object<wl_data_offer> data_offer_;
   std::vector<std::string> mime_types_;
+  // Actions offered by the data source
+  uint32_t source_actions_;
+  // Action selected by the compositor
+  uint32_t dnd_action_;
 
   bool text_plain_mime_type_inserted_ = false;
 
diff --git a/ui/ozone/platform/wayland/wayland_data_source.cc b/ui/ozone/platform/wayland/wayland_data_source.cc
index 7b61ad24c02fe..5fe15166150f2 100644
--- a/ui/ozone/platform/wayland/wayland_data_source.cc
+++ b/ui/ozone/platform/wayland/wayland_data_source.cc
@@ -5,17 +5,22 @@
 #include "ui/ozone/platform/wayland/wayland_data_source.h"
 
 #include "base/files/file_util.h"
+#include "ui/base/dragdrop/drag_drop_types.h"
 #include "ui/ozone/platform/wayland/wayland_connection.h"
+#include "ui/ozone/platform/wayland/wayland_window.h"
 
 namespace ui {
 
+constexpr char kTextMimeType[] = "text/plain";
 constexpr char kTextMimeTypeUtf8[] = "text/plain;charset=utf-8";
 
-WaylandDataSource::WaylandDataSource(wl_data_source* data_source)
-    : data_source_(data_source) {
+WaylandDataSource::WaylandDataSource(wl_data_source* data_source,
+                                     WaylandConnection* connection)
+    : data_source_(data_source), connection_(connection) {
   static const struct wl_data_source_listener kDataSourceListener = {
-      WaylandDataSource::OnTarget, WaylandDataSource::OnSend,
-      WaylandDataSource::OnCancel};
+      WaylandDataSource::OnTarget,      WaylandDataSource::OnSend,
+      WaylandDataSource::OnCancel,      WaylandDataSource::OnDnDDropPerformed,
+      WaylandDataSource::OnDnDFinished, WaylandDataSource::OnAction};
   wl_data_source_add_listener(data_source, &kDataSourceListener, this);
 }
 
@@ -25,7 +30,7 @@ void WaylandDataSource::WriteToClipboard(
     const ClipboardDelegate::DataMap& data_map) {
   for (const auto& data : data_map) {
     wl_data_source_offer(data_source_.get(), data.first.c_str());
-    if (strcmp(data.first.c_str(), "text/plain") == 0)
+    if (strcmp(data.first.c_str(), kTextMimeType) == 0)
       wl_data_source_offer(data_source_.get(), kTextMimeTypeUtf8);
   }
   wl_data_device_set_selection(connection_->data_device(), data_source_.get(),
@@ -39,11 +44,38 @@ void WaylandDataSource::UpdataDataMap(
   data_map_ = data_map;
 }
 
+void WaylandDataSource::Offer(const ui::OSExchangeData& data) {
+  // TODO(jkim): Handle mime types based on data.
+  std::vector<std::string> mime_types;
+  mime_types.push_back(kTextMimeType);
+  mime_types.push_back(kTextMimeTypeUtf8);
+
+  source_window_ = connection_->GetCurrentFocusedWindow();
+  for (auto mime_type : mime_types)
+    wl_data_source_offer(data_source_.get(), mime_type.data());
+}
+
+void WaylandDataSource::SetDragData(const DragDataMap& data_map) {
+  drag_data_map_ = data_map;
+}
+
+void WaylandDataSource::SetAction(int operation) {
+  if (wl_data_source_get_version(data_source_.get()) >=
+      WL_DATA_SOURCE_SET_ACTIONS_SINCE_VERSION) {
+    uint32_t dnd_actions = WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE;
+    if (operation & DragDropTypes::DRAG_COPY)
+      dnd_actions |= WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY;
+    if (operation & DragDropTypes::DRAG_MOVE)
+      dnd_actions |= WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE;
+    wl_data_source_set_actions(data_source_.get(), dnd_actions);
+  }
+}
+
 // static
 void WaylandDataSource::OnTarget(void* data,
                                  wl_data_source* source,
                                  const char* mime_type) {
-  NOTIMPLEMENTED();
+  NOTIMPLEMENTED_LOG_ONCE();
 }
 
 // static
@@ -52,12 +84,18 @@ void WaylandDataSource::OnSend(void* data,
                                const char* mime_type,
                                int32_t fd) {
   WaylandDataSource* self = static_cast<WaylandDataSource*>(data);
-  base::Optional<std::vector<uint8_t>> mime_data;
-  self->GetClipboardData(mime_type, &mime_data);
-  if (!mime_data.has_value() && strcmp(mime_type, kTextMimeTypeUtf8) == 0)
-    self->GetClipboardData("text/plain", &mime_data);
-
-  std::string contents(mime_data->begin(), mime_data->end());
+  std::string contents;
+  if (self->source_window_) {
+    // If |source_window_| is valid when OnSend() is called, it means that DnD
+    // is working.
+    self->GetDragData(mime_type, &contents);
+  } else {
+    base::Optional<std::vector<uint8_t>> mime_data;
+    self->GetClipboardData(mime_type, &mime_data);
+    if (!mime_data.has_value() && strcmp(mime_type, kTextMimeTypeUtf8) == 0)
+      self->GetClipboardData(kTextMimeType, &mime_data);
+    contents.assign(mime_data->begin(), mime_data->end());
+  }
   bool result =
       base::WriteFileDescriptor(fd, contents.data(), contents.length());
   DCHECK(result);
@@ -67,7 +105,30 @@ void WaylandDataSource::OnSend(void* data,
 // static
 void WaylandDataSource::OnCancel(void* data, wl_data_source* source) {
   WaylandDataSource* self = static_cast<WaylandDataSource*>(data);
-  self->connection_->DataSourceCancelled();
+  if (self->source_window_) {
+    // If it has |source_window_|, it is in the middle of 'drag and drop'. it
+    // cancels 'drag and drop'.
+    self->connection_->FinishDragSession(self->dnd_action_,
+                                         self->source_window_);
+  } else {
+    self->connection_->DataSourceCancelled();
+  }
+}
+
+void WaylandDataSource::OnDnDDropPerformed(void* data, wl_data_source* source) {
+  NOTIMPLEMENTED_LOG_ONCE();
+}
+
+void WaylandDataSource::OnDnDFinished(void* data, wl_data_source* source) {
+  WaylandDataSource* self = static_cast<WaylandDataSource*>(data);
+  self->connection_->FinishDragSession(self->dnd_action_, self->source_window_);
+}
+
+void WaylandDataSource::OnAction(void* data,
+                                 wl_data_source* source,
+                                 uint32_t dnd_action) {
+  WaylandDataSource* self = static_cast<WaylandDataSource*>(data);
+  self->dnd_action_ = dnd_action;
 }
 
 void WaylandDataSource::GetClipboardData(
@@ -81,4 +142,15 @@ void WaylandDataSource::GetClipboardData(
   }
 }
 
+void WaylandDataSource::GetDragData(const std::string& mime_type,
+                                    std::string* contents) {
+  auto it = drag_data_map_.find(mime_type);
+  if (it != drag_data_map_.end()) {
+    *contents = it->second;
+    return;
+  }
+
+  connection_->GetDragData(mime_type, contents);
+}
+
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/wayland_data_source.h b/ui/ozone/platform/wayland/wayland_data_source.h
index 9ee33971a9386..109eb8d0103f3 100644
--- a/ui/ozone/platform/wayland/wayland_data_source.h
+++ b/ui/ozone/platform/wayland/wayland_data_source.h
@@ -19,7 +19,9 @@
 
 namespace ui {
 
+class OSExchangeData;
 class WaylandConnection;
+class WaylandWindow;
 
 // The WaylandDataSource object represents the source side of a
 // WaylandDataOffer. It is created by the source client in a data
@@ -28,8 +30,11 @@ class WaylandConnection;
 // transfer the data (OnSend listener).
 class WaylandDataSource {
  public:
+  using DragDataMap = std::unordered_map<std::string, std::string>;
+
   // Takes ownership of data_source.
-  explicit WaylandDataSource(wl_data_source* data_source);
+  explicit WaylandDataSource(wl_data_source* data_source,
+                             WaylandConnection* connection);
   ~WaylandDataSource();
 
   void set_connection(WaylandConnection* connection) {
@@ -39,6 +44,11 @@ class WaylandDataSource {
 
   void WriteToClipboard(const ClipboardDelegate::DataMap& data_map);
   void UpdataDataMap(const ClipboardDelegate::DataMap& data_map);
+  void Offer(const ui::OSExchangeData& data);
+  void SetAction(int operation);
+  void SetDragData(const DragDataMap& data_map);
+
+  const wl_data_source* data_source() { return data_source_.get(); }
 
  private:
   static void OnTarget(void* data,
@@ -49,14 +59,22 @@ class WaylandDataSource {
                      const char* mime_type,
                      int32_t fd);
   static void OnCancel(void* data, wl_data_source* source);
+  static void OnDnDDropPerformed(void* data, wl_data_source* source);
+  static void OnDnDFinished(void* data, wl_data_source* source);
+  static void OnAction(void* data, wl_data_source* source, uint32_t dnd_action);
 
   void GetClipboardData(const std::string& mime_type,
                         base::Optional<std::vector<uint8_t>>* data);
+  void GetDragData(const std::string& mime_type, std::string* contents);
 
   wl::Object<wl_data_source> data_source_;
   WaylandConnection* connection_ = nullptr;
+  WaylandWindow* source_window_ = nullptr;
 
   ClipboardDelegate::DataMap data_map_;
+  DragDataMap drag_data_map_;
+  // Action selected by the compositor
+  uint32_t dnd_action_;
 
   DISALLOW_COPY_AND_ASSIGN(WaylandDataSource);
 };
diff --git a/ui/ozone/platform/wayland/wayland_object.cc b/ui/ozone/platform/wayland/wayland_object.cc
index 9292a279cd1fb..54265129a0ac1 100644
--- a/ui/ozone/platform/wayland/wayland_object.cc
+++ b/ui/ozone/platform/wayland/wayland_object.cc
@@ -41,6 +41,15 @@ void delete_touch(wl_touch* touch) {
     wl_touch_destroy(touch);
 }
 
+void delete_data_device(wl_data_device* data_device) {
+  if (wl_data_device_get_version(data_device) >=
+      WL_DATA_DEVICE_RELEASE_SINCE_VERSION) {
+    wl_data_device_release(data_device);
+  } else {
+    wl_data_device_destroy(data_device);
+  }
+}
+
 }  // namespace
 
 const wl_interface* ObjectTraits<wl_buffer>::interface = &wl_buffer_interface;
@@ -63,7 +72,7 @@ void (*ObjectTraits<wl_data_device_manager>::deleter)(wl_data_device_manager*) =
 const wl_interface* ObjectTraits<wl_data_device>::interface =
     &wl_data_device_interface;
 void (*ObjectTraits<wl_data_device>::deleter)(wl_data_device*) =
-    &wl_data_device_destroy;
+    &delete_data_device;
 
 const wl_interface* ObjectTraits<wl_data_offer>::interface =
     &wl_data_offer_interface;
diff --git a/ui/ozone/platform/wayland/wayland_window.cc b/ui/ozone/platform/wayland/wayland_window.cc
index 990d3cb90a20d..f845626078a0e 100644
--- a/ui/ozone/platform/wayland/wayland_window.cc
+++ b/ui/ozone/platform/wayland/wayland_window.cc
@@ -8,6 +8,7 @@
 
 #include "base/bind.h"
 #include "ui/base/cursor/ozone/bitmap_cursor_factory_ozone.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
 #include "ui/base/hit_test.h"
 #include "ui/events/event.h"
 #include "ui/events/event_utils.h"
@@ -402,6 +403,12 @@ void WaylandWindow::StartWindowMoveOrResize(int hittest,
     xdg_surface_->SurfaceResize(connection_, hittest);
 }
 
+void WaylandWindow::StartDrag(const ui::OSExchangeData& data,
+                              const int operation,
+                              gfx::NativeCursor cursor) {
+  connection_->StartDrag(data, operation);
+}
+
 bool WaylandWindow::RunMoveLoop(const gfx::Vector2d& drag_offset) {
   return true;
 }
@@ -532,6 +539,31 @@ void WaylandWindow::OnCloseRequest() {
   delegate_->OnCloseRequest();
 }
 
+void WaylandWindow::OnDragEnter(const gfx::PointF& point,
+                                std::unique_ptr<OSExchangeData> data,
+                                int operation) {
+  delegate_->OnDragEnter(this, point, std::move(data), operation);
+}
+
+int WaylandWindow::OnDragMotion(const gfx::PointF& point,
+                                uint32_t time,
+                                int operation) {
+  gfx::AcceleratedWidget widget = gfx::kNullAcceleratedWidget;
+  return delegate_->OnDragMotion(point, time, operation, &widget);
+}
+
+void WaylandWindow::OnDragDrop(std::unique_ptr<OSExchangeData> data) {
+  delegate_->OnDragDrop(std::move(data));
+}
+
+void WaylandWindow::OnDragLeave() {
+  delegate_->OnDragLeave();
+}
+
+void WaylandWindow::OnDragSessionClose(uint32_t dnd_action) {
+  delegate_->OnDragSessionClose(dnd_action);
+}
+
 bool WaylandWindow::IsMinimized() const {
   return state_ == PlatformWindowState::PLATFORM_WINDOW_STATE_MINIMIZED;
 }
diff --git a/ui/ozone/platform/wayland/wayland_window.h b/ui/ozone/platform/wayland/wayland_window.h
index 77b83f62c6f18..c1bebce11a500 100644
--- a/ui/ozone/platform/wayland/wayland_window.h
+++ b/ui/ozone/platform/wayland/wayland_window.h
@@ -16,6 +16,7 @@
 namespace ui {
 
 class BitmapCursorOzone;
+class OSExchangeData;
 class PlatformWindowDelegate;
 class WaylandConnection;
 class XDGPopupWrapper;
@@ -92,6 +93,9 @@ class WaylandWindow : public PlatformWindow, public PlatformEventDispatcher {
   gfx::Rect GetRestoredBoundsInPixels() const override;
   void StartWindowMoveOrResize(int hittest,
                                gfx::Point pointer_location) override;
+  void StartDrag(const ui::OSExchangeData& data,
+                 const int operation,
+                 gfx::NativeCursor cursor) override;
   bool RunMoveLoop(const gfx::Vector2d& drag_offset) override;
   void StopMoveLoop() override;
 
@@ -107,6 +111,14 @@ class WaylandWindow : public PlatformWindow, public PlatformEventDispatcher {
 
   void OnCloseRequest();
 
+  void OnDragEnter(const gfx::PointF& point,
+                   std::unique_ptr<OSExchangeData> data,
+                   int operation);
+  int OnDragMotion(const gfx::PointF& point, uint32_t time, int operation);
+  void OnDragDrop(std::unique_ptr<OSExchangeData> data);
+  void OnDragLeave();
+  void OnDragSessionClose(uint32_t dnd_action);
+
  private:
   bool IsMinimized() const;
   bool IsMaximized() const;
diff --git a/ui/ozone/test/mock_platform_window_delegate.cc b/ui/ozone/test/mock_platform_window_delegate.cc
index ceab1932f5bb5..d3f9238173c15 100644
--- a/ui/ozone/test/mock_platform_window_delegate.cc
+++ b/ui/ozone/test/mock_platform_window_delegate.cc
@@ -10,4 +10,11 @@ MockPlatformWindowDelegate::MockPlatformWindowDelegate() {}
 
 MockPlatformWindowDelegate::~MockPlatformWindowDelegate() {}
 
+int MockPlatformWindowDelegate::OnDragMotion(const gfx::PointF& point,
+                                             uint32_t time,
+                                             int operation,
+                                             gfx::AcceleratedWidget* widget) {
+  return 0;
+}
+
 }  // namespace ui
diff --git a/ui/ozone/test/mock_platform_window_delegate.h b/ui/ozone/test/mock_platform_window_delegate.h
index 8ace6bb106bf8..bc690785ee9f4 100644
--- a/ui/ozone/test/mock_platform_window_delegate.h
+++ b/ui/ozone/test/mock_platform_window_delegate.h
@@ -6,6 +6,7 @@
 #define UI_OZONE_TEST_MOCK_PLATFORM_WINDOW_DELEGATE_H_
 
 #include "testing/gmock/include/gmock/gmock.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
 #include "ui/gfx/geometry/rect.h"
 #include "ui/platform_window/platform_window_delegate.h"
 
@@ -28,6 +29,21 @@ class MockPlatformWindowDelegate : public PlatformWindowDelegate {
   MOCK_METHOD0(OnAcceleratedWidgetDestroyed, void());
   MOCK_METHOD1(OnActivationChanged, void(bool active));
 
+  void OnDragEnter(ui::PlatformWindow* window,
+                   const gfx::PointF& point,
+                   std::unique_ptr<OSExchangeData> data,
+                   int operation) override {}
+
+  int OnDragMotion(const gfx::PointF& point,
+                   uint32_t time,
+                   int operation,
+                   gfx::AcceleratedWidget* widget) override;
+  MOCK_METHOD1(OnDragDrop, void(std::unique_ptr<OSExchangeData> data));
+  MOCK_METHOD0(OnDragLeave, void());
+  MOCK_METHOD2(OnMouseMoved,
+               void(const gfx::Point& point, gfx::AcceleratedWidget* widget));
+  MOCK_METHOD1(OnDragSessionClose, void(int operation));
+
  private:
   DISALLOW_COPY_AND_ASSIGN(MockPlatformWindowDelegate);
 };
diff --git a/ui/platform_window/platform_window.h b/ui/platform_window/platform_window.h
index c5f7ed9fc7808..de7ef503ef0fb 100644
--- a/ui/platform_window/platform_window.h
+++ b/ui/platform_window/platform_window.h
@@ -18,6 +18,7 @@ class Rect;
 
 namespace ui {
 
+class OSExchangeData;
 class PlatformImeController;
 
 // Platform window.
@@ -76,6 +77,12 @@ class PlatformWindow {
   virtual void StartWindowMoveOrResize(int hittest,
                                        gfx::Point pointer_location) = 0;
 
+  // TODO(jkim): Make pure virtual functions.
+  // Initiates Drag Action.
+  virtual void StartDrag(const ui::OSExchangeData& data,
+                         const int operation,
+                         gfx::NativeCursor cursor) {}
+
   // Asks to window move client to start move loop.
   virtual bool RunMoveLoop(const gfx::Vector2d& drag_offset) = 0;
 
diff --git a/ui/platform_window/platform_window_delegate.h b/ui/platform_window/platform_window_delegate.h
index bf8b46b61ee15..b7705fd97436c 100644
--- a/ui/platform_window/platform_window_delegate.h
+++ b/ui/platform_window/platform_window_delegate.h
@@ -5,15 +5,19 @@
 #ifndef UI_PLATFORM_WINDOW_PLATFORM_WINDOW_DELEGATE_H_
 #define UI_PLATFORM_WINDOW_PLATFORM_WINDOW_DELEGATE_H_
 
+#include "base/callback.h"
 #include "ui/gfx/native_widget_types.h"
 
 namespace gfx {
 class Rect;
+class PointF;
 }
 
 namespace ui {
 
 class Event;
+class PlatformWindow;
+class OSExchangeData;
 
 enum PlatformWindowState {
   PLATFORM_WINDOW_STATE_UNKNOWN,
@@ -51,6 +55,37 @@ class PlatformWindowDelegate {
   virtual void OnAcceleratedWidgetDestroyed() = 0;
 
   virtual void OnActivationChanged(bool active) = 0;
+
+  // TODO(jkim): Make them pure virtual functions.
+  // Notifies the delegate that dragging is entered to |window|.
+  virtual void OnDragEnter(ui::PlatformWindow* window,
+                           const gfx::PointF& point,
+                           std::unique_ptr<OSExchangeData> data,
+                           int operation) {}
+
+  // Notifies the delegate that dragging is moved. |widget| will be set with the
+  // widget located at |point|. It returns the operation selected by client.
+  virtual int OnDragMotion(const gfx::PointF& point,
+                           uint32_t time,
+                           int operation,
+                           gfx::AcceleratedWidget* widget) = 0;
+
+  // Notifies the delegate that dragged data is dropped. When it doesn't deliver
+  // the dragged data on OnDragEnter, it should put it to |data|.
+  virtual void OnDragDrop(std::unique_ptr<ui::OSExchangeData> data) {}
+
+  // Notifies the delegate that dragging is left.
+  virtual void OnDragLeave() {}
+
+  // Notifies the delegate that mouse is moved generally and expects that
+  // |widget| is filled with the widget located at |point|.
+  virtual void OnMouseMoved(const gfx::Point& point,
+                            gfx::AcceleratedWidget* widget) {}
+
+  // Notifies the delegate that Drag and Drop is completed or canceled and the
+  // session is finished. If Drag and Drop is completed, |operation| has the
+  // result operation.
+  virtual void OnDragSessionClose(int operation) {}
 };
 
 }  // namespace ui
diff --git a/ui/views/BUILD.gn b/ui/views/BUILD.gn
index 329662263397c..ac20fdb1e38f3 100644
--- a/ui/views/BUILD.gn
+++ b/ui/views/BUILD.gn
@@ -704,8 +704,14 @@ jumbo_component("views") {
         ]
         deps += [ "//ui/events:dom_keyboard_layout" ]
       } else if (use_ozone) {
-        public += [ "widget/desktop_aura/desktop_screen_ozone.h" ]
-        sources += [ "widget/desktop_aura/desktop_screen_ozone.cc" ]
+        public += [
+          "widget/desktop_aura/desktop_drag_drop_client_ozone.h",
+          "widget/desktop_aura/desktop_screen_ozone.h"
+        ]
+        sources += [
+          "widget/desktop_aura/desktop_drag_drop_client_ozone.cc",
+          "widget/desktop_aura/desktop_screen_ozone.cc"
+        ]
       }
       if (is_linux) {
         sources += [
diff --git a/ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone.cc b/ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone.cc
new file mode 100644
index 0000000000000..bf99d447451c3
--- /dev/null
+++ b/ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone.cc
@@ -0,0 +1,258 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone.h"
+
+#include "base/run_loop.h"
+#include "base/strings/string16.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "ui/aura/client/capture_client.h"
+#include "ui/aura/client/cursor_client.h"
+#include "ui/aura/window.h"
+#include "ui/aura/window_tree_host.h"
+#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/dragdrop/drag_drop_types.h"
+#include "ui/base/dragdrop/drop_target_event.h"
+#include "ui/base/dragdrop/os_exchange_data_provider_aura.h"
+#include "ui/platform_window/platform_window.h"
+#include "ui/views/widget/desktop_aura/desktop_native_cursor_manager.h"
+
+namespace views {
+
+namespace {
+
+aura::Window* GetTargetWindow(aura::Window* root_window, const gfx::Point& point) {
+  gfx::Point root_location(point);
+
+  root_window->GetHost()->ConvertScreenInPixelsToDIP(&root_location);
+  return root_window->GetEventHandlerForPoint(root_location);
+}
+
+}  // namespace
+
+DesktopDragDropClientOzone::DesktopDragDropClientOzone(
+    aura::Window* root_window,
+    views::DesktopNativeCursorManager* cursor_manager,
+    ui::PlatformWindow* platform_window,
+    gfx::AcceleratedWidget widget)
+    : root_window_(root_window),
+      cursor_manager_(cursor_manager),
+      platform_window_(platform_window),
+      target_window_(nullptr),
+      delegate_(nullptr),
+      os_exchange_data_(nullptr) {}
+
+DesktopDragDropClientOzone::~DesktopDragDropClientOzone() = default;
+
+int DesktopDragDropClientOzone::StartDragAndDrop(
+    const ui::OSExchangeData& data,
+    aura::Window* root_window,
+    aura::Window* source_window,
+    const gfx::Point& root_location,
+    int operation,
+    ui::DragDropTypes::DragEventSource source) {
+
+  base::RunLoop run_loop(base::RunLoop::Type::kNestableTasksAllowed);
+  quit_closure_ = run_loop.QuitClosure();
+
+  // Chrome expects starting drag and drop to release capture.
+  aura::Window* capture_window =
+      aura::client::GetCaptureClient(root_window)->GetGlobalCaptureWindow();
+  if (capture_window)
+    capture_window->ReleaseCapture();
+
+  aura::client::CursorClient* cursor_client =
+      aura::client::GetCursorClient(root_window);
+
+  initial_cursor_ = source_window->GetHost()->last_cursor();
+  drag_operation_ = operation;
+  cursor_client->SetCursor(
+      cursor_manager_->GetInitializedCursor(ui::CursorType::kGrabbing));
+
+  platform_window_->StartDrag(data, operation, cursor_client->GetCursor());
+  in_move_loop_ = true;
+  run_loop.Run();
+  return drag_operation_;
+}
+
+void DesktopDragDropClientOzone::DragCancel() {
+  QuitClosure();
+  DragDropSessionCompleted();
+}
+
+bool DesktopDragDropClientOzone::IsDragDropInProgress() {
+  return in_move_loop_;
+}
+
+void DesktopDragDropClientOzone::AddObserver(
+    aura::client::DragDropClientObserver* observer) {
+  NOTIMPLEMENTED();
+}
+
+void DesktopDragDropClientOzone::RemoveObserver(
+    aura::client::DragDropClientObserver* observer) {
+  NOTIMPLEMENTED();
+}
+
+void DesktopDragDropClientOzone::OnWindowDestroying(aura::Window* window) {
+  DCHECK_EQ(target_window_, window);
+  target_window_->RemoveObserver(this);
+  target_window_ = nullptr;
+}
+
+void DesktopDragDropClientOzone::OnDragEnter(
+    ui::PlatformWindow* window,
+    const gfx::PointF& point,
+    std::unique_ptr<ui::OSExchangeData> data,
+    int operation) {
+  DCHECK(window);
+
+  point_ = point;
+  drag_operation_ = operation;
+  UpdateTargetWindowAndDelegate(point_);
+
+  if (!data)
+    return;
+
+  os_exchange_data_ = std::move(data);
+
+  std::unique_ptr<ui::DropTargetEvent> event = CreateDropTargetEvent();
+  if (delegate_ && event)
+    delegate_->OnDragEntered(*event);
+}
+
+void DesktopDragDropClientOzone::OnDragLeave() {
+  if (delegate_)
+    delegate_->OnDragExited();
+}
+
+int DesktopDragDropClientOzone::OnDragMotion(const gfx::PointF& point,
+                                             uint32_t time,
+                                             int operation,
+                                             gfx::AcceleratedWidget* widget) {
+  point_ = point;
+  *widget = UpdateTargetWindowAndDelegate(point_);
+  drag_operation_ = operation;
+
+  int client_operation =
+      ui::DragDropTypes::DRAG_COPY | ui::DragDropTypes::DRAG_MOVE;
+
+  // If it has valid data in |os_exchange_data_|, it gets operation.
+  if (os_exchange_data_) {
+    std::unique_ptr<ui::DropTargetEvent> event = CreateDropTargetEvent();
+    if (event)
+      client_operation = delegate_->OnDragUpdated(*event);
+  }
+  return client_operation;
+}
+
+void DesktopDragDropClientOzone::OnDragDrop(
+    std::unique_ptr<ui::OSExchangeData> data) {
+  // If it doesn't has |os_exchange_data_|, it needs to update it with |data|.
+  if (!os_exchange_data_) {
+    DCHECK(data);
+    os_exchange_data_ = std::move(data);
+    std::unique_ptr<ui::DropTargetEvent> event = CreateDropTargetEvent();
+    if (event) {
+      delegate_->OnDragEntered(*event);
+      delegate_->OnDragUpdated(*event);
+    }
+  }
+  PerformDrop();
+}
+
+void DesktopDragDropClientOzone::OnMouseMoved(const gfx::Point& point,
+                                              gfx::AcceleratedWidget* widget) {
+  DCHECK(widget);
+
+  aura::Window* target_window = GetTargetWindow(root_window_, point);
+  if (!target_window) {
+    LOG(ERROR) << "Failed to find target_window at " << point.ToString();
+    return;
+  }
+
+  *widget = target_window->GetHost()->GetAcceleratedWidget();
+}
+
+void DesktopDragDropClientOzone::OnDragSessionClose(int dnd_action) {
+  drag_operation_ = dnd_action;
+  QuitClosure();
+  DragDropSessionCompleted();
+}
+
+std::unique_ptr<ui::DropTargetEvent>
+DesktopDragDropClientOzone::CreateDropTargetEvent(
+    const gfx::PointF& root_location) const {
+  if (!target_window_) {
+    LOG(ERROR) << "Invalid target window";
+    return nullptr;
+  }
+
+  gfx::PointF target_location = root_location;
+  target_window_->GetHost()->ConvertDIPToPixels(&target_location);
+  aura::Window::ConvertPointToTarget(root_window_, target_window_,
+                                     &target_location);
+
+  return std::make_unique<ui::DropTargetEvent>(
+      *os_exchange_data_, target_location, root_location, drag_operation_);
+}
+
+std::unique_ptr<ui::DropTargetEvent>
+DesktopDragDropClientOzone::CreateDropTargetEvent() const {
+  gfx::Point root_location(point_.x(), point_.y());
+  root_window_->GetHost()->ConvertScreenInPixelsToDIP(&root_location);
+
+  return CreateDropTargetEvent(gfx::PointF(root_location));
+}
+
+gfx::AcceleratedWidget
+DesktopDragDropClientOzone::UpdateTargetWindowAndDelegate(gfx::PointF& pointf) {
+  const gfx::Point point(pointf.x(), pointf.y());
+  aura::Window* target_window = GetTargetWindow(root_window_, point);
+  if (target_window_ != target_window) {
+    aura::client::DragDropDelegate* delegate = nullptr;
+    if (target_window_) {
+      target_window_->RemoveObserver(this);
+      delegate_->OnDragExited();
+    }
+    if (target_window) {
+      target_window->AddObserver(this);
+      delegate = aura::client::GetDragDropDelegate(target_window);
+    }
+    target_window_ = target_window;
+    delegate_ = delegate;
+  }
+
+  return target_window ? target_window->GetHost()->GetAcceleratedWidget()
+                       : gfx::kNullAcceleratedWidget;
+}
+
+void DesktopDragDropClientOzone::DragDropSessionCompleted() {
+  aura::client::CursorClient* cursor_client =
+      aura::client::GetCursorClient(root_window_);
+  cursor_client->SetCursor(initial_cursor_);
+
+  os_exchange_data_ = nullptr;
+  if (!target_window_)
+    return;
+  target_window_->RemoveObserver(this);
+  target_window_ = nullptr;
+}
+
+void DesktopDragDropClientOzone::PerformDrop() {
+  DCHECK(delegate_);
+  std::unique_ptr<ui::DropTargetEvent> event = CreateDropTargetEvent();
+  delegate_->OnPerformDrop(*event);
+  DragDropSessionCompleted();
+}
+
+void DesktopDragDropClientOzone::QuitClosure() {
+  in_move_loop_ = false;
+  if (quit_closure_.is_null())
+    return;
+  quit_closure_.Run();
+}
+
+}  // namespace views
diff --git a/ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone.h b/ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone.h
new file mode 100644
index 0000000000000..71acfc737b0a4
--- /dev/null
+++ b/ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone.h
@@ -0,0 +1,114 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_IMPL_DESKTOP_AURA_DESKTOP_DRAG_DROP_CLIENT_OZONE_H_
+#define OZONE_IMPL_DESKTOP_AURA_DESKTOP_DRAG_DROP_CLIENT_OZONE_H_
+
+#include "base/callback.h"
+#include "ui/aura/client/drag_drop_client.h"
+#include "ui/aura/client/drag_drop_delegate.h"
+#include "ui/aura/window_observer.h"
+#include "ui/base/cursor/cursor.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/gfx/geometry/point_f.h"
+#include "ui/gfx/native_widget_types.h"
+#include "ui/views/views_export.h"
+
+namespace ui {
+class PlatformWindow;
+}  // namespace ui
+
+namespace views {
+class DesktopNativeCursorManager;
+
+class VIEWS_EXPORT DesktopDragDropClientOzone
+    : public aura::client::DragDropClient,
+      public aura::WindowObserver {
+ public:
+  explicit DesktopDragDropClientOzone(
+      aura::Window* root_window,
+      views::DesktopNativeCursorManager* cursor_manager,
+      ui::PlatformWindow* platform_window,
+      gfx::AcceleratedWidget widget);
+  ~DesktopDragDropClientOzone() override;
+  // Overridden from aura::client::DragDropClient:
+  int StartDragAndDrop(const ui::OSExchangeData& data,
+                       aura::Window* root_window,
+                       aura::Window* source_window,
+                       const gfx::Point& root_location,
+                       int operation,
+                       ui::DragDropTypes::DragEventSource source) override;
+  void DragCancel() override;
+  bool IsDragDropInProgress() override;
+  void AddObserver(aura::client::DragDropClientObserver* observer) override;
+  void RemoveObserver(aura::client::DragDropClientObserver* observer) override;
+
+  // Overridden from void aura::WindowObserver:
+  void OnWindowDestroying(aura::Window* window) override;
+
+  void OnDragEnter(ui::PlatformWindow* window,
+                   const gfx::PointF& point,
+                   std::unique_ptr<ui::OSExchangeData> data,
+                   int operation);
+  int OnDragMotion(const gfx::PointF& point,
+                   uint32_t time,
+                   int operation,
+                   gfx::AcceleratedWidget* widget);
+  void OnDragDrop(std::unique_ptr<ui::OSExchangeData> data);
+  void OnDragLeave();
+  void OnMouseMoved(const gfx::Point& point, gfx::AcceleratedWidget* widget);
+  void OnDragSessionClose(int operation);
+
+ private:
+  // Returns a DropTargetEvent to be passed to the DragDropDelegate, or null to
+  // abort the drag, using the location of point_ if no root location is passed.
+  std::unique_ptr<ui::DropTargetEvent> CreateDropTargetEvent(
+      const gfx::PointF& point) const;
+  std::unique_ptr<ui::DropTargetEvent> CreateDropTargetEvent() const;
+
+  void DragDropSessionCompleted();
+
+  // Update |target_window_| and |delegate_| along with |point|.
+  gfx::AcceleratedWidget UpdateTargetWindowAndDelegate(gfx::PointF& point);
+
+  void PerformDrop();
+
+  void QuitClosure();
+
+  aura::Window* root_window_;
+
+  DesktopNativeCursorManager* cursor_manager_;
+
+  ui::PlatformWindow* platform_window_;
+
+  // Null unless all drag data has been received and the drag is unfinished.
+  aura::Window* target_window_;
+
+  // This is the interface that allows us to send drag events from Ozone-Wayland
+  // to the cross-platform code.
+  aura::client::DragDropDelegate* delegate_;
+
+  std::unique_ptr<ui::OSExchangeData> os_exchange_data_;
+
+  // The most recent native coordinates of a drag.
+  gfx::PointF point_;
+
+  // Cursor in use prior to the move loop starting. Restored when the move loop
+  // quits.
+  gfx::NativeCursor initial_cursor_;
+
+  base::Closure quit_closure_;
+
+  // The operation bitfield.
+  int drag_operation_;
+
+  // Are we running a nested run loop from RunMoveLoop()?
+  bool in_move_loop_ = false;
+
+  DISALLOW_COPY_AND_ASSIGN(DesktopDragDropClientOzone);
+};
+
+}  // namespace views
+
+#endif  // OZONE_IMPL_DESKTOP_AURA_DESKTOP_DRAG_DROP_CLIENT_OZONE_H_
diff --git a/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.cc b/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.cc
index 563b015411ab8..37273ca586091 100644
--- a/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.cc
+++ b/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.cc
@@ -13,6 +13,7 @@
 #include "ui/platform_window/platform_window.h"
 #include "ui/platform_window/platform_window_init_properties.h"
 #include "ui/views/corewm/tooltip_aura.h"
+#include "ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone.h"
 #include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
 #include "ui/views/widget/desktop_aura/window_event_filter.h"
 #include "ui/views/widget/widget_aura_utils.h"
@@ -117,9 +118,9 @@ DesktopWindowTreeHostPlatform::CreateTooltip() {
 std::unique_ptr<aura::client::DragDropClient>
 DesktopWindowTreeHostPlatform::CreateDragDropClient(
     DesktopNativeCursorManager* cursor_manager) {
-  // TODO: needs PlatformWindow support.
-  NOTIMPLEMENTED_LOG_ONCE();
-  return nullptr;
+  drag_drop_client_ = new DesktopDragDropClientOzone(
+      window(), cursor_manager, platform_window(), GetAcceleratedWidget());
+  return base::WrapUnique(drag_drop_client_);
 }
 
 void DesktopWindowTreeHostPlatform::Close() {
@@ -526,6 +527,41 @@ void DesktopWindowTreeHostPlatform::OnActivationChanged(bool active) {
   desktop_native_widget_aura_->HandleActivationChanged(active);
 }
 
+void DesktopWindowTreeHostPlatform::OnDragEnter(
+    ui::PlatformWindow* window,
+    const gfx::PointF& point,
+    std::unique_ptr<ui::OSExchangeData> data,
+    int operation) {
+  drag_drop_client_->OnDragEnter(window, point, std::move(data), operation);
+}
+
+int DesktopWindowTreeHostPlatform::OnDragMotion(
+    const gfx::PointF& point,
+    uint32_t time,
+    int operation,
+    gfx::AcceleratedWidget* widget) {
+  return drag_drop_client_->OnDragMotion(point, time, operation, widget);
+}
+
+void DesktopWindowTreeHostPlatform::OnDragDrop(
+    std::unique_ptr<ui::OSExchangeData> data) {
+  drag_drop_client_->OnDragDrop(std::move(data));
+}
+
+void DesktopWindowTreeHostPlatform::OnDragLeave() {
+  drag_drop_client_->OnDragLeave();
+}
+
+void DesktopWindowTreeHostPlatform::OnMouseMoved(
+    const gfx::Point& point,
+    gfx::AcceleratedWidget* widget) {
+  drag_drop_client_->OnMouseMoved(point, widget);
+}
+
+void DesktopWindowTreeHostPlatform::OnDragSessionClose(int operation) {
+  drag_drop_client_->OnDragSessionClose(operation);
+}
+
 void DesktopWindowTreeHostPlatform::Relayout() {
   Widget* widget = native_widget_delegate_->AsWidget();
   NonClientView* non_client_view = widget->non_client_view();
diff --git a/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.h b/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.h
index 8af0ce17833b6..61ccdd187df0d 100644
--- a/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.h
+++ b/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.h
@@ -11,6 +11,8 @@
 #include "ui/views/widget/desktop_aura/desktop_window_tree_host.h"
 
 namespace views {
+class DesktopDragDropClientOzone;
+class PlatformWindow;
 
 class VIEWS_EXPORT DesktopWindowTreeHostPlatform
     : public aura::WindowTreeHostPlatform,
@@ -97,6 +99,19 @@ class VIEWS_EXPORT DesktopWindowTreeHostPlatform
   void OnWindowStateChanged(ui::PlatformWindowState new_state) override;
   void OnCloseRequest() override;
   void OnActivationChanged(bool active) override;
+  void OnDragEnter(ui::PlatformWindow* window,
+                   const gfx::PointF& point,
+                   std::unique_ptr<ui::OSExchangeData> data,
+                   int operation) override;
+  int OnDragMotion(const gfx::PointF& point,
+                   uint32_t time,
+                   int operation,
+                   gfx::AcceleratedWidget* widget) override;
+  void OnDragDrop(std::unique_ptr<ui::OSExchangeData> data) override;
+  void OnDragLeave() override;
+  void OnMouseMoved(const gfx::Point& point,
+                    gfx::AcceleratedWidget* widget) override;
+  void OnDragSessionClose(int operation) override;
 
  private:
   void Relayout();
@@ -121,6 +136,8 @@ class VIEWS_EXPORT DesktopWindowTreeHostPlatform
   // A handler for events inteded for non client area.
   std::unique_ptr<ui::EventHandler> non_client_window_event_filter_;
 
+  DesktopDragDropClientOzone* drag_drop_client_;
+
   base::WeakPtrFactory<DesktopWindowTreeHostPlatform> weak_factory_{this};
 
   DISALLOW_COPY_AND_ASSIGN(DesktopWindowTreeHostPlatform);

From c91385c7946978aab8df1bbb7430e7d70fa2937c Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Wed, 8 Aug 2018 21:51:02 +0900
Subject: [PATCH 17/32] Implements Drag and Drop for Ozone/X11

It introduces X11DragSource and X11DragContext to handle DnD
on Ozone/X11. They are from DesktopDragDropClientAuraX11 which
includes implementation for platform layer.

X11DragSource handles event and deliver the data at a server side
and X11DragContext handles events and read the data at a client
side.

It splits OSExchangeDataProviderAuraX11 to OSExchangeDataProviderAuraX11
and OSExchangeDataProviderAuraX11Base to resue it.
OSExchangeDataProviderAuraX11 keeps only platform event specific part.
---
 ui/base/BUILD.gn                              |  44 +-
 .../os_exchange_data_provider_aurax11.cc      | 444 +---------------
 .../os_exchange_data_provider_aurax11.h       | 105 +---
 .../os_exchange_data_provider_aurax11_base.cc | 473 ++++++++++++++++++
 .../os_exchange_data_provider_aurax11_base.h  | 135 +++++
 ui/ozone/platform/x11/BUILD.gn                |   6 +
 ui/ozone/platform/x11/x11_drag_context.cc     | 251 ++++++++++
 ui/ozone/platform/x11/x11_drag_context.h      | 115 +++++
 ui/ozone/platform/x11/x11_drag_source.cc      | 458 +++++++++++++++++
 ui/ozone/platform/x11/x11_drag_source.h       | 157 ++++++
 ui/ozone/platform/x11/x11_drag_util.cc        | 108 ++++
 ui/ozone/platform/x11/x11_drag_util.h         | 107 ++++
 ui/ozone/platform/x11/x11_window_ozone.cc     | 156 +++++-
 ui/ozone/platform/x11/x11_window_ozone.h      |  37 ++
 ui/platform_window/x11/x11_window_base.cc     |   9 +
 ui/platform_window/x11/x11_window_base.h      |   4 +
 16 files changed, 2050 insertions(+), 559 deletions(-)
 create mode 100644 ui/base/dragdrop/os_exchange_data_provider_aurax11_base.cc
 create mode 100644 ui/base/dragdrop/os_exchange_data_provider_aurax11_base.h
 create mode 100644 ui/ozone/platform/x11/x11_drag_context.cc
 create mode 100644 ui/ozone/platform/x11/x11_drag_context.h
 create mode 100644 ui/ozone/platform/x11/x11_drag_source.cc
 create mode 100644 ui/ozone/platform/x11/x11_drag_source.h
 create mode 100644 ui/ozone/platform/x11/x11_drag_util.cc
 create mode 100644 ui/ozone/platform/x11/x11_drag_util.h

diff --git a/ui/base/BUILD.gn b/ui/base/BUILD.gn
index c6af8f7dcd995..86f37d234e007 100644
--- a/ui/base/BUILD.gn
+++ b/ui/base/BUILD.gn
@@ -487,30 +487,46 @@ component("base") {
     }
   }
 
-  if (use_x11 && use_aura) {
+  if (use_x11 && use_aura || ozone_platform_x11) {
     sources += [
-      "cursor/cursor_loader_x11.cc",
-      "cursor/cursor_loader_x11.h",
-      "cursor/cursor_x11.cc",
-      "x/selection_owner.cc",
-      "x/selection_owner.h",
-      "x/selection_requestor.cc",
-      "x/selection_requestor.h",
       "x/selection_utils.cc",
       "x/selection_utils.h",
-    ]
-    deps += [
-      "//ui/events/platform/x11",
-      "//ui/gfx/x",
+      "x/selection_owner.cc",
+      "x/selection_owner.h",
     ]
 
     if (!is_chromeos) {
       # These Aura X11 files aren't used on ChromeOS.
       sources += [
-        "dragdrop/os_exchange_data_provider_aurax11.cc",
-        "dragdrop/os_exchange_data_provider_aurax11.h",
+        "dragdrop/os_exchange_data_provider_aurax11_base.cc",
+        "dragdrop/os_exchange_data_provider_aurax11_base.h",
       ]
     }
+
+    if (use_x11 && use_aura) {
+      sources += [
+        "cursor/cursor_loader_x11.cc",
+        "cursor/cursor_loader_x11.h",
+        "cursor/cursor_x11.cc",
+        "x/selection_requestor.cc",
+        "x/selection_requestor.h",
+      ]
+
+      if (!is_chromeos) {
+        # These Aura X11 files aren't used on ChromeOS.
+        sources += [
+          "dragdrop/os_exchange_data_provider_aurax11.cc",
+          "dragdrop/os_exchange_data_provider_aurax11.h",
+        ]
+      }
+    }
+
+    configs += [ "//build/config/linux:x11" ]
+
+    deps += [
+      "//ui/events/platform/x11",
+      "//ui/gfx/x",
+    ]
   }
 
   if (use_aura) {
diff --git a/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc b/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc
index 1a6e9a1c78928..33452b2dec62c 100644
--- a/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc
+++ b/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc
@@ -7,17 +7,8 @@
 #include <utility>
 
 #include "base/logging.h"
-#include "base/memory/ref_counted_memory.h"
-#include "base/strings/string_split.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "net/base/filename_util.h"
-#include "ui/base/clipboard/clipboard.h"
-#include "ui/base/clipboard/scoped_clipboard_writer.h"
-#include "ui/base/dragdrop/file_info.h"
 #include "ui/base/x/selection_utils.h"
 #include "ui/events/platform/platform_event_source.h"
-#include "ui/gfx/x/x11_atom_cache.h"
 
 // Note: the GetBlah() methods are used immediately by the
 // web_contents_view_aura.cc:PrepareDropData(), while the omnibox is a
@@ -26,377 +17,19 @@
 
 namespace ui {
 
-namespace {
-
-const char kDndSelection[] = "XdndSelection";
-const char kRendererTaint[] = "chromium/x-renderer-taint";
-
-const char kNetscapeURL[] = "_NETSCAPE_URL";
-
-}  // namespace
-
 OSExchangeDataProviderAuraX11::OSExchangeDataProviderAuraX11(
     ::Window x_window,
     const SelectionFormatMap& selection)
-    : x_display_(gfx::GetXDisplay()),
-      x_root_window_(DefaultRootWindow(x_display_)),
-      own_window_(false),
-      x_window_(x_window),
-      format_map_(selection),
-      selection_owner_(x_display_, x_window_, gfx::GetAtom(kDndSelection)) {}
+    : OSExchangeDataProviderAuraX11Base(x_window, selection) {}
 
 OSExchangeDataProviderAuraX11::OSExchangeDataProviderAuraX11()
-    : x_display_(gfx::GetXDisplay()),
-      x_root_window_(DefaultRootWindow(x_display_)),
-      own_window_(true),
-      x_window_(XCreateWindow(x_display_,
-                              x_root_window_,
-                              -100,
-                              -100,
-                              10,
-                              10,              // x, y, width, height
-                              0,               // border width
-                              CopyFromParent,  // depth
-                              InputOnly,
-                              CopyFromParent,  // visual
-                              0,
-                              NULL)),
-      format_map_(),
-      selection_owner_(x_display_, x_window_, gfx::GetAtom(kDndSelection)) {
-  XStoreName(x_display_, x_window_, "Chromium Drag & Drop Window");
-
+    : OSExchangeDataProviderAuraX11Base() {
   PlatformEventSource::GetInstance()->AddPlatformEventDispatcher(this);
 }
 
 OSExchangeDataProviderAuraX11::~OSExchangeDataProviderAuraX11() {
-  if (own_window_) {
+  if (own_window_)
     PlatformEventSource::GetInstance()->RemovePlatformEventDispatcher(this);
-    XDestroyWindow(x_display_, x_window_);
-  }
-}
-
-void OSExchangeDataProviderAuraX11::TakeOwnershipOfSelection() const {
-  selection_owner_.TakeOwnershipOfSelection(format_map_);
-}
-
-void OSExchangeDataProviderAuraX11::RetrieveTargets(
-    std::vector<Atom>* targets) const {
-  selection_owner_.RetrieveTargets(targets);
-}
-
-SelectionFormatMap OSExchangeDataProviderAuraX11::GetFormatMap() const {
-  // We return the |selection_owner_|'s format map instead of our own in case
-  // ours has been modified since TakeOwnershipOfSelection() was called.
-  return selection_owner_.selection_format_map();
-}
-
-std::unique_ptr<OSExchangeData::Provider>
-OSExchangeDataProviderAuraX11::Clone() const {
-  std::unique_ptr<OSExchangeDataProviderAuraX11> ret(
-      new OSExchangeDataProviderAuraX11());
-  ret->format_map_ = format_map_;
-  return std::move(ret);
-}
-
-void OSExchangeDataProviderAuraX11::MarkOriginatedFromRenderer() {
-  std::string empty;
-  format_map_.Insert(gfx::GetAtom(kRendererTaint),
-                     scoped_refptr<base::RefCountedMemory>(
-                         base::RefCountedString::TakeString(&empty)));
-}
-
-bool OSExchangeDataProviderAuraX11::DidOriginateFromRenderer() const {
-  return format_map_.find(gfx::GetAtom(kRendererTaint)) != format_map_.end();
-}
-
-void OSExchangeDataProviderAuraX11::SetString(const base::string16& text_data) {
-  if (HasString())
-    return;
-
-  std::string utf8 = base::UTF16ToUTF8(text_data);
-  scoped_refptr<base::RefCountedMemory> mem(
-      base::RefCountedString::TakeString(&utf8));
-
-  format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeText), mem);
-  format_map_.Insert(gfx::GetAtom(kText), mem);
-  format_map_.Insert(gfx::GetAtom(kString), mem);
-  format_map_.Insert(gfx::GetAtom(kUtf8String), mem);
-}
-
-void OSExchangeDataProviderAuraX11::SetURL(const GURL& url,
-                                           const base::string16& title) {
-  // TODO(dcheng): The original GTK code tries very hard to avoid writing out an
-  // empty title. Is this necessary?
-  if (url.is_valid()) {
-    // Mozilla's URL format: (UTF16: URL, newline, title)
-    base::string16 spec = base::UTF8ToUTF16(url.spec());
-
-    std::vector<unsigned char> data;
-    ui::AddString16ToVector(spec, &data);
-    ui::AddString16ToVector(base::ASCIIToUTF16("\n"), &data);
-    ui::AddString16ToVector(title, &data);
-    scoped_refptr<base::RefCountedMemory> mem(
-        base::RefCountedBytes::TakeVector(&data));
-
-    format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeMozillaURL), mem);
-
-    // Set a string fallback as well.
-    SetString(spec);
-
-    // Return early if this drag already contains file contents (this implies
-    // that file contents must be populated before URLs). Nautilus (and possibly
-    // other file managers) prefer _NETSCAPE_URL over the X Direct Save
-    // protocol, but we want to prioritize XDS in this case.
-    if (!file_contents_name_.empty())
-      return;
-
-    // Set _NETSCAPE_URL for file managers like Nautilus that use it as a hint
-    // to create a link to the URL. Setting text/uri-list doesn't work because
-    // Nautilus will fetch and copy the contents of the URL to the drop target
-    // instead of linking...
-    // Format is UTF8: URL + "\n" + title.
-    std::string netscape_url = url.spec();
-    netscape_url += "\n";
-    netscape_url += base::UTF16ToUTF8(title);
-    format_map_.Insert(gfx::GetAtom(kNetscapeURL),
-                       scoped_refptr<base::RefCountedMemory>(
-                           base::RefCountedString::TakeString(&netscape_url)));
-  }
-}
-
-void OSExchangeDataProviderAuraX11::SetFilename(const base::FilePath& path) {
-  std::vector<FileInfo> data;
-  data.push_back(FileInfo(path, base::FilePath()));
-  SetFilenames(data);
-}
-
-void OSExchangeDataProviderAuraX11::SetFilenames(
-    const std::vector<FileInfo>& filenames) {
-  std::vector<std::string> paths;
-  for (std::vector<FileInfo>::const_iterator it = filenames.begin();
-       it != filenames.end();
-       ++it) {
-    std::string url_spec = net::FilePathToFileURL(it->path).spec();
-    if (!url_spec.empty())
-      paths.push_back(url_spec);
-  }
-
-  std::string joined_data = base::JoinString(paths, "\n");
-  scoped_refptr<base::RefCountedMemory> mem(
-      base::RefCountedString::TakeString(&joined_data));
-  format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeURIList), mem);
-}
-
-void OSExchangeDataProviderAuraX11::SetPickledData(
-    const Clipboard::FormatType& format,
-    const base::Pickle& pickle) {
-  const unsigned char* data =
-      reinterpret_cast<const unsigned char*>(pickle.data());
-
-  std::vector<unsigned char> bytes;
-  bytes.insert(bytes.end(), data, data + pickle.size());
-  scoped_refptr<base::RefCountedMemory> mem(
-      base::RefCountedBytes::TakeVector(&bytes));
-
-  format_map_.Insert(gfx::GetAtom(format.ToString().c_str()), mem);
-}
-
-bool OSExchangeDataProviderAuraX11::GetString(base::string16* result) const {
-  if (HasFile()) {
-    // Various Linux file managers both pass a list of file:// URIs and set the
-    // string representation to the URI. We explicitly don't want to return use
-    // this representation.
-    return false;
-  }
-
-  std::vector<::Atom> text_atoms = ui::GetTextAtomsFrom();
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(text_atoms, GetTargets(), &requested_types);
-
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    std::string text = data.GetText();
-    *result = base::UTF8ToUTF16(text);
-    return true;
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::GetURLAndTitle(
-    OSExchangeData::FilenameToURLPolicy policy,
-    GURL* url,
-    base::string16* title) const {
-  std::vector<::Atom> url_atoms = ui::GetURLAtomsFrom();
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    // TODO(erg): Technically, both of these forms can accept multiple URLs,
-    // but that doesn't match the assumptions of the rest of the system which
-    // expect single types.
-
-    if (data.GetType() == gfx::GetAtom(Clipboard::kMimeTypeMozillaURL)) {
-      // Mozilla URLs are (UTF16: URL, newline, title).
-      base::string16 unparsed;
-      data.AssignTo(&unparsed);
-
-      std::vector<base::string16> tokens = base::SplitString(
-          unparsed, base::ASCIIToUTF16("\n"),
-          base::KEEP_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
-      if (tokens.size() > 0) {
-        if (tokens.size() > 1)
-          *title = tokens[1];
-        else
-          *title = base::string16();
-
-        *url = GURL(tokens[0]);
-        return true;
-      }
-    } else if (data.GetType() == gfx::GetAtom(Clipboard::kMimeTypeURIList)) {
-      std::vector<std::string> tokens = ui::ParseURIList(data);
-      for (std::vector<std::string>::const_iterator it = tokens.begin();
-           it != tokens.end(); ++it) {
-        GURL test_url(*it);
-        if (!test_url.SchemeIsFile() ||
-            policy == OSExchangeData::CONVERT_FILENAMES) {
-          *url = test_url;
-          *title = base::string16();
-          return true;
-        }
-      }
-    }
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::GetFilename(base::FilePath* path) const {
-  std::vector<FileInfo> filenames;
-  if (GetFilenames(&filenames)) {
-    *path = filenames.front().path;
-    return true;
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::GetFilenames(
-    std::vector<FileInfo>* filenames) const {
-  std::vector<::Atom> url_atoms = ui::GetURIListAtomsFrom();
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  filenames->clear();
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    std::vector<std::string> tokens = ui::ParseURIList(data);
-    for (std::vector<std::string>::const_iterator it = tokens.begin();
-         it != tokens.end(); ++it) {
-      GURL url(*it);
-      base::FilePath file_path;
-      if (url.SchemeIsFile() && net::FileURLToFilePath(url, &file_path)) {
-        filenames->push_back(FileInfo(file_path, base::FilePath()));
-      }
-    }
-  }
-
-  return !filenames->empty();
-}
-
-bool OSExchangeDataProviderAuraX11::GetPickledData(
-    const Clipboard::FormatType& format,
-    base::Pickle* pickle) const {
-  std::vector< ::Atom> requested_types;
-  requested_types.push_back(gfx::GetAtom(format.ToString().c_str()));
-
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    // Note that the pickle object on the right hand side of the assignment
-    // only refers to the bytes in |data|. The assignment copies the data.
-    *pickle = base::Pickle(reinterpret_cast<const char*>(data.GetData()),
-                           static_cast<int>(data.GetSize()));
-    return true;
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::HasString() const {
-  std::vector<::Atom> text_atoms = ui::GetTextAtomsFrom();
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(text_atoms, GetTargets(), &requested_types);
-  return !requested_types.empty() && !HasFile();
-}
-
-bool OSExchangeDataProviderAuraX11::HasURL(
-    OSExchangeData::FilenameToURLPolicy policy) const {
-  std::vector<::Atom> url_atoms = ui::GetURLAtomsFrom();
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  if (requested_types.empty())
-    return false;
-
-  // The Linux desktop doesn't differentiate between files and URLs like
-  // Windows does and stuffs all the data into one mime type.
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    if (data.GetType() == gfx::GetAtom(Clipboard::kMimeTypeMozillaURL)) {
-      // File managers shouldn't be using this type, so this is a URL.
-      return true;
-    } else if (data.GetType() ==
-               gfx::GetAtom(ui::Clipboard::kMimeTypeURIList)) {
-      std::vector<std::string> tokens = ui::ParseURIList(data);
-      for (std::vector<std::string>::const_iterator it = tokens.begin();
-           it != tokens.end(); ++it) {
-        if (!GURL(*it).SchemeIsFile() ||
-            policy == OSExchangeData::CONVERT_FILENAMES)
-          return true;
-      }
-
-      return false;
-    }
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::HasFile() const {
-  std::vector<::Atom> url_atoms = ui::GetURIListAtomsFrom();
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  if (requested_types.empty())
-    return false;
-
-  // To actually answer whether we have a file, we need to look through the
-  // contents of the kMimeTypeURIList type, and see if any of them are file://
-  // URIs.
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    std::vector<std::string> tokens = ui::ParseURIList(data);
-    for (std::vector<std::string>::const_iterator it = tokens.begin();
-         it != tokens.end(); ++it) {
-      GURL url(*it);
-      base::FilePath file_path;
-      if (url.SchemeIsFile() && net::FileURLToFilePath(url, &file_path))
-        return true;
-    }
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::HasCustomFormat(
-    const Clipboard::FormatType& format) const {
-  std::vector< ::Atom> url_atoms;
-  url_atoms.push_back(gfx::GetAtom(format.ToString().c_str()));
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  return !requested_types.empty();
 }
 
 void OSExchangeDataProviderAuraX11::SetFileContents(
@@ -434,60 +67,6 @@ void OSExchangeDataProviderAuraX11::SetFileContents(
           base::RefCountedString::TakeString(&file_contents_copy)));
 }
 
-void OSExchangeDataProviderAuraX11::SetHtml(const base::string16& html,
-                                            const GURL& base_url) {
-  std::vector<unsigned char> bytes;
-  // Manually jam a UTF16 BOM into bytes because otherwise, other programs will
-  // assume UTF-8.
-  bytes.push_back(0xFF);
-  bytes.push_back(0xFE);
-  ui::AddString16ToVector(html, &bytes);
-  scoped_refptr<base::RefCountedMemory> mem(
-      base::RefCountedBytes::TakeVector(&bytes));
-
-  format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeHTML), mem);
-}
-
-bool OSExchangeDataProviderAuraX11::GetHtml(base::string16* html,
-                                            GURL* base_url) const {
-  std::vector< ::Atom> url_atoms;
-  url_atoms.push_back(gfx::GetAtom(Clipboard::kMimeTypeHTML));
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    *html = data.GetHtml();
-    *base_url = GURL();
-    return true;
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::HasHtml() const {
-  std::vector< ::Atom> url_atoms;
-  url_atoms.push_back(gfx::GetAtom(Clipboard::kMimeTypeHTML));
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  return !requested_types.empty();
-}
-
-void OSExchangeDataProviderAuraX11::SetDragImage(
-    const gfx::ImageSkia& image,
-    const gfx::Vector2d& cursor_offset) {
-  drag_image_ = image;
-  drag_image_offset_ = cursor_offset;
-}
-
-gfx::ImageSkia OSExchangeDataProviderAuraX11::GetDragImage() const {
-  return drag_image_;
-}
-
-gfx::Vector2d OSExchangeDataProviderAuraX11::GetDragImageOffset() const {
-  return drag_image_offset_;
-}
 
 bool OSExchangeDataProviderAuraX11::CanDispatchEvent(
     const PlatformEvent& event) {
@@ -507,21 +86,4 @@ uint32_t OSExchangeDataProviderAuraX11::DispatchEvent(
   return ui::POST_DISPATCH_NONE;
 }
 
-bool OSExchangeDataProviderAuraX11::GetPlainTextURL(GURL* url) const {
-  base::string16 text;
-  if (GetString(&text)) {
-    GURL test_url(text);
-    if (test_url.is_valid()) {
-      *url = test_url;
-      return true;
-    }
-  }
-
-  return false;
-}
-
-std::vector< ::Atom> OSExchangeDataProviderAuraX11::GetTargets() const {
-  return format_map_.GetTypes();
-}
-
 }  // namespace ui
diff --git a/ui/base/dragdrop/os_exchange_data_provider_aurax11.h b/ui/base/dragdrop/os_exchange_data_provider_aurax11.h
index f8e60b31ac610..81ac03837aa4a 100644
--- a/ui/base/dragdrop/os_exchange_data_provider_aurax11.h
+++ b/ui/base/dragdrop/os_exchange_data_provider_aurax11.h
@@ -5,30 +5,14 @@
 #ifndef UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_AURAX11_H_
 #define UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_AURAX11_H_
 
-#include <stdint.h>
-#include <map>
-
-#include "base/files/file_path.h"
-#include "base/macros.h"
-#include "base/pickle.h"
-#include "ui/base/dragdrop/os_exchange_data.h"
-#include "ui/base/x/selection_owner.h"
-#include "ui/base/x/selection_requestor.h"
-#include "ui/base/x/selection_utils.h"
+#include "ui/base/dragdrop/os_exchange_data_provider_aurax11_base.h"
 #include "ui/events/platform/platform_event_dispatcher.h"
-#include "ui/gfx/geometry/vector2d.h"
-#include "ui/gfx/image/image_skia.h"
-#include "ui/gfx/x/x11.h"
-#include "url/gurl.h"
 
 namespace ui {
 
-class Clipboard;
-class OSExchangeDataProviderAuraX11Test;
-
 // OSExchangeData::Provider implementation for aura on linux.
 class UI_BASE_EXPORT OSExchangeDataProviderAuraX11
-    : public OSExchangeData::Provider,
+    : public OSExchangeDataProviderAuraX11Base,
       public PlatformEventDispatcher {
  public:
   // |x_window| is the window the cursor is over, and |selection| is the set of
@@ -42,99 +26,14 @@ class UI_BASE_EXPORT OSExchangeDataProviderAuraX11
 
   ~OSExchangeDataProviderAuraX11() override;
 
-  // After all the Set* methods have built up the data we're offering, call
-  // this to take ownership of the XdndSelection clipboard.
-  void TakeOwnershipOfSelection() const;
-
-  // Retrieves a list of types we're offering. Noop if we haven't taken the
-  // selection.
-  void RetrieveTargets(std::vector<Atom>* targets) const;
-
-  // Makes a copy of the format map currently being offered.
-  SelectionFormatMap GetFormatMap() const;
-
-  const base::FilePath& file_contents_name() const {
-    return file_contents_name_;
-  }
-
-  // Overridden from OSExchangeData::Provider:
-  std::unique_ptr<Provider> Clone() const override;
-  void MarkOriginatedFromRenderer() override;
-  bool DidOriginateFromRenderer() const override;
-  void SetString(const base::string16& data) override;
-  void SetURL(const GURL& url, const base::string16& title) override;
-  void SetFilename(const base::FilePath& path) override;
-  void SetFilenames(const std::vector<FileInfo>& filenames) override;
-  void SetPickledData(const Clipboard::FormatType& format,
-                      const base::Pickle& pickle) override;
-  bool GetString(base::string16* data) const override;
-  bool GetURLAndTitle(OSExchangeData::FilenameToURLPolicy policy,
-                      GURL* url,
-                      base::string16* title) const override;
-  bool GetFilename(base::FilePath* path) const override;
-  bool GetFilenames(std::vector<FileInfo>* filenames) const override;
-  bool GetPickledData(const Clipboard::FormatType& format,
-                      base::Pickle* pickle) const override;
-  bool HasString() const override;
-  bool HasURL(OSExchangeData::FilenameToURLPolicy policy) const override;
-  bool HasFile() const override;
-  bool HasCustomFormat(const Clipboard::FormatType& format) const override;
-
   void SetFileContents(const base::FilePath& filename,
                        const std::string& file_contents) override;
 
-  void SetHtml(const base::string16& html, const GURL& base_url) override;
-  bool GetHtml(base::string16* html, GURL* base_url) const override;
-  bool HasHtml() const override;
-  void SetDragImage(const gfx::ImageSkia& image,
-                    const gfx::Vector2d& cursor_offset) override;
-  gfx::ImageSkia GetDragImage() const override;
-  gfx::Vector2d GetDragImageOffset() const override;
-
   // PlatformEventDispatcher:
   bool CanDispatchEvent(const PlatformEvent& event) override;
   uint32_t DispatchEvent(const PlatformEvent& event) override;
 
  private:
-  friend class OSExchangeDataProviderAuraX11Test;
-  typedef std::map<Clipboard::FormatType, base::Pickle> PickleData;
-
-  // Returns true if |formats_| contains a string format and the string can be
-  // parsed as a URL.
-  bool GetPlainTextURL(GURL* url) const;
-
-  // Returns the targets in |format_map_|.
-  std::vector< ::Atom> GetTargets() const;
-
-  // Drag image and offset data.
-  gfx::ImageSkia drag_image_;
-  gfx::Vector2d drag_image_offset_;
-
-  // Our X11 state.
-  Display* x_display_;
-  ::Window x_root_window_;
-
-  // In X11, because the IPC parts of drag operations are implemented by
-  // XSelection, we require an x11 window to receive drag messages on. The
-  // OSExchangeDataProvider system is modeled on the Windows implementation,
-  // which does not require a window. We only sometimes have a valid window
-  // available (in the case of drag receiving). Other times, we need to create
-  // our own xwindow just to receive events on it.
-  const bool own_window_;
-
-  ::Window x_window_;
-
-  // A representation of data. This is either passed to us from the other
-  // process, or built up through a sequence of Set*() calls. It can be passed
-  // to |selection_owner_| when we take the selection.
-  SelectionFormatMap format_map_;
-
-  // Auxilary data for the X Direct Save protocol.
-  base::FilePath file_contents_name_;
-
-  // Takes a snapshot of |format_map_| and offers it to other windows.
-  mutable SelectionOwner selection_owner_;
-
   DISALLOW_COPY_AND_ASSIGN(OSExchangeDataProviderAuraX11);
 };
 
diff --git a/ui/base/dragdrop/os_exchange_data_provider_aurax11_base.cc b/ui/base/dragdrop/os_exchange_data_provider_aurax11_base.cc
new file mode 100644
index 0000000000000..b5b1341b62128
--- /dev/null
+++ b/ui/base/dragdrop/os_exchange_data_provider_aurax11_base.cc
@@ -0,0 +1,473 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/dragdrop/os_exchange_data_provider_aurax11_base.h"
+
+#include <utility>
+
+#include "base/logging.h"
+#include "base/memory/ref_counted_memory.h"
+#include "base/strings/string_split.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "net/base/filename_util.h"
+#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/scoped_clipboard_writer.h"
+#include "ui/base/dragdrop/file_info.h"
+#include "ui/base/x/selection_utils.h"
+#include "ui/events/platform/platform_event_source.h"
+#include "ui/gfx/x/x11_atom_cache.h"
+
+// Note: the GetBlah() methods are used immediately by the
+// web_contents_view_aura.cc:PrepareDropData(), while the omnibox is a
+// little more discriminating and calls HasBlah() before trying to get the
+// information.
+
+namespace ui {
+
+namespace {
+
+const char kDndSelection[] = "XdndSelection";
+const char kRendererTaint[] = "chromium/x-renderer-taint";
+
+const char kNetscapeURL[] = "_NETSCAPE_URL";
+
+}  // namespace
+
+OSExchangeDataProviderAuraX11Base::OSExchangeDataProviderAuraX11Base(
+    ::Window x_window,
+    const SelectionFormatMap& selection)
+    : x_display_(gfx::GetXDisplay()),
+      x_root_window_(DefaultRootWindow(x_display_)),
+      own_window_(false),
+      x_window_(x_window),
+      format_map_(selection),
+      selection_owner_(x_display_, x_window_, gfx::GetAtom(kDndSelection)) {}
+
+OSExchangeDataProviderAuraX11Base::OSExchangeDataProviderAuraX11Base()
+    : x_display_(gfx::GetXDisplay()),
+      x_root_window_(DefaultRootWindow(x_display_)),
+      own_window_(true),
+      x_window_(XCreateWindow(x_display_,
+                              x_root_window_,
+                              -100,
+                              -100,
+                              10,
+                              10,              // x, y, width, height
+                              0,               // border width
+                              CopyFromParent,  // depth
+                              InputOnly,
+                              CopyFromParent,  // visual
+                              0,
+                              NULL)),
+      format_map_(),
+      selection_owner_(x_display_, x_window_, gfx::GetAtom(kDndSelection)) {
+  XStoreName(x_display_, x_window_, "Chromium Drag & Drop Window");
+}
+
+OSExchangeDataProviderAuraX11Base::~OSExchangeDataProviderAuraX11Base() {
+  if (own_window_)
+    XDestroyWindow(x_display_, x_window_);
+}
+
+void OSExchangeDataProviderAuraX11Base::TakeOwnershipOfSelection() const {
+  selection_owner_.TakeOwnershipOfSelection(format_map_);
+}
+
+void OSExchangeDataProviderAuraX11Base::RetrieveTargets(
+    std::vector<Atom>* targets) const {
+  selection_owner_.RetrieveTargets(targets);
+}
+
+SelectionFormatMap OSExchangeDataProviderAuraX11Base::GetFormatMap() const {
+  // We return the |selection_owner_|'s format map instead of our own in case
+  // ours has been modified since TakeOwnershipOfSelection() was called.
+  return selection_owner_.selection_format_map();
+}
+
+std::unique_ptr<OSExchangeData::Provider>
+OSExchangeDataProviderAuraX11Base::Clone() const {
+  std::unique_ptr<OSExchangeDataProviderAuraX11Base> ret(
+      new OSExchangeDataProviderAuraX11Base());
+  ret->format_map_ = format_map_;
+  return std::move(ret);
+}
+
+void OSExchangeDataProviderAuraX11Base::MarkOriginatedFromRenderer() {
+  std::string empty;
+  format_map_.Insert(gfx::GetAtom(kRendererTaint),
+                     scoped_refptr<base::RefCountedMemory>(
+                         base::RefCountedString::TakeString(&empty)));
+}
+
+bool OSExchangeDataProviderAuraX11Base::DidOriginateFromRenderer() const {
+  return format_map_.find(gfx::GetAtom(kRendererTaint)) != format_map_.end();
+}
+
+void OSExchangeDataProviderAuraX11Base::SetString(
+    const base::string16& text_data) {
+  if (HasString())
+    return;
+
+  std::string utf8 = base::UTF16ToUTF8(text_data);
+  scoped_refptr<base::RefCountedMemory> mem(
+      base::RefCountedString::TakeString(&utf8));
+
+  format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeText), mem);
+  format_map_.Insert(gfx::GetAtom(kText), mem);
+  format_map_.Insert(gfx::GetAtom(kString), mem);
+  format_map_.Insert(gfx::GetAtom(kUtf8String), mem);
+}
+
+void OSExchangeDataProviderAuraX11Base::SetURL(const GURL& url,
+                                               const base::string16& title) {
+  // TODO(dcheng): The original GTK code tries very hard to avoid writing out an
+  // empty title. Is this necessary?
+  if (url.is_valid()) {
+    // Mozilla's URL format: (UTF16: URL, newline, title)
+    base::string16 spec = base::UTF8ToUTF16(url.spec());
+
+    std::vector<unsigned char> data;
+    ui::AddString16ToVector(spec, &data);
+    ui::AddString16ToVector(base::ASCIIToUTF16("\n"), &data);
+    ui::AddString16ToVector(title, &data);
+    scoped_refptr<base::RefCountedMemory> mem(
+        base::RefCountedBytes::TakeVector(&data));
+
+    format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeMozillaURL), mem);
+
+    // Set a string fallback as well.
+    SetString(spec);
+
+    // Return early if this drag already contains file contents (this implies
+    // that file contents must be populated before URLs). Nautilus (and possibly
+    // other file managers) prefer _NETSCAPE_URL over the X Direct Save
+    // protocol, but we want to prioritize XDS in this case.
+    if (!file_contents_name_.empty())
+      return;
+
+    // Set _NETSCAPE_URL for file managers like Nautilus that use it as a hint
+    // to create a link to the URL. Setting text/uri-list doesn't work because
+    // Nautilus will fetch and copy the contents of the URL to the drop target
+    // instead of linking...
+    // Format is UTF8: URL + "\n" + title.
+    std::string netscape_url = url.spec();
+    netscape_url += "\n";
+    netscape_url += base::UTF16ToUTF8(title);
+    format_map_.Insert(gfx::GetAtom(kNetscapeURL),
+                       scoped_refptr<base::RefCountedMemory>(
+                           base::RefCountedString::TakeString(&netscape_url)));
+  }
+}
+
+void OSExchangeDataProviderAuraX11Base::SetFilename(
+    const base::FilePath& path) {
+  std::vector<FileInfo> data;
+  data.push_back(FileInfo(path, base::FilePath()));
+  SetFilenames(data);
+}
+
+void OSExchangeDataProviderAuraX11Base::SetFilenames(
+    const std::vector<FileInfo>& filenames) {
+  std::vector<std::string> paths;
+  for (std::vector<FileInfo>::const_iterator it = filenames.begin();
+       it != filenames.end(); ++it) {
+    std::string url_spec = net::FilePathToFileURL(it->path).spec();
+    if (!url_spec.empty())
+      paths.push_back(url_spec);
+  }
+
+  std::string joined_data = base::JoinString(paths, "\n");
+  scoped_refptr<base::RefCountedMemory> mem(
+      base::RefCountedString::TakeString(&joined_data));
+  format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeURIList), mem);
+}
+
+void OSExchangeDataProviderAuraX11Base::SetPickledData(
+    const Clipboard::FormatType& format,
+    const base::Pickle& pickle) {
+  const unsigned char* data =
+      reinterpret_cast<const unsigned char*>(pickle.data());
+
+  std::vector<unsigned char> bytes;
+  bytes.insert(bytes.end(), data, data + pickle.size());
+  scoped_refptr<base::RefCountedMemory> mem(
+      base::RefCountedBytes::TakeVector(&bytes));
+
+  format_map_.Insert(gfx::GetAtom(format.ToString().c_str()), mem);
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetString(
+    base::string16* result) const {
+  if (HasFile()) {
+    // Various Linux file managers both pass a list of file:// URIs and set the
+    // string representation to the URI. We explicitly don't want to return use
+    // this representation.
+    return false;
+  }
+
+  std::vector<::Atom> text_atoms = ui::GetTextAtomsFrom();
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(text_atoms, GetTargets(), &requested_types);
+
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    std::string text = data.GetText();
+    *result = base::UTF8ToUTF16(text);
+    return true;
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetURLAndTitle(
+    OSExchangeData::FilenameToURLPolicy policy,
+    GURL* url,
+    base::string16* title) const {
+  std::vector<::Atom> url_atoms = ui::GetURLAtomsFrom();
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    // TODO(erg): Technically, both of these forms can accept multiple URLs,
+    // but that doesn't match the assumptions of the rest of the system which
+    // expect single types.
+
+    if (data.GetType() == gfx::GetAtom(Clipboard::kMimeTypeMozillaURL)) {
+      // Mozilla URLs are (UTF16: URL, newline, title).
+      base::string16 unparsed;
+      data.AssignTo(&unparsed);
+
+      std::vector<base::string16> tokens =
+          base::SplitString(unparsed, base::ASCIIToUTF16("\n"),
+                            base::KEEP_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
+      if (tokens.size() > 0) {
+        if (tokens.size() > 1)
+          *title = tokens[1];
+        else
+          *title = base::string16();
+
+        *url = GURL(tokens[0]);
+        return true;
+      }
+    } else if (data.GetType() == gfx::GetAtom(Clipboard::kMimeTypeURIList)) {
+      std::vector<std::string> tokens = ui::ParseURIList(data);
+      for (std::vector<std::string>::const_iterator it = tokens.begin();
+           it != tokens.end(); ++it) {
+        GURL test_url(*it);
+        if (!test_url.SchemeIsFile() ||
+            policy == OSExchangeData::CONVERT_FILENAMES) {
+          *url = test_url;
+          *title = base::string16();
+          return true;
+        }
+      }
+    }
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetFilename(
+    base::FilePath* path) const {
+  std::vector<FileInfo> filenames;
+  if (GetFilenames(&filenames)) {
+    *path = filenames.front().path;
+    return true;
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetFilenames(
+    std::vector<FileInfo>* filenames) const {
+  std::vector<::Atom> url_atoms = ui::GetURIListAtomsFrom();
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  filenames->clear();
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    std::vector<std::string> tokens = ui::ParseURIList(data);
+    for (std::vector<std::string>::const_iterator it = tokens.begin();
+         it != tokens.end(); ++it) {
+      GURL url(*it);
+      base::FilePath file_path;
+      if (url.SchemeIsFile() && net::FileURLToFilePath(url, &file_path)) {
+        filenames->push_back(FileInfo(file_path, base::FilePath()));
+      }
+    }
+  }
+
+  return !filenames->empty();
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetPickledData(
+    const Clipboard::FormatType& format,
+    base::Pickle* pickle) const {
+  std::vector<::Atom> requested_types;
+  requested_types.push_back(gfx::GetAtom(format.ToString().c_str()));
+
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    // Note that the pickle object on the right hand side of the assignment
+    // only refers to the bytes in |data|. The assignment copies the data.
+    *pickle = base::Pickle(reinterpret_cast<const char*>(data.GetData()),
+                           static_cast<int>(data.GetSize()));
+    return true;
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::HasString() const {
+  std::vector<::Atom> text_atoms = ui::GetTextAtomsFrom();
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(text_atoms, GetTargets(), &requested_types);
+  return !requested_types.empty() && !HasFile();
+}
+
+bool OSExchangeDataProviderAuraX11Base::HasURL(
+    OSExchangeData::FilenameToURLPolicy policy) const {
+  std::vector<::Atom> url_atoms = ui::GetURLAtomsFrom();
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  if (requested_types.empty())
+    return false;
+
+  // The Linux desktop doesn't differentiate between files and URLs like
+  // Windows does and stuffs all the data into one mime type.
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    if (data.GetType() == gfx::GetAtom(Clipboard::kMimeTypeMozillaURL)) {
+      // File managers shouldn't be using this type, so this is a URL.
+      return true;
+    } else if (data.GetType() ==
+               gfx::GetAtom(ui::Clipboard::kMimeTypeURIList)) {
+      std::vector<std::string> tokens = ui::ParseURIList(data);
+      for (std::vector<std::string>::const_iterator it = tokens.begin();
+           it != tokens.end(); ++it) {
+        if (!GURL(*it).SchemeIsFile() ||
+            policy == OSExchangeData::CONVERT_FILENAMES)
+          return true;
+      }
+
+      return false;
+    }
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::HasFile() const {
+  std::vector<::Atom> url_atoms = ui::GetURIListAtomsFrom();
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  if (requested_types.empty())
+    return false;
+
+  // To actually answer whether we have a file, we need to look through the
+  // contents of the kMimeTypeURIList type, and see if any of them are file://
+  // URIs.
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    std::vector<std::string> tokens = ui::ParseURIList(data);
+    for (std::vector<std::string>::const_iterator it = tokens.begin();
+         it != tokens.end(); ++it) {
+      GURL url(*it);
+      base::FilePath file_path;
+      if (url.SchemeIsFile() && net::FileURLToFilePath(url, &file_path))
+        return true;
+    }
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::HasCustomFormat(
+    const Clipboard::FormatType& format) const {
+  std::vector<::Atom> url_atoms;
+  url_atoms.push_back(gfx::GetAtom(format.ToString().c_str()));
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  return !requested_types.empty();
+}
+
+void OSExchangeDataProviderAuraX11Base::SetHtml(const base::string16& html,
+                                                const GURL& base_url) {
+  std::vector<unsigned char> bytes;
+  // Manually jam a UTF16 BOM into bytes because otherwise, other programs will
+  // assume UTF-8.
+  bytes.push_back(0xFF);
+  bytes.push_back(0xFE);
+  ui::AddString16ToVector(html, &bytes);
+  scoped_refptr<base::RefCountedMemory> mem(
+      base::RefCountedBytes::TakeVector(&bytes));
+
+  format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeHTML), mem);
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetHtml(base::string16* html,
+                                                GURL* base_url) const {
+  std::vector<::Atom> url_atoms;
+  url_atoms.push_back(gfx::GetAtom(Clipboard::kMimeTypeHTML));
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    *html = data.GetHtml();
+    *base_url = GURL();
+    return true;
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::HasHtml() const {
+  std::vector<::Atom> url_atoms;
+  url_atoms.push_back(gfx::GetAtom(Clipboard::kMimeTypeHTML));
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  return !requested_types.empty();
+}
+
+void OSExchangeDataProviderAuraX11Base::SetDragImage(
+    const gfx::ImageSkia& image,
+    const gfx::Vector2d& cursor_offset) {
+  drag_image_ = image;
+  drag_image_offset_ = cursor_offset;
+}
+
+gfx::ImageSkia OSExchangeDataProviderAuraX11Base::GetDragImage() const {
+  return drag_image_;
+}
+
+gfx::Vector2d OSExchangeDataProviderAuraX11Base::GetDragImageOffset() const {
+  return drag_image_offset_;
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetPlainTextURL(GURL* url) const {
+  base::string16 text;
+  if (GetString(&text)) {
+    GURL test_url(text);
+    if (test_url.is_valid()) {
+      *url = test_url;
+      return true;
+    }
+  }
+
+  return false;
+}
+
+std::vector<::Atom> OSExchangeDataProviderAuraX11Base::GetTargets() const {
+  return format_map_.GetTypes();
+}
+
+}  // namespace ui
diff --git a/ui/base/dragdrop/os_exchange_data_provider_aurax11_base.h b/ui/base/dragdrop/os_exchange_data_provider_aurax11_base.h
new file mode 100644
index 0000000000000..ae7e3fbe1eceb
--- /dev/null
+++ b/ui/base/dragdrop/os_exchange_data_provider_aurax11_base.h
@@ -0,0 +1,135 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_AURAX11_BASE_H_
+#define UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_AURAX11_BASE_H_
+
+#include <stdint.h>
+#include <map>
+
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/pickle.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/base/x/selection_owner.h"
+#include "ui/base/x/selection_requestor.h"
+#include "ui/base/x/selection_utils.h"
+#include "ui/events/platform/platform_event_dispatcher.h"
+#include "ui/gfx/geometry/vector2d.h"
+#include "ui/gfx/image/image_skia.h"
+#include "ui/gfx/x/x11.h"
+#include "url/gurl.h"
+
+namespace ui {
+
+class Clipboard;
+class OSExchangeDataProviderAuraX11Test;
+
+// OSExchangeData::Provider implementation for aura on linux.
+class UI_BASE_EXPORT OSExchangeDataProviderAuraX11Base
+    : public OSExchangeData::Provider {
+ public:
+  // |x_window| is the window the cursor is over, and |selection| is the set of
+  // data being offered.
+  OSExchangeDataProviderAuraX11Base(::Window x_window,
+                                    const SelectionFormatMap& selection);
+
+  // Creates a Provider for sending drag information. This creates its own,
+  // hidden X11 window to own send data.
+  OSExchangeDataProviderAuraX11Base();
+
+  ~OSExchangeDataProviderAuraX11Base() override;
+
+  // After all the Set* methods have built up the data we're offering, call
+  // this to take ownership of the XdndSelection clipboard.
+  void TakeOwnershipOfSelection() const;
+
+  // Retrieves a list of types we're offering. Noop if we haven't taken the
+  // selection.
+  void RetrieveTargets(std::vector<Atom>* targets) const;
+
+  // Makes a copy of the format map currently being offered.
+  SelectionFormatMap GetFormatMap() const;
+
+  const base::FilePath& file_contents_name() const {
+    return file_contents_name_;
+  }
+
+  // Overridden from OSExchangeData::Provider:
+  std::unique_ptr<Provider> Clone() const override;
+  void MarkOriginatedFromRenderer() override;
+  bool DidOriginateFromRenderer() const override;
+  void SetString(const base::string16& data) override;
+  void SetURL(const GURL& url, const base::string16& title) override;
+  void SetFilename(const base::FilePath& path) override;
+  void SetFilenames(const std::vector<FileInfo>& filenames) override;
+  void SetPickledData(const Clipboard::FormatType& format,
+                      const base::Pickle& pickle) override;
+  bool GetString(base::string16* data) const override;
+  bool GetURLAndTitle(OSExchangeData::FilenameToURLPolicy policy,
+                      GURL* url,
+                      base::string16* title) const override;
+  bool GetFilename(base::FilePath* path) const override;
+  bool GetFilenames(std::vector<FileInfo>* filenames) const override;
+  bool GetPickledData(const Clipboard::FormatType& format,
+                      base::Pickle* pickle) const override;
+  bool HasString() const override;
+  bool HasURL(OSExchangeData::FilenameToURLPolicy policy) const override;
+  bool HasFile() const override;
+  bool HasCustomFormat(const Clipboard::FormatType& format) const override;
+
+  void SetHtml(const base::string16& html, const GURL& base_url) override;
+  bool GetHtml(base::string16* html, GURL* base_url) const override;
+  bool HasHtml() const override;
+  void SetDragImage(const gfx::ImageSkia& image,
+                    const gfx::Vector2d& cursor_offset) override;
+  gfx::ImageSkia GetDragImage() const override;
+  gfx::Vector2d GetDragImageOffset() const override;
+
+ protected:
+  friend class OSExchangeDataProviderAuraX11Test;
+  typedef std::map<Clipboard::FormatType, base::Pickle> PickleData;
+
+  // Returns true if |formats_| contains a string format and the string can be
+  // parsed as a URL.
+  bool GetPlainTextURL(GURL* url) const;
+
+  // Returns the targets in |format_map_|.
+  std::vector<::Atom> GetTargets() const;
+
+  // Drag image and offset data.
+  gfx::ImageSkia drag_image_;
+  gfx::Vector2d drag_image_offset_;
+
+  // Our X11 state.
+  Display* x_display_;
+  ::Window x_root_window_;
+
+  // In X11, because the IPC parts of drag operations are implemented by
+  // XSelection, we require an x11 window to receive drag messages on. The
+  // OSExchangeDataProvider system is modeled on the Windows implementation,
+  // which does not require a window. We only sometimes have a valid window
+  // available (in the case of drag receiving). Other times, we need to create
+  // our own xwindow just to receive events on it.
+  const bool own_window_;
+
+  ::Window x_window_;
+
+  // A representation of data. This is either passed to us from the other
+  // process, or built up through a sequence of Set*() calls. It can be passed
+  // to |selection_owner_| when we take the selection.
+  SelectionFormatMap format_map_;
+
+  // Auxilary data for the X Direct Save protocol.
+  base::FilePath file_contents_name_;
+
+  // Takes a snapshot of |format_map_| and offers it to other windows.
+  mutable SelectionOwner selection_owner_;
+
+  DISALLOW_COPY_AND_ASSIGN(OSExchangeDataProviderAuraX11Base);
+};
+
+}  // namespace ui
+
+#endif  // UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_AURAX11_BASE_H_
diff --git a/ui/ozone/platform/x11/BUILD.gn b/ui/ozone/platform/x11/BUILD.gn
index f0655fb8227c8..16cb495ed805c 100644
--- a/ui/ozone/platform/x11/BUILD.gn
+++ b/ui/ozone/platform/x11/BUILD.gn
@@ -28,6 +28,12 @@ source_set("x11") {
     "x11_display_manager_ozone.h",
     "x11_native_display_delegate.cc",
     "x11_native_display_delegate.h",
+    "x11_drag_context.h",
+    "x11_drag_context.cc",
+    "x11_drag_source.h",
+    "x11_drag_source.cc",
+    "x11_drag_util.h",
+    "x11_drag_util.cc",
     "x11_surface_factory.cc",
     "x11_surface_factory.h",
     "x11_window_manager_ozone.cc",
diff --git a/ui/ozone/platform/x11/x11_drag_context.cc b/ui/ozone/platform/x11/x11_drag_context.cc
new file mode 100644
index 0000000000000..7202b48419781
--- /dev/null
+++ b/ui/ozone/platform/x11/x11_drag_context.cc
@@ -0,0 +1,251 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/ozone/platform/x11/x11_drag_context.h"
+
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/base/dragdrop/os_exchange_data_provider_aurax11_base.h"
+#include "ui/base/x/x11_util.h"
+#include "ui/base/x/x11_window_event_manager.h"
+#include "ui/events/platform/x11/x11_event_source.h"
+#include "ui/gfx/x/x11.h"
+#include "ui/gfx/x/x11_atom_cache.h"
+#include "ui/ozone/platform/x11/x11_drag_util.h"
+#include "ui/ozone/platform/x11/x11_window_ozone.h"
+
+namespace ui {
+
+namespace {
+
+constexpr int kWillAcceptDrop = 1;
+constexpr int kWantFurtherPosEvents = 2;
+
+// Window property that will receive the drag and drop selection data.
+const char kChromiumDragReciever[] = "_CHROMIUM_DRAG_RECEIVER";
+
+}  // namespace
+
+X11DragContext::X11DragContext(X11WindowOzone* window,
+                               XID local_window,
+                               const XClientMessageEvent& event,
+                               const SelectionFormatMap* map)
+    : window_(window),
+      local_window_(local_window),
+      source_window_(event.data.l[0]),
+      waiting_to_handle_position_(false),
+      suggested_action_(x11::None) {
+  if (!map) {
+    bool get_types_from_property = ((event.data.l[1] & 1) != 0);
+
+    if (get_types_from_property) {
+      if (!ui::GetAtomArrayProperty(source_window_, kXdndTypeList,
+                                    &unfetched_targets_)) {
+        return;
+      }
+    } else {
+      // data.l[2,3,4] contain the first three types. Unused slots can be None.
+      for (int i = 0; i < 3; ++i) {
+        if (event.data.l[2 + i] != x11::None) {
+          unfetched_targets_.push_back(event.data.l[2 + i]);
+        }
+      }
+    }
+
+#if DCHECK_IS_ON()
+    DVLOG(1) << "XdndEnter has " << unfetched_targets_.size() << " data types";
+    for (::Atom target : unfetched_targets_) {
+      DVLOG(1) << "XdndEnter data type: " << target;
+    }
+#endif  // DCHECK_IS_ON()
+
+    // The window doesn't have a DesktopDragDropClientAura, that means it's
+    // created by some other process. Listen for messages on it.
+    source_window_events_.reset(
+        new ui::XScopedEventSelector(source_window_, PropertyChangeMask));
+
+    // We must perform a full sync here because we could be racing
+    // |source_window_|.
+    XSync(gfx::GetXDisplay(), x11::False);
+  } else {
+    // This drag originates from an aura window within our process. This means
+    // that we can shortcut the X11 server and ask the owning SelectionOwner
+    // for the data it's offering.
+    fetched_targets_ = *map;
+  }
+
+  ReadActions();
+}
+
+X11DragContext::~X11DragContext() = default;
+
+void X11DragContext::OnXdndPosition(const XClientMessageEvent& event) {
+  unsigned long source_window = event.data.l[0];
+  int x_root_window = event.data.l[2] >> 16;
+  int y_root_window = event.data.l[2] & 0xffff;
+  ::Time time_stamp = event.data.l[3];
+  ::Atom suggested_action = event.data.l[4];
+
+  OnXdndPositionMessage(suggested_action, source_window, time_stamp,
+                        gfx::PointF(x_root_window, y_root_window));
+}
+
+void X11DragContext::OnXdndPositionMessage(
+    ::Atom suggested_action,
+    XID source_window,
+    ::Time time_stamp,
+    const gfx::PointF& screen_point) {
+  DCHECK_EQ(source_window_, source_window);
+  suggested_action_ = suggested_action;
+
+  if (!unfetched_targets_.empty()) {
+    // We have unfetched targets. That means we need to pause the handling of
+    // the position message and ask the other window for its data.
+    screen_point_ = screen_point;
+    position_time_stamp_ = time_stamp;
+    waiting_to_handle_position_ = true;
+
+    fetched_targets_ = ui::SelectionFormatMap();
+    RequestNextTarget();
+  } else {
+    CompleteXdndPosition(source_window, screen_point);
+  }
+}
+
+void X11DragContext::RequestNextTarget() {
+  DCHECK(!unfetched_targets_.empty());
+  DCHECK(waiting_to_handle_position_);
+
+  ::Atom target = unfetched_targets_.back();
+  unfetched_targets_.pop_back();
+
+  XConvertSelection(gfx::GetXDisplay(), gfx::GetAtom(kXdndSelection), target,
+                    gfx::GetAtom(kChromiumDragReciever), local_window_,
+                    position_time_stamp_);
+}
+
+void X11DragContext::OnSelectionNotify(const XSelectionEvent& event) {
+  if (!waiting_to_handle_position_) {
+    // A misbehaved window may send SelectionNotify without us requesting data
+    // via XConvertSelection().
+    return;
+  }
+
+  DVLOG(1) << "SelectionNotify, format " << event.target;
+
+  if (event.property != x11::None) {
+    DCHECK_EQ(event.property, gfx::GetAtom(kChromiumDragReciever));
+
+    scoped_refptr<base::RefCountedMemory> data;
+    ::Atom type = x11::None;
+    if (ui::GetRawBytesOfProperty(local_window_, event.property, &data, NULL,
+                                  &type)) {
+      fetched_targets_.Insert(event.target, data);
+    }
+  } else {
+    // The source failed to convert the drop data to the format (target in X11
+    // parlance) that we asked for. This happens, even though we only ask for
+    // the formats advertised by the source. http://crbug.com/628099
+    DVLOG(1) << "XConvertSelection failed for source-advertised target "
+               << event.target;
+  }
+
+  if (!unfetched_targets_.empty()) {
+    RequestNextTarget();
+  } else {
+    waiting_to_handle_position_ = false;
+    CompleteXdndPosition(source_window_, screen_point_);
+  }
+}
+
+void X11DragContext::ReadActions() {
+  std::vector<::Atom> atom_array;
+  if (!ui::GetAtomArrayProperty(source_window_, kXdndActionList, &atom_array)) {
+    actions_.clear();
+  } else {
+    actions_.swap(atom_array);
+  }
+}
+
+int X11DragContext::GetDragOperation() const {
+  int drag_operation = ui::DragDropTypes::DRAG_NONE;
+  for (std::vector<::Atom>::const_iterator it = actions_.begin();
+       it != actions_.end(); ++it) {
+    MaskOperation(*it, &drag_operation);
+  }
+
+  MaskOperation(suggested_action_, &drag_operation);
+
+  return drag_operation;
+}
+
+void X11DragContext::MaskOperation(::Atom xdnd_operation,
+                                   int* drag_operation) const {
+  if (xdnd_operation == gfx::GetAtom(kXdndActionCopy))
+    *drag_operation |= ui::DragDropTypes::DRAG_COPY;
+  else if (xdnd_operation == gfx::GetAtom(kXdndActionMove))
+    *drag_operation |= ui::DragDropTypes::DRAG_MOVE;
+  else if (xdnd_operation == gfx::GetAtom(kXdndActionLink))
+    *drag_operation |= ui::DragDropTypes::DRAG_LINK;
+}
+
+void X11DragContext::CompleteXdndPosition(XID source_window,
+                                          const gfx::PointF& screen_point) {
+  // int drag_operation = ui::DragDropTypes::DRAG_COPY;
+  std::unique_ptr<OSExchangeData> data = std::make_unique<OSExchangeData>(
+      std::make_unique<OSExchangeDataProviderAuraX11Base>(local_window_,
+                                                          fetched_targets()));
+  int drag_operation = GetDragOperation();
+  // KDE-based file browsers such as Dolphin change the drag operation depending
+  // on whether alt/ctrl/shift was pressed. However once Chromium gets control
+  // over the X11 events, the source application does no longer receive X11
+  // events for key modifier changes, so the dnd operation gets stuck in an
+  // incorrect state. Blink can only dnd-open files of type DRAG_COPY, so the
+  // DRAG_COPY mask is added if the dnd object is a file.
+  if (drag_operation &
+          (ui::DragDropTypes::DRAG_MOVE | ui::DragDropTypes::DRAG_LINK) &&
+      data->HasFile()) {
+    drag_operation |= ui::DragDropTypes::DRAG_COPY;
+  }
+
+  if (!sent_entered_) {
+    window_->OnDragDataCollected(screen_point, std::move(data), drag_operation);
+    sent_entered_ = true;
+  }
+  window_->OnDragMotion(screen_point, 0, position_time_stamp_, drag_operation);
+
+  // Sends an XdndStatus message back to the source_window. l[2,3]
+  // theoretically represent an area in the window where the current action is
+  // the same as what we're returning, but I can't find any implementation that
+  // actually making use of this. A client can return (0, 0) and/or set the
+  // first bit of l[1] to disable the feature, and it appears that gtk neither
+  // sets this nor respects it if set.
+  XEvent xev;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = gfx::GetAtom(kXdndStatus);
+  xev.xclient.format = 32;
+  xev.xclient.window = source_window;
+  xev.xclient.data.l[0] = local_window_;
+  xev.xclient.data.l[1] =
+      (drag_operation != 0) ? (kWantFurtherPosEvents | kWillAcceptDrop) : 0;
+  xev.xclient.data.l[2] = 0;
+  xev.xclient.data.l[3] = 0;
+  xev.xclient.data.l[4] = DragOperationToAtom(drag_operation);
+
+  ui::SendXClientEvent(source_window, &xev);
+}
+
+void X11DragContext::OnXdndDrop(int drag_operation) {
+  XEvent xev;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = gfx::GetAtom(kXdndFinished);
+  xev.xclient.format = 32;
+  xev.xclient.window = source_window();
+  xev.xclient.data.l[0] = local_window_;
+  xev.xclient.data.l[1] = (drag_operation != 0) ? 1 : 0;
+  xev.xclient.data.l[2] = DragOperationToAtom(drag_operation);
+
+  ui::SendXClientEvent(source_window(), &xev);
+}
+
+}  // namespace ui
diff --git a/ui/ozone/platform/x11/x11_drag_context.h b/ui/ozone/platform/x11/x11_drag_context.h
new file mode 100644
index 0000000000000..191c1beae0ae4
--- /dev/null
+++ b/ui/ozone/platform/x11/x11_drag_context.h
@@ -0,0 +1,115 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PLATFORM_X11_X11_DRAG_CONTEXT_H_
+#define UI_OZONE_PLATFORM_X11_X11_DRAG_CONTEXT_H_
+
+#include "ui/base/x/selection_utils.h"
+#include "ui/gfx/x/x11.h"
+#include "ui/gfx/x/x11_atom_cache.h"
+#include "ui/gfx/geometry/point_f.h"
+
+namespace ui {
+
+class XScopedEventSelector;
+class X11WindowOzone;
+
+class X11DragContext {
+ public:
+  X11DragContext(X11WindowOzone* window,
+                 XID local_window,
+                 const XClientMessageEvent& event,
+                 const SelectionFormatMap* map);
+  ~X11DragContext();
+
+  void OnXdndPosition(const XClientMessageEvent& event);
+  // When we receive an XdndPosition message, we need to have all the data
+  // copied from the other window before we process the XdndPosition
+  // message. If we have that data already, dispatch immediately. Otherwise,
+  // delay dispatching until we do.
+  void OnXdndPositionMessage(::Atom suggested_action,
+                             XID source_window,
+                             ::Time time_stamp,
+                             const gfx::PointF& screen_point);
+
+  // Called when XSelection data has been copied to our process.
+  void OnSelectionNotify(const XSelectionEvent& xselection);
+
+  void OnXdndDrop(int drag_operation);
+
+  // Clones the fetched targets.
+  const ui::SelectionFormatMap& fetched_targets() { return fetched_targets_; }
+
+  // Reads the kXdndActionList property from |source_window| and copies it
+  // into |actions|.
+  void ReadActions();
+
+  // Creates a ui::DragDropTypes::DragOperation representation of the current
+  // action list.
+  int GetDragOperation() const;
+
+  // views::DesktopDragDropClientOzone* source_client() { return source_client_; }
+
+  XID source_window() { return source_window_; }
+
+ private:
+  // Called to request the next target from the source window. This is only
+  // done on the first XdndPosition; after that, we cache the data offered by
+  // the source window.
+  void RequestNextTarget();
+
+  // Masks the X11 atom |xdnd_operation|'s views representation onto
+  // |drag_operation|.
+  void MaskOperation(::Atom xdnd_operation, int* drag_operation) const;
+
+  void CompleteXdndPosition(::Window source_window,
+                            const gfx::PointF& screen_point);
+
+  void SendXClientEvent(XID xid, XEvent* xev);
+
+  X11WindowOzone* window_;
+
+  // The XID of our chrome local aura window handling our events.
+  XID local_window_;
+
+  // The XID of the window that's initiated the drag.
+  XID source_window_;
+
+  // Events that we have selected on |source_window_|.
+  std::unique_ptr<ui::XScopedEventSelector> source_window_events_;
+
+  // Whether we're blocking the handling of an XdndPosition message by waiting
+  // for |unfetched_targets_| to be fetched.
+  bool waiting_to_handle_position_;
+
+  // Where the cursor is on screen.
+  gfx::PointF screen_point_;
+
+  // The time stamp of the last XdndPosition event we received. The XDND
+  // specification mandates that we use this time stamp when querying the source
+  // about the drag and drop data.
+  ::Time position_time_stamp_;
+
+  // A SelectionFormatMap of data that we have in our process.
+  ui::SelectionFormatMap fetched_targets_;
+
+  // The names of various data types offered by the other window that we
+  // haven't fetched and put in |fetched_targets_| yet.
+  std::vector<::Atom> unfetched_targets_;
+
+  // XdndPosition messages have a suggested action. Qt applications exclusively
+  // use this, instead of the XdndActionList which is backed by |actions_|.
+  ::Atom suggested_action_;
+
+  // Possible actions.
+  std::vector<::Atom> actions_;
+
+  bool sent_entered_ = false;
+
+  DISALLOW_COPY_AND_ASSIGN(X11DragContext);
+};
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_X11_X11_DRAG_CONTEXT_H_
diff --git a/ui/ozone/platform/x11/x11_drag_source.cc b/ui/ozone/platform/x11/x11_drag_source.cc
new file mode 100644
index 0000000000000..c2c3d7eca545f
--- /dev/null
+++ b/ui/ozone/platform/x11/x11_drag_source.cc
@@ -0,0 +1,458 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/ozone/platform/x11/x11_drag_source.h"
+
+#include "base/threading/thread_task_runner_handle.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/base/x/x11_window_event_manager.h"
+#include "ui/events/event.h"
+#include "ui/events/event_utils.h"
+#include "ui/events/platform/scoped_event_dispatcher.h"
+#include "ui/ozone/platform/x11/x11_drag_util.h"
+#include "ui/ozone/platform/x11/x11_window_ozone.h"
+
+namespace ui {
+
+namespace {
+
+// The time to wait since sending the last XdndPosition message before
+// reprocessing the most recent mouse move event in case that the window
+// stacking order has changed and |source_current_window_| needs to be updated.
+const int kRepeatMouseMoveTimeoutMs = 350;
+
+// The time to wait for the target to respond after the user has released the
+// mouse button before ending the move loop.
+const int kEndMoveLoopTimeoutMs = 1000;
+
+XID ValidateXdndWindow(XID window) {
+  if (window == x11::None)
+    return x11::None;
+
+  // TODO(crbug/651775): The proxy window should be reported separately from the
+  //     target window. XDND messages should be sent to the proxy, and their
+  //     window field should point to the target.
+
+  // Figure out which window we should test as XdndAware. If |target| has
+  // XdndProxy, it will set that proxy on target, and if not, |target|'s
+  // original value will remain.
+  ui::GetXIDProperty(window, kXdndProxy, &window);
+
+  int version;
+  if (ui::GetIntProperty(window, kXdndAware, &version) &&
+      version >= kMaxXdndVersion) {
+    return window;
+  }
+  return x11::None;
+}
+
+}  // namespace
+
+X11DragSource::X11DragSource(X11WindowOzone* window,
+                             XID xwindow,
+                             int operation,
+                             const ui::OSExchangeData& data)
+    : window_(window),
+      xwindow_(xwindow),
+      drag_operation_(operation),
+      negotiated_operation_(ui::DragDropTypes::DRAG_NONE),
+      source_state_(SOURCE_STATE_OTHER),
+      format_map_(),
+      selection_owner_(gfx::GetXDisplay(),
+                       xwindow,
+                       gfx::GetAtom(kXdndSelection)),
+      screen_point_(gfx::Point()),
+      weak_factory_(this) {
+  XStoreName(gfx::GetXDisplay(), xwindow, "Chromium Drag & Drop Window");
+  CreateDragInputWindow(gfx::GetXDisplay());
+
+  base::string16 str;
+  const OSExchangeData::FilenameToURLPolicy policy =
+      OSExchangeData::FilenameToURLPolicy::DO_NOT_CONVERT_FILENAMES;
+  if (data.HasURL(policy)) {
+    GURL url;
+    base::string16 title;
+    data.GetURLAndTitle(policy, &url, &title);
+    InsertURLToSelectionFormatMap(url, title, &format_map_);
+  }
+  if (data.GetString(&str)) {
+    InsertStringToSelectionFormatMap(str, &format_map_);
+  }
+  selection_owner_.TakeOwnershipOfSelection(format_map_);
+
+  old_dispatcher_ = std::move(nested_dispatcher_);
+  nested_dispatcher_ =
+      ui::PlatformEventSource::GetInstance()->OverrideDispatcher(this);
+}
+
+X11DragSource::~X11DragSource() {
+  window_ = nullptr;
+  last_motion_in_screen_.reset();
+
+  if (source_current_window_ != gfx::kNullAcceleratedWidget) {
+    SendXdndLeave(source_current_window_);
+    source_current_window_ = gfx::kNullAcceleratedWidget;
+  }
+  repeat_mouse_move_timer_.Stop();
+  end_move_loop_timer_.Stop();
+
+  grab_input_window_events_.reset();
+  XDestroyWindow(gfx::GetXDisplay(), grab_input_window_);
+  grab_input_window_ = gfx::kNullAcceleratedWidget;
+
+  nested_dispatcher_ = std::move(old_dispatcher_);
+}
+
+void X11DragSource::OnXdndStatus(const XClientMessageEvent& event) {
+  DVLOG(1) << "OnXdndStatus";
+
+  gfx::AcceleratedWidget source_window = event.data.l[0];
+
+  if (source_window != source_current_window_)
+    return;
+
+  if (source_state_ != SOURCE_STATE_PENDING_DROP &&
+      source_state_ != SOURCE_STATE_OTHER) {
+    return;
+  }
+
+  waiting_on_status_ = false;
+  status_received_since_enter_ = true;
+
+  if (event.data.l[1] & 1) {
+    ::Atom atom_operation = event.data.l[4];
+    negotiated_operation_ = AtomToDragOperation(atom_operation);
+  } else {
+    negotiated_operation_ = ui::DragDropTypes::DRAG_NONE;
+  }
+
+  if (source_state_ == SOURCE_STATE_PENDING_DROP) {
+    // We were waiting on the status message so we could send the XdndDrop.
+    if (negotiated_operation_ == ui::DragDropTypes::DRAG_NONE) {
+      FinishDragDrop();
+      return;
+    }
+    source_state_ = SOURCE_STATE_DROPPED;
+    SendXdndDrop(source_window);
+    return;
+  }
+
+  ui::CursorType cursor_type = ui::CursorType::kNull;
+  switch (negotiated_operation_) {
+    case ui::DragDropTypes::DRAG_NONE:
+      cursor_type = ui::CursorType::kDndNone;
+      break;
+    case ui::DragDropTypes::DRAG_MOVE:
+      cursor_type = ui::CursorType::kDndMove;
+      break;
+    case ui::DragDropTypes::DRAG_COPY:
+      cursor_type = ui::CursorType::kDndCopy;
+      break;
+    case ui::DragDropTypes::DRAG_LINK:
+      cursor_type = ui::CursorType::kDndLink;
+      break;
+  }
+  // Note: event.data.[2,3] specify a rectangle. It is a request by the other
+  // window to not send further XdndPosition messages while the cursor is
+  // within it. However, it is considered advisory and (at least according to
+  // the spec) the other side must handle further position messages within
+  // it. GTK+ doesn't bother with this, so neither should we.
+
+  if (next_position_message_.get()) {
+    // We were waiting on the status message so we could send off the next
+    // position message we queued up.
+    gfx::Point p = next_position_message_->first;
+    unsigned long event_time = next_position_message_->second;
+    next_position_message_.reset();
+
+    SendXdndPosition(source_window, p, event_time);
+  }
+}
+
+void X11DragSource::OnXdndFinished(const XClientMessageEvent& event) {
+  gfx::AcceleratedWidget source_window = event.data.l[0];
+  if (source_current_window_ != source_window)
+    return;
+
+  // Clear |negotiated_operation_| if the drag was rejected.
+  if ((event.data.l[1] & 1) == 0)
+    negotiated_operation_ = ui::DragDropTypes::DRAG_NONE;
+
+  // Clear |source_current_window_| to avoid sending XdndLeave upon ending the
+  // move loop.
+  source_current_window_ = gfx::kNullAcceleratedWidget;
+  FinishDragDrop();
+}
+
+void X11DragSource::OnSelectionRequest(const XEvent& event) {
+  selection_owner_.OnSelectionRequest(event);
+}
+
+DragDropTypes::DragOperation X11DragSource::negotiated_operation() {
+  return negotiated_operation_;
+}
+
+bool X11DragSource::CanDispatchEvent(const ui::PlatformEvent& event) {
+  return true;
+}
+
+uint32_t X11DragSource::DispatchEvent(const ui::PlatformEvent& event) {
+  DCHECK(base::MessageLoopForUI::IsCurrent());
+
+  // This method processes all events while the move loop is active.
+  ui::EventType type = event->type();
+  switch (type) {
+    case ui::ET_MOUSE_MOVED:
+    case ui::ET_MOUSE_DRAGGED: {
+      bool dispatch_mouse_event = !last_motion_in_screen_.get();
+      last_motion_in_screen_.reset(
+          ui::EventFromNative(event).release()->AsMouseEvent());
+
+      last_motion_in_screen_->set_location(
+          ui::EventSystemLocationFromNative(event));
+      if (dispatch_mouse_event) {
+        // Post a task to dispatch mouse movement event when control returns to
+        // the message loop. This allows smoother dragging since the events are
+        // dispatched without waiting for the drag widget updates.
+        base::ThreadTaskRunnerHandle::Get()->PostTask(
+            FROM_HERE, base::Bind(&X11DragSource::DispatchMouseMovement,
+                                  weak_factory_.GetWeakPtr()));
+      }
+      return ui::POST_DISPATCH_NONE;
+    } break;
+    case ui::ET_MOUSE_RELEASED: {
+      // TODO: left button checking.
+      // Assume that drags are being done with the left mouse button. Only
+      // break the drag if the left mouse button was released.
+      DispatchMouseMovement();
+      HandleMouseRelease();
+
+      if (!grabbed_pointer_) {
+        // If the source widget had capture prior to the move loop starting,
+        // it may be relying on views::Widget getting the mouse release and
+        // releasing capture in Widget::OnMouseEvent().
+        return ui::POST_DISPATCH_PERFORM_DEFAULT;
+      }
+    } break;
+    default:
+      break;
+  }
+  return ui::POST_DISPATCH_PERFORM_DEFAULT;
+}
+
+void X11DragSource::CreateDragInputWindow(XDisplay* display) {
+  unsigned long attribute_mask = CWEventMask | CWOverrideRedirect;
+  XSetWindowAttributes swa;
+  memset(&swa, 0, sizeof(swa));
+  swa.override_redirect = x11::True;
+  grab_input_window_ = XCreateWindow(display, DefaultRootWindow(display), -100,
+                                     -100, 10, 10, 0, CopyFromParent, InputOnly,
+                                     CopyFromParent, attribute_mask, &swa);
+  uint32_t event_mask = ButtonPressMask | ButtonReleaseMask |
+                        PointerMotionMask | KeyPressMask | KeyReleaseMask |
+                        StructureNotifyMask;
+  grab_input_window_events_.reset(
+      new ui::XScopedEventSelector(grab_input_window_, event_mask));
+
+  XMapRaised(display, grab_input_window_);
+}
+
+void X11DragSource::SendXdndEnter(XID dest_window) {
+  XEvent xev;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = gfx::GetAtom(kXdndEnter);
+  xev.xclient.format = 32;
+  xev.xclient.window = dest_window;
+  xev.xclient.data.l[0] = xwindow_;
+  xev.xclient.data.l[1] = (kMaxXdndVersion << 24);  // The version number.
+  xev.xclient.data.l[2] = 0;
+  xev.xclient.data.l[3] = 0;
+  xev.xclient.data.l[4] = 0;
+
+  std::vector<Atom> targets;
+  selection_owner_.RetrieveTargets(&targets);
+
+  if (targets.size() > 3) {
+    xev.xclient.data.l[1] |= 1;
+    ui::SetAtomArrayProperty(xwindow_, kXdndTypeList, "ATOM", targets);
+  } else {
+    // Pack the targets into the enter message.
+    for (size_t i = 0; i < targets.size(); ++i)
+      xev.xclient.data.l[2 + i] = targets[i];
+  }
+
+  ui::SendXClientEvent(dest_window, &xev);
+}
+
+void X11DragSource::SendXdndLeave(XID dest_window) {
+  XEvent xev;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = gfx::GetAtom(kXdndLeave);
+  xev.xclient.format = 32;
+  xev.xclient.window = dest_window;
+  xev.xclient.data.l[0] = xwindow_;
+  xev.xclient.data.l[1] = 0;
+  xev.xclient.data.l[2] = 0;
+  xev.xclient.data.l[3] = 0;
+  xev.xclient.data.l[4] = 0;
+  ui::SendXClientEvent(dest_window, &xev);
+}
+
+void X11DragSource::SendXdndPosition(XID dest_window,
+                                     const gfx::Point& screen_point,
+                                     unsigned long event_time) {
+  waiting_on_status_ = true;
+
+  XEvent xev;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = gfx::GetAtom(kXdndPosition);
+  xev.xclient.format = 32;
+  xev.xclient.window = dest_window;
+  xev.xclient.data.l[0] = xwindow_;
+  xev.xclient.data.l[1] = 0;
+  xev.xclient.data.l[2] = (screen_point.x() << 16) | screen_point.y();
+  xev.xclient.data.l[3] = event_time;
+  xev.xclient.data.l[4] = DragOperationToAtom(drag_operation_);
+  ui::SendXClientEvent(dest_window, &xev);
+
+  // http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html and
+  // the Xdnd protocol both recommend that drag events should be sent
+  // periodically.
+  repeat_mouse_move_timer_.Start(
+      FROM_HERE, base::TimeDelta::FromMilliseconds(kRepeatMouseMoveTimeoutMs),
+      base::Bind(&X11DragSource::ProcessMouseMove, base::Unretained(this),
+                 screen_point, event_time));
+}
+
+void X11DragSource::SendXdndDrop(XID dest_window) {
+  XEvent xev;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = gfx::GetAtom(kXdndDrop);
+  xev.xclient.format = 32;
+  xev.xclient.window = dest_window;
+  xev.xclient.data.l[0] = xwindow_;
+  xev.xclient.data.l[1] = 0;
+  xev.xclient.data.l[2] = x11::CurrentTime;
+  xev.xclient.data.l[3] = x11::None;
+  xev.xclient.data.l[4] = x11::None;
+  ui::SendXClientEvent(dest_window, &xev);
+}
+
+void X11DragSource::DispatchMouseMovement() {
+  if (!last_motion_in_screen_)
+    return;
+
+  repeat_mouse_move_timer_.Stop();
+  base::TimeTicks time_stamp = last_motion_in_screen_->time_stamp();
+  ProcessMouseMove(last_motion_in_screen_->location(),
+                   (time_stamp - base::TimeTicks()).InMilliseconds());
+
+  last_motion_in_screen_.reset();
+}
+
+void X11DragSource::ProcessMouseMove(const gfx::Point& screen_point,
+                                     unsigned long event_time) {
+  if (source_state_ != SOURCE_STATE_OTHER)
+    return;
+
+  // Find the current window the cursor is over.
+  gfx::AcceleratedWidget dest_window = gfx::kNullAcceleratedWidget;
+  window_->OnMouseMoved(screen_point, &dest_window);
+  if (dest_window == gfx::kNullAcceleratedWidget) {
+    screen_point_ = screen_point;
+    ui::EnumerateTopLevelWindows(this);
+    dest_window = ValidateXdndWindow(toplevel_);
+  }
+
+  if (source_current_window_ != dest_window) {
+    if (source_current_window_ != gfx::kNullAcceleratedWidget)
+      SendXdndLeave(source_current_window_);
+
+    source_current_window_ = dest_window;
+    waiting_on_status_ = false;
+    next_position_message_.reset();
+    status_received_since_enter_ = false;
+    negotiated_operation_ = ui::DragDropTypes::DRAG_NONE;
+
+    if (source_current_window_ != gfx::kNullAcceleratedWidget)
+      SendXdndEnter(source_current_window_);
+  }
+
+  if (source_current_window_ != gfx::kNullAcceleratedWidget) {
+    if (waiting_on_status_) {
+      next_position_message_.reset(
+          new std::pair<gfx::Point, unsigned long>(screen_point, event_time));
+    } else {
+      SendXdndPosition(dest_window, screen_point, event_time);
+    }
+  }
+}
+
+void X11DragSource::StartEndMoveLoopTimer() {
+  end_move_loop_timer_.Start(
+      FROM_HERE, base::TimeDelta::FromMilliseconds(kEndMoveLoopTimeoutMs), this,
+      &X11DragSource::FinishDragDrop);
+}
+
+void X11DragSource::FinishDragDrop() {
+  window_->OnDragSessionClose(negotiated_operation_);
+}
+
+void X11DragSource::HandleMouseRelease() {
+  repeat_mouse_move_timer_.Stop();
+
+  if (source_state_ != SOURCE_STATE_OTHER) {
+    // The user has previously released the mouse and is clicking in
+    // frustration.
+    FinishDragDrop();
+    return;
+  }
+
+  if (source_current_window_ != gfx::kNullAcceleratedWidget) {
+    if (waiting_on_status_) {
+      if (status_received_since_enter_) {
+        // If we are waiting for an XdndStatus message, we need to wait for it
+        // to complete.
+        source_state_ = SOURCE_STATE_PENDING_DROP;
+
+        // Start timer to end the move loop if the target takes too long to send
+        // the XdndStatus and XdndFinished messages.
+        StartEndMoveLoopTimer();
+        return;
+      }
+
+      FinishDragDrop();
+      return;
+    }
+
+    if (negotiated_operation_ != ui::DragDropTypes::DRAG_NONE) {
+      // Start timer to end the move loop if the target takes too long to send
+      // an XdndFinished message. It is important that StartEndMoveLoopTimer()
+      // is called before SendXdndDrop() because SendXdndDrop()
+      // sends XdndFinished synchronously if the drop target is a Chrome
+      // window.
+      StartEndMoveLoopTimer();
+
+      // We have negotiated an action with the other end.
+      source_state_ = SOURCE_STATE_DROPPED;
+      SendXdndDrop(source_current_window_);
+      return;
+    }
+  }
+
+  FinishDragDrop();
+}
+
+bool X11DragSource::ShouldStopIterating(XID xid) {
+  if (!ui::IsWindowVisible(xid))
+    return false;
+
+  if (ui::WindowContainsPoint(xid, screen_point_)) {
+    toplevel_ = xid;
+    return true;
+  }
+  return false;
+}
+
+}  // namespace ui
diff --git a/ui/ozone/platform/x11/x11_drag_source.h b/ui/ozone/platform/x11/x11_drag_source.h
new file mode 100644
index 0000000000000..e1445e04361ec
--- /dev/null
+++ b/ui/ozone/platform/x11/x11_drag_source.h
@@ -0,0 +1,157 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PLATFORM_X11_X11_DRAG_SOURCE_H_
+#define UI_OZONE_PLATFORM_X11_X11_DRAG_SOURCE_H_
+
+#include "base/timer/timer.h"
+#include "ui/base/dragdrop/drag_drop_types.h"
+#include "ui/base/x/selection_owner.h"
+#include "ui/base/x/x11_util.h"
+#include "ui/events/platform/platform_event_dispatcher.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/native_widget_types.h"
+
+namespace ui {
+class MouseEvent;
+class ScopedEventDispatcher;
+class XScopedEventSelector;
+class X11WindowOzone;
+class OSExchangeData;
+
+class X11DragSource : public ui::PlatformEventDispatcher,
+                      public ui::EnumerateWindowsDelegate {
+ public:
+  explicit X11DragSource(X11WindowOzone* window,
+                         XID xwindow,
+                         int operation,
+                         const OSExchangeData& data);
+  ~X11DragSource() override;
+
+  void OnXdndStatus(const XClientMessageEvent& event);
+  void OnXdndFinished(const XClientMessageEvent& event);
+  void OnSelectionRequest(const XEvent& event);
+
+  DragDropTypes::DragOperation negotiated_operation();
+  SelectionFormatMap* format_map() { return &format_map_; }
+
+  // ui:::PlatformEventDispatcher:
+  bool CanDispatchEvent(const ui::PlatformEvent& event) override;
+  uint32_t DispatchEvent(const ui::PlatformEvent& event) override;
+
+ private:
+  enum SourceState {
+    // |source_current_window_| will receive a drop once we receive an
+    // XdndStatus from it.
+    SOURCE_STATE_PENDING_DROP,
+
+    // The move looped will be ended once we receive XdndFinished from
+    // |source_current_window_|. We should not send XdndPosition to
+    // |source_current_window_| while in this state.
+    SOURCE_STATE_DROPPED,
+
+    // There is no drag in progress or there is a drag in progress and the
+    // user has not yet released the mouse.
+    SOURCE_STATE_OTHER,
+  };
+
+  // Creates an input-only window to be used during the drag.
+  void CreateDragInputWindow(XDisplay* display);
+
+  void HandleMouseRelease();
+
+  void FinishDragDrop();
+
+  void SendXdndEnter(XID dest_window);
+  void SendXdndLeave(XID dest_window);
+  void SendXdndPosition(XID dest_window,
+                        const gfx::Point& screen_point,
+                        unsigned long event_time);
+  void SendXdndDrop(XID dest_window);
+
+  void ProcessMouseMove(const gfx::Point& screen_point,
+                        unsigned long event_time);
+
+  // Dispatch mouse movement event to |delegate_| in a posted task.
+  void DispatchMouseMovement();
+
+  void StartEndMoveLoopTimer();
+
+  // ui::EnumerateWindowsDelegate:
+  bool ShouldStopIterating(XID xid) override;
+
+  // An invisible InputOnly window. Keyboard grab and sometimes mouse grab
+  // are set on this window.
+  XID grab_input_window_;
+
+  // Events selected on |grab_input_window_|.
+  std::unique_ptr<ui::XScopedEventSelector> grab_input_window_events_;
+
+  // Whether the pointer was grabbed on |grab_input_window_|.
+  bool grabbed_pointer_;
+
+  X11WindowOzone* window_;
+
+  XID xwindow_;
+
+  std::unique_ptr<MouseEvent> last_motion_in_screen_;
+  gfx::AcceleratedWidget source_current_window_;
+
+  // When the mouse is released, we need to wait for the last XdndStatus message
+  // only if we have previously received a status message from
+  // |source_current_window_|.
+  bool status_received_since_enter_;
+
+  // In the Xdnd protocol, we aren't supposed to send another XdndPosition
+  // message until we have received a confirming XdndStatus message.
+  bool waiting_on_status_;
+
+  // If we would send an XdndPosition message while we're waiting for an
+  // XdndStatus response, we need to cache the latest details we'd send.
+  std::unique_ptr<std::pair<gfx::Point, unsigned long>> next_position_message_;
+
+  // The operation bitfield as requested by StartDragAndDrop.
+  int drag_operation_;
+
+  // We offer the other window a list of possible operations,
+  // XdndActionsList. This is the requested action from the other window. This
+  // is DRAG_NONE if we haven't sent out an XdndPosition message yet, haven't
+  // yet received an XdndStatus or if the other window has told us that there's
+  // no action that we can agree on.
+  DragDropTypes::DragOperation negotiated_operation_;
+
+  // Reprocesses the most recent mouse move event if the mouse has not moved
+  // in a while in case the window stacking order has changed and
+  // |source_current_window_| needs to be updated.
+  base::OneShotTimer repeat_mouse_move_timer_;
+
+  SourceState source_state_;
+
+  // Ends the move loop if the target is too slow to respond after the mouse is
+  // released.
+  base::OneShotTimer end_move_loop_timer_;
+
+  std::unique_ptr<ui::ScopedEventDispatcher> nested_dispatcher_;
+
+  std::unique_ptr<ui::ScopedEventDispatcher> old_dispatcher_;
+
+  // A representation of data. This is either passed to us from the other
+  // process, or built up through a sequence of Set*() calls. It can be passed
+  // to |selection_owner_| when we take the selection.
+  SelectionFormatMap format_map_;
+
+  // Takes a snapshot of |format_map_| and offers it to other windows.
+  mutable SelectionOwner selection_owner_;
+
+  gfx::Point screen_point_;
+  XID toplevel_;
+
+  base::WeakPtrFactory<X11DragSource> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(X11DragSource);
+};
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_X11_X11_DRAG_SOURCE_H_
diff --git a/ui/ozone/platform/x11/x11_drag_util.cc b/ui/ozone/platform/x11/x11_drag_util.cc
new file mode 100644
index 0000000000000..62c15ab59d52c
--- /dev/null
+++ b/ui/ozone/platform/x11/x11_drag_util.cc
@@ -0,0 +1,108 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/ozone/platform/x11/x11_drag_util.h"
+
+#include "base/memory/ref_counted_memory.h"
+#include "base/strings/string_split.h"
+#include "base/strings/utf_string_conversions.h"
+#include "ui/base/x/selection_utils.h"
+
+namespace ui {
+
+namespace {
+const char kDragNetscapeURL[] = "_NETSCAPE_URL";
+const char kDragString[] = "STRING";
+const char kDragText[] = "TEXT";
+const char kDragTextPlain[] = "text/plain";
+const char kDragTextPlainUtf8[] = "text/plain;charset=utf-8";
+const char kDragUtf8String[] = "UTF8_STRING";
+}  // namespace
+
+::Atom DragOperationToAtom(int drag_operation) {
+  if (drag_operation & DragDropTypes::DRAG_COPY)
+    return gfx::GetAtom(kXdndActionCopy);
+  if (drag_operation & DragDropTypes::DRAG_MOVE)
+    return gfx::GetAtom(kXdndActionMove);
+  if (drag_operation & DragDropTypes::DRAG_LINK)
+    return gfx::GetAtom(kXdndActionLink);
+
+  return x11::None;
+}
+
+DragDropTypes::DragOperation AtomToDragOperation(::Atom atom) {
+  if (atom == gfx::GetAtom(kXdndActionCopy))
+    return DragDropTypes::DRAG_COPY;
+  if (atom == gfx::GetAtom(kXdndActionMove))
+    return DragDropTypes::DRAG_MOVE;
+  if (atom == gfx::GetAtom(kXdndActionLink))
+    return DragDropTypes::DRAG_LINK;
+
+  return DragDropTypes::DRAG_NONE;
+}
+
+std::vector<::Atom> GetOfferedDragOperations(int drag_operations) {
+  std::vector<::Atom> operations;
+  if (drag_operations & DragDropTypes::DRAG_COPY)
+    operations.push_back(gfx::GetAtom(kXdndActionCopy));
+  if (drag_operations & DragDropTypes::DRAG_MOVE)
+    operations.push_back(gfx::GetAtom(kXdndActionMove));
+  if (drag_operations & DragDropTypes::DRAG_LINK)
+    operations.push_back(gfx::GetAtom(kXdndActionLink));
+  return operations;
+}
+
+void InsertStringToSelectionFormatMap(const base::string16& text_data,
+                                      SelectionFormatMap* map) {
+  std::string utf8 = base::UTF16ToUTF8(text_data);
+  scoped_refptr<base::RefCountedMemory> mem(
+      base::RefCountedString::TakeString(&utf8));
+
+  map->Insert(gfx::GetAtom(Clipboard::kMimeTypeText), mem);
+  map->Insert(gfx::GetAtom(kDragText), mem);
+  map->Insert(gfx::GetAtom(kDragString), mem);
+  map->Insert(gfx::GetAtom(kDragUtf8String), mem);
+  map->Insert(gfx::GetAtom(kDragTextPlain), mem);
+  map->Insert(gfx::GetAtom(kDragTextPlainUtf8), mem);
+}
+
+void InsertURLToSelectionFormatMap(const GURL& url,
+                                   const base::string16& title,
+                                   SelectionFormatMap* map) {
+  if (url.is_valid()) {
+    // Mozilla's URL format: (UTF16: URL, newline, title)
+    base::string16 spec = base::UTF8ToUTF16(url.spec());
+
+    std::vector<unsigned char> data;
+    ui::AddString16ToVector(spec, &data);
+    ui::AddString16ToVector(base::ASCIIToUTF16("\n"), &data);
+    ui::AddString16ToVector(title, &data);
+    scoped_refptr<base::RefCountedMemory> mem(
+        base::RefCountedBytes::TakeVector(&data));
+
+    map->Insert(gfx::GetAtom(Clipboard::kMimeTypeMozillaURL), mem);
+
+    // Set a string fallback as well.
+    InsertStringToSelectionFormatMap(spec, map);
+
+    // Set _NETSCAPE_URL for file managers like Nautilus that use it as a hint
+    // to create a link to the URL. Setting text/uri-list doesn't work because
+    // Nautilus will fetch and copy the contents of the URL to the drop target
+    // instead of linking...
+    // Format is UTF8: URL + "\n" + title.
+    std::string netscape_url = url.spec();
+    netscape_url += "\n";
+    netscape_url += base::UTF16ToUTF8(title);
+    map->Insert(gfx::GetAtom(kDragNetscapeURL),
+                scoped_refptr<base::RefCountedMemory>(
+                    base::RefCountedString::TakeString(&netscape_url)));
+  }
+}
+
+void SendXClientEvent(XID window, XEvent* xev) {
+  DCHECK_EQ(ClientMessage, xev->type);
+  XSendEvent(gfx::GetXDisplay(), window, x11::False, 0, xev);
+}
+
+}  // namespace ui
diff --git a/ui/ozone/platform/x11/x11_drag_util.h b/ui/ozone/platform/x11/x11_drag_util.h
new file mode 100644
index 0000000000000..a7121c2a5a7fd
--- /dev/null
+++ b/ui/ozone/platform/x11/x11_drag_util.h
@@ -0,0 +1,107 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PLATFORM_X11_X11_DRAG_UTIL_H_
+#define UI_OZONE_PLATFORM_X11_X11_DRAG_UTIL_H_
+
+#include <vector>
+
+#include "base/strings/string_util.h"
+#include "ui/base/dragdrop/drag_drop_types.h"
+#include "ui/gfx/x/x11.h"
+#include "ui/gfx/x/x11_atom_cache.h"
+#include "url/gurl.h"
+
+namespace ui {
+
+class SelectionFormatMap;
+
+// The lowest XDND protocol version that we understand.
+//
+// The XDND protocol specification says that we must support all versions
+// between 3 and the version we advertise in the XDndAware property.
+constexpr int kMinXdndVersion = 3;
+
+// The value used in the XdndAware property.
+//
+// The XDND protocol version used between two windows will be the minimum
+// between the two versions advertised in the XDndAware property.
+constexpr int kMaxXdndVersion = 5;
+
+// Window property that contains the possible actions that will be presented to
+// the user when the drag and drop action is kXdndActionAsk.
+const char kXdndActionList[] = "XdndActionList";
+
+// Window property that tells other applications the window understands XDND.
+const char kXdndAware[] = "XdndAware";
+
+// Window property pointing to a proxy window to receive XDND target messages.
+// The XDND source must check the proxy window must for the XdndAware property,
+// and must send all XDND messages to the proxy instead of the target. However,
+// the target field in the messages must still represent the original target
+// window (the window pointed to by the cursor).
+const char kXdndProxy[] = "XdndProxy";
+
+// These actions have the same meaning as in the W3C Drag and Drop spec.
+const char kXdndActionCopy[] = "XdndActionCopy";
+const char kXdndActionMove[] = "XdndActionMove";
+const char kXdndActionLink[] = "XdndActionLink";
+
+// Message sent from an XDND source to the target to start the XDND protocol.
+// The target must wait for an XDndPosition event before querying the data.
+const char kXdndEnter[] = "XdndEnter";
+
+// Window property that holds the supported drag and drop data types.
+// This property is set on the XDND source window when the drag and drop data
+// can be converted to more than 3 types.
+const char kXdndTypeList[] = "XdndTypeList";
+
+// Message sent from an XDND source to the target when the user cancels the drag
+// and drop operation.
+const char kXdndLeave[] = "XdndLeave";
+
+// Message sent by the XDND source when the cursor position changes.
+// The source will also send an XdndPosition event right after the XdndEnter
+// event, to tell the target about the initial cursor position and the desired
+// drop action.
+// The time stamp in the XdndPosition must be used when requesting selection
+// information.
+// After the target optionally acquires selection information, it must tell the
+// source if it can accept the drop via an XdndStatus message.
+const char kXdndPosition[] = "XdndPosition";
+
+// Message sent from an XDND source to the target when the user confirms the
+// drag and drop operation.
+const char kXdndDrop[] = "XdndDrop";
+
+// Selection used by the XDND protocol to transfer data between applications.
+const char kXdndSelection[] = "XdndSelection";
+
+// Message sent by the XDND target in response to an XdndPosition message.
+// The message informs the source if the target will accept the drop, and what
+// action will be taken if the drop is accepted.
+const char kXdndStatus[] = "XdndStatus";
+
+// Message sent from an XDND target to the source in respose to an XdndDrop.
+// The message must be sent whether the target acceepts the drop or not.
+const char kXdndFinished[] = "XdndFinished";
+
+::Atom DragOperationToAtom(int drag_operation);
+
+DragDropTypes::DragOperation AtomToDragOperation(::Atom atom);
+
+std::vector<::Atom> GetOfferedDragOperations(int drag_operations);
+
+void InsertStringToSelectionFormatMap(const base::string16& text_data,
+                                      SelectionFormatMap* map);
+
+void InsertURLToSelectionFormatMap(const GURL& url,
+                                   const base::string16& title,
+                                   SelectionFormatMap* map);
+
+void SendXClientEvent(XID xwindow, XEvent* xev);
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_X11_X11_DRAG_UTIL_H_
diff --git a/ui/ozone/platform/x11/x11_window_ozone.cc b/ui/ozone/platform/x11/x11_window_ozone.cc
index 9c312abdad9d1..672e0da68b0e8 100644
--- a/ui/ozone/platform/x11/x11_window_ozone.cc
+++ b/ui/ozone/platform/x11/x11_window_ozone.cc
@@ -5,6 +5,8 @@
 #include "ui/ozone/platform/x11/x11_window_ozone.h"
 
 #include "base/bind.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/base/x/x11_util.h"
 #include "ui/events/event.h"
 #include "ui/events/event_utils.h"
 #include "ui/events/ozone/events_ozone.h"
@@ -12,6 +14,9 @@
 #include "ui/gfx/geometry/point.h"
 #include "ui/gfx/x/x11.h"
 #include "ui/ozone/platform/x11/x11_cursor_ozone.h"
+#include "ui/ozone/platform/x11/x11_drag_context.h"
+#include "ui/ozone/platform/x11/x11_drag_source.h"
+#include "ui/ozone/platform/x11/x11_drag_util.h"
 #include "ui/ozone/platform/x11/x11_window_manager_ozone.h"
 
 namespace ui {
@@ -19,7 +24,9 @@ namespace ui {
 X11WindowOzone::X11WindowOzone(X11WindowManagerOzone* window_manager,
                                PlatformWindowDelegate* delegate,
                                const gfx::Rect& bounds)
-    : X11WindowBase(delegate, bounds), window_manager_(window_manager) {
+    : X11WindowBase(delegate, bounds),
+      window_manager_(window_manager),
+      target_current_context_(nullptr) {
   DCHECK(window_manager);
   auto* event_source = X11EventSourceLibevent::GetInstance();
   if (event_source)
@@ -29,6 +36,11 @@ X11WindowOzone::X11WindowOzone(X11WindowManagerOzone* window_manager,
 #if !defined(OS_CHROMEOS)
   move_loop_client_.reset(new WindowMoveLoopClient());
 #endif
+
+  unsigned long xdnd_version = kMaxXdndVersion;
+  XChangeProperty(xdisplay(), xwindow(), gfx::GetAtom(kXdndAware), XA_ATOM, 32,
+                  PropModeReplace,
+                  reinterpret_cast<unsigned char*>(&xdnd_version), 1);
 }
 
 X11WindowOzone::~X11WindowOzone() {
@@ -54,6 +66,16 @@ void X11WindowOzone::SetCursor(PlatformCursor cursor) {
   XDefineCursor(xdisplay(), xwindow(), cursor_ozone->xcursor());
 }
 
+void X11WindowOzone::StartDrag(const ui::OSExchangeData& data,
+                               const int operation,
+                               gfx::NativeCursor cursor) {
+  std::vector<::Atom> actions = GetOfferedDragOperations(operation);
+  ui::SetAtomArrayProperty(xwindow(), kXdndActionList, "ATOM", actions);
+
+  drag_source_ =
+      std::make_unique<X11DragSource>(this, xwindow(), operation, data);
+}
+
 bool X11WindowOzone::RunMoveLoop(const gfx::Vector2d& drag_offset) {
 // TODO(msisov, tonikitoo): Add a dummy implementation for chromeos.
 #if !defined(OS_CHROMEOS)
@@ -88,6 +110,9 @@ bool X11WindowOzone::DispatchXEvent(XEvent* xev) {
   if (!IsEventForXWindow(*xev))
     return false;
 
+  if (ProcessDragDropEvent(xev))
+    return true;
+
   ProcessXWindowEvent(xev);
   return true;
 }
@@ -127,4 +152,133 @@ void X11WindowOzone::OnLostCapture() {
   delegate()->OnLostCapture();
 }
 
+void X11WindowOzone::OnDragDataCollected(const gfx::PointF& screen_point,
+                                         std::unique_ptr<OSExchangeData> data,
+                                         int operation) {
+  delegate()->OnDragEnter(this, screen_point, std::move(data), operation);
+}
+
+void X11WindowOzone::OnMouseMoved(const gfx::Point& point,
+                                  gfx::AcceleratedWidget* widget) {
+  delegate()->OnMouseMoved(point, widget);
+}
+
+void X11WindowOzone::OnDragSessionClose(int dnd_action) {
+  drag_source_.reset();
+  delegate()->OnDragSessionClose(dnd_action);
+}
+
+void X11WindowOzone::OnDragMotion(const gfx::PointF& screen_point,
+                                  int flags,
+                                  ::Time event_time,
+                                  int operation) {
+  gfx::AcceleratedWidget widget = gfx::kNullAcceleratedWidget;
+  drag_operation_ =
+      delegate()->OnDragMotion(screen_point, event_time, operation, &widget);
+}
+
+bool X11WindowOzone::ProcessDragDropEvent(XEvent* xev) {
+  switch (xev->type) {
+    case SelectionNotify: {
+      if (!target_current_context_.get()) {
+        NOTREACHED();
+        return false;
+      }
+      target_current_context_->OnSelectionNotify(xev->xselection);
+      return true;
+    }
+    case PropertyNotify: {
+      if (xev->xproperty.atom != gfx::GetAtom(kXdndActionList))
+        return false;
+      if (!target_current_context_.get() ||
+          target_current_context_->source_window() != xev->xany.window) {
+        return false;
+      }
+      target_current_context_->ReadActions();
+      return true;
+    }
+    case SelectionRequest: {
+      if (!drag_source_)
+        return false;
+      drag_source_->OnSelectionRequest(*xev);
+      return true;
+    }
+    case ClientMessage: {
+      XClientMessageEvent& event = xev->xclient;
+      Atom message_type = event.message_type;
+      if (message_type == gfx::GetAtom("WM_PROTOCOLS"))
+        return false;
+
+      if (message_type == gfx::GetAtom(kXdndEnter)) {
+        int version = (event.data.l[1] & 0xff000000) >> 24;
+        if (version < kMinXdndVersion) {
+          // This protocol version is not documented in the XDND standard (last
+          // revised in 1999), so we don't support it. Since don't understand
+          // the protocol spoken by the source, we can't tell it that we can't
+          // talk to it.
+          LOG(ERROR)
+              << "XdndEnter message discarded because its version is too old.";
+          return false;
+        }
+        if (version > kMaxXdndVersion) {
+          // The XDND version used should be the minimum between the versions
+          // advertised by the source and the target. We advertise
+          // kMaxXdndVersion, so this should never happen when talking to an
+          // XDND-compliant application.
+          LOG(ERROR)
+              << "XdndEnter message discarded because its version is too new.";
+          return false;
+        }
+        // Make sure that we've run ~X11DragContext() before creating another
+        // one.
+        target_current_context_.reset();
+        SelectionFormatMap* map = nullptr;
+        if (drag_source_)
+          map = drag_source_->format_map();
+        target_current_context_.reset(
+            new X11DragContext(this, xwindow(), event, map));
+        return true;
+      }
+      if (message_type == gfx::GetAtom(kXdndLeave)) {
+        delegate()->OnDragLeave();
+        return true;
+      }
+      if (message_type == gfx::GetAtom(kXdndPosition)) {
+        if (!target_current_context_.get()) {
+          NOTREACHED();
+          return false;
+        }
+
+        target_current_context_->OnXdndPosition(event);
+        return true;
+      }
+      if (message_type == gfx::GetAtom(kXdndStatus)) {
+        drag_source_->OnXdndStatus(event);
+        return true;
+      }
+      if (message_type == gfx::GetAtom(kXdndFinished)) {
+        int negotiated_operation = drag_source_->negotiated_operation();
+        drag_source_->OnXdndFinished(event);
+        delegate()->OnDragSessionClose(negotiated_operation);
+        return true;
+      }
+      if (message_type == gfx::GetAtom(kXdndDrop)) {
+        delegate()->OnDragDrop(nullptr);
+
+        if (!target_current_context_.get()) {
+          NOTREACHED();
+          return false;
+        }
+        target_current_context_->OnXdndDrop(drag_operation_);
+        target_current_context_.reset();
+        return true;
+      }
+      break;
+    }
+    default:
+      break;
+  }
+  return false;
+}
+
 }  // namespace ui
diff --git a/ui/ozone/platform/x11/x11_window_ozone.h b/ui/ozone/platform/x11/x11_window_ozone.h
index 6be3f747549df..b03890b4cf813 100644
--- a/ui/ozone/platform/x11/x11_window_ozone.h
+++ b/ui/ozone/platform/x11/x11_window_ozone.h
@@ -13,6 +13,9 @@
 
 namespace ui {
 
+class OSExchangeData;
+class X11DragContext;
+class X11DragSource;
 class X11WindowManagerOzone;
 
 // PlatformWindow implementation for X11 Ozone. PlatformEvents are ui::Events.
@@ -34,6 +37,10 @@ class X11WindowOzone : public X11WindowBase,
 
   void ReleaseCapture() override;
   void SetCursor(PlatformCursor cursor) override;
+  void StartDrag(const ui::OSExchangeData& data,
+                 const int operation,
+                 gfx::NativeCursor cursor) override;
+
   bool RunMoveLoop(const gfx::Vector2d& drag_offset) override;
   void StopMoveLoop() override;
 
@@ -43,10 +50,35 @@ class X11WindowOzone : public X11WindowBase,
   PlatformEventDispatcher* GetPlatformEventDispatcher() override;
   bool DispatchXEvent(XEvent* event) override;
 
+  void OnDragDataCollected(const gfx::PointF& screen_point,
+                           std::unique_ptr<OSExchangeData> data,
+                           int operation);
+  void OnDragMotion(const gfx::PointF& screen_point,
+                    int flags,
+                    ::Time event_time,
+                    int operation);
+  void OnMouseMoved(const gfx::Point& point, gfx::AcceleratedWidget* widget);
+  void OnDragSessionClose(int dnd_action);
+
  private:
+  enum SourceState {
+    // |source_current_window_| will receive a drop once we receive an
+    // XdndStatus from it.
+    SOURCE_STATE_PENDING_DROP,
+
+    // The move looped will be ended once we receive XdndFinished from
+    // |source_current_window_|. We should not send XdndPosition to
+    // |source_current_window_| while in this state.
+    SOURCE_STATE_DROPPED,
+
+    // There is no drag in progress or there is a drag in progress and the
+    // user has not yet released the mouse.
+    SOURCE_STATE_OTHER,
+  };
   // PlatformEventDispatcher:
   bool CanDispatchEvent(const PlatformEvent& event) override;
   uint32_t DispatchEvent(const PlatformEvent& event) override;
+  bool ProcessDragDropEvent(XEvent* xev);
 
   X11WindowManagerOzone* window_manager_;
 
@@ -59,6 +91,11 @@ class X11WindowOzone : public X11WindowBase,
   // previous check in ::CheckCanDispatchNextPlatformEvent based on a XID
   // target.
   bool handle_next_event_ = false;
+  std::unique_ptr<X11DragContext> target_current_context_;
+  // DesktopDragDropClientOzone* drag_drop_client_;
+  int drag_operation_;
+  // unsigned long source_window_;
+  std::unique_ptr<X11DragSource> drag_source_;
 
   DISALLOW_COPY_AND_ASSIGN(X11WindowOzone);
 };
diff --git a/ui/platform_window/x11/x11_window_base.cc b/ui/platform_window/x11/x11_window_base.cc
index a4b81a7a87cdd..a018afece259d 100644
--- a/ui/platform_window/x11/x11_window_base.cc
+++ b/ui/platform_window/x11/x11_window_base.cc
@@ -428,6 +428,15 @@ void X11WindowBase::StartWindowMoveOrResize(int hittest,
              SubstructureRedirectMask | SubstructureNotifyMask, &event);
 }
 
+void X11WindowBase::StartDrag(const ui::OSExchangeData& data,
+                              const int operation,
+                              gfx::NativeCursor cursor) {
+  // If this is for ozone/X11, the child class of this, X11WindowOzone, will
+  // handle it. Otherwise, DragDrop has been implemented directly, for instance
+  // DesktopDragDropClientAuraX11 or DragDropControllerMus.
+  NOTREACHED();
+}
+
 bool X11WindowBase::RunMoveLoop(const gfx::Vector2d& drag_offset) {
   return false;
 }
diff --git a/ui/platform_window/x11/x11_window_base.h b/ui/platform_window/x11/x11_window_base.h
index a8298c43ef3ab..f73871ce3796e 100644
--- a/ui/platform_window/x11/x11_window_base.h
+++ b/ui/platform_window/x11/x11_window_base.h
@@ -52,6 +52,10 @@ class X11_WINDOW_EXPORT X11WindowBase : public PlatformWindow {
   gfx::Rect GetRestoredBoundsInPixels() const override;
   void StartWindowMoveOrResize(int hittest,
                                gfx::Point pointer_location) override;
+  // Initiates Drag Action.
+  void StartDrag(const ui::OSExchangeData& data,
+                 const int operation,
+                 gfx::NativeCursor cursor) override;
   bool RunMoveLoop(const gfx::Vector2d& drag_offset) override;
   void StopMoveLoop() override;
 

From 5a210ab25f8281edd8c63d7293fdb3bea3b4bed4 Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Mon, 13 Aug 2018 19:11:10 +0900
Subject: [PATCH 18/32] Create string files for file_manager

---
 chrome/app/chromeos_strings.grdp        | 1274 -----------------------
 chrome/app/file_manager_strings.grdp    | 1259 ++++++++++++++++++++++
 chrome/app/generated_resources.grd      |    6 +
 chrome/app/webstore_widget_strings.grdp |   24 +
 4 files changed, 1289 insertions(+), 1274 deletions(-)
 create mode 100644 chrome/app/file_manager_strings.grdp
 create mode 100644 chrome/app/webstore_widget_strings.grdp

diff --git a/chrome/app/chromeos_strings.grdp b/chrome/app/chromeos_strings.grdp
index ced2c0391dbea..0596aef3c3bdd 100644
--- a/chrome/app/chromeos_strings.grdp
+++ b/chrome/app/chromeos_strings.grdp
@@ -204,1232 +204,6 @@
     Remove your phone and disable Better Together
   </message>
 
-  <!-- File Manager -->
-  <message name="IDS_FILE_BROWSER_ANDROID_FILES_ROOT_LABEL" desc="A label for the 'Play files' root which shows Android files. 'Play' in this label is an abbreviation of 'Google Play', so it should not be translated. Use sentence case.">
-    Play files
-  </message>
-  <message name="IDS_FILE_BROWSER_SHOW_ALL_ANDROID_FOLDERS_OPTION" desc="A label for an option menu item to show all Android folders. By default, only several folders are visible to users, and users will click this option menu item to show all folders. 'Play' in this label is an abbreviation of 'Google Play', so it should not be translated.">
-    Show all Play folders
-  </message>
-  <message name="IDS_FILE_SYSTEM_PROVIDER_UNRESPONSIVE_WARNING" desc="A warning shown in a notification that an operation is taking longer than expected.">
-    An operation is taking longer than expected. Do you want to abort it?
-  </message>
-  <message name="IDS_FILE_SYSTEM_PROVIDER_MANY_UNRESPONSIVE_WARNING" desc="A warning shown in a notification that more than one operations are taking longer than expected.">
-    Some operations are taking longer than expected. Do you want to abort them?
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_CONFIRM_TD_MEMBERS_LOSE_ACCESS" desc="Part of message in the confirmation dialog box when moving a file out of a Team Drive.">
-    Members of '<ph name="SOURCE_NAME">$1</ph>' will lose access unless these items are shared with them.
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_CONFIRM_CANNOT_MOVE_BACK_TO_TEAM_DRIVE" desc="Part of message in the confirmation dialog box when moving a file from Team Drives to My Drive to tell that the operation is not undoable.">
-    The items cannot be moved back into '<ph name="DESTINATION_NAME">$1</ph>', so you won't be able to undo this action.
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_CONFIRM_TD_MEMBERS_GAIN_ACCESS" desc="Part of message in the confirmation dialog box when moving or copying files into a Team Drive.">
-    Members of '<ph name="DESTINATION_NAME">$1</ph>' will gain access to these items.
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_CONFIRM_TD_MEMBERS_GAIN_ACCESS_TO_COPY" desc="Part of message in the confirmation dialog box when copying files into a Team Drive.">
-    Members of '<ph name="DESTINATION_NAME">$1</ph>' will gain access to the copy of these items.
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_CONFIRM_OWNERSHIP_TRANSFER" desc="Part of message in the confirmation dialog box when moving files between two Team Drives that belong to different domains.">
-    Ownership will be transferred to <ph name="DESTINATION_DOMAIN">$1</ph>.
-  </message>
-  <message name="IDS_FILE_BROWSER_CONFIRM_COPY_BUTTON_LABEL" desc="Button label for approving file copy operation in the confirmation dialog box. This is placed next to CANCEL button.">
-    Copy
-  </message>
-  <message name="IDS_FILE_BROWSER_CONFIRM_MOVE_BUTTON_LABEL" desc="Button label for approving file move operation in the confirmation dialog box. This is placed next to CANCEL button.">
-    Move
-  </message>
-  <message name="IDS_FILE_SYSTEM_PROVIDER_UNRESPONSIVE_ABORT_BUTTON" desc="Label of the button on the notification about an operation(s) taking to long.">
-    Abort
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_DIRECTORY_LABEL" desc="/drive directory label.">
-    Google Drive
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_MY_DRIVE_LABEL" desc="A label for the 'My Drive' collection of Google Drive.">
-    My Drive
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_TEAM_DRIVES_LABEL" desc="A label for the 'Team Drives' collection of Google Drive.">
-    Team Drives
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_SHARED_WITH_ME_COLLECTION_LABEL" desc="A label for the 'shared with me' collection of Google Drive.">
-    Shared with me
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_RECENT_COLLECTION_LABEL" desc="A label for the 'Recent' collection of Google Drive.">
-    Recent
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_OFFLINE_COLLECTION_LABEL" desc="A label for the 'Offline' collection of Google Drive.">
-    Offline
-  </message>
-  <message name="IDS_FILE_BROWSER_DOWNLOADS_DIRECTORY_LABEL" desc="Downloads local directory label.">
-    Downloads
-  </message>
-  <message name="IDS_FILE_BROWSER_LINUX_FILES_ROOT_LABEL" desc="A label for the 'Linux files' root which shows crostini files. Use sentence case.">
-    Linux files
-  </message>
-  <message name="IDS_FILE_BROWSER_MY_FILES_ROOT_LABEL" desc="A label for the 'My files' root which is parent of Downloads, Linux and Android files. Use sentence case.">
-    My files
-  </message>
-  <message name="IDS_FILE_BROWSER_MEDIA_VIEW_IMAGES_ROOT_LABEL" desc="A label for the 'Images' root of media views.">
-    Images
-  </message>
-  <message name="IDS_FILE_BROWSER_MEDIA_VIEW_VIDEOS_ROOT_LABEL" desc="A label for the 'Videos' root of media views.">
-    Videos
-  </message>
-  <message name="IDS_FILE_BROWSER_MEDIA_VIEW_AUDIO_ROOT_LABEL" desc="A label for the 'Audio' root of media views.">
-    Audio
-  </message>
-  <message name="IDS_FILE_BROWSER_RECENT_ROOT_LABEL" desc="A label for the 'Recent' root which shows files recently modified by the user.">
-    Recent
-  </message>
-  <message name="IDS_FILE_BROWSER_DOWNLOADS_DIRECTORY_WARNING" desc="Warning displayed to user when viewing downloads folder.">
-    <ph name="BEGIN_BOLD">&lt;strong&gt;</ph>Caution:<ph name="END_BOLD">&lt;/strong&gt;</ph>  These files are temporary and may be automatically deleted to free up disk space.  <ph name="BEGIN_LINK">&lt;a href="javascript://"&gt;</ph>Learn More<ph name="END_LINK">&lt;/a&gt;<ex>&lt;/a&gt;</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_NAME_COLUMN_LABEL" desc="Name column label.">
-    Name
-  </message>
-  <message name="IDS_FILE_BROWSER_SIZE_COLUMN_LABEL" desc="Size column label.">
-    Size
-  </message>
-
-  <message name="IDS_FILE_BROWSER_SIZE_BYTES" desc="Size in bytes.">
-    $1 bytes
-  </message>
-  <message name="IDS_FILE_BROWSER_SIZE_KB" desc="Size in kilo bytes.">
-    $1 KB
-  </message>
-  <message name="IDS_FILE_BROWSER_SIZE_MB" desc="Size in mega bytes.">
-    $1 MB
-  </message>
-  <message name="IDS_FILE_BROWSER_SIZE_GB" desc="Size in giga bytes.">
-    $1 GB
-  </message>
-  <message name="IDS_FILE_BROWSER_SIZE_TB" desc="Size in tera bytes.">
-    $1 TB
-  </message>
-  <message name="IDS_FILE_BROWSER_SIZE_PB" desc="Size in peta bytes.">
-    $1 PB
-  </message>
-
-  <message name="IDS_FILE_BROWSER_SHORTCUT_CTRL" desc="[Ctrl] key name to use in shortcuts descriptions. Shouldn't be translated in many languages actually.">
-    Ctrl
-  </message>
-  <message name="IDS_FILE_BROWSER_SHORTCUT_ALT" desc="[Alt] key name to use in shortcuts descriptions. Shouldn't be translated in many languages actually.">
-    Alt
-  </message>
-  <message name="IDS_FILE_BROWSER_SHORTCUT_SHIFT" desc="[Shift] key name to use in shortcuts descriptions. Shouldn't be translated in many languages actually.">
-    Shift
-  </message>
-  <message name="IDS_FILE_BROWSER_SHORTCUT_META" desc="[Meta] key name to use in shortcuts descriptions. Shouldn't be translated in many languages actually.">
-    Meta
-  </message>
-  <message name="IDS_FILE_BROWSER_SHORTCUT_SPACE" desc="[Space] key name to use in shortcuts descriptions. Shouldn't be translated in many languages actually.">
-    Space
-  </message>
-  <message name="IDS_FILE_BROWSER_SHORTCUT_ENTER" desc="[Enter] key name to use in shortcuts descriptions. Shouldn't be translated in many languages actually.">
-    Enter
-  </message>
-  <message name="IDS_FILE_BROWSER_SHORTCUT_BACKSPACE" desc="[Backspace] key name to use in shortcuts descriptions. Shouldn't be translated in many languages actually.">
-    Backspace
-  </message>
-
-  <message name="IDS_FILE_BROWSER_STATUS_COLUMN_LABEL" desc="Status column label.  This column reflects the cloud import status of files.  The status is an icon depicting whether a file has been imported, and if so, where to - for example, a Drive icon if a file has been imported to Google Drive.  For unimported files, this column is blank. ">
-    Status
-  </message>
-  <message name="IDS_FILE_BROWSER_TOTAL_FILE_COUNT_LABEL" desc="Total count of files that user selects in the Files app">
-    Total file count
-  </message>
-  <message name="IDS_FILE_BROWSER_TOTAL_FILE_SIZE_LABEL" desc="Total size of files that user selects in the Files app">
-    Total file size
-  </message>
-  <message name="IDS_FILE_BROWSER_IMAGE_RESOLUTION_COLUMN_LABEL" desc="Image resolution of a file that user selects in the Files app">
-    Image resolution
-  </message>
-  <message name="IDS_FILE_BROWSER_MEDIA_TITLE_COLUMN_LABEL" desc="Artist of a music file that user selects in the Files app">
-    Title
-  </message>
-  <message name="IDS_FILE_BROWSER_MEDIA_ARTIST_COLUMN_LABEL" desc="Title of a music file that user selects in the Files app">
-    Artist
-  </message>
-  <message name="IDS_FILE_BROWSER_TYPE_COLUMN_LABEL" desc="Type column label.">
-    Type
-  </message>
-  <message name="IDS_FILE_BROWSER_DATE_COLUMN_LABEL" desc="Date column label.">
-    Date modified
-  </message>
-  <message name="IDS_FILE_BROWSER_OFFLINE_COLUMN_LABEL" desc="Available offline column label.">
-    Available offline
-  </message>
-  <message name="IDS_FILE_BROWSER_ERROR_CREATING_FOLDER" desc="Message displayed when we can't create a folder.">
-    Unable to create folder "<ph name="FOLDER_NAME">$1<ex>Documents</ex></ph>". <ph name="ERROR_MESSAGE">$2<ex>An error occurred (code: ABORT)</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_ERROR_INVALID_CHARACTER" desc="Error message displayed when the user enters an invalid character in a file or directory name.">
-    Invalid character: $1
-  </message>
-  <message name="IDS_FILE_BROWSER_ERROR_EXTERNAL_DRIVE_INVALID_CHARACTER" desc="Error message displayed when the user enters an invalid character in an external drive's name.">
-    Invalid character: $1
-  </message>
-  <message name="IDS_FILE_BROWSER_ERROR_RESERVED_NAME" desc="Error message displayed when the user enters a file name which is reserved.">
-    This name may not be used as a file of folder name
-  </message>
-  <message name="IDS_FILE_BROWSER_ERROR_HIDDEN_NAME" desc="Error message displayed when the user tries to rename to or create a file started with dot.">
-    Names starting with dot are reserved for the system. Please choose another name.
-  </message>
-  <message name="IDS_FILE_BROWSER_ERROR_WHITESPACE_NAME" desc="Error message displayed when the user enters a file name consisting of only whitespace characters.">
-    Invalid name
-  </message>
-  <message name="IDS_FILE_BROWSER_ERROR_LONG_NAME" desc="Error message displayed when user tries to enter too long name for a file or a folder.">
-    Use a shorter name
-  </message>
-  <message name="IDS_FILE_BROWSER_ERROR_EXTERNAL_DRIVE_LONG_NAME" desc="Error message displayed when user tries to enter too long name for an external drive.">
-    Use a name that's <ph name="MAX_LENGTH">$1<ex>11</ex></ph> characters or less
-  </message>
-  <message name="IDS_FILE_BROWSER_ERROR_LINUX_FILES_CONNECTION" desc="Text to show user when there is an error starting or mounting crostini container to show Linux files.">
-    Unable to view Linux files
-  </message>
-
-  <message name="IDS_FILE_BROWSER_EMPTY_FOLDER" desc="Label shown in an empty folder.">
-    Nothing to see here...
-  </message>
-  <message name="IDS_FILE_BROWSER_NEW_FOLDER_BUTTON_LABEL" desc="Label on the 'New folder' button.">
-    New folder
-  </message>
-  <message name="IDS_FILE_BROWSER_NEW_WINDOW_BUTTON_LABEL" desc="Label on the 'New window' button.">
-    New window
-  </message>
-  <message name="IDS_FILE_BROWSER_FILENAME_LABEL" desc="Filename text area label.">
-    File name
-  </message>
-  <message name="IDS_FILE_BROWSER_PREPARING_LABEL" desc="Label informing about preparing the file.">
-    Preparing
-  </message>
-  <message name="IDS_FILE_BROWSER_QUICK_VIEW_CLOSE_BUTTON_LABEL" desc="Label for button to close QuickView.">
-    Back
-  </message>
-  <message name="IDS_FILE_BROWSER_QUICK_VIEW_OPEN_IN_NEW_BUTTON_LABEL" desc="Label for button to open a file with external app.">
-    Open
-  </message>
-  <message name="IDS_FILE_BROWSER_QUICK_VIEW_TOGGLE_METADATA_BOX_BUTTON_LABEL" desc="Label for button to toggle show/hide status of metadata box.">
-    File info
-  </message>
-  <message name="IDS_FILE_BROWSER_DRAGGING_MULTIPLE_ITEMS" desc="Tooltip message for dragging multiple files.">
-    $1 items
-  </message>
-
-  <message name="IDS_FILE_BROWSER_ARCHIVE_MOUNT_FAILED" desc="Title of the error dialog when file mount operation failed.">
-    Unable to open "$1": $2
-  </message>
-  <message name="IDS_FILE_BROWSER_UNMOUNT_FAILED" desc="Title of the error dialog when device unmount operation failed.">
-   <ph name="BEGIN_BOLD">&lt;b&gt;</ph>Don't remove your device just yet!<ph name="END_BOLD">&lt;/b&gt;</ph>
-   <ph name="LINE_BREAKS">&lt;br/&gt;&lt;br/&gt;</ph>
-   Removing your device while it is in use may cause data loss.  Please wait until the operation is over, then eject the device using the Files app.
-  </message>
-  <message name="IDS_FILE_BROWSER_UNMOUNT_PROVIDED_FAILED" desc="Title of the error dialog when unmount operation for a volume provided by an extension failed. One of the most typical use case is an archive (i.e. ZIP) file mounted as a virtual disk. However, arbitrary Chrome apps can mount volumes. So we should not assume this is an archive file.">
-   <ph name="BEGIN_BOLD">&lt;b&gt;</ph>Can't disconnect from an archive or virtual disk<ph name="END_BOLD">&lt;/b&gt;</ph>
-   <ph name="LINE_BREAKS">&lt;br/&gt;&lt;br/&gt;</ph>
-   Close all files on the archive or virtual disk, then try again.
-  </message>
-  <message name="IDS_FILE_BROWSER_MOUNT_ARCHIVE" desc="Title of the action for mounting an archive file to work with its contents.">
-    Open
-  </message>
-  <message name="IDS_FILE_BROWSER_FORMAT_DEVICE_BUTTON_LABEL" desc="Title of the action for formatting removable device.">
-    Format device
-  </message>
-  <message name="IDS_FILE_BROWSER_CONFIGURE_VOLUME_BUTTON_LABEL" desc="Title of the action for configuring the selected volume.">
-    Configure
-  </message>
-  <message name="IDS_FILE_BROWSER_UNMOUNT_DEVICE_BUTTON_LABEL" desc="Title of the action for unmounting removable device.">
-    Eject device
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOSE_VOLUME_BUTTON_LABEL" desc="Title of the action for closing either an archive volume or a volume provided by an extension.">
-    Close
-  </message>
-  <message name="IDS_FILE_BROWSER_ADD_NEW_SERVICES_BUTTON_LABEL" desc="Title of the button in the left nav to add new services (file systems) to the Files app.">
-    Add new service
-  </message>
-  <message name="IDS_FILE_BROWSER_INSTALL_NEW_EXTENSION_LABEL" desc="Title of the menu item for installing new extensions from the web store.">
-    Install new service
-  </message>
-  <message name="IDS_FILE_BROWSER_TASK_VIEW" desc="Title of the action to view (no edit) a file.">
-    View
-  </message>
-  <message name="IDS_FILE_BROWSER_TASK_OPEN" desc="Title of the action to open (and possibly edit) a file.">
-    Open
-  </message>
-  <message name="IDS_FILE_BROWSER_TASK_OPEN_GDOC" desc="Title of the action to open a Google Docs document.">
-    Docs
-  </message>
-  <message name="IDS_FILE_BROWSER_TASK_OPEN_GSHEET" desc="Title of the action to open a Google Spreadsheets document.">
-    Sheets
-  </message>
-  <message name="IDS_FILE_BROWSER_TASK_OPEN_GSLIDES" desc="Title of the action to open a Google Slides document.">
-    Slides
-  </message>
-  <message name="IDS_FILE_BROWSER_TASK_LISTEN" desc="Title of the action to play an audio file.">
-    Listen
-  </message>
-  <message name="IDS_FILE_BROWSER_TASK_INSTALL_LINUX_PACKAGE" desc="Title of the action to install a Linux package.">
-    Install with Linux (Beta)
-  </message>
-
-  <message name="IDS_FILE_BROWSER_INSTALL_LINUX_PACKAGE_TITLE" desc="In the File Manager, the title shown in the dialog for installing a Linux application.">
-    Install app with Linux (Beta)
-  </message>
-  <message name="IDS_FILE_BROWSER_INSTALL_LINUX_PACKAGE_DESCRIPTION" desc="In the File Manager, the message shown in the dialog for installing a Linux application.">
-    The Linux application will be available within your Terminal and may also show an icon in your Launcher.
-  </message>
-  <message name="IDS_FILE_BROWSER_INSTALL_LINUX_PACKAGE_INSTALL_BUTTON" desc="In the File Manager, the label on the button to begin installing a Linux application. ">
-    Install
-  </message>
-  <message name="IDS_FILE_BROWSER_INSTALL_LINUX_PACKAGE_INSTALLATION_STARTED" desc="In the File Manager, the dialog message when a Linux application installation successfully starts.">
-    Installation successfully started.
-  </message>
-  <message name="IDS_FILE_BROWSER_INSTALL_LINUX_PACKAGE_ERROR_TITLE" desc="In the File Manager, the title shown in the dialog for installing a Linux application when an error occurs.">
-    Error installing Linux application
-  </message>
-  <message name="IDS_FILE_BROWSER_INSTALL_LINUX_PACKAGE_ERROR_DESCRIPTION" desc="In the File Manager, the dialog message when a Linux application installation fails.">
-    An error occured during installation of your Linux application.
-  </message>
-
-  <message name="IDS_FILE_BROWSER_GALLERY_NO_IMAGES" desc="In the Gallery, the message that there are no images in this directory.">
-    No images in this directory.
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_ITEMS_SELECTED" desc="In the Gallery, the message showing the selected item count.">
-    <ph name="COUNT">$1<ex>3</ex></ph> items selected
-  </message>
-
-  <message name="IDS_FILE_BROWSER_GALLERY_THUMBNAIL" desc="In the Gallery, the title on the button that switches to the thumbnail view.">
-    Thumbnail view
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_SLIDE" desc="In the Gallery, the title on the button that switches to the slide view.">
-    Slide view
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_SLIDESHOW" desc="In the Gallery, the title on the button that starts the slide show.">
-    Slideshow
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_DELETE" desc="In the Gallery, the title on the button that deletes selected images.">
-    Delete
-  </message>
-
-  <message name="IDS_FILE_BROWSER_GALLERY_EDIT" desc="In the Gallery, the title on the button shows/hides editing buttons.">
-    Edit
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_PRINT" desc="In the Gallery, the title on the button showing the print dialog for the current image or video.">
-    Print
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_SHARE" desc="In the Gallery, the title on the button that lets the user share a photo.">
-    Share
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_EXIT" desc="In the Gallery, the title on the button that exits edit mode.">
-    Exit
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_ENTER_WHEN_DONE" desc="In the Gallery, the text in a floating panel that prompts the user to press enter when they are done with the changes to a photo.">
-    Press Enter when done
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_AUTOFIX" desc="In the Gallery, the title on the button that applies the Auto-Fix filter to a photo.">
-    Auto-fix
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_FIXED" desc="In the Gallery, the text in a floating panel that notifies that the photo has been automatically fixed.">
-    Fixed
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_CROP" desc="In the Gallery, the title on the button that cuts out a rectangular fragment from a photo">
-    Crop
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_ASPECT_RATIO_1_1" desc="Button label to fix aspect to 1:1 ratio when cropping.">
-    1x1
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_ASPECT_RATIO_6_4" desc="Button label to fix aspect to 6:4 ratio when cropping.">
-    6x4
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_ASPECT_RATIO_7_5" desc="Button label to fix aspect to 7:5 ratio when cropping.">
-    7x5
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_ASPECT_RATIO_16_9" desc="Button label to fix aspect to 16:9 ratio when cropping.">
-    16x9
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_RESIZE" desc="In the Gallery, the title on the button that resize a photo.">
-    Resize
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_FIXRATIO" desc="Togglable Button to fix the ratio of width/height input field when resizing.">
-    Fix ratio
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_HEIGHT" desc="Input field to set the new size for height.">
-    Height
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_INVALIDVALUE" desc="In the Gallery, the message informing that the input value is invalid.">
-    Input value is invalid.
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_WIDTH" desc="Input field to set the new size for width.">
-    Width
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_EXPOSURE" desc="In the Gallery, the title on the button that applies the Brightness/Contrast filter to a photo.">
-    Brightness
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_BRIGHTNESS" desc="In the Gallery, the text next to the Brightness slider.">
-    Brightness
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_CONTRAST" desc="In the Gallery, the text next to the Contrast slider.">
-    Contrast
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_ROTATE_LEFT" desc="In the Gallery, the title on the button that rotates the photo 90 degrees to the left (counterclockwise).">
-    Left
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_ROTATE_RIGHT" desc="In the Gallery, the title on the button that rotates the photo 90 degrees to the right (clockwise).">
-    Right
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_UNDO" desc="In the Gallery, the text on the button that reverts the most recent operation.">
-    Undo
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_REDO" desc="In the Gallery, the text on the button that performs again the operation that has been recently reverted.">
-    Redo
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_DONE" desc="In the Gallery, the text on the button that commit image edit.">
-    DONE
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_FILE_EXISTS" desc="In the Gallery, the message informing that file already exists when attempting to rename.">
-    File already exists
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_SAVED" meaning="saved to disk" desc="In the Gallery, the message informing that editing saved successfully.">
-    Saved
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_SAVE_FAILED" desc="In the Gallery, the message informing that it failed to save editing image.">
-    Failed to save image.
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_OVERWRITE_ORIGINAL" desc="In the Gallery, text on the button to overwrite original file along with the edited copy.">
-    Overwrite original
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_OVERWRITE_BUBBLE" desc="In the Gallery, text in the bubble informing user about saving and overwriting original file.">
-    Your edits are saved automatically.<ph name="BREAKS">&lt;br&gt;&lt;br&gt;<ex>&lt;br&gt;&lt;br&gt;</ex></ph>To keep a copy of the original image, uncheck "Overwrite original"
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_READONLY_AND_NON_WRITABLE_FORMAT_WARNING" desc="In the Gallery, message informing that all edits will be saved to Downloads directory since the directory is readonly and the file is non-writable format of Gallery.">
-    Cannot save to $1. All edits will be saved to $2 in the Downloads folder.
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_READONLY_WARNING" desc="In the Gallery, message informing that directory is readonly, and edited files will be saved to Downloads directory.">
-    Cannot save to $1. Edited images will be saved in the Downloads folder.
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_NON_WRITABLE_FORMAT_WARNING" desc="In the Gallery, message informing that Gallery cannot overwrite to the original file and all edits will be saved to a copy.">
-    All edits will be saved to $1.
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_IMAGE_ERROR" desc="In the Gallery, message informing that the image failed to load.">
-    This file could not be displayed.
-  </message>
-  <message name="IDS_FILE_BROWSER_AUDIO_ERROR" desc="In the Audio Player, message informing that the file could not be played.">
-    This file could not be played.
-  </message>
-  <message name="IDS_FILE_BROWSER_GALLERY_IMAGE_OFFLINE" desc="In the Gallery, message informing that the image could be displayed in the offline mode.">
-    This image is not available offline.
-  </message>
-  <message name="IDS_FILE_BROWSER_AUDIO_OFFLINE" desc="In the Audio Player, message informing that the audio file could not be played in the offline mode.">
-    This file is not available offline.
-  </message>
-
-  <message name="IDS_FILE_BROWSER_RECOVERED_FILES_FROM_GOOGLE_DRIVE_DIRECTORY_NAME" desc="The name of the direcotry which stores files recovered from Google Drive directory when the locally stored Google Drive data is found to be broken.">
-    Recovered files from Google Drive
-  </message>
-
-  <message name="IDS_FILE_BROWSER_CONFLICT_DIALOG_MESSAGE" desc="Message of the conflict dialog shown when a file transfer operation is conflicted.">
-    A file named "<ph name="FILENAME">$1<ex>photo.jpg</ex></ph>" already exists. What do you want to do?
-  </message>
-  <message name="IDS_FILE_BROWSER_CONFLICT_DIALOG_KEEP_BOTH" desc="Label of a button to keep both entries after the file transfer operation.">
-    Keep both
-  </message>
-  <message name="IDS_FILE_BROWSER_CONFLICT_DIALOG_REPLACE" desc="Label of a button to replace the old entry with the new entry.">
-    Replace
-  </message>
-  <message name="IDS_FILE_BROWSER_CONFLICT_DIALOG_APPLY_TO_ALL" desc="Label of checkbox in the conflict dialog box to apply the user selection to all entries.">
-    Apply to all
-  </message>
-
-  <message name="IDS_FILE_BROWSER_CONFIRM_OVERWRITE_FILE" desc="Asks the user if they are sure they want to overwrite an existing file with another one.">
-    A file named "$1" already exists. Do you want to replace it?
-  </message>
-  <message name="IDS_FILE_BROWSER_FILE_ALREADY_EXISTS" desc="Error message displayed when user tries to create a file with an existing name.">
-    The file named "$1" already exists. Please choose a different name.
-  </message>
-  <message name="IDS_FILE_BROWSER_DIRECTORY_ALREADY_EXISTS" desc="Error message displayed when user tries to create a directory with an existing name.">
-    The folder named "$1" already exists. Please choose a different name.
-  </message>
-  <message name="IDS_FILE_BROWSER_ERROR_RENAMING" desc="Error message.">
-    Unable to rename "<ph name="FILE_NAME">$1<ex>document.pdf</ex></ph>". <ph name="ERROR_MESSAGE">$2<ex>An error occurred (code: ABORT)</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_GET_INFO_BUTTON_LABEL" desc="Context menu item that shows the currently-selected file's metadata.">
-    Get info
-  </message>
-  <message name="IDS_FILE_BROWSER_RENAME_BUTTON_LABEL" desc="Context menu item that renames the currently-selected file.">
-    Rename
-  </message>
-  <message name="IDS_FILE_BROWSER_DELETE_BUTTON_LABEL" desc="Context menu item that deletes the currently-selected file(s).">
-    Delete
-  </message>
-  <message name="IDS_FILE_BROWSER_PASTE_BUTTON_LABEL" desc="Context menu item that pastes the file(s) in the clipboard.">
-    Paste
-  </message>
-  <message name="IDS_FILE_BROWSER_REFRESH_BUTTON_LABEL" desc="Label for a button for refreshing the current directory.">
-    Refresh
-  </message>
-  <message name="IDS_FILE_BROWSER_PASTE_INTO_FOLDER_BUTTON_LABEL" desc="Menu item label, pasting files into the selected folder.">
-    Paste into folder
-  </message>
-  <message name="IDS_FILE_BROWSER_COPY_BUTTON_LABEL" desc="Context menu item that copies the currently-selected file(s) to the clipboard.">
-    Copy
-  </message>
-  <message name="IDS_FILE_BROWSER_CUT_BUTTON_LABEL" desc="Context menu item that cuts the currently-selected file(s) to the clipboard.">
-    Cut
-  </message>
-  <message name="IDS_FILE_BROWSER_OPEN_WITH_BUTTON_LABEL" desc="Menu item label, showing dialog to choose extension to open selected files or directories.">
-    Open with...
-  </message>
-  <message name="IDS_FILE_BROWSER_MORE_ACTIONS_BUTTON_LABEL" desc="Menu item label, showing dialog to choose extension to open/share/pack/etc... selected files or directories.">
-    More actions
-  </message>
-  <message name="IDS_FILE_BROWSER_OPEN_WITH_VERB_BUTTON_LABEL" desc="Verb that describe the action of opening one or more files or directories with the given extension.">
-    Open with <ph name="EXTENSION_NAME">$1<ex>Gallery</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_ADD_TO_VERB_BUTTON_LABEL" desc="Verb that describes the uploading or addition of one or multiple files or directories to the given extension.">
-    Add to <ph name="EXTENSION_NAME">$1<ex>Evernote</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_PACK_WITH_VERB_BUTTON_LABEL" desc="Verb that describes the packing or archiving of one or multiple files or directories with the given extension.">
-    Pack with <ph name="EXTENSION_NAME">$1<ex>ZIP</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_SHARE_WITH_VERB_BUTTON_LABEL" desc="Verb that describes the action of sharing/attaching/sending files with the given application.">
-    Share with <ph name="EXTENSION_NAME">$1<ex>GMail</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_ZIP_SELECTION_BUTTON_LABEL" desc="Menu item label, showing dialog to create zip file for selected files.">
-    Zip selection
-  </message>
-  <message name="IDS_FILE_BROWSER_SET_WALLPAPER_BUTTON_LABEL" desc="The context menu item to set wallpaper.">
-    Set wallpaper
-  </message>
-  <message name="IDS_FILE_BROWSER_CREATE_FOLDER_SHORTCUT_BUTTON_LABEL" desc="Menu item label, creating a shortcut of the selected folder to the left nav.">
-    Create shortcut
-  </message>
-  <message name="IDS_FILE_BROWSER_REMOVE_FOLDER_SHORTCUT_BUTTON_LABEL" desc="Menu item label, unpinning the selected folder from the left nav.">
-    Remove shortcut
-  </message>
-  <message name="IDS_FILE_BROWSER_SELECT_ALL_COMMAND_LABEL" desc="Menu item label, select all files and folders in the right view">
-    Select all
-  </message>
-  <message name="IDS_FILE_BROWSER_SHARE_BUTTON_LABEL" desc="Menu item's label, showing dialog to share the selected Google Drive files. This message is also used as a tooltip label and a spoken feedback label of a button which also shows the dialog to share the files. The translation should be consistent with the sharing dialog's title in Google Drive Web UI.">
-    Share with others
-  </message>
-  <message name="IDS_FILE_BROWSER_MANAGE_IN_DRIVE_BUTTON_LABEL" desc="Menu item's label, showing dialog to open the selected Google Drive files in the Drive webpage for managing sharing permissions, etc.">
-    Manage in Drive
-  </message>
-  <message name="IDS_FILE_BROWSER_TOGGLE_HIDDEN_FILES_COMMAND_LABEL" desc="Label for menu or button with checkmark that toggles visibility of hidden files.">
-    Show hidden files
-  </message>
-  <message name="IDS_FILE_BROWSER_TASKS_BUTTON_LABEL" desc="Label for button that selects a task to open the current file.">
-    Open
-  </message>
-  <message name="IDS_FILE_BROWSER_CANCEL_SELECTION_BUTTON_LABEL" desc="Label for button that unselects all selected items.">
-    Cancel selection
-  </message>
-  <message name="IDS_FILE_BROWSER_CHANGE_TO_LISTVIEW_BUTTON_LABEL" desc="Label for button that changes the view mode to 'list view' mode.">
-    Switch to list view
-  </message>
-  <message name="IDS_FILE_BROWSER_CHANGE_TO_THUMBNAILVIEW_BUTTON_LABEL" desc="Label for button that changes the view mode to 'thumbnail view' mode.">
-    Switch to thumbnail view
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_TITLE" desc="Title of the cloud import feature.">
-    Cloud backup
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_DESTINATION_FOLDER" desc="Title of the cloud import destination folder.">
-    Chrome OS Cloud backup
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_DESCRIPTION" desc="Short description of the cloud import feature.">
-    Back up your media device’s photos and videos to Google Drive.
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_START" desc="Tooltip of the toolbar button that starts backup.">
-    Backup your photos and videos
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_SHOW_DETAILS" desc="Tooltip for button that shows details panel.">
-    Show Cloud backup details
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_COMMAND" desc="Label of button on details panel that invokes cloud import feature.">
-    Back up
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_CANCEL_COMMAND" desc="Label of button on details panel that cancels an active import.">
-    Cancel
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_ONE_FILE" desc="Cloud import 1 new photo.">
-    1 new photo
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_MULTIPLE_FILES" desc="Cloud import multiple new photos.">
-    <ph name="FILE_COUNT">$1<ex>5</ex></ph> new photos
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_SCANNING" desc="Cloud import scanning status message.">
-    Scanning your media device...
-    <ph name="LINE_BREAK1">&lt;br&gt;</ph>
-    <ph name="FILE_COUNT">$1<ex>5 new photos</ex></ph> found
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_SCANNING" desc="Cloud import scanning tooltip.">
-    Scanning your media device...
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_NO_MEDIA" desc="Cloud import no-new-media-found status message. Shown after backup is completed and when a search for new files to backup produces no result.">
-    All backed up to <ph name="BEGIN_LINK">&lt;a is='action-link' class='destination-link'&gt;</ph>Google Drive!<ph name="END_LINK">&lt;/a&gt;</ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_NO_MEDIA" desc="Cloud import no-new-media-found tooltip. Shown after backup is completed and when a search for new files to backup produces no result.">
-    All backed up!
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_INSUFFICIENT_CLOUD_SPACE" desc="Cloud import insufficient cloud space status message.">
-    <ph name="FILE_COUNT">$1<ex>5 new photos</ex></ph> found.
-    <ph name="LINE_BREAK1">&lt;br&gt;</ph>
-    Your Google Drive quota isn't large enough. Additional <ph name="FILE_SIZE">$2<ex>5 MB</ex></ph> needed.
-    <ph name="LINE_BREAK2">&lt;br&gt;</ph>
-    Try selecting fewer photos.
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_INSUFFICIENT_CLOUD_SPACE" desc="Cloud import insufficient cloud space tooltip.">
-    Your Google Drive quota isn't large enough.
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_INSUFFICIENT_LOCAL_SPACE" desc="Cloud import insufficient local space status message.">
-    <ph name="FILE_COUNT">$1<ex>5 new photos</ex></ph> found.
-    <ph name="LINE_BREAK1">&lt;br&gt;</ph>
-    Not enough space available in local storage. Additional <ph name="FILE_SIZE">$2<ex>5 MB</ex></ph> needed.
-    <ph name="LINE_BREAK2">&lt;br&gt;</ph>
-    Try selecting fewer photos.
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_INSUFFICIENT_LOCAL_SPACE" desc="Cloud import insufficient local space tooltip.">
-    Not enough space available in local storage.
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_READY" desc="Cloud import ready status message.">
-    <ph name="FILE_COUNT">$1<ex>5 new photos</ex></ph> found
-    <ph name="LINE_BREAK1">&lt;br&gt;</ph>
-    Ready to back up to <ph name="BEGIN_LINK">&lt;a is='action-link' class='destination-link'&gt;</ph>Google Drive<ph name="END_LINK">&lt;/a&gt;</ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_READY" desc="Cloud import ready tooltip.">
-    Ready to backup <ph name="FILE_COUNT">$1<ex>5 new photos</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_IMPORTING" desc="Cloud import active-backup status. Message shown when importing is in progress">
-    Backing up <ph name="FILE_COUNT">$1<ex>5 new photos</ex></ph> to <ph name="BEGIN_LINK">&lt;a is='action-link' class='destination-link'&gt;</ph>Google Drive<ph name="END_LINK">&lt;/a&gt;</ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_IMPORTING" desc="Cloud import active-backup tooltip.">
-    Backing up <ph name="FILE_COUNT">$1<ex>5 new photos</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_DONE" desc="Cloud import backup is complete status.">
-    <ph name="FILE_COUNT">$1<ex>5</ex></ph> photos backed up to <ph name="BEGIN_LINK">&lt;a is='action-link' class='destination-link'&gt;</ph>Google Drive<ph name="END_LINK">&lt;/a&gt;</ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_ERROR_ITEM" desc="Cloud import error message for a file it couldn't back up.">
-    Couldn't back up <ph name="FILE_NAME">$1<ex>photo.jpg</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_DONE" desc="Cloud import backup is complete tooltip.">
-    <ph name="FILE_COUNT">$1<ex>5</ex></ph> photos backed up
-  </message>
-  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_ITEMS_REMAINING" desc="File Manager status message.">
-    Importing <ph name="FILE_COUNT">$1<ex>5</ex></ph> files...
-  </message>
-  <message name="IDS_FILE_BROWSER_COPY_FILE_NAME" desc="File Manager status message.">
-    Copying <ph name="FILE_NAME">$1<ex>movie.avi</ex></ph>...
-  </message>
-  <message name="IDS_FILE_BROWSER_COPY_ITEMS_REMAINING" desc="File Manager status message. 'Item' is used here as a generic term for file or directory.">
-    Copying $1 items...
-  </message>
-  <message name="IDS_FILE_BROWSER_COPY_TARGET_EXISTS_ERROR" desc="File Manager error message. 'Item' is used here as a generic term for file or directory.">
-    Whoops, <ph name="FILE_NAME">$1<ex>movie.avi</ex></ph> already exists. Rename it and try again.
-  </message>
-  <message name="IDS_FILE_BROWSER_COPY_SOURCE_NOT_FOUND_ERROR" desc="File Manager error message. 'Item' is used here as a generic term for file or directory.">
-    Whoops, <ph name="FILE_NAME">$1<ex>movie.avi</ex></ph> no longer exists.
-  </message>
-  <message name="IDS_FILE_BROWSER_COPY_FILESYSTEM_ERROR" desc="File Manager error message.">
-    Copy operation failed. <ph name="ERROR_MESSAGE">$1<ex>An error occurred (code: ABORT)</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_COPY_UNEXPECTED_ERROR" desc="File Manager error message.">
-    Copy operation failed, unexpected error: $1
-  </message>
-  <message name="IDS_FILE_BROWSER_MOVE_FILE_NAME" desc="File Manager status message.">
-    Moving <ph name="FILE_NAME">$1<ex>movie.avi</ex></ph>...
-  </message>
-  <message name="IDS_FILE_BROWSER_MOVE_ITEMS_REMAINING" desc="File Manager status message. 'Item' is used here as a generic term for file or directory.">
-    Moving $1 items...
-  </message>
-  <message name="IDS_FILE_BROWSER_MOVE_TARGET_EXISTS_ERROR" desc="File Manager error message. 'Item' is used here as a generic term for file or directory.">
-    Whoops, <ph name="FILE_NAME">$1<ex>movie.avi</ex></ph> already exists. Rename it and try again.
-  </message>
-  <message name="IDS_FILE_BROWSER_MOVE_SOURCE_NOT_FOUND_ERROR" desc="File Manager error message. 'Item' is used here as a generic term for file or directory.">
-    Whoops, <ph name="FILE_NAME">$1<ex>movie.avi</ex></ph> no longer exists.
-  </message>
-  <message name="IDS_FILE_BROWSER_MOVE_FILESYSTEM_ERROR" desc="File Manager error message.">
-    Move failed. <ph name="ERROR_MESSAGE">$1<ex>An error occurred (code: ABORT)</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_MOVE_UNEXPECTED_ERROR" desc="File Manager error message.">
-    Move failed, unexpected error: $1
-  </message>
-  <message name="IDS_FILE_BROWSER_ZIP_FILE_NAME" desc="File Manager status message.">
-    Zipping <ph name="FILE_NAME">$1<ex>movie.avi</ex></ph>...
-  </message>
-  <message name="IDS_FILE_BROWSER_ZIP_ITEMS_REMAINING" desc="File Manager status message. 'Item' is used here as a generic term for file or directory.">
-    Zipping $1 items...
-  </message>
-  <message name="IDS_FILE_BROWSER_ZIP_TARGET_EXISTS_ERROR" desc="File Manager error message. 'Item' is used here as a generic term for file or directory.">
-    Zipping failed, item exists: "$1"
-  </message>
-  <message name="IDS_FILE_BROWSER_ZIP_FILESYSTEM_ERROR" desc="File Manager error message.">
-    Zipping failed. <ph name="ERROR_MESSAGE">$1<ex>An error occurred (code: ABORT)</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_ZIP_UNEXPECTED_ERROR" desc="File Manager error message.">
-    Zipping failed, unexpected error: $1
-  </message>
-  <message name="IDS_FILE_BROWSER_SYNC_FILE_NAME" desc="File Manager status message.">
-    Syncing <ph name="FILE_NAME">$1<ex>movie.avi</ex></ph>...
-  </message>
-  <message name="IDS_FILE_BROWSER_SYNC_FILE_NUMBER" desc="File Manager status message.">
-    Syncing <ph name="NUMBER_OF_FILES">$1<ex>7</ex></ph> items...
-  </message>
-  <message name="IDS_FILE_BROWSER_SYNC_DELETE_WITHOUT_PERMISSION_ERROR" desc="File Manager status message shown when the drive sync is failed because a user try to remove shared files that the user does not own.">
-    "<ph name="FILENAME">$1<ex>photo.jpg</ex></ph>" has been shared with you. You cannot delete it because you do not own it.
-  </message>
-  <message name="IDS_FILE_BROWSER_SYNC_SERVICE_UNAVAILABLE_ERROR" desc="File Manager status message shown when the drive sync is failed because Google Drive is temporary unavailable.">
-    Google Drive is not available right now. Uploading will automatically restart once Google Drive is back.
-  </message>
-  <message name="IDS_FILE_BROWSER_SYNC_MISC_ERROR" desc="File Manager status message shown when the drive sync is failed because of miscellaneous errors.">
-    Google Drive was unable to sync "<ph name="FILENAME">$1<ex>photo.jpg</ex></ph>" right now. Google Drive will try again later.
-  </message>
-  <message name="IDS_FILE_BROWSER_SYNC_NO_SERVER_SPACE" desc="File Manager status message shown when the drive sync is failed because it runs out the space in Google Drive server.">
-    "<ph name="FILENAME">$1<ex>photo.jpg</ex></ph>" was not uploaded. There is not enough free space in your Google Drive.
-  </message>
-  <message name="IDS_FILE_BROWSER_SHARE_ERROR" desc="File Manager error message when sharing a file or a directory on Drive fails because of internet connection problems.">
-    Sharing failed. Check your connection and try again later.
-  </message>
-  <message name="IDS_FILE_BROWSER_DELETE_FILE_NAME" desc="File Manager status message.">
-    Deleting "<ph name="FILENAME">$1<ex>photo.jpg</ex></ph>"...
-  </message>
-  <message name="IDS_FILE_BROWSER_DELETE_ITEMS_REMAINING" desc="File Manager status message. 'Item' is used here as a generic term for file or directory.">
-    Deleting <ph name="COUNT">$1<ex>10</ex></ph> items...
-  </message>
-  <message name="IDS_FILE_BROWSER_DELETE_ERROR" desc="Message informing about error while deleting an item or items.">
-    An error occurred. Some items may not have been deleted.
-  </message>
-
-  <message name="IDS_FILE_BROWSER_COPY_PROGRESS_SUMMARY" desc="Summary message for multiple copying tasks above the progress bar.">
-    Copying...
-  </message>
-  <message name="IDS_FILE_BROWSER_MOVE_PROGRESS_SUMMARY" desc="Summary message for multiple moving tasks above the progress bar.">
-    Moving...
-  </message>
-  <message name="IDS_FILE_BROWSER_ZIP_PROGRESS_SUMMARY" desc="Summary message for multiple zipping tasks above the progress bar.">
-    Zipping...
-  </message>
-  <message name="IDS_FILE_BROWSER_DELETE_PROGRESS_SUMMARY" desc="Summary message for multiple deleting tasks above the progress bar.">
-    Deleting...
-  </message>
-  <message name="IDS_FILE_BROWSER_TRANSFER_PROGRESS_SUMMARY" desc="Summary message for mixed operation tasks above the progress bar. 'Transferring' is used here as a generic term for copying, moving, zipping, or deleting.">
-    Transferring...
-  </message>
-  <message name="IDS_FILE_BROWSER_SYNC_PROGRESS_SUMMARY" desc="Summary message for drive sync operation. This message can be shown without a progress bar.">
-    Syncing...
-  </message>
-  <message name="IDS_FILE_BROWSER_ERROR_PROGRESS_SUMMARY" desc="Summary message for an error above the progress bar. This message may be placed at the next to ohter *_PROGERSS_SUMMARY messages.">
-    1 error.
-  </message>
-  <message name="IDS_FILE_BROWSER_ERROR_PROGRESS_SUMMARY_PLURAL" desc="Summary message for multiple errors above the progress bar. This message may be placed at the next to ohter *_PROGERSS_SUMMARY messages.">
-    <ph name="COUNT">$1<ex>10</ex></ph> errors.
-  </message>
-
-  <message name="IDS_FILE_BROWSER_CANCEL_LABEL" desc="Cancel label.">
-    Cancel
-  </message>
-  <message name="IDS_FILE_BROWSER_OPEN_LABEL" desc="Open label.">
-    Open
-  </message>
-  <message name="IDS_FILE_BROWSER_SAVE_LABEL" desc="Save label.">
-    Save
-  </message>
-  <message name="IDS_FILE_BROWSER_OK_LABEL" desc="OK label.">
-    OK
-  </message>
-  <message name="IDS_FILE_BROWSER_UPLOAD_LABEL" desc="Upload label.">
-    Upload
-  </message>
-  <message name="IDS_FILE_BROWSER_SEARCH_TEXT_LABEL" desc="Search text field label.">
-    Search
-  </message>
-
-  <message name="IDS_FILE_BROWSER_DEFAULT_NEW_FOLDER_NAME" desc="The default name for a newly created folder.">
-    New Folder
-  </message>
-
- <message name="IDS_FILE_BROWSER_CONFIRM_DELETE_ONE" desc="Asks the user if they are sure they want to delete a single file.">
-   Are you sure you want to delete "$1"?
- </message>
- <message name="IDS_FILE_BROWSER_CONFIRM_DELETE_SOME" desc="Asks the user if they are sure they want to delete multiple files/directories.">
-   Are you sure you want to delete $1 items?
- </message>
-
-  <message name="IDS_FILE_BROWSER_UNKNOWN_FILESYSTEM_WARNING" desc="Displayed when device contents cannot be read because filesystem is unknown.">
-    This device cannot be opened because its filesystem was not recognized.
-  </message>
-  <message name="IDS_FILE_BROWSER_UNSUPPORTED_FILESYSTEM_WARNING" desc="Displayed when device contents cannot be read because filesystem is unsupported.">
-    This device cannot be opened because its filesystem is not supported.
-  </message>
-  <message name="IDS_FILE_BROWSER_FORMATTING_WARNING" desc="Displayed when you attempt to format device.">
-    Formatting the removable media is going to erase all data. Do you wish to continue?
-  </message>
-
-  <message name="IDS_FILE_BROWSER_SUGGEST_DIALOG_TITLE" desc="Title of the suggest app dialog, which shows the list of the apps which supports the selected file.">
-    Select an app to open this file
-  </message>
-  <message name="IDS_FILE_BROWSER_SUGGEST_DIALOG_FOR_PROVIDERS_TITLE" desc="Title of the suggest app dialog, which shows the list of the apps that can be added to the left nav of the Files app.">
-    Available services
-  </message>
-  <message name="IDS_FILE_BROWSER_SUGGEST_DIALOG_LINK_TO_WEBSTORE" desc="Text of the link to the app list on Chrome Webstore, which shows the more apps than in the suggest app dialog.">
-    See more...
-  </message>
-  <message name="IDS_FILE_BROWSER_SUGGEST_DIALOG_INSTALLATION_FAILED" desc="Error message when the installation of the app from WebStore is failed.">
-    Installation failed.
-  </message>
-  <message name="IDS_FILE_BROWSER_DROP_TARGET_DEVICE_WRITE_PROTECTED" desc="Tooltip label displayed besides mouse pointer while dragging files or folders over a write-protected folder or disk.">
-    Device is read-only
-  </message>
-  <message name="IDS_FILE_BROWSER_DROP_TARGET_ACCESS_RESTRICTED" desc="Tooltip label displayed besides mouse pointer when dragging files or folders over a removable device whose write access is restricted by administration policy.">
-    Access restricted
-  </message>
-  <message name="IDS_FILE_BROWSER_DROP_TARGET_FOLDER_NO_MOVE_PERMISSION" desc="Tooltip label displayed besides mouse pointer while dragging files or folders over a Team Drive or folder in Drive that does not have write access.">
-    You don't have permission to move files into '<ph name="FOLDER_NAME">$1<ex>Trip Photos</ex></ph>'.
-  </message>
-  <message name="IDS_FILE_BROWSER_DROP_TARGET_OPENING_LINUX_FILES" desc="Tooltip label displayed besides mouse pointer when dragging files or folders over Linux files root before the container has been started and mounted.">
-    Opening Linux files...
-  </message>
-
-  <message name="IDS_FILE_BROWSER_SELECT_FOLDER_TITLE" desc="Select folder title.">
-    Select a folder to open
-  </message>
-  <message name="IDS_FILE_BROWSER_SELECT_UPLOAD_FOLDER_TITLE" desc="Select folder title for upload.">
-    Select a folder to upload
-  </message>
-  <message name="IDS_FILE_BROWSER_SELECT_OPEN_FILE_TITLE" desc="Select open file title.">
-    Select a file to open
-  </message>
-  <message name="IDS_FILE_BROWSER_SELECT_OPEN_MULTI_FILE_TITLE" desc="Select open multi file title.">
-    Select one or more files
-  </message>
-  <message name="IDS_FILE_BROWSER_SELECT_SAVEAS_FILE_TITLE" desc="Select saveas file title.">
-    Save file as
-  </message>
-
-  <message name="IDS_FILE_BROWSER_ONE_FILE_SELECTED" desc="One file selected.">
-    1 file selected
-  </message>
-  <message name="IDS_FILE_BROWSER_ONE_DIRECTORY_SELECTED" desc="One directory selected.">
-    1 folder selected
-  </message>
-  <message name="IDS_FILE_BROWSER_MANY_FILES_SELECTED" desc="Many files selected.">
-    <ph name="SELCTED_FILE_COUNT">$1<ex>13</ex></ph> files selected
-  </message>
-  <message name="IDS_FILE_BROWSER_MANY_DIRECTORIES_SELECTED" desc="Many directories selected.">
-    <ph name="SELCTED_FOLDERS_COUNT">$1<ex>2</ex></ph> folders selected
-  </message>
-  <message name="IDS_FILE_BROWSER_MANY_ENTRIES_SELECTED" desc="Many items (both files and directories) selected.">
-    <ph name="SELCTED_FILES_COUNT">$1<ex>21</ex></ph> items selected
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_ALBUM_TITLE" desc="Label for audio album title.">
-    Album
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_AUDIO_INFO" desc="Category label for audio file info.">
-    Audio info
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_CODEC" desc="Label for video codec.">
-    Codec
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_CREATED_BY" desc="Label for who created the file.">
-    Created by
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_CREATION_TIME" desc="Label for file creation time.">
-    Created time
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_DIMENSION" desc="Label for image dimensions.">
-    Dimensions
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_DURATION" desc="Label for audio/video duration.">
-    Duration
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_EXIF_DEVICE_MODEL" desc="Label for the device model which created the image.">
-    Device model
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_EXIF_DEVICE_SETTINGS" desc="Label for the device settings (exif's F number, exposure time, focal length and ISO speed rating) metadata.">
-    Device settings
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_EXIF_GEOGRAPHY" desc="Label for the latitude and the longitude where the image was taken.">
-    Geography
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_FILE_PATH" desc="Label for file path.">
-    Path
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_FILE_SIZE" desc="Label for file size.">
-    Size
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_FRAME_RATE" desc="Label for video frame rate.">
-    Frame rate
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_GENERAL_INFO" desc="Category label for general file info.">
-    General info
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_GENRE" desc="Label for audio genre.">
-    Genre
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_IMAGE_INFO" desc="Category label for image file info.">
-    Image info
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_MEDIA_ARTIST" desc="Label for media artist.">
-    Artist
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_MEDIA_MIME_TYPE" desc="Label for media mime type.">
-    Type
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_MEDIA_TITLE" desc="Label for media title.">
-    Title
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_MODIFICATION_TIME" desc="Label for file modification time.">
-    Modified time
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_MODIFIED_BY" desc="Label for who modified the file.">
-    Modified by
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_PAGE_COUNT" desc="Label for pdf page count.">
-    Page count
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_SOURCE" desc="Label for the device used to capture the image.">
-    Source
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_TRACK" desc="Label for track number.">
-    Track
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_VIDEO_INFO" desc="Category label for video file info.">
-    Video info
-  </message>
-  <message name="IDS_FILE_BROWSER_METADATA_BOX_YEAR_RECORDED" desc="Label for audio recorded year.">
-    Year recorded
-  </message>
-  <message name="IDS_FILE_BROWSER_CALCULATING_SIZE" desc="Message informing the user that total items size is being calculated.">
-    Calculating size
-  </message>
-  <message name="IDS_FILE_BROWSER_OFFLINE_HEADER" desc="Message informing the user that the browser is offline.">
-    You are offline
-  </message>
-  <message name="IDS_FILE_BROWSER_OFFLINE_MESSAGE" desc="Message informing the user how to make the selected file available offline.">
-    To save this file for offline use, get back online, right-click the file, and select the <ph name="OFFLINE_CHECKBOX_NAME">'$1'<ex>'Available offline'</ex></ph> option.
-  </message>
-  <message name="IDS_FILE_BROWSER_OFFLINE_MESSAGE_PLURAL" desc="Message informing the user how to make multiple selected files available offline.">
-    To save these files for offline use, get back online, right-click the files, and select the <ph name="OFFLINE_CHECKBOX_NAME">'$1'<ex>'Available offline'</ex></ph> option.
-  </message>
-  <message name="IDS_FILE_BROWSER_QUICK_VIEW_NO_PLAYBACK_AVAILABLE" desc="Massage for user to notify no playback is available.">
-    No playback available
-  </message>
-  <message name="IDS_FILE_BROWSER_QUICK_VIEW_NO_PREVIEW_AVAILABLE" desc="Massage for user to notify no preview is available.">
-    No preview available
-  </message>
-  <message name="IDS_FILE_BROWSER_HOSTED_OFFLINE_MESSAGE" desc="Message informing the user that the selected file is only available online.">
-    You must be online to access this file.
-  </message>
-  <message name="IDS_FILE_BROWSER_HOSTED_OFFLINE_MESSAGE_PLURAL" desc="Message informing the user that the selected files are only available online.">
-    You must be online to access these files.
-  </message>
-  <message name="IDS_FILE_BROWSER_CONFIRM_MOBILE_DATA_USE" desc="Message informing the user that opening the file from Google Drive will use mobile data.">
-    Fetching this file will use approximately <ph name="FILE_SIZE">$1<ex>44 MB</ex></ph> of mobile data.
-  </message>
-  <message name="IDS_FILE_BROWSER_CONFIRM_MOBILE_DATA_USE_PLURAL" desc="Message informing the user that opening several files from Google Drive will use mobile data.">
-    Fetching these files will use approximately <ph name="FILE_SIZE">$1<ex>44 MB</ex></ph> of mobile data.
-  </message>
-  <message name="IDS_FILE_BROWSER_DISABLED_MOBILE_SYNC_NOTIFICATION_MESSAGE" desc="Notification message shown when the drive sync is needed on mobile network, but it is disabled.">
-    Google Drive sync is disabled by default, when using mobile data.
-  </message>
-  <message name="IDS_FILE_BROWSER_DISABLED_MOBILE_SYNC_NOTIFICATION_ENABLE_BUTTON" desc="Button label to enable drive sync over, on the notifcation of |IDS_FILE_BROWSER_DISABLED_MOBILE_SYNC_NOTIFICATION_MESSAGE|.">
-    Enable syncing over mobile data
-  </message>
-  <message name="IDS_FILE_BROWSER_OPEN_IN_OTHER_DESKTOP_MESSAGE" desc="Message of an alert dialog that is shown when a user opens a file in a desktop of another profile but the file is opened in the original desktop.">
-    This file opened on a different desktop. Move to <ph name="USER_NAME">$1<ex>John Doe</ex></ph> (<ph name="MAIL_ADDRESS">$2<ex>xxxxxx@gmail.com</ex></ph>) to view it.
-  </message>
-  <message name="IDS_FILE_BROWSER_OPEN_IN_OTHER_DESKTOP_MESSAGE_PLURAL" desc="Prural verson of the message of an alert dialog that is shown when a user opens a file in a desktop of another profile but the file is opened in the original desktop.">
-    These files opened on a different desktop. Move to <ph name="USER_NAME">$1<ex>John Doe</ex></ph> (<ph name="MAIL_ADDRESS">$2<ex>xxxxxx@gmail.com</ex></ph>) to view it.
-  </message>
-  <message name="IDS_FILE_BROWSER_MULTI_PROFILE_SHARE_DIALOG_TITLE" desc="Title of a dialog to request drive share for files that come from other profiles during file transfering.">
-    This Drive file isn't shared yet
-  </message>
-  <message name="IDS_FILE_BROWSER_MULTI_PROFILE_SHARE_DIALOG_TITLE_PLURAL" desc="Title of a dialog to request drive share for files that come from other profiles during file transfering.">
-    These Drive files aren't shared yet
-  </message>
-  <message name="IDS_FILE_BROWSER_MULTI_PROFILE_SHARE_DIALOG_MESSAGE" desc="Message of a dialog to request drive share for files that come from other profiles during file transfering. Below the message, there are the e-mail address of the account to be shared with the file, and a drop down list to select a share type.">
-    Change how this file is shared
-  </message>
-  <message name="IDS_FILE_BROWSER_MULTI_PROFILE_SHARE_DIALOG_MESSAGE_PLURAL" desc="Message of a dialog to request drive share for files that come from other profiles during file transfering. Below the message, there are the e-mail address of the account to be shared with the file, and a drop down list to select a share type.">
-    Change how these files are shared
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_SHARE_TYPE_CAN_EDIT" desc="Label text of 'Can edit' share type. Please use the same string with Google Drive.">
-    Can edit
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_SHARE_TYPE_CAN_COMMENT" desc="Label text of 'Can comment' share type. Please use the same string with Google Drive.">
-    Can comment
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_SHARE_TYPE_CAN_VIEW" desc="Label text of 'Can view' share type. Please use the same string with Google Drive.">
-    Can view
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_MOBILE_CONNECTION_OPTION" desc="Option that determines if we will allow Google Drive content sync over mobile connections.">
-    Do not use mobile data for sync
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_SHOW_HOSTED_FILES_OPTION" desc="Option that determines if we will show hosted Google Docs files in file browser.">
-    Show Google Docs files
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_MENU_HELP" desc="In the Google Drive settings menu, name of the Help item.">
-    Help
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_BUY_MORE_SPACE" desc="Menu item, offering user to buy more space on Google Drive">
-    Buy more storage...
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_VISIT_DRIVE_GOOGLE_COM" desc="Menu item, redirecting user to drive.google.com">
-    Go to drive.google.com...
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_SPACE_AVAILABLE_LONG" desc="Text showing space left on Google Drive">
-    Google Drive space left: <ph name="SPACE_AVAILABLE">$1<ex>400 MB</ex></ph>.
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_BUY_MORE_SPACE_LINK" desc="Text on the link, offering user to buy more space on Google Drive">
-    Buy more storage
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_OUT_OF_SPACE_HEADER" desc="Message informing the user that there is not enough space to make the selected file(s) available offline.">
-    You have run out of space
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_CANNOT_REACH" desc="Message informing the user that Google Drive can not be reached at this moment.">
-    Google Drive cannot be reached at this time.
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_OUT_OF_SPACE_MESSAGE" desc="Message informing the user how to make more space available to save the selected file offline.">
-    To save "<ph name="FILE_NAME">$1<ex>document.pdf</ex></ph>" offline you must free up an additional <ph name="TOTAL_FILE_SIZE">$2<ex>3.3 MB</ex></ph> of space:<ph name="MARKUP_1">&lt;br&gt;<ex>&lt;br&gt;</ex></ph>
-    <ph name="MARKUP_2">&lt;ul&gt;&lt;li&gt;<ex>&lt;ul&gt;&lt;li&gt;</ex></ph>unpin files that you no longer need to access offline<ph name="MARKUP_3">&lt;/li&gt;<ex>>&lt;/li&gt;</ex></ph>
-    <ph name="MARKUP_4">&lt;li&gt;<ex>&lt;li&gt;</ex></ph>delete files from your Downloads folder<ph name="MARKUP_5">&lt;/li&gt;&lt;/ul&gt;<ex>&lt;/li&gt;&lt;/ul&gt;</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_NOT_REACHED" desc="Message informing that Drive is unreachable and encuraging user to log out from the device and log back in.">
-    Google Drive could not be reached. Please <ph name="BEGIN_LINK">&lt;a href="javascript://"&gt;<ex>&lt;a href="javascript://"&gt;</ex></ph>log out<ph name="END_LINK">&lt;/a&gt;<ex>&lt;/a&gt;</ex></ph> and log back in.
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_WELCOME_TITLE" desc="In the Welcome to Google Drive banner, title of banner.">
-    Welcome to Google Drive!
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_WELCOME_TITLE_ALTERNATIVE" desc="In the Welcome to Google Drive banner, title of the alternative banner offering 100GB free storage.">
-    Get 100 GB free with Google Drive
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_WELCOME_TITLE_ALTERNATIVE_1TB" desc="In the Welcome to Google Drive banner, title of the alternative banner offering 1TB free storage.">
-    Get 1 TB free with Google Drive
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_WELCOME_TEXT_SHORT" desc="In the Welcome to Google Drive banner, text of the welcome message, short version.">
-    All files saved in this folder are backed up online automatically
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_WELCOME_TEXT_LONG" desc="In the Welcome to Google Drive banner, text of the welcome message, long version.">
-    <ph name="MARKUP_1">&lt;p&gt;&lt;strong&gt;<ex>&lt;strong&gt;</ex></ph>Access files from everywhere, even offline.<ph name="MARKUP_2">&lt;/strong&gt;<ex>&lt;/strong&gt;</ex></ph>
-    Files in Google Drive are up to date and available from any device.<ph name="MARKUP_3">&lt;/p&gt;<ex>&lt;/p&gt;</ex></ph>
-    <ph name="MARKUP_4">&lt;p&gt;&lt;strong&gt;<ex>&lt;strong&gt;</ex></ph>Keep your files safe.<ph name="MARKUP_5">&lt;/strong&gt;<ex>&lt;/strong&gt;</ex></ph>
-    No matter what happens to your device, your files are safely stored in Google Drive.<ph name="MARKUP_6">&lt;/p&gt;<ex>&lt;/p&gt;</ex></ph>
-    <ph name="MARKUP_7">&lt;p&gt;&lt;strong&gt;<ex>&lt;strong&gt;</ex></ph>Share, create and collaborate<ph name="MARKUP_8">&lt;/strong&gt;<ex>&lt;/strong&gt;</ex></ph>
-    on files with others all in one place.<ph name="MARKUP_9">&lt;/p&gt;<ex>&lt;/p&gt;</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_WELCOME_CHECK_ELIGIBILITY" desc="In the Welcome to Google Drive banner, a text on the button to check promo eligibility.">
-    Check eligibility
-  </message>
-  <message name="IDS_FILE_BROWSER_DRIVE_WELCOME_DISMISS" desc="In the Welcome to Google Drive banner, a text on the button to dismiss the banner.">
-    Dismiss
-  </message>
-  <message name="IDS_FILE_BROWSER_NO_TASK_FOR_FILE" desc="Message shown when user tries to open file, which we can't handle.">
-    This file type is not supported. Please visit the <ph name="BEGIN_LINK">&lt;a target='_blank' href='$1'&gt;<ex>&lt;a target='_blank' href='$1'&gt;</ex></ph>Chrome Web Store<ph name="END_LINK">&lt;/a&gt;<ex>&lt;/a&gt;</ex></ph> to find an app that can open this type of file.
-    <ph name="BEGIN_LINK_HELP">&lt;a target='_blank' href='$2'&gt;<ex>&lt;a target='_blank' href='$2'&gt;</ex></ph>Learn More<ph name="END_LINK_HELP">&lt;/a&gt;<ex>&lt;/a&gt;</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_NO_TASK_FOR_EXECUTABLE" desc="Message shown when user tries to open a windows executable file, which we can't handle.">
-    This file is designed for a PC using Windows software. This is not compatible with your device which runs Chrome OS. Please search the <ph name="BEGIN_LINK">&lt;a target='_blank' href='$1'&gt;<ex>&lt;a target='_blank' href='$1'&gt;</ex></ph>Chrome Web Store<ph name="END_LINK">&lt;/a&gt;<ex>&lt;/a&gt;</ex></ph> for a suitable replacement app.<ph name="BEGIN_LINK_HELP">&lt;a target='_blank' href='$2'&gt;<ex>&lt;a target='_blank' href='$2'&gt;</ex></ph>Learn More<ph name="END_LINK_HELP">&lt;/a&gt;<ex>&lt;/a&gt;</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_NO_TASK_FOR_DMG" desc="Message shown when user tries to open a windows executable file, which we can't handle.">
-    This file is designed for a computer using Macintosh software. This is not compatible with your device which runs Chrome OS. Please search the <ph name="BEGIN_LINK">&lt;a target='_blank' href='$1'&gt;<ex>&lt;a target='_blank' href='$1'&gt;</ex></ph>Chrome Web Store<ph name="END_LINK">&lt;/a&gt;<ex>&lt;/a&gt;</ex></ph> for a suitable replacement app.<ph name="BEGIN_LINK_HELP">&lt;a target='_blank' href='$2'&gt;<ex>&lt;a target='_blank' href='$2'&gt;</ex></ph>Learn More<ph name="END_LINK_HELP">&lt;/a&gt;<ex>&lt;/a&gt;</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_NO_TASK_FOR_CRX_TITLE" desc="Message shown when a user tries to open a *.crx file, which we don't handle in the Files app.">
-    Wait just a sec
-  </message>
-  <message name="IDS_FILE_BROWSER_NO_TASK_FOR_CRX" desc="Message shown when a user tries to open a *.crx file, which we don't handle in the Files app.">
-    We're constantly looking for ways to make your browsing safer. Previously, any website could prompt you to add an extension into your browser. In the latest versions of Google Chrome, you must explicitly tell Chrome that you want to install these extensions by adding them through the Extensions page. <ph name="BEGIN_LINK">&lt;a target='_blank' href='https://support.google.com/chrome_webstore/answer/2664769?p=crx_warning&amp;rd=1'&gt;</ph>Learn more<ph name="END_LINK">&lt;/a&gt;</ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_UNABLE_TO_OPEN_CROSTINI_TITLE" desc="Message title shown when a user tries to use a crostini app to open a file outside the crostini container (e.g. in Downloads).  This message will be removed once we support this action.">
-    Unable to open with $1
-  </message>
-  <message name="IDS_FILE_BROWSER_UNABLE_TO_OPEN_CROSTINI" desc="Message shown when a user tries to use a crostini app to open a file outside the crostini container (e.g. in Downloads).  This message will be removed once we support this action.">
-    To open files with $1, first copy to Linux files folder.
-  </message>
-
-  <message name="IDS_FILE_BROWSER_FOLDER" desc="Folder entry type">
-    Folder
-  </message>
-  <message name="IDS_FILE_BROWSER_GENERIC_FILE_TYPE" desc="An entry type for a file with an extension that the File Manager does not recognize.">
-    <ph name="FILE_TYPE">$1<ex>ABC</ex></ph> file
-  </message>
-  <message name="IDS_FILE_BROWSER_NO_EXTENSION_FILE_TYPE" desc="An entry type for a file without an extension">
-    File
-  </message>
-  <message name="IDS_FILE_BROWSER_IMAGE_FILE_TYPE" desc="Image file type">
-    $1 image
-  </message>
-  <message name="IDS_FILE_BROWSER_VIDEO_FILE_TYPE" desc="Video file type">
-    $1 video
-  </message>
-  <message name="IDS_FILE_BROWSER_AUDIO_FILE_TYPE" desc="Audio file type">
-    $1 audio
-  </message>
-  <message name="IDS_FILE_BROWSER_HTML_DOCUMENT_FILE_TYPE" desc="HTML document file type">
-    HTML document
-  </message>
-  <message name="IDS_FILE_BROWSER_ZIP_ARCHIVE_FILE_TYPE" desc="Zip archive file type">
-    Zip archive
-  </message>
-  <message name="IDS_FILE_BROWSER_RAR_ARCHIVE_FILE_TYPE" desc="RAR archive file type">
-    RAR archive
-  </message>
-  <message name="IDS_FILE_BROWSER_TAR_ARCHIVE_FILE_TYPE" desc="Tar archive file type">
-    Tar archive
-  </message>
-  <message name="IDS_FILE_BROWSER_TAR_BZIP2_ARCHIVE_FILE_TYPE" desc="Bzip2 compressed tar archive file type">
-    Bzip2 compressed tar archive
-  </message>
-  <message name="IDS_FILE_BROWSER_TAR_GZIP_ARCHIVE_FILE_TYPE" desc="Gzip compressed tar archive file type">
-    Gzip compressed tar archive
-  </message>
-  <message name="IDS_FILE_BROWSER_PLAIN_TEXT_FILE_TYPE" desc="Plain text file type">
-    Plain text
-  </message>
-  <message name="IDS_FILE_BROWSER_PDF_DOCUMENT_FILE_TYPE" desc="PDF document file type">
-    PDF document
-  </message>
-  <message name="IDS_FILE_BROWSER_WORD_DOCUMENT_FILE_TYPE" desc="Word document file type">
-    Word document
-  </message>
-  <message name="IDS_FILE_BROWSER_POWERPOINT_PRESENTATION_FILE_TYPE" desc="PowerPoint presentation file type">
-    PowerPoint presentation
-  </message>
-  <message name="IDS_FILE_BROWSER_EXCEL_FILE_TYPE" desc="Excel spreadsheet file type">
-    Excel spreadsheet
-  </message>
-
-  <message name="IDS_FILE_BROWSER_GDOC_DOCUMENT_FILE_TYPE" desc="Google document file type">
-    Google document
-  </message>
-  <message name="IDS_FILE_BROWSER_GSHEET_DOCUMENT_FILE_TYPE" desc="Google spreadsheet file type">
-    Google spreadsheet
-  </message>
-  <message name="IDS_FILE_BROWSER_GSLIDES_DOCUMENT_FILE_TYPE" desc="Google presentation file type">
-    Google presentation
-  </message>
-  <message name="IDS_FILE_BROWSER_GDRAW_DOCUMENT_FILE_TYPE" desc="Google drawing file type">
-    Google drawing
-  </message>
-  <message name="IDS_FILE_BROWSER_GTABLE_DOCUMENT_FILE_TYPE" desc="Google table file type">
-    Google table
-  </message>
-  <message name="IDS_FILE_BROWSER_GFORM_DOCUMENT_FILE_TYPE" desc="Google form file type">
-    Google form
-  </message>
-  <message name="IDS_FILE_BROWSER_GMAP_DOCUMENT_FILE_TYPE" desc="Google map file type">
-    Google map
-  </message>
-  <message name="IDS_FILE_BROWSER_GSITE_DOCUMENT_FILE_TYPE" desc="Google site file type">
-    Google site
-  </message>
-  <message name="IDS_FILE_BROWSER_GLINK_DOCUMENT_FILE_TYPE" desc="Google Drive link file type">
-    Google Drive link
-  </message>
-
-  <message name="IDS_FILE_BROWSER_ERROR_VIEWING_FILE_TITLE" desc="Title of error message propmt when user attempts to open a non-supported file in file browser.">
-    <ph name="FILENAME">$1</ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_ERROR_VIEWING_FILE" desc="Error message when user attempts to open a non-supported file in the Files app via Downloads panel.">
-    This file type is not supported. Please visit the Chrome Web Store to find an app that can open this type of file.
-  </message>
-  <message name="IDS_FILE_BROWSER_ERROR_VIEWING_FILE_FOR_DMG" desc="Error message when user attempts to open a dmg file in the Files app via Downloads panel.">
-    This file is designed for a computer using Macintosh software. This is not compatible with your device which runs Chrome OS. Please search the Chrome Web Store for a suitable replacement app.
-  </message>
-  <message name="IDS_FILE_BROWSER_ERROR_VIEWING_FILE_FOR_EXECUTABLE" desc="Error message when user attempts to open a exe file in the Files app via Downloads panel.">
-    This file is designed for a PC using Windows software. This is not compatible with your device which runs Chrome OS. Please search the Chrome Web Store for a suitable replacement app.
-  </message>
-  <message name="IDS_FILE_BROWSER_ERROR_UNRESOLVABLE_FILE" desc="Error message when the file attempted to open from Downloads panel was not found under paths managed by file manager.">
-    This file has wandered off somewhere. Please check your download location setting and try again.
-  </message>
-  <message name="IDS_FILE_BROWSER_AUDIO_PLAYER_TITLE" desc="Title of the Audio Player window.">
-    Audio Player
-  </message>
-  <message name="IDS_FILE_BROWSER_AUDIO_PLAYER_DEFAULT_ARTIST" desc="In the Audio Player window, default artist name used when artist name is unknown.">
-    Unknown Artist
-  </message>
-
-  <message name="IDS_FILE_BROWSER_FILE_ERROR_GENERIC" desc="In the File Manager, the error message when the file operation failed.">
-    An error occurred.
-  </message>
-  <message name="IDS_FILE_BROWSER_FILE_ERROR_NOT_FOUND" desc="In the File Manager, the error message when the file could not be found.">
-    The file could not be found.
-  </message>
-  <message name="IDS_FILE_BROWSER_FILE_ERROR_SECURITY" desc="In the File Manager, the error message when the file could not be accessed for security reasons.">
-    The file could not be accessed for security reasons.
-  </message>
-  <message name="IDS_FILE_BROWSER_FILE_ERROR_NOT_READABLE" desc="In the File Manager, the error message when the file could not be read.">
-    The file could not be read.
-  </message>
-  <message name="IDS_FILE_BROWSER_FILE_ERROR_NO_MODIFICATION_ALLOWED" desc="In the File Manager, the error message when the file could not be modified.">
-    The file could not be modified.
-  </message>
-  <message name="IDS_FILE_BROWSER_FILE_ERROR_INVALID_STATE" desc="In the File Manager, the error message when the file is not usable.">
-    The file or the directory is not usable.
-  </message>
-  <message name="IDS_FILE_BROWSER_FILE_ERROR_INVALID_MODIFICATION" desc="In the File Manager, the error message when the file could not be modified.">
-    The file could not be modified.
-  </message>
-  <message name="IDS_FILE_BROWSER_FILE_ERROR_PATH_EXISTS" desc="In the File Manager, the error message when the a file or a directory with the same name already exists.">
-    A file or a directory with the same name already exists.
-  </message>
-  <message name="IDS_FILE_BROWSER_FILE_ERROR_QUOTA_EXCEEDED" desc="In the File Manager, the error message when there is not enough space to complete the operation.">
-    There is not enough space.
-  </message>
-
-  <message name="IDS_FILE_BROWSER_SEARCH_DRIVE_HTML" desc="In the File Manager, the item in the autocomplete suggestion item just under the search box, to continue searching in the list.">
-    '&lt;b&gt;<ph name="SEARCH_STRING">$1<ex>abc</ex></ph>&lt;/b&gt;' - &lt;em&gt;search Drive&lt;/em&gt;
-  </message>
-  <message name="IDS_FILE_BROWSER_SEARCH_NO_MATCHING_FILES_HTML" desc="In the File Manager, the message informing the user that the search did not match any files or directories.">
-    No items match &lt;b&gt;"<ph name="SEARCH_STRING">$1<ex>abc</ex></ph>"&lt;/b&gt;
-  </message>
-
-  <message name="IDS_FILE_BROWSER_CHANGE_DEFAULT_MENU_ITEM" desc="In the File Manager, the text in the menu item to change the default action for a particular file type.">
-    Change default...
-  </message>
-  <message name="IDS_FILE_BROWSER_CHANGE_DEFAULT_CAPTION" desc="In the File Manager, the caption on the dialog box that chooses the default action for a particular file type.">
-    Choose the default app for <ph name="FILE_TYPE">$1<ex>PNG</ex></ph> files:
-  </message>
-  <message name="IDS_FILE_BROWSER_DEFAULT_TASK_LABEL" desc="In the File Manager actions menu, the text next to the default action name.">
-    (default)
-  </message>
-
-  <message name="IDS_FILE_BROWSER_THUMBNAIL_VIEW_TOOLTIP" desc="Tooltip for the Thumbnail View button.">
-    Thumbnail view
-  </message>
-  <message name="IDS_FILE_BROWSER_SHARE_BUTTON_TOOLTIP" desc="Tooltip for the button which provides share options in the Files app.">
-    More actions
-  </message>
-  <message name="IDS_FILE_BROWSER_SORT_BUTTON_TOOLTIP" desc="Tooltip for the button which provides sort options in the Files app.">
-    Sort options
-  </message>
-  <message name="IDS_FILE_BROWSER_GEAR_BUTTON_TOOLTIP" desc="Tooltip for the gear button in the Files app.">
-    More...
-  </message>
-  <message name="IDS_FILE_BROWSER_SELECTION_MENU_BUTTON_TOOLTIP" desc="Tooltip for the button to open the context menu of currently selected items in the Files app.">
-    More...
-  </message>
-
-  <message name="IDS_FILE_BROWSER_TIME_TODAY" desc="File date and time in case the date is today.">
-    Today <ph name="TODAY_DAYTIME">$1<ex>6:19 AM</ex></ph>
-  </message>
-  <message name="IDS_FILE_BROWSER_TIME_YESTERDAY" desc="File date and time in case the date is yesterday.">
-    Yesterday <ph name="YESTERDAY_DAYTIME">$1<ex>4:48 PM</ex></ph>
-  </message>
-
-  <message name="IDS_FILE_BROWSER_ALL_FILES_FILTER" desc="All Files filter for Open/Save dialog">
-    All files
-  </message>
-
-  <message name="IDS_FILE_BROWSER_SPACE_AVAILABLE" desc="Menu item showing space left for storage.">
-    <ph name="SPACE_AVAILABLE">$1<ex>4.8 GB</ex></ph> available
-  </message>
-  <message name="IDS_FILE_BROWSER_WAITING_FOR_SPACE_INFO" desc="Menu item, saying that FileBrowser is waiting for space information for storage. When actual data arrives, this item will be replaced with IDS_FILE_BROWSER_SPACE_AVAILABLE">
-    Waiting for space info...
-  </message>
-  <message name="IDS_FILE_BROWSER_FAILED_SPACE_INFO" desc="Menu item, saying that FileBrowser is failed to retrieve space information.">
-    Failed to retrieve space info
-  </message>
-  <message name="IDS_FILE_BROWSER_SEE_MENU_FOR_ACTIONS" desc="Text to be used by screen reader to indicate users that there are more options on the action bar.">
-    More options available on the action bar. Press Alt + A to focus the action bar.
-  </message>
-
 <!-- Common for Audio player and Media player -->
   <message name="IDS_MEDIA_PLAYER_PLAY_BUTTON_LABEL" desc="Label for the Play button of media players (audio player / video player).">
     Play
@@ -3810,12 +2584,6 @@
   <message name="IDS_GENIUS_APP_DESCRIPTION" desc="Description of the genius app in the app shelf">
     Get help with your <ph name="DEVICE_TYPE">$1<ex>Chromebook</ex></ph>.
   </message>
-  <message name="IDS_FILEMANAGER_APP_NAME" desc="Name for the File Manager app.">
-    Files
-  </message>
-  <message name="IDS_FILEMANAGER_APP_DESCRIPTION" desc="Description for the File Manager app.">
-    The Files app provides quick access to files that you've saved on Google Drive, external storage, or your Chrome OS device.
-  </message>
 
   <!-- Platform verification UI -->
   <message name="IDS_PLATFORM_VERIFICATION_DIALOG_HEADLINE" desc="The label to describe what the dialog wants to confirm.">
@@ -4538,48 +3306,6 @@
     System time
   </message>
 
-  <message name="IDS_FILE_SYSTEM_REQUEST_FILE_SYSTEM_DIALOG_TITLE" desc="Title of a prompt dialog for granting permissions to a volume (eg. USB drive, SD card, MTP device) with the specified name. Only used for screen readers (a11y); not visible.">
-    Permission requested
-  </message>
-  <message name="IDS_FILE_SYSTEM_REQUEST_FILE_SYSTEM_DIALOG_MESSAGE" desc="Message in a prompt dialog for granting read-only permissions to a volume (eg. USB drive, SD card, MTP device) with the specified name to the extension.">
-    <ph name="APP_NAME">$1<ex>Super Kiosk app</ex></ph> wants to copy files from <ph name="VOLUME_NAME">$2<ex>FooBar 4GB</ex></ph>.
-  </message>
-  <message name="IDS_FILE_SYSTEM_REQUEST_FILE_SYSTEM_DIALOG_WRITABLE_MESSAGE" desc="Message in a prompt dialog for granting full permissions (read, write, delete, create files and directories) to a volume (eg. USB drive, SD card, MTP device) with the specified name to the extension.">
-    <ph name="APP_NAME">$1<ex>Super Kiosk app</ex></ph> wants to access <ph name="VOLUME_NAME">$2<ex>FooBar 4GB</ex></ph>. It may modify or delete your files.
-  </message>
-  <message name="IDS_FILE_SYSTEM_REQUEST_FILE_SYSTEM_DIALOG_ALLOW_BUTTON" desc="Label on the button to grant permissions.">
-    Allow
-  </message>
-  <message name="IDS_FILE_SYSTEM_REQUEST_FILE_SYSTEM_DIALOG_DENY_BUTTON" desc="Label on the button to reject permissions.">
-    Deny
-  </message>
-  <message name="IDS_FILE_SYSTEM_REQUEST_FILE_SYSTEM_NOTIFICATION_MESSAGE" desc="Message in a notification about granted read-only pemissions (read, write, delete, create files and directories) to a volume (eg. USB drive, SD card, MTP device) with the specified name to the extension.">
-    Read-only access to <ph name="VOLUME_NAME">$1<ex>FooBar 4GB</ex></ph> has been granted.
-  </message>
-  <message name="IDS_FILE_SYSTEM_REQUEST_FILE_SYSTEM_NOTIFICATION_WRITABLE_MESSAGE" desc="Message in a notification about granted full permissions (read, write, delete, create files and directories) to a volume (eg. USB drive, SD card, MTP device) with the specified name to the extension.">
-    Read and write access to <ph name="VOLUME_NAME">$1<ex>FooBar 4GB</ex></ph> has been granted.
-  </message>
-
-  <!-- Webstore widget app -->
-  <message name="IDS_WEBSTORE_WIDGET_APP_NAME" desc="App name for Webstore Gallery Widget app. The app shows a filtered list of extensions from Chrome Web Store. Extensions from the list can be installed directly from the app.">
-    Chrome Web Store Gallery
-  </message>
-  <message name="IDS_WEBSTORE_WIDGET_APP_DESC" desc="Description of Chrome Webstore Gallery Widget app.">
-    An app that shows a filtered list of extensions from Chrome Web Store. Extensions in the list can be installed directly from the app.
-  </message>
-  <message name="IDS_WEBSTORE_WIDGET_TITLE_PRINTER_PROVIDERS" desc="Title for Chrome Web Store Gallery Widget which lists all print driver apps from Chrome Web Store for a specific printer.">
-    Select a printer driver app
-  </message>
-  <message name="IDS_WEBSTORE_WIDGET_DEFAULT_ERROR" desc="Default message shown when Chrome Web Store Widget app window content fails to load (e.g. if it fails to load Chrome Web Store Gallery in a webview).">
-    Could not connect to the Chrome Web Store.
-  </message>
-  <message name="IDS_WEBSTORE_WIDGET_LOADING_SPINNER_ALT" desc="Alt text for spinner shown in Chrome Web Store Gallery widget while the widget contents is loading. This is the text that will be read by screen reader when the spinner is focused. The string should be translated as a verb.">
-    Loading
-  </message>
-  <message name="IDS_WEBSTORE_WIDGET_INSTALLING_SPINNER_ALT" desc="Alt text for spinner shown in Chrome Web Store Gallery widget while an app is being installed from the widget. This is the text that will be read by screen reader when the spinner has focus. The string should be translated as a verb.">
-    Installing
-  </message>
-
   <!-- Android Apps -->
   <message name="IDS_ARC_PLAYSTORE_ICON_TITLE_BETA" desc="The Play Store icon title with the beta label in the launcher.">
     Play Store
diff --git a/chrome/app/file_manager_strings.grdp b/chrome/app/file_manager_strings.grdp
new file mode 100644
index 0000000000000..1085cb0e5782f
--- /dev/null
+++ b/chrome/app/file_manager_strings.grdp
@@ -0,0 +1,1259 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- file mamanger strings (included from generated_resources.grd). -->
+<grit-part>
+
+  <!-- File Manager -->
+  <message name="IDS_FILE_BROWSER_ANDROID_FILES_ROOT_LABEL" desc="A label for the 'Play files' root which shows Android files. 'Play' in this label is an abbreviation of 'Google Play', so it should not be translated. Use sentence case.">
+    Play files
+  </message>
+  <message name="IDS_FILE_BROWSER_SHOW_ALL_ANDROID_FOLDERS_OPTION" desc="A label for an option menu item to show all Android folders. By default, only several folders are visible to users, and users will click this option menu item to show all folders. 'Play' in this label is an abbreviation of 'Google Play', so it should not be translated.">
+    Show all Play folders
+  </message>
+  <message name="IDS_FILE_SYSTEM_PROVIDER_UNRESPONSIVE_WARNING" desc="A warning shown in a notification that an operation is taking longer than expected.">
+    An operation is taking longer than expected. Do you want to abort it?
+  </message>
+  <message name="IDS_FILE_SYSTEM_PROVIDER_MANY_UNRESPONSIVE_WARNING" desc="A warning shown in a notification that more than one operations are taking longer than expected.">
+    Some operations are taking longer than expected. Do you want to abort them?
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_CONFIRM_TD_MEMBERS_LOSE_ACCESS" desc="Part of message in the confirmation dialog box when moving a file out of a Team Drive.">
+    Members of '<ph name="SOURCE_NAME">$1</ph>' will lose access unless these items are shared with them.
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_CONFIRM_CANNOT_MOVE_BACK_TO_TEAM_DRIVE" desc="Part of message in the confirmation dialog box when moving a file from Team Drives to My Drive to tell that the operation is not undoable.">
+    The items cannot be moved back into '<ph name="DESTINATION_NAME">$1</ph>', so you won't be able to undo this action.
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_CONFIRM_TD_MEMBERS_GAIN_ACCESS" desc="Part of message in the confirmation dialog box when moving or copying files into a Team Drive.">
+    Members of '<ph name="DESTINATION_NAME">$1</ph>' will gain access to these items.
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_CONFIRM_TD_MEMBERS_GAIN_ACCESS_TO_COPY" desc="Part of message in the confirmation dialog box when copying files into a Team Drive.">
+    Members of '<ph name="DESTINATION_NAME">$1</ph>' will gain access to the copy of these items.
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_CONFIRM_OWNERSHIP_TRANSFER" desc="Part of message in the confirmation dialog box when moving files between two Team Drives that belong to different domains.">
+    Ownership will be transferred to <ph name="DESTINATION_DOMAIN">$1</ph>.
+  </message>
+  <message name="IDS_FILE_BROWSER_CONFIRM_COPY_BUTTON_LABEL" desc="Button label for approving file copy operation in the confirmation dialog box. This is placed next to CANCEL button.">
+    Copy
+  </message>
+  <message name="IDS_FILE_BROWSER_CONFIRM_MOVE_BUTTON_LABEL" desc="Button label for approving file move operation in the confirmation dialog box. This is placed next to CANCEL button.">
+    Move
+  </message>
+  <message name="IDS_FILE_SYSTEM_PROVIDER_UNRESPONSIVE_ABORT_BUTTON" desc="Label of the button on the notification about an operation(s) taking to long.">
+    Abort
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_DIRECTORY_LABEL" desc="/drive directory label.">
+    Google Drive
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_MY_DRIVE_LABEL" desc="A label for the 'My Drive' collection of Google Drive.">
+    My Drive
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_TEAM_DRIVES_LABEL" desc="A label for the 'Team Drives' collection of Google Drive.">
+    Team Drives
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_SHARED_WITH_ME_COLLECTION_LABEL" desc="A label for the 'shared with me' collection of Google Drive.">
+    Shared with me
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_RECENT_COLLECTION_LABEL" desc="A label for the 'Recent' collection of Google Drive.">
+    Recent
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_OFFLINE_COLLECTION_LABEL" desc="A label for the 'Offline' collection of Google Drive.">
+    Offline
+  </message>
+  <message name="IDS_FILE_BROWSER_DOWNLOADS_DIRECTORY_LABEL" desc="Downloads local directory label.">
+    Downloads
+  </message>
+  <message name="IDS_FILE_BROWSER_LINUX_FILES_ROOT_LABEL" desc="A label for the 'Linux files' root which shows crostini files. Use sentence case.">
+    Linux files
+  </message>
+  <message name="IDS_FILE_BROWSER_MY_FILES_ROOT_LABEL" desc="A label for the 'My files' root which is parent of Downloads, Linux and Android files. Use sentence case.">
+    My files
+  </message>
+  <message name="IDS_FILE_BROWSER_MEDIA_VIEW_IMAGES_ROOT_LABEL" desc="A label for the 'Images' root of media views.">
+    Images
+  </message>
+  <message name="IDS_FILE_BROWSER_MEDIA_VIEW_VIDEOS_ROOT_LABEL" desc="A label for the 'Videos' root of media views.">
+    Videos
+  </message>
+  <message name="IDS_FILE_BROWSER_MEDIA_VIEW_AUDIO_ROOT_LABEL" desc="A label for the 'Audio' root of media views.">
+    Audio
+  </message>
+  <message name="IDS_FILE_BROWSER_RECENT_ROOT_LABEL" desc="A label for the 'Recent' root which shows files recently modified by the user.">
+    Recent
+  </message>
+  <message name="IDS_FILE_BROWSER_DOWNLOADS_DIRECTORY_WARNING" desc="Warning displayed to user when viewing downloads folder.">
+    <ph name="BEGIN_BOLD">&lt;strong&gt;</ph>Caution:<ph name="END_BOLD">&lt;/strong&gt;</ph>  These files are temporary and may be automatically deleted to free up disk space.  <ph name="BEGIN_LINK">&lt;a href="javascript://"&gt;</ph>Learn More<ph name="END_LINK">&lt;/a&gt;<ex>&lt;/a&gt;</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_NAME_COLUMN_LABEL" desc="Name column label.">
+    Name
+  </message>
+  <message name="IDS_FILE_BROWSER_SIZE_COLUMN_LABEL" desc="Size column label.">
+    Size
+  </message>
+
+  <message name="IDS_FILE_BROWSER_SIZE_BYTES" desc="Size in bytes.">
+    $1 bytes
+  </message>
+  <message name="IDS_FILE_BROWSER_SIZE_KB" desc="Size in kilo bytes.">
+    $1 KB
+  </message>
+  <message name="IDS_FILE_BROWSER_SIZE_MB" desc="Size in mega bytes.">
+    $1 MB
+  </message>
+  <message name="IDS_FILE_BROWSER_SIZE_GB" desc="Size in giga bytes.">
+    $1 GB
+  </message>
+  <message name="IDS_FILE_BROWSER_SIZE_TB" desc="Size in tera bytes.">
+    $1 TB
+  </message>
+  <message name="IDS_FILE_BROWSER_SIZE_PB" desc="Size in peta bytes.">
+    $1 PB
+  </message>
+
+  <message name="IDS_FILE_BROWSER_SHORTCUT_CTRL" desc="[Ctrl] key name to use in shortcuts descriptions. Shouldn't be translated in many languages actually.">
+    Ctrl
+  </message>
+  <message name="IDS_FILE_BROWSER_SHORTCUT_ALT" desc="[Alt] key name to use in shortcuts descriptions. Shouldn't be translated in many languages actually.">
+    Alt
+  </message>
+  <message name="IDS_FILE_BROWSER_SHORTCUT_SHIFT" desc="[Shift] key name to use in shortcuts descriptions. Shouldn't be translated in many languages actually.">
+    Shift
+  </message>
+  <message name="IDS_FILE_BROWSER_SHORTCUT_META" desc="[Meta] key name to use in shortcuts descriptions. Shouldn't be translated in many languages actually.">
+    Meta
+  </message>
+  <message name="IDS_FILE_BROWSER_SHORTCUT_SPACE" desc="[Space] key name to use in shortcuts descriptions. Shouldn't be translated in many languages actually.">
+    Space
+  </message>
+  <message name="IDS_FILE_BROWSER_SHORTCUT_ENTER" desc="[Enter] key name to use in shortcuts descriptions. Shouldn't be translated in many languages actually.">
+    Enter
+  </message>
+  <message name="IDS_FILE_BROWSER_SHORTCUT_BACKSPACE" desc="[Backspace] key name to use in shortcuts descriptions. Shouldn't be translated in many languages actually.">
+    Backspace
+  </message>
+
+  <message name="IDS_FILE_BROWSER_STATUS_COLUMN_LABEL" desc="Status column label.  This column reflects the cloud import status of files.  The status is an icon depicting whether a file has been imported, and if so, where to - for example, a Drive icon if a file has been imported to Google Drive.  For unimported files, this column is blank. ">
+    Status
+  </message>
+  <message name="IDS_FILE_BROWSER_TOTAL_FILE_COUNT_LABEL" desc="Total count of files that user selects in the Files app">
+    Total file count
+  </message>
+  <message name="IDS_FILE_BROWSER_TOTAL_FILE_SIZE_LABEL" desc="Total size of files that user selects in the Files app">
+    Total file size
+  </message>
+  <message name="IDS_FILE_BROWSER_IMAGE_RESOLUTION_COLUMN_LABEL" desc="Image resolution of a file that user selects in the Files app">
+    Image resolution
+  </message>
+  <message name="IDS_FILE_BROWSER_MEDIA_TITLE_COLUMN_LABEL" desc="Artist of a music file that user selects in the Files app">
+    Title
+  </message>
+  <message name="IDS_FILE_BROWSER_MEDIA_ARTIST_COLUMN_LABEL" desc="Title of a music file that user selects in the Files app">
+    Artist
+  </message>
+  <message name="IDS_FILE_BROWSER_TYPE_COLUMN_LABEL" desc="Type column label.">
+    Type
+  </message>
+  <message name="IDS_FILE_BROWSER_DATE_COLUMN_LABEL" desc="Date column label.">
+    Date modified
+  </message>
+  <message name="IDS_FILE_BROWSER_OFFLINE_COLUMN_LABEL" desc="Available offline column label.">
+    Available offline
+  </message>
+  <message name="IDS_FILE_BROWSER_ERROR_CREATING_FOLDER" desc="Message displayed when we can't create a folder.">
+    Unable to create folder "<ph name="FOLDER_NAME">$1<ex>Documents</ex></ph>". <ph name="ERROR_MESSAGE">$2<ex>An error occurred (code: ABORT)</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_ERROR_INVALID_CHARACTER" desc="Error message displayed when the user enters an invalid character in a file or directory name.">
+    Invalid character: $1
+  </message>
+  <message name="IDS_FILE_BROWSER_ERROR_EXTERNAL_DRIVE_INVALID_CHARACTER" desc="Error message displayed when the user enters an invalid character in an external drive's name.">
+    Invalid character: $1
+  </message>
+  <message name="IDS_FILE_BROWSER_ERROR_RESERVED_NAME" desc="Error message displayed when the user enters a file name which is reserved.">
+    This name may not be used as a file of folder name
+  </message>
+  <message name="IDS_FILE_BROWSER_ERROR_HIDDEN_NAME" desc="Error message displayed when the user tries to rename to or create a file started with dot.">
+    Names starting with dot are reserved for the system. Please choose another name.
+  </message>
+  <message name="IDS_FILE_BROWSER_ERROR_WHITESPACE_NAME" desc="Error message displayed when the user enters a file name consisting of only whitespace characters.">
+    Invalid name
+  </message>
+  <message name="IDS_FILE_BROWSER_ERROR_LONG_NAME" desc="Error message displayed when user tries to enter too long name for a file or a folder.">
+    Use a shorter name
+  </message>
+  <message name="IDS_FILE_BROWSER_ERROR_EXTERNAL_DRIVE_LONG_NAME" desc="Error message displayed when user tries to enter too long name for an external drive.">
+    Use a name that's <ph name="MAX_LENGTH">$1<ex>11</ex></ph> characters or less
+  </message>
+  <message name="IDS_FILE_BROWSER_ERROR_LINUX_FILES_CONNECTION" desc="Text to show user when there is an error starting or mounting crostini container to show Linux files.">
+    Unable to view Linux files
+  </message>
+
+  <message name="IDS_FILE_BROWSER_EMPTY_FOLDER" desc="Label shown in an empty folder.">
+    Nothing to see here...
+  </message>
+  <message name="IDS_FILE_BROWSER_NEW_FOLDER_BUTTON_LABEL" desc="Label on the 'New folder' button.">
+    New folder
+  </message>
+  <message name="IDS_FILE_BROWSER_NEW_WINDOW_BUTTON_LABEL" desc="Label on the 'New window' button.">
+    New window
+  </message>
+  <message name="IDS_FILE_BROWSER_FILENAME_LABEL" desc="Filename text area label.">
+    File name
+  </message>
+  <message name="IDS_FILE_BROWSER_PREPARING_LABEL" desc="Label informing about preparing the file.">
+    Preparing
+  </message>
+  <message name="IDS_FILE_BROWSER_QUICK_VIEW_CLOSE_BUTTON_LABEL" desc="Label for button to close QuickView.">
+    Back
+  </message>
+  <message name="IDS_FILE_BROWSER_QUICK_VIEW_OPEN_IN_NEW_BUTTON_LABEL" desc="Label for button to open a file with external app.">
+    Open
+  </message>
+  <message name="IDS_FILE_BROWSER_QUICK_VIEW_TOGGLE_METADATA_BOX_BUTTON_LABEL" desc="Label for button to toggle show/hide status of metadata box.">
+    File info
+  </message>
+  <message name="IDS_FILE_BROWSER_DRAGGING_MULTIPLE_ITEMS" desc="Tooltip message for dragging multiple files.">
+    $1 items
+  </message>
+
+  <message name="IDS_FILE_BROWSER_ARCHIVE_MOUNT_FAILED" desc="Title of the error dialog when file mount operation failed.">
+    Unable to open "$1": $2
+  </message>
+  <message name="IDS_FILE_BROWSER_UNMOUNT_FAILED" desc="Title of the error dialog when device unmount operation failed.">
+   <ph name="BEGIN_BOLD">&lt;b&gt;</ph>Don't remove your device just yet!<ph name="END_BOLD">&lt;/b&gt;</ph>
+   <ph name="LINE_BREAKS">&lt;br/&gt;&lt;br/&gt;</ph>
+   Removing your device while it is in use may cause data loss.  Please wait until the operation is over, then eject the device using the Files app.
+  </message>
+  <message name="IDS_FILE_BROWSER_UNMOUNT_PROVIDED_FAILED" desc="Title of the error dialog when unmount operation for a volume provided by an extension failed. One of the most typical use case is an archive (i.e. ZIP) file mounted as a virtual disk. However, arbitrary Chrome apps can mount volumes. So we should not assume this is an archive file.">
+   <ph name="BEGIN_BOLD">&lt;b&gt;</ph>Can't disconnect from an archive or virtual disk<ph name="END_BOLD">&lt;/b&gt;</ph>
+   <ph name="LINE_BREAKS">&lt;br/&gt;&lt;br/&gt;</ph>
+   Close all files on the archive or virtual disk, then try again.
+  </message>
+  <message name="IDS_FILE_BROWSER_MOUNT_ARCHIVE" desc="Title of the action for mounting an archive file to work with its contents.">
+    Open
+  </message>
+  <message name="IDS_FILE_BROWSER_FORMAT_DEVICE_BUTTON_LABEL" desc="Title of the action for formatting removable device.">
+    Format device
+  </message>
+  <message name="IDS_FILE_BROWSER_CONFIGURE_VOLUME_BUTTON_LABEL" desc="Title of the action for configuring the selected volume.">
+    Configure
+  </message>
+  <message name="IDS_FILE_BROWSER_UNMOUNT_DEVICE_BUTTON_LABEL" desc="Title of the action for unmounting removable device.">
+    Eject device
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOSE_VOLUME_BUTTON_LABEL" desc="Title of the action for closing either an archive volume or a volume provided by an extension.">
+    Close
+  </message>
+  <message name="IDS_FILE_BROWSER_ADD_NEW_SERVICES_BUTTON_LABEL" desc="Title of the button in the left nav to add new services (file systems) to the Files app.">
+    Add new service
+  </message>
+  <message name="IDS_FILE_BROWSER_INSTALL_NEW_EXTENSION_LABEL" desc="Title of the menu item for installing new extensions from the web store.">
+    Install new service
+  </message>
+  <message name="IDS_FILE_BROWSER_TASK_VIEW" desc="Title of the action to view (no edit) a file.">
+    View
+  </message>
+  <message name="IDS_FILE_BROWSER_TASK_OPEN" desc="Title of the action to open (and possibly edit) a file.">
+    Open
+  </message>
+  <message name="IDS_FILE_BROWSER_TASK_OPEN_GDOC" desc="Title of the action to open a Google Docs document.">
+    Docs
+  </message>
+  <message name="IDS_FILE_BROWSER_TASK_OPEN_GSHEET" desc="Title of the action to open a Google Spreadsheets document.">
+    Sheets
+  </message>
+  <message name="IDS_FILE_BROWSER_TASK_OPEN_GSLIDES" desc="Title of the action to open a Google Slides document.">
+    Slides
+  </message>
+  <message name="IDS_FILE_BROWSER_TASK_LISTEN" desc="Title of the action to play an audio file.">
+    Listen
+  </message>
+  <message name="IDS_FILE_BROWSER_TASK_INSTALL_LINUX_PACKAGE" desc="Title of the action to install a Linux package.">
+    Install with Linux (Beta)
+  </message>
+
+  <message name="IDS_FILE_BROWSER_INSTALL_LINUX_PACKAGE_TITLE" desc="In the File Manager, the title shown in the dialog for installing a Linux application.">
+    Install app with Linux (Beta)
+  </message>
+  <message name="IDS_FILE_BROWSER_INSTALL_LINUX_PACKAGE_DESCRIPTION" desc="In the File Manager, the message shown in the dialog for installing a Linux application.">
+    The Linux application will be available within your Terminal and may also show an icon in your Launcher.
+  </message>
+  <message name="IDS_FILE_BROWSER_INSTALL_LINUX_PACKAGE_INSTALL_BUTTON" desc="In the File Manager, the label on the button to begin installing a Linux application. ">
+    Install
+  </message>
+  <message name="IDS_FILE_BROWSER_INSTALL_LINUX_PACKAGE_INSTALLATION_STARTED" desc="In the File Manager, the dialog message when a Linux application installation successfully starts.">
+    Installation successfully started.
+  </message>
+  <message name="IDS_FILE_BROWSER_INSTALL_LINUX_PACKAGE_ERROR_TITLE" desc="In the File Manager, the title shown in the dialog for installing a Linux application when an error occurs.">
+    Error installing Linux application
+  </message>
+  <message name="IDS_FILE_BROWSER_INSTALL_LINUX_PACKAGE_ERROR_DESCRIPTION" desc="In the File Manager, the dialog message when a Linux application installation fails.">
+    An error occured during installation of your Linux application.
+  </message>
+
+  <message name="IDS_FILE_BROWSER_GALLERY_NO_IMAGES" desc="In the Gallery, the message that there are no images in this directory.">
+    No images in this directory.
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_ITEMS_SELECTED" desc="In the Gallery, the message showing the selected item count.">
+    <ph name="COUNT">$1<ex>3</ex></ph> items selected
+  </message>
+
+  <message name="IDS_FILE_BROWSER_GALLERY_THUMBNAIL" desc="In the Gallery, the title on the button that switches to the thumbnail view.">
+    Thumbnail view
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_SLIDE" desc="In the Gallery, the title on the button that switches to the slide view.">
+    Slide view
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_SLIDESHOW" desc="In the Gallery, the title on the button that starts the slide show.">
+    Slideshow
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_DELETE" desc="In the Gallery, the title on the button that deletes selected images.">
+    Delete
+  </message>
+
+  <message name="IDS_FILE_BROWSER_GALLERY_EDIT" desc="In the Gallery, the title on the button shows/hides editing buttons.">
+    Edit
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_PRINT" desc="In the Gallery, the title on the button showing the print dialog for the current image or video.">
+    Print
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_SHARE" desc="In the Gallery, the title on the button that lets the user share a photo.">
+    Share
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_EXIT" desc="In the Gallery, the title on the button that exits edit mode.">
+    Exit
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_ENTER_WHEN_DONE" desc="In the Gallery, the text in a floating panel that prompts the user to press enter when they are done with the changes to a photo.">
+    Press Enter when done
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_AUTOFIX" desc="In the Gallery, the title on the button that applies the Auto-Fix filter to a photo.">
+    Auto-fix
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_FIXED" desc="In the Gallery, the text in a floating panel that notifies that the photo has been automatically fixed.">
+    Fixed
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_CROP" desc="In the Gallery, the title on the button that cuts out a rectangular fragment from a photo">
+    Crop
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_ASPECT_RATIO_1_1" desc="Button label to fix aspect to 1:1 ratio when cropping.">
+    1x1
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_ASPECT_RATIO_6_4" desc="Button label to fix aspect to 6:4 ratio when cropping.">
+    6x4
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_ASPECT_RATIO_7_5" desc="Button label to fix aspect to 7:5 ratio when cropping.">
+    7x5
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_ASPECT_RATIO_16_9" desc="Button label to fix aspect to 16:9 ratio when cropping.">
+    16x9
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_RESIZE" desc="In the Gallery, the title on the button that resize a photo.">
+    Resize
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_FIXRATIO" desc="Togglable Button to fix the ratio of width/height input field when resizing.">
+    Fix ratio
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_HEIGHT" desc="Input field to set the new size for height.">
+    Height
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_INVALIDVALUE" desc="In the Gallery, the message informing that the input value is invalid.">
+    Input value is invalid.
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_WIDTH" desc="Input field to set the new size for width.">
+    Width
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_EXPOSURE" desc="In the Gallery, the title on the button that applies the Brightness/Contrast filter to a photo.">
+    Brightness
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_BRIGHTNESS" desc="In the Gallery, the text next to the Brightness slider.">
+    Brightness
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_CONTRAST" desc="In the Gallery, the text next to the Contrast slider.">
+    Contrast
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_ROTATE_LEFT" desc="In the Gallery, the title on the button that rotates the photo 90 degrees to the left (counterclockwise).">
+    Left
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_ROTATE_RIGHT" desc="In the Gallery, the title on the button that rotates the photo 90 degrees to the right (clockwise).">
+    Right
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_UNDO" desc="In the Gallery, the text on the button that reverts the most recent operation.">
+    Undo
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_REDO" desc="In the Gallery, the text on the button that performs again the operation that has been recently reverted.">
+    Redo
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_DONE" desc="In the Gallery, the text on the button that commit image edit.">
+    DONE
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_FILE_EXISTS" desc="In the Gallery, the message informing that file already exists when attempting to rename.">
+    File already exists
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_SAVED" meaning="saved to disk" desc="In the Gallery, the message informing that editing saved successfully.">
+    Saved
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_SAVE_FAILED" desc="In the Gallery, the message informing that it failed to save editing image.">
+    Failed to save image.
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_OVERWRITE_ORIGINAL" desc="In the Gallery, text on the button to overwrite original file along with the edited copy.">
+    Overwrite original
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_OVERWRITE_BUBBLE" desc="In the Gallery, text in the bubble informing user about saving and overwriting original file.">
+    Your edits are saved automatically.<ph name="BREAKS">&lt;br&gt;&lt;br&gt;<ex>&lt;br&gt;&lt;br&gt;</ex></ph>To keep a copy of the original image, uncheck "Overwrite original"
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_READONLY_AND_NON_WRITABLE_FORMAT_WARNING" desc="In the Gallery, message informing that all edits will be saved to Downloads directory since the directory is readonly and the file is non-writable format of Gallery.">
+    Cannot save to $1. All edits will be saved to $2 in the Downloads folder.
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_READONLY_WARNING" desc="In the Gallery, message informing that directory is readonly, and edited files will be saved to Downloads directory.">
+    Cannot save to $1. Edited images will be saved in the Downloads folder.
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_NON_WRITABLE_FORMAT_WARNING" desc="In the Gallery, message informing that Gallery cannot overwrite to the original file and all edits will be saved to a copy.">
+    All edits will be saved to $1.
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_IMAGE_ERROR" desc="In the Gallery, message informing that the image failed to load.">
+    This file could not be displayed.
+  </message>
+  <message name="IDS_FILE_BROWSER_AUDIO_ERROR" desc="In the Audio Player, message informing that the file could not be played.">
+    This file could not be played.
+  </message>
+  <message name="IDS_FILE_BROWSER_GALLERY_IMAGE_OFFLINE" desc="In the Gallery, message informing that the image could be displayed in the offline mode.">
+    This image is not available offline.
+  </message>
+  <message name="IDS_FILE_BROWSER_AUDIO_OFFLINE" desc="In the Audio Player, message informing that the audio file could not be played in the offline mode.">
+    This file is not available offline.
+  </message>
+
+  <message name="IDS_FILE_BROWSER_RECOVERED_FILES_FROM_GOOGLE_DRIVE_DIRECTORY_NAME" desc="The name of the direcotry which stores files recovered from Google Drive directory when the locally stored Google Drive data is found to be broken.">
+    Recovered files from Google Drive
+  </message>
+
+  <message name="IDS_FILE_BROWSER_CONFLICT_DIALOG_MESSAGE" desc="Message of the conflict dialog shown when a file transfer operation is conflicted.">
+    A file named "<ph name="FILENAME">$1<ex>photo.jpg</ex></ph>" already exists. What do you want to do?
+  </message>
+  <message name="IDS_FILE_BROWSER_CONFLICT_DIALOG_KEEP_BOTH" desc="Label of a button to keep both entries after the file transfer operation.">
+    Keep both
+  </message>
+  <message name="IDS_FILE_BROWSER_CONFLICT_DIALOG_REPLACE" desc="Label of a button to replace the old entry with the new entry.">
+    Replace
+  </message>
+  <message name="IDS_FILE_BROWSER_CONFLICT_DIALOG_APPLY_TO_ALL" desc="Label of checkbox in the conflict dialog box to apply the user selection to all entries.">
+    Apply to all
+  </message>
+
+  <message name="IDS_FILE_BROWSER_CONFIRM_OVERWRITE_FILE" desc="Asks the user if they are sure they want to overwrite an existing file with another one.">
+    A file named "$1" already exists. Do you want to replace it?
+  </message>
+  <message name="IDS_FILE_BROWSER_FILE_ALREADY_EXISTS" desc="Error message displayed when user tries to create a file with an existing name.">
+    The file named "$1" already exists. Please choose a different name.
+  </message>
+  <message name="IDS_FILE_BROWSER_DIRECTORY_ALREADY_EXISTS" desc="Error message displayed when user tries to create a directory with an existing name.">
+    The folder named "$1" already exists. Please choose a different name.
+  </message>
+  <message name="IDS_FILE_BROWSER_ERROR_RENAMING" desc="Error message.">
+    Unable to rename "<ph name="FILE_NAME">$1<ex>document.pdf</ex></ph>". <ph name="ERROR_MESSAGE">$2<ex>An error occurred (code: ABORT)</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_GET_INFO_BUTTON_LABEL" desc="Context menu item that shows the currently-selected file's metadata.">
+    Get info
+  </message>
+  <message name="IDS_FILE_BROWSER_RENAME_BUTTON_LABEL" desc="Context menu item that renames the currently-selected file.">
+    Rename
+  </message>
+  <message name="IDS_FILE_BROWSER_DELETE_BUTTON_LABEL" desc="Context menu item that deletes the currently-selected file(s).">
+    Delete
+  </message>
+  <message name="IDS_FILE_BROWSER_PASTE_BUTTON_LABEL" desc="Context menu item that pastes the file(s) in the clipboard.">
+    Paste
+  </message>
+  <message name="IDS_FILE_BROWSER_REFRESH_BUTTON_LABEL" desc="Label for a button for refreshing the current directory.">
+    Refresh
+  </message>
+  <message name="IDS_FILE_BROWSER_PASTE_INTO_FOLDER_BUTTON_LABEL" desc="Menu item label, pasting files into the selected folder.">
+    Paste into folder
+  </message>
+  <message name="IDS_FILE_BROWSER_COPY_BUTTON_LABEL" desc="Context menu item that copies the currently-selected file(s) to the clipboard.">
+    Copy
+  </message>
+  <message name="IDS_FILE_BROWSER_CUT_BUTTON_LABEL" desc="Context menu item that cuts the currently-selected file(s) to the clipboard.">
+    Cut
+  </message>
+  <message name="IDS_FILE_BROWSER_OPEN_WITH_BUTTON_LABEL" desc="Menu item label, showing dialog to choose extension to open selected files or directories.">
+    Open with...
+  </message>
+  <message name="IDS_FILE_BROWSER_MORE_ACTIONS_BUTTON_LABEL" desc="Menu item label, showing dialog to choose extension to open/share/pack/etc... selected files or directories.">
+    More actions
+  </message>
+  <message name="IDS_FILE_BROWSER_OPEN_WITH_VERB_BUTTON_LABEL" desc="Verb that describe the action of opening one or more files or directories with the given extension.">
+    Open with <ph name="EXTENSION_NAME">$1<ex>Gallery</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_ADD_TO_VERB_BUTTON_LABEL" desc="Verb that describes the uploading or addition of one or multiple files or directories to the given extension.">
+    Add to <ph name="EXTENSION_NAME">$1<ex>Evernote</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_PACK_WITH_VERB_BUTTON_LABEL" desc="Verb that describes the packing or archiving of one or multiple files or directories with the given extension.">
+    Pack with <ph name="EXTENSION_NAME">$1<ex>ZIP</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_SHARE_WITH_VERB_BUTTON_LABEL" desc="Verb that describes the action of sharing/attaching/sending files with the given application.">
+    Share with <ph name="EXTENSION_NAME">$1<ex>GMail</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_ZIP_SELECTION_BUTTON_LABEL" desc="Menu item label, showing dialog to create zip file for selected files.">
+    Zip selection
+  </message>
+  <message name="IDS_FILE_BROWSER_SET_WALLPAPER_BUTTON_LABEL" desc="The context menu item to set wallpaper.">
+    Set wallpaper
+  </message>
+  <message name="IDS_FILE_BROWSER_CREATE_FOLDER_SHORTCUT_BUTTON_LABEL" desc="Menu item label, creating a shortcut of the selected folder to the left nav.">
+    Create shortcut
+  </message>
+  <message name="IDS_FILE_BROWSER_REMOVE_FOLDER_SHORTCUT_BUTTON_LABEL" desc="Menu item label, unpinning the selected folder from the left nav.">
+    Remove shortcut
+  </message>
+  <message name="IDS_FILE_BROWSER_SELECT_ALL_COMMAND_LABEL" desc="Menu item label, select all files and folders in the right view">
+    Select all
+  </message>
+  <message name="IDS_FILE_BROWSER_SHARE_BUTTON_LABEL" desc="Menu item's label, showing dialog to share the selected Google Drive files. This message is also used as a tooltip label and a spoken feedback label of a button which also shows the dialog to share the files. The translation should be consistent with the sharing dialog's title in Google Drive Web UI.">
+    Share with others
+  </message>
+  <message name="IDS_FILE_BROWSER_MANAGE_IN_DRIVE_BUTTON_LABEL" desc="Menu item's label, showing dialog to open the selected Google Drive files in the Drive webpage for managing sharing permissions, etc.">
+    Manage in Drive
+  </message>
+  <message name="IDS_FILE_BROWSER_TOGGLE_HIDDEN_FILES_COMMAND_LABEL" desc="Label for menu or button with checkmark that toggles visibility of hidden files.">
+    Show hidden files
+  </message>
+  <message name="IDS_FILE_BROWSER_TASKS_BUTTON_LABEL" desc="Label for button that selects a task to open the current file.">
+    Open
+  </message>
+  <message name="IDS_FILE_BROWSER_CANCEL_SELECTION_BUTTON_LABEL" desc="Label for button that unselects all selected items.">
+    Cancel selection
+  </message>
+  <message name="IDS_FILE_BROWSER_CHANGE_TO_LISTVIEW_BUTTON_LABEL" desc="Label for button that changes the view mode to 'list view' mode.">
+    Switch to list view
+  </message>
+  <message name="IDS_FILE_BROWSER_CHANGE_TO_THUMBNAILVIEW_BUTTON_LABEL" desc="Label for button that changes the view mode to 'thumbnail view' mode.">
+    Switch to thumbnail view
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_TITLE" desc="Title of the cloud import feature.">
+    Cloud backup
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_DESTINATION_FOLDER" desc="Title of the cloud import destination folder.">
+    Chrome OS Cloud backup
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_DESCRIPTION" desc="Short description of the cloud import feature.">
+    Back up your media device’s photos and videos to Google Drive.
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_START" desc="Tooltip of the toolbar button that starts backup.">
+    Backup your photos and videos
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_SHOW_DETAILS" desc="Tooltip for button that shows details panel.">
+    Show Cloud backup details
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_COMMAND" desc="Label of button on details panel that invokes cloud import feature.">
+    Back up
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_CANCEL_COMMAND" desc="Label of button on details panel that cancels an active import.">
+    Cancel
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_ONE_FILE" desc="Cloud import 1 new photo.">
+    1 new photo
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_MULTIPLE_FILES" desc="Cloud import multiple new photos.">
+    <ph name="FILE_COUNT">$1<ex>5</ex></ph> new photos
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_SCANNING" desc="Cloud import scanning status message.">
+    Scanning your media device...
+    <ph name="LINE_BREAK1">&lt;br&gt;</ph>
+    <ph name="FILE_COUNT">$1<ex>5 new photos</ex></ph> found
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_SCANNING" desc="Cloud import scanning tooltip.">
+    Scanning your media device...
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_NO_MEDIA" desc="Cloud import no-new-media-found status message. Shown after backup is completed and when a search for new files to backup produces no result.">
+    All backed up to <ph name="BEGIN_LINK">&lt;a is='action-link' class='destination-link'&gt;</ph>Google Drive!<ph name="END_LINK">&lt;/a&gt;</ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_NO_MEDIA" desc="Cloud import no-new-media-found tooltip. Shown after backup is completed and when a search for new files to backup produces no result.">
+    All backed up!
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_INSUFFICIENT_CLOUD_SPACE" desc="Cloud import insufficient cloud space status message.">
+    <ph name="FILE_COUNT">$1<ex>5 new photos</ex></ph> found.
+    <ph name="LINE_BREAK1">&lt;br&gt;</ph>
+    Your Google Drive quota isn't large enough. Additional <ph name="FILE_SIZE">$2<ex>5 MB</ex></ph> needed.
+    <ph name="LINE_BREAK2">&lt;br&gt;</ph>
+    Try selecting fewer photos.
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_INSUFFICIENT_CLOUD_SPACE" desc="Cloud import insufficient cloud space tooltip.">
+    Your Google Drive quota isn't large enough.
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_INSUFFICIENT_LOCAL_SPACE" desc="Cloud import insufficient local space status message.">
+    <ph name="FILE_COUNT">$1<ex>5 new photos</ex></ph> found.
+    <ph name="LINE_BREAK1">&lt;br&gt;</ph>
+    Not enough space available in local storage. Additional <ph name="FILE_SIZE">$2<ex>5 MB</ex></ph> needed.
+    <ph name="LINE_BREAK2">&lt;br&gt;</ph>
+    Try selecting fewer photos.
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_INSUFFICIENT_LOCAL_SPACE" desc="Cloud import insufficient local space tooltip.">
+    Not enough space available in local storage.
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_READY" desc="Cloud import ready status message.">
+    <ph name="FILE_COUNT">$1<ex>5 new photos</ex></ph> found
+    <ph name="LINE_BREAK1">&lt;br&gt;</ph>
+    Ready to back up to <ph name="BEGIN_LINK">&lt;a is='action-link' class='destination-link'&gt;</ph>Google Drive<ph name="END_LINK">&lt;/a&gt;</ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_READY" desc="Cloud import ready tooltip.">
+    Ready to backup <ph name="FILE_COUNT">$1<ex>5 new photos</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_IMPORTING" desc="Cloud import active-backup status. Message shown when importing is in progress">
+    Backing up <ph name="FILE_COUNT">$1<ex>5 new photos</ex></ph> to <ph name="BEGIN_LINK">&lt;a is='action-link' class='destination-link'&gt;</ph>Google Drive<ph name="END_LINK">&lt;/a&gt;</ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_IMPORTING" desc="Cloud import active-backup tooltip.">
+    Backing up <ph name="FILE_COUNT">$1<ex>5 new photos</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_DONE" desc="Cloud import backup is complete status.">
+    <ph name="FILE_COUNT">$1<ex>5</ex></ph> photos backed up to <ph name="BEGIN_LINK">&lt;a is='action-link' class='destination-link'&gt;</ph>Google Drive<ph name="END_LINK">&lt;/a&gt;</ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_ERROR_ITEM" desc="Cloud import error message for a file it couldn't back up.">
+    Couldn't back up <ph name="FILE_NAME">$1<ex>photo.jpg</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_DONE" desc="Cloud import backup is complete tooltip.">
+    <ph name="FILE_COUNT">$1<ex>5</ex></ph> photos backed up
+  </message>
+  <message name="IDS_FILE_BROWSER_CLOUD_IMPORT_ITEMS_REMAINING" desc="File Manager status message.">
+    Importing <ph name="FILE_COUNT">$1<ex>5</ex></ph> files...
+  </message>
+  <message name="IDS_FILE_BROWSER_COPY_FILE_NAME" desc="File Manager status message.">
+    Copying <ph name="FILE_NAME">$1<ex>movie.avi</ex></ph>...
+  </message>
+  <message name="IDS_FILE_BROWSER_COPY_ITEMS_REMAINING" desc="File Manager status message. 'Item' is used here as a generic term for file or directory.">
+    Copying $1 items...
+  </message>
+  <message name="IDS_FILE_BROWSER_COPY_TARGET_EXISTS_ERROR" desc="File Manager error message. 'Item' is used here as a generic term for file or directory.">
+    Whoops, <ph name="FILE_NAME">$1<ex>movie.avi</ex></ph> already exists. Rename it and try again.
+  </message>
+  <message name="IDS_FILE_BROWSER_COPY_SOURCE_NOT_FOUND_ERROR" desc="File Manager error message. 'Item' is used here as a generic term for file or directory.">
+    Whoops, <ph name="FILE_NAME">$1<ex>movie.avi</ex></ph> no longer exists.
+  </message>
+  <message name="IDS_FILE_BROWSER_COPY_FILESYSTEM_ERROR" desc="File Manager error message.">
+    Copy operation failed. <ph name="ERROR_MESSAGE">$1<ex>An error occurred (code: ABORT)</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_COPY_UNEXPECTED_ERROR" desc="File Manager error message.">
+    Copy operation failed, unexpected error: $1
+  </message>
+  <message name="IDS_FILE_BROWSER_MOVE_FILE_NAME" desc="File Manager status message.">
+    Moving <ph name="FILE_NAME">$1<ex>movie.avi</ex></ph>...
+  </message>
+  <message name="IDS_FILE_BROWSER_MOVE_ITEMS_REMAINING" desc="File Manager status message. 'Item' is used here as a generic term for file or directory.">
+    Moving $1 items...
+  </message>
+  <message name="IDS_FILE_BROWSER_MOVE_TARGET_EXISTS_ERROR" desc="File Manager error message. 'Item' is used here as a generic term for file or directory.">
+    Whoops, <ph name="FILE_NAME">$1<ex>movie.avi</ex></ph> already exists. Rename it and try again.
+  </message>
+  <message name="IDS_FILE_BROWSER_MOVE_SOURCE_NOT_FOUND_ERROR" desc="File Manager error message. 'Item' is used here as a generic term for file or directory.">
+    Whoops, <ph name="FILE_NAME">$1<ex>movie.avi</ex></ph> no longer exists.
+  </message>
+  <message name="IDS_FILE_BROWSER_MOVE_FILESYSTEM_ERROR" desc="File Manager error message.">
+    Move failed. <ph name="ERROR_MESSAGE">$1<ex>An error occurred (code: ABORT)</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_MOVE_UNEXPECTED_ERROR" desc="File Manager error message.">
+    Move failed, unexpected error: $1
+  </message>
+  <message name="IDS_FILE_BROWSER_ZIP_FILE_NAME" desc="File Manager status message.">
+    Zipping <ph name="FILE_NAME">$1<ex>movie.avi</ex></ph>...
+  </message>
+  <message name="IDS_FILE_BROWSER_ZIP_ITEMS_REMAINING" desc="File Manager status message. 'Item' is used here as a generic term for file or directory.">
+    Zipping $1 items...
+  </message>
+  <message name="IDS_FILE_BROWSER_ZIP_TARGET_EXISTS_ERROR" desc="File Manager error message. 'Item' is used here as a generic term for file or directory.">
+    Zipping failed, item exists: "$1"
+  </message>
+  <message name="IDS_FILE_BROWSER_ZIP_FILESYSTEM_ERROR" desc="File Manager error message.">
+    Zipping failed. <ph name="ERROR_MESSAGE">$1<ex>An error occurred (code: ABORT)</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_ZIP_UNEXPECTED_ERROR" desc="File Manager error message.">
+    Zipping failed, unexpected error: $1
+  </message>
+  <message name="IDS_FILE_BROWSER_SYNC_FILE_NAME" desc="File Manager status message.">
+    Syncing <ph name="FILE_NAME">$1<ex>movie.avi</ex></ph>...
+  </message>
+  <message name="IDS_FILE_BROWSER_SYNC_FILE_NUMBER" desc="File Manager status message.">
+    Syncing <ph name="NUMBER_OF_FILES">$1<ex>7</ex></ph> items...
+  </message>
+  <message name="IDS_FILE_BROWSER_SYNC_DELETE_WITHOUT_PERMISSION_ERROR" desc="File Manager status message shown when the drive sync is failed because a user try to remove shared files that the user does not own.">
+    "<ph name="FILENAME">$1<ex>photo.jpg</ex></ph>" has been shared with you. You cannot delete it because you do not own it.
+  </message>
+  <message name="IDS_FILE_BROWSER_SYNC_SERVICE_UNAVAILABLE_ERROR" desc="File Manager status message shown when the drive sync is failed because Google Drive is temporary unavailable.">
+    Google Drive is not available right now. Uploading will automatically restart once Google Drive is back.
+  </message>
+  <message name="IDS_FILE_BROWSER_SYNC_MISC_ERROR" desc="File Manager status message shown when the drive sync is failed because of miscellaneous errors.">
+    Google Drive was unable to sync "<ph name="FILENAME">$1<ex>photo.jpg</ex></ph>" right now. Google Drive will try again later.
+  </message>
+  <message name="IDS_FILE_BROWSER_SYNC_NO_SERVER_SPACE" desc="File Manager status message shown when the drive sync is failed because it runs out the space in Google Drive server.">
+    "<ph name="FILENAME">$1<ex>photo.jpg</ex></ph>" was not uploaded. There is not enough free space in your Google Drive.
+  </message>
+  <message name="IDS_FILE_BROWSER_SHARE_ERROR" desc="File Manager error message when sharing a file or a directory on Drive fails because of internet connection problems.">
+    Sharing failed. Check your connection and try again later.
+  </message>
+  <message name="IDS_FILE_BROWSER_DELETE_FILE_NAME" desc="File Manager status message.">
+    Deleting "<ph name="FILENAME">$1<ex>photo.jpg</ex></ph>"...
+  </message>
+  <message name="IDS_FILE_BROWSER_DELETE_ITEMS_REMAINING" desc="File Manager status message. 'Item' is used here as a generic term for file or directory.">
+    Deleting <ph name="COUNT">$1<ex>10</ex></ph> items...
+  </message>
+  <message name="IDS_FILE_BROWSER_DELETE_ERROR" desc="Message informing about error while deleting an item or items.">
+    An error occurred. Some items may not have been deleted.
+  </message>
+
+  <message name="IDS_FILE_BROWSER_COPY_PROGRESS_SUMMARY" desc="Summary message for multiple copying tasks above the progress bar.">
+    Copying...
+  </message>
+  <message name="IDS_FILE_BROWSER_MOVE_PROGRESS_SUMMARY" desc="Summary message for multiple moving tasks above the progress bar.">
+    Moving...
+  </message>
+  <message name="IDS_FILE_BROWSER_ZIP_PROGRESS_SUMMARY" desc="Summary message for multiple zipping tasks above the progress bar.">
+    Zipping...
+  </message>
+  <message name="IDS_FILE_BROWSER_DELETE_PROGRESS_SUMMARY" desc="Summary message for multiple deleting tasks above the progress bar.">
+    Deleting...
+  </message>
+  <message name="IDS_FILE_BROWSER_TRANSFER_PROGRESS_SUMMARY" desc="Summary message for mixed operation tasks above the progress bar. 'Transferring' is used here as a generic term for copying, moving, zipping, or deleting.">
+    Transferring...
+  </message>
+  <message name="IDS_FILE_BROWSER_SYNC_PROGRESS_SUMMARY" desc="Summary message for drive sync operation. This message can be shown without a progress bar.">
+    Syncing...
+  </message>
+  <message name="IDS_FILE_BROWSER_ERROR_PROGRESS_SUMMARY" desc="Summary message for an error above the progress bar. This message may be placed at the next to ohter *_PROGERSS_SUMMARY messages.">
+    1 error.
+  </message>
+  <message name="IDS_FILE_BROWSER_ERROR_PROGRESS_SUMMARY_PLURAL" desc="Summary message for multiple errors above the progress bar. This message may be placed at the next to ohter *_PROGERSS_SUMMARY messages.">
+    <ph name="COUNT">$1<ex>10</ex></ph> errors.
+  </message>
+
+  <message name="IDS_FILE_BROWSER_CANCEL_LABEL" desc="Cancel label.">
+    Cancel
+  </message>
+  <message name="IDS_FILE_BROWSER_OPEN_LABEL" desc="Open label.">
+    Open
+  </message>
+  <message name="IDS_FILE_BROWSER_SAVE_LABEL" desc="Save label.">
+    Save
+  </message>
+  <message name="IDS_FILE_BROWSER_OK_LABEL" desc="OK label.">
+    OK
+  </message>
+  <message name="IDS_FILE_BROWSER_UPLOAD_LABEL" desc="Upload label.">
+    Upload
+  </message>
+  <message name="IDS_FILE_BROWSER_SEARCH_TEXT_LABEL" desc="Search text field label.">
+    Search
+  </message>
+
+  <message name="IDS_FILE_BROWSER_DEFAULT_NEW_FOLDER_NAME" desc="The default name for a newly created folder.">
+    New Folder
+  </message>
+
+ <message name="IDS_FILE_BROWSER_CONFIRM_DELETE_ONE" desc="Asks the user if they are sure they want to delete a single file.">
+   Are you sure you want to delete "$1"?
+ </message>
+ <message name="IDS_FILE_BROWSER_CONFIRM_DELETE_SOME" desc="Asks the user if they are sure they want to delete multiple files/directories.">
+   Are you sure you want to delete $1 items?
+ </message>
+
+  <message name="IDS_FILE_BROWSER_UNKNOWN_FILESYSTEM_WARNING" desc="Displayed when device contents cannot be read because filesystem is unknown.">
+    This device cannot be opened because its filesystem was not recognized.
+  </message>
+  <message name="IDS_FILE_BROWSER_UNSUPPORTED_FILESYSTEM_WARNING" desc="Displayed when device contents cannot be read because filesystem is unsupported.">
+    This device cannot be opened because its filesystem is not supported.
+  </message>
+  <message name="IDS_FILE_BROWSER_FORMATTING_WARNING" desc="Displayed when you attempt to format device.">
+    Formatting the removable media is going to erase all data. Do you wish to continue?
+  </message>
+
+  <message name="IDS_FILE_BROWSER_SUGGEST_DIALOG_TITLE" desc="Title of the suggest app dialog, which shows the list of the apps which supports the selected file.">
+    Select an app to open this file
+  </message>
+  <message name="IDS_FILE_BROWSER_SUGGEST_DIALOG_FOR_PROVIDERS_TITLE" desc="Title of the suggest app dialog, which shows the list of the apps that can be added to the left nav of the Files app.">
+    Available services
+  </message>
+  <message name="IDS_FILE_BROWSER_SUGGEST_DIALOG_LINK_TO_WEBSTORE" desc="Text of the link to the app list on Chrome Webstore, which shows the more apps than in the suggest app dialog.">
+    See more...
+  </message>
+  <message name="IDS_FILE_BROWSER_SUGGEST_DIALOG_INSTALLATION_FAILED" desc="Error message when the installation of the app from WebStore is failed.">
+    Installation failed.
+  </message>
+  <message name="IDS_FILE_BROWSER_DROP_TARGET_DEVICE_WRITE_PROTECTED" desc="Tooltip label displayed besides mouse pointer while dragging files or folders over a write-protected folder or disk.">
+    Device is read-only
+  </message>
+  <message name="IDS_FILE_BROWSER_DROP_TARGET_ACCESS_RESTRICTED" desc="Tooltip label displayed besides mouse pointer when dragging files or folders over a removable device whose write access is restricted by administration policy.">
+    Access restricted
+  </message>
+  <message name="IDS_FILE_BROWSER_DROP_TARGET_FOLDER_NO_MOVE_PERMISSION" desc="Tooltip label displayed besides mouse pointer while dragging files or folders over a Team Drive or folder in Drive that does not have write access.">
+    You don't have permission to move files into '<ph name="FOLDER_NAME">$1<ex>Trip Photos</ex></ph>'.
+  </message>
+  <message name="IDS_FILE_BROWSER_DROP_TARGET_OPENING_LINUX_FILES" desc="Tooltip label displayed besides mouse pointer when dragging files or folders over Linux files root before the container has been started and mounted.">
+    Opening Linux files...
+  </message>
+
+  <message name="IDS_FILE_BROWSER_SELECT_FOLDER_TITLE" desc="Select folder title.">
+    Select a folder to open
+  </message>
+  <message name="IDS_FILE_BROWSER_SELECT_UPLOAD_FOLDER_TITLE" desc="Select folder title for upload.">
+    Select a folder to upload
+  </message>
+  <message name="IDS_FILE_BROWSER_SELECT_OPEN_FILE_TITLE" desc="Select open file title.">
+    Select a file to open
+  </message>
+  <message name="IDS_FILE_BROWSER_SELECT_OPEN_MULTI_FILE_TITLE" desc="Select open multi file title.">
+    Select one or more files
+  </message>
+  <message name="IDS_FILE_BROWSER_SELECT_SAVEAS_FILE_TITLE" desc="Select saveas file title.">
+    Save file as
+  </message>
+
+  <message name="IDS_FILE_BROWSER_ONE_FILE_SELECTED" desc="One file selected.">
+    1 file selected
+  </message>
+  <message name="IDS_FILE_BROWSER_ONE_DIRECTORY_SELECTED" desc="One directory selected.">
+    1 folder selected
+  </message>
+  <message name="IDS_FILE_BROWSER_MANY_FILES_SELECTED" desc="Many files selected.">
+    <ph name="SELCTED_FILE_COUNT">$1<ex>13</ex></ph> files selected
+  </message>
+  <message name="IDS_FILE_BROWSER_MANY_DIRECTORIES_SELECTED" desc="Many directories selected.">
+    <ph name="SELCTED_FOLDERS_COUNT">$1<ex>2</ex></ph> folders selected
+  </message>
+  <message name="IDS_FILE_BROWSER_MANY_ENTRIES_SELECTED" desc="Many items (both files and directories) selected.">
+    <ph name="SELCTED_FILES_COUNT">$1<ex>21</ex></ph> items selected
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_ALBUM_TITLE" desc="Label for audio album title.">
+    Album
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_AUDIO_INFO" desc="Category label for audio file info.">
+    Audio info
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_CODEC" desc="Label for video codec.">
+    Codec
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_CREATED_BY" desc="Label for who created the file.">
+    Created by
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_CREATION_TIME" desc="Label for file creation time.">
+    Created time
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_DIMENSION" desc="Label for image dimensions.">
+    Dimensions
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_DURATION" desc="Label for audio/video duration.">
+    Duration
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_EXIF_DEVICE_MODEL" desc="Label for the device model which created the image.">
+    Device model
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_EXIF_DEVICE_SETTINGS" desc="Label for the device settings (exif's F number, exposure time, focal length and ISO speed rating) metadata.">
+    Device settings
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_EXIF_GEOGRAPHY" desc="Label for the latitude and the longitude where the image was taken.">
+    Geography
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_FILE_PATH" desc="Label for file path.">
+    Path
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_FILE_SIZE" desc="Label for file size.">
+    Size
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_FRAME_RATE" desc="Label for video frame rate.">
+    Frame rate
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_GENERAL_INFO" desc="Category label for general file info.">
+    General info
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_GENRE" desc="Label for audio genre.">
+    Genre
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_IMAGE_INFO" desc="Category label for image file info.">
+    Image info
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_MEDIA_ARTIST" desc="Label for media artist.">
+    Artist
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_MEDIA_MIME_TYPE" desc="Label for media mime type.">
+    Type
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_MEDIA_TITLE" desc="Label for media title.">
+    Title
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_MODIFICATION_TIME" desc="Label for file modification time.">
+    Modified time
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_MODIFIED_BY" desc="Label for who modified the file.">
+    Modified by
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_PAGE_COUNT" desc="Label for pdf page count.">
+    Page count
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_SOURCE" desc="Label for the device used to capture the image.">
+    Source
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_TRACK" desc="Label for track number.">
+    Track
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_VIDEO_INFO" desc="Category label for video file info.">
+    Video info
+  </message>
+  <message name="IDS_FILE_BROWSER_METADATA_BOX_YEAR_RECORDED" desc="Label for audio recorded year.">
+    Year recorded
+  </message>
+  <message name="IDS_FILE_BROWSER_CALCULATING_SIZE" desc="Message informing the user that total items size is being calculated.">
+    Calculating size
+  </message>
+  <message name="IDS_FILE_BROWSER_OFFLINE_HEADER" desc="Message informing the user that the browser is offline.">
+    You are offline
+  </message>
+  <message name="IDS_FILE_BROWSER_OFFLINE_MESSAGE" desc="Message informing the user how to make the selected file available offline.">
+    To save this file for offline use, get back online, right-click the file, and select the <ph name="OFFLINE_CHECKBOX_NAME">'$1'<ex>'Available offline'</ex></ph> option.
+  </message>
+  <message name="IDS_FILE_BROWSER_OFFLINE_MESSAGE_PLURAL" desc="Message informing the user how to make multiple selected files available offline.">
+    To save these files for offline use, get back online, right-click the files, and select the <ph name="OFFLINE_CHECKBOX_NAME">'$1'<ex>'Available offline'</ex></ph> option.
+  </message>
+  <message name="IDS_FILE_BROWSER_QUICK_VIEW_NO_PLAYBACK_AVAILABLE" desc="Massage for user to notify no playback is available.">
+    No playback available
+  </message>
+  <message name="IDS_FILE_BROWSER_QUICK_VIEW_NO_PREVIEW_AVAILABLE" desc="Massage for user to notify no preview is available.">
+    No preview available
+  </message>
+  <message name="IDS_FILE_BROWSER_HOSTED_OFFLINE_MESSAGE" desc="Message informing the user that the selected file is only available online.">
+    You must be online to access this file.
+  </message>
+  <message name="IDS_FILE_BROWSER_HOSTED_OFFLINE_MESSAGE_PLURAL" desc="Message informing the user that the selected files are only available online.">
+    You must be online to access these files.
+  </message>
+  <message name="IDS_FILE_BROWSER_CONFIRM_MOBILE_DATA_USE" desc="Message informing the user that opening the file from Google Drive will use mobile data.">
+    Fetching this file will use approximately <ph name="FILE_SIZE">$1<ex>44 MB</ex></ph> of mobile data.
+  </message>
+  <message name="IDS_FILE_BROWSER_CONFIRM_MOBILE_DATA_USE_PLURAL" desc="Message informing the user that opening several files from Google Drive will use mobile data.">
+    Fetching these files will use approximately <ph name="FILE_SIZE">$1<ex>44 MB</ex></ph> of mobile data.
+  </message>
+  <message name="IDS_FILE_BROWSER_DISABLED_MOBILE_SYNC_NOTIFICATION_MESSAGE" desc="Notification message shown when the drive sync is needed on mobile network, but it is disabled.">
+    Google Drive sync is disabled by default, when using mobile data.
+  </message>
+  <message name="IDS_FILE_BROWSER_DISABLED_MOBILE_SYNC_NOTIFICATION_ENABLE_BUTTON" desc="Button label to enable drive sync over, on the notifcation of |IDS_FILE_BROWSER_DISABLED_MOBILE_SYNC_NOTIFICATION_MESSAGE|.">
+    Enable syncing over mobile data
+  </message>
+  <message name="IDS_FILE_BROWSER_OPEN_IN_OTHER_DESKTOP_MESSAGE" desc="Message of an alert dialog that is shown when a user opens a file in a desktop of another profile but the file is opened in the original desktop.">
+    This file opened on a different desktop. Move to <ph name="USER_NAME">$1<ex>John Doe</ex></ph> (<ph name="MAIL_ADDRESS">$2<ex>xxxxxx@gmail.com</ex></ph>) to view it.
+  </message>
+  <message name="IDS_FILE_BROWSER_OPEN_IN_OTHER_DESKTOP_MESSAGE_PLURAL" desc="Prural verson of the message of an alert dialog that is shown when a user opens a file in a desktop of another profile but the file is opened in the original desktop.">
+    These files opened on a different desktop. Move to <ph name="USER_NAME">$1<ex>John Doe</ex></ph> (<ph name="MAIL_ADDRESS">$2<ex>xxxxxx@gmail.com</ex></ph>) to view it.
+  </message>
+  <message name="IDS_FILE_BROWSER_MULTI_PROFILE_SHARE_DIALOG_TITLE" desc="Title of a dialog to request drive share for files that come from other profiles during file transfering.">
+    This Drive file isn't shared yet
+  </message>
+  <message name="IDS_FILE_BROWSER_MULTI_PROFILE_SHARE_DIALOG_TITLE_PLURAL" desc="Title of a dialog to request drive share for files that come from other profiles during file transfering.">
+    These Drive files aren't shared yet
+  </message>
+  <message name="IDS_FILE_BROWSER_MULTI_PROFILE_SHARE_DIALOG_MESSAGE" desc="Message of a dialog to request drive share for files that come from other profiles during file transfering. Below the message, there are the e-mail address of the account to be shared with the file, and a drop down list to select a share type.">
+    Change how this file is shared
+  </message>
+  <message name="IDS_FILE_BROWSER_MULTI_PROFILE_SHARE_DIALOG_MESSAGE_PLURAL" desc="Message of a dialog to request drive share for files that come from other profiles during file transfering. Below the message, there are the e-mail address of the account to be shared with the file, and a drop down list to select a share type.">
+    Change how these files are shared
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_SHARE_TYPE_CAN_EDIT" desc="Label text of 'Can edit' share type. Please use the same string with Google Drive.">
+    Can edit
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_SHARE_TYPE_CAN_COMMENT" desc="Label text of 'Can comment' share type. Please use the same string with Google Drive.">
+    Can comment
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_SHARE_TYPE_CAN_VIEW" desc="Label text of 'Can view' share type. Please use the same string with Google Drive.">
+    Can view
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_MOBILE_CONNECTION_OPTION" desc="Option that determines if we will allow Google Drive content sync over mobile connections.">
+    Do not use mobile data for sync
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_SHOW_HOSTED_FILES_OPTION" desc="Option that determines if we will show hosted Google Docs files in file browser.">
+    Show Google Docs files
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_MENU_HELP" desc="In the Google Drive settings menu, name of the Help item.">
+    Help
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_BUY_MORE_SPACE" desc="Menu item, offering user to buy more space on Google Drive">
+    Buy more storage...
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_VISIT_DRIVE_GOOGLE_COM" desc="Menu item, redirecting user to drive.google.com">
+    Go to drive.google.com...
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_SPACE_AVAILABLE_LONG" desc="Text showing space left on Google Drive">
+    Google Drive space left: <ph name="SPACE_AVAILABLE">$1<ex>400 MB</ex></ph>.
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_BUY_MORE_SPACE_LINK" desc="Text on the link, offering user to buy more space on Google Drive">
+    Buy more storage
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_OUT_OF_SPACE_HEADER" desc="Message informing the user that there is not enough space to make the selected file(s) available offline.">
+    You have run out of space
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_CANNOT_REACH" desc="Message informing the user that Google Drive can not be reached at this moment.">
+    Google Drive cannot be reached at this time.
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_OUT_OF_SPACE_MESSAGE" desc="Message informing the user how to make more space available to save the selected file offline.">
+    To save "<ph name="FILE_NAME">$1<ex>document.pdf</ex></ph>" offline you must free up an additional <ph name="TOTAL_FILE_SIZE">$2<ex>3.3 MB</ex></ph> of space:<ph name="MARKUP_1">&lt;br&gt;<ex>&lt;br&gt;</ex></ph>
+    <ph name="MARKUP_2">&lt;ul&gt;&lt;li&gt;<ex>&lt;ul&gt;&lt;li&gt;</ex></ph>unpin files that you no longer need to access offline<ph name="MARKUP_3">&lt;/li&gt;<ex>>&lt;/li&gt;</ex></ph>
+    <ph name="MARKUP_4">&lt;li&gt;<ex>&lt;li&gt;</ex></ph>delete files from your Downloads folder<ph name="MARKUP_5">&lt;/li&gt;&lt;/ul&gt;<ex>&lt;/li&gt;&lt;/ul&gt;</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_NOT_REACHED" desc="Message informing that Drive is unreachable and encuraging user to log out from the device and log back in.">
+    Google Drive could not be reached. Please <ph name="BEGIN_LINK">&lt;a href="javascript://"&gt;<ex>&lt;a href="javascript://"&gt;</ex></ph>log out<ph name="END_LINK">&lt;/a&gt;<ex>&lt;/a&gt;</ex></ph> and log back in.
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_WELCOME_TITLE" desc="In the Welcome to Google Drive banner, title of banner.">
+    Welcome to Google Drive!
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_WELCOME_TITLE_ALTERNATIVE" desc="In the Welcome to Google Drive banner, title of the alternative banner offering 100GB free storage.">
+    Get 100 GB free with Google Drive
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_WELCOME_TITLE_ALTERNATIVE_1TB" desc="In the Welcome to Google Drive banner, title of the alternative banner offering 1TB free storage.">
+    Get 1 TB free with Google Drive
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_WELCOME_TEXT_SHORT" desc="In the Welcome to Google Drive banner, text of the welcome message, short version.">
+    All files saved in this folder are backed up online automatically
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_WELCOME_TEXT_LONG" desc="In the Welcome to Google Drive banner, text of the welcome message, long version.">
+    <ph name="MARKUP_1">&lt;p&gt;&lt;strong&gt;<ex>&lt;strong&gt;</ex></ph>Access files from everywhere, even offline.<ph name="MARKUP_2">&lt;/strong&gt;<ex>&lt;/strong&gt;</ex></ph>
+    Files in Google Drive are up to date and available from any device.<ph name="MARKUP_3">&lt;/p&gt;<ex>&lt;/p&gt;</ex></ph>
+    <ph name="MARKUP_4">&lt;p&gt;&lt;strong&gt;<ex>&lt;strong&gt;</ex></ph>Keep your files safe.<ph name="MARKUP_5">&lt;/strong&gt;<ex>&lt;/strong&gt;</ex></ph>
+    No matter what happens to your device, your files are safely stored in Google Drive.<ph name="MARKUP_6">&lt;/p&gt;<ex>&lt;/p&gt;</ex></ph>
+    <ph name="MARKUP_7">&lt;p&gt;&lt;strong&gt;<ex>&lt;strong&gt;</ex></ph>Share, create and collaborate<ph name="MARKUP_8">&lt;/strong&gt;<ex>&lt;/strong&gt;</ex></ph>
+    on files with others all in one place.<ph name="MARKUP_9">&lt;/p&gt;<ex>&lt;/p&gt;</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_WELCOME_CHECK_ELIGIBILITY" desc="In the Welcome to Google Drive banner, a text on the button to check promo eligibility.">
+    Check eligibility
+  </message>
+  <message name="IDS_FILE_BROWSER_DRIVE_WELCOME_DISMISS" desc="In the Welcome to Google Drive banner, a text on the button to dismiss the banner.">
+    Dismiss
+  </message>
+  <message name="IDS_FILE_BROWSER_NO_TASK_FOR_FILE" desc="Message shown when user tries to open file, which we can't handle.">
+    This file type is not supported. Please visit the <ph name="BEGIN_LINK">&lt;a target='_blank' href='$1'&gt;<ex>&lt;a target='_blank' href='$1'&gt;</ex></ph>Chrome Web Store<ph name="END_LINK">&lt;/a&gt;<ex>&lt;/a&gt;</ex></ph> to find an app that can open this type of file.
+    <ph name="BEGIN_LINK_HELP">&lt;a target='_blank' href='$2'&gt;<ex>&lt;a target='_blank' href='$2'&gt;</ex></ph>Learn More<ph name="END_LINK_HELP">&lt;/a&gt;<ex>&lt;/a&gt;</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_NO_TASK_FOR_EXECUTABLE" desc="Message shown when user tries to open a windows executable file, which we can't handle.">
+    This file is designed for a PC using Windows software. This is not compatible with your device which runs Chrome OS. Please search the <ph name="BEGIN_LINK">&lt;a target='_blank' href='$1'&gt;<ex>&lt;a target='_blank' href='$1'&gt;</ex></ph>Chrome Web Store<ph name="END_LINK">&lt;/a&gt;<ex>&lt;/a&gt;</ex></ph> for a suitable replacement app.<ph name="BEGIN_LINK_HELP">&lt;a target='_blank' href='$2'&gt;<ex>&lt;a target='_blank' href='$2'&gt;</ex></ph>Learn More<ph name="END_LINK_HELP">&lt;/a&gt;<ex>&lt;/a&gt;</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_NO_TASK_FOR_DMG" desc="Message shown when user tries to open a windows executable file, which we can't handle.">
+    This file is designed for a computer using Macintosh software. This is not compatible with your device which runs Chrome OS. Please search the <ph name="BEGIN_LINK">&lt;a target='_blank' href='$1'&gt;<ex>&lt;a target='_blank' href='$1'&gt;</ex></ph>Chrome Web Store<ph name="END_LINK">&lt;/a&gt;<ex>&lt;/a&gt;</ex></ph> for a suitable replacement app.<ph name="BEGIN_LINK_HELP">&lt;a target='_blank' href='$2'&gt;<ex>&lt;a target='_blank' href='$2'&gt;</ex></ph>Learn More<ph name="END_LINK_HELP">&lt;/a&gt;<ex>&lt;/a&gt;</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_NO_TASK_FOR_CRX_TITLE" desc="Message shown when a user tries to open a *.crx file, which we don't handle in the Files app.">
+    Wait just a sec
+  </message>
+  <message name="IDS_FILE_BROWSER_NO_TASK_FOR_CRX" desc="Message shown when a user tries to open a *.crx file, which we don't handle in the Files app.">
+    We're constantly looking for ways to make your browsing safer. Previously, any website could prompt you to add an extension into your browser. In the latest versions of Google Chrome, you must explicitly tell Chrome that you want to install these extensions by adding them through the Extensions page. <ph name="BEGIN_LINK">&lt;a target='_blank' href='https://support.google.com/chrome_webstore/answer/2664769?p=crx_warning&amp;rd=1'&gt;</ph>Learn more<ph name="END_LINK">&lt;/a&gt;</ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_UNABLE_TO_OPEN_CROSTINI_TITLE" desc="Message title shown when a user tries to use a crostini app to open a file outside the crostini container (e.g. in Downloads).  This message will be removed once we support this action.">
+    Unable to open with $1
+  </message>
+  <message name="IDS_FILE_BROWSER_UNABLE_TO_OPEN_CROSTINI" desc="Message shown when a user tries to use a crostini app to open a file outside the crostini container (e.g. in Downloads).  This message will be removed once we support this action.">
+    To open files with $1, first copy to Linux files folder.
+  </message>
+
+  <message name="IDS_FILE_BROWSER_FOLDER" desc="Folder entry type">
+    Folder
+  </message>
+  <message name="IDS_FILE_BROWSER_GENERIC_FILE_TYPE" desc="An entry type for a file with an extension that the File Manager does not recognize.">
+    <ph name="FILE_TYPE">$1<ex>ABC</ex></ph> file
+  </message>
+  <message name="IDS_FILE_BROWSER_NO_EXTENSION_FILE_TYPE" desc="An entry type for a file without an extension">
+    File
+  </message>
+  <message name="IDS_FILE_BROWSER_IMAGE_FILE_TYPE" desc="Image file type">
+    $1 image
+  </message>
+  <message name="IDS_FILE_BROWSER_VIDEO_FILE_TYPE" desc="Video file type">
+    $1 video
+  </message>
+  <message name="IDS_FILE_BROWSER_AUDIO_FILE_TYPE" desc="Audio file type">
+    $1 audio
+  </message>
+  <message name="IDS_FILE_BROWSER_HTML_DOCUMENT_FILE_TYPE" desc="HTML document file type">
+    HTML document
+  </message>
+  <message name="IDS_FILE_BROWSER_ZIP_ARCHIVE_FILE_TYPE" desc="Zip archive file type">
+    Zip archive
+  </message>
+  <message name="IDS_FILE_BROWSER_RAR_ARCHIVE_FILE_TYPE" desc="RAR archive file type">
+    RAR archive
+  </message>
+  <message name="IDS_FILE_BROWSER_TAR_ARCHIVE_FILE_TYPE" desc="Tar archive file type">
+    Tar archive
+  </message>
+  <message name="IDS_FILE_BROWSER_TAR_BZIP2_ARCHIVE_FILE_TYPE" desc="Bzip2 compressed tar archive file type">
+    Bzip2 compressed tar archive
+  </message>
+  <message name="IDS_FILE_BROWSER_TAR_GZIP_ARCHIVE_FILE_TYPE" desc="Gzip compressed tar archive file type">
+    Gzip compressed tar archive
+  </message>
+  <message name="IDS_FILE_BROWSER_PLAIN_TEXT_FILE_TYPE" desc="Plain text file type">
+    Plain text
+  </message>
+  <message name="IDS_FILE_BROWSER_PDF_DOCUMENT_FILE_TYPE" desc="PDF document file type">
+    PDF document
+  </message>
+  <message name="IDS_FILE_BROWSER_WORD_DOCUMENT_FILE_TYPE" desc="Word document file type">
+    Word document
+  </message>
+  <message name="IDS_FILE_BROWSER_POWERPOINT_PRESENTATION_FILE_TYPE" desc="PowerPoint presentation file type">
+    PowerPoint presentation
+  </message>
+  <message name="IDS_FILE_BROWSER_EXCEL_FILE_TYPE" desc="Excel spreadsheet file type">
+    Excel spreadsheet
+  </message>
+
+  <message name="IDS_FILE_BROWSER_GDOC_DOCUMENT_FILE_TYPE" desc="Google document file type">
+    Google document
+  </message>
+  <message name="IDS_FILE_BROWSER_GSHEET_DOCUMENT_FILE_TYPE" desc="Google spreadsheet file type">
+    Google spreadsheet
+  </message>
+  <message name="IDS_FILE_BROWSER_GSLIDES_DOCUMENT_FILE_TYPE" desc="Google presentation file type">
+    Google presentation
+  </message>
+  <message name="IDS_FILE_BROWSER_GDRAW_DOCUMENT_FILE_TYPE" desc="Google drawing file type">
+    Google drawing
+  </message>
+  <message name="IDS_FILE_BROWSER_GTABLE_DOCUMENT_FILE_TYPE" desc="Google table file type">
+    Google table
+  </message>
+  <message name="IDS_FILE_BROWSER_GFORM_DOCUMENT_FILE_TYPE" desc="Google form file type">
+    Google form
+  </message>
+  <message name="IDS_FILE_BROWSER_GMAP_DOCUMENT_FILE_TYPE" desc="Google map file type">
+    Google map
+  </message>
+  <message name="IDS_FILE_BROWSER_GSITE_DOCUMENT_FILE_TYPE" desc="Google site file type">
+    Google site
+  </message>
+  <message name="IDS_FILE_BROWSER_GLINK_DOCUMENT_FILE_TYPE" desc="Google Drive link file type">
+    Google Drive link
+  </message>
+
+  <message name="IDS_FILE_BROWSER_ERROR_VIEWING_FILE_TITLE" desc="Title of error message propmt when user attempts to open a non-supported file in file browser.">
+    <ph name="FILENAME">$1</ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_ERROR_VIEWING_FILE" desc="Error message when user attempts to open a non-supported file in the Files app via Downloads panel.">
+    This file type is not supported. Please visit the Chrome Web Store to find an app that can open this type of file.
+  </message>
+  <message name="IDS_FILE_BROWSER_ERROR_VIEWING_FILE_FOR_DMG" desc="Error message when user attempts to open a dmg file in the Files app via Downloads panel.">
+    This file is designed for a computer using Macintosh software. This is not compatible with your device which runs Chrome OS. Please search the Chrome Web Store for a suitable replacement app.
+  </message>
+  <message name="IDS_FILE_BROWSER_ERROR_VIEWING_FILE_FOR_EXECUTABLE" desc="Error message when user attempts to open a exe file in the Files app via Downloads panel.">
+    This file is designed for a PC using Windows software. This is not compatible with your device which runs Chrome OS. Please search the Chrome Web Store for a suitable replacement app.
+  </message>
+  <message name="IDS_FILE_BROWSER_ERROR_UNRESOLVABLE_FILE" desc="Error message when the file attempted to open from Downloads panel was not found under paths managed by file manager.">
+    This file has wandered off somewhere. Please check your download location setting and try again.
+  </message>
+  <message name="IDS_FILE_BROWSER_AUDIO_PLAYER_TITLE" desc="Title of the Audio Player window.">
+    Audio Player
+  </message>
+  <message name="IDS_FILE_BROWSER_AUDIO_PLAYER_DEFAULT_ARTIST" desc="In the Audio Player window, default artist name used when artist name is unknown.">
+    Unknown Artist
+  </message>
+
+  <message name="IDS_FILE_BROWSER_FILE_ERROR_GENERIC" desc="In the File Manager, the error message when the file operation failed.">
+    An error occurred.
+  </message>
+  <message name="IDS_FILE_BROWSER_FILE_ERROR_NOT_FOUND" desc="In the File Manager, the error message when the file could not be found.">
+    The file could not be found.
+  </message>
+  <message name="IDS_FILE_BROWSER_FILE_ERROR_SECURITY" desc="In the File Manager, the error message when the file could not be accessed for security reasons.">
+    The file could not be accessed for security reasons.
+  </message>
+  <message name="IDS_FILE_BROWSER_FILE_ERROR_NOT_READABLE" desc="In the File Manager, the error message when the file could not be read.">
+    The file could not be read.
+  </message>
+  <message name="IDS_FILE_BROWSER_FILE_ERROR_NO_MODIFICATION_ALLOWED" desc="In the File Manager, the error message when the file could not be modified.">
+    The file could not be modified.
+  </message>
+  <message name="IDS_FILE_BROWSER_FILE_ERROR_INVALID_STATE" desc="In the File Manager, the error message when the file is not usable.">
+    The file or the directory is not usable.
+  </message>
+  <message name="IDS_FILE_BROWSER_FILE_ERROR_INVALID_MODIFICATION" desc="In the File Manager, the error message when the file could not be modified.">
+    The file could not be modified.
+  </message>
+  <message name="IDS_FILE_BROWSER_FILE_ERROR_PATH_EXISTS" desc="In the File Manager, the error message when the a file or a directory with the same name already exists.">
+    A file or a directory with the same name already exists.
+  </message>
+  <message name="IDS_FILE_BROWSER_FILE_ERROR_QUOTA_EXCEEDED" desc="In the File Manager, the error message when there is not enough space to complete the operation.">
+    There is not enough space.
+  </message>
+
+  <message name="IDS_FILE_BROWSER_SEARCH_DRIVE_HTML" desc="In the File Manager, the item in the autocomplete suggestion item just under the search box, to continue searching in the list.">
+    '&lt;b&gt;<ph name="SEARCH_STRING">$1<ex>abc</ex></ph>&lt;/b&gt;' - &lt;em&gt;search Drive&lt;/em&gt;
+  </message>
+  <message name="IDS_FILE_BROWSER_SEARCH_NO_MATCHING_FILES_HTML" desc="In the File Manager, the message informing the user that the search did not match any files or directories.">
+    No items match &lt;b&gt;"<ph name="SEARCH_STRING">$1<ex>abc</ex></ph>"&lt;/b&gt;
+  </message>
+
+  <message name="IDS_FILE_BROWSER_CHANGE_DEFAULT_MENU_ITEM" desc="In the File Manager, the text in the menu item to change the default action for a particular file type.">
+    Change default...
+  </message>
+  <message name="IDS_FILE_BROWSER_CHANGE_DEFAULT_CAPTION" desc="In the File Manager, the caption on the dialog box that chooses the default action for a particular file type.">
+    Choose the default app for <ph name="FILE_TYPE">$1<ex>PNG</ex></ph> files:
+  </message>
+  <message name="IDS_FILE_BROWSER_DEFAULT_TASK_LABEL" desc="In the File Manager actions menu, the text next to the default action name.">
+    (default)
+  </message>
+
+  <message name="IDS_FILE_BROWSER_THUMBNAIL_VIEW_TOOLTIP" desc="Tooltip for the Thumbnail View button.">
+    Thumbnail view
+  </message>
+  <message name="IDS_FILE_BROWSER_SHARE_BUTTON_TOOLTIP" desc="Tooltip for the button which provides share options in the Files app.">
+    More actions
+  </message>
+  <message name="IDS_FILE_BROWSER_SORT_BUTTON_TOOLTIP" desc="Tooltip for the button which provides sort options in the Files app.">
+    Sort options
+  </message>
+  <message name="IDS_FILE_BROWSER_GEAR_BUTTON_TOOLTIP" desc="Tooltip for the gear button in the Files app.">
+    More...
+  </message>
+  <message name="IDS_FILE_BROWSER_SELECTION_MENU_BUTTON_TOOLTIP" desc="Tooltip for the button to open the context menu of currently selected items in the Files app.">
+    More...
+  </message>
+
+  <message name="IDS_FILE_BROWSER_TIME_TODAY" desc="File date and time in case the date is today.">
+    Today <ph name="TODAY_DAYTIME">$1<ex>6:19 AM</ex></ph>
+  </message>
+  <message name="IDS_FILE_BROWSER_TIME_YESTERDAY" desc="File date and time in case the date is yesterday.">
+    Yesterday <ph name="YESTERDAY_DAYTIME">$1<ex>4:48 PM</ex></ph>
+  </message>
+
+  <message name="IDS_FILE_BROWSER_ALL_FILES_FILTER" desc="All Files filter for Open/Save dialog">
+    All files
+  </message>
+
+  <message name="IDS_FILE_BROWSER_SPACE_AVAILABLE" desc="Menu item showing space left for storage.">
+    <ph name="SPACE_AVAILABLE">$1<ex>4.8 GB</ex></ph> available
+  </message>
+  <message name="IDS_FILE_BROWSER_WAITING_FOR_SPACE_INFO" desc="Menu item, saying that FileBrowser is waiting for space information for storage. When actual data arrives, this item will be replaced with IDS_FILE_BROWSER_SPACE_AVAILABLE">
+    Waiting for space info...
+  </message>
+  <message name="IDS_FILE_BROWSER_FAILED_SPACE_INFO" desc="Menu item, saying that FileBrowser is failed to retrieve space information.">
+    Failed to retrieve space info
+  </message>
+  <message name="IDS_FILE_BROWSER_SEE_MENU_FOR_ACTIONS" desc="Text to be used by screen reader to indicate users that there are more options on the action bar.">
+    More options available on the action bar. Press Alt + A to focus the action bar.
+  </message>
+
+  <message name="IDS_FILEMANAGER_APP_NAME" desc="Name for the File Manager app.">
+    Files
+  </message>
+  <message name="IDS_FILEMANAGER_APP_DESCRIPTION" desc="Description for the File Manager app.">
+    The Files app provides quick access to files that you've saved on Google Drive, external storage, or your Chrome OS device.
+  </message>
+
+  <message name="IDS_FILE_SYSTEM_REQUEST_FILE_SYSTEM_DIALOG_TITLE" desc="Title of a prompt dialog for granting permissions to a volume (eg. USB drive, SD card, MTP device) with the specified name. Only used for screen readers (a11y); not visible.">
+    Permission requested
+  </message>
+  <message name="IDS_FILE_SYSTEM_REQUEST_FILE_SYSTEM_DIALOG_MESSAGE" desc="Message in a prompt dialog for granting read-only permissions to a volume (eg. USB drive, SD card, MTP device) with the specified name to the extension.">
+    <ph name="APP_NAME">$1<ex>Super Kiosk app</ex></ph> wants to copy files from <ph name="VOLUME_NAME">$2<ex>FooBar 4GB</ex></ph>.
+  </message>
+  <message name="IDS_FILE_SYSTEM_REQUEST_FILE_SYSTEM_DIALOG_WRITABLE_MESSAGE" desc="Message in a prompt dialog for granting full permissions (read, write, delete, create files and directories) to a volume (eg. USB drive, SD card, MTP device) with the specified name to the extension.">
+    <ph name="APP_NAME">$1<ex>Super Kiosk app</ex></ph> wants to access <ph name="VOLUME_NAME">$2<ex>FooBar 4GB</ex></ph>. It may modify or delete your files.
+  </message>
+  <message name="IDS_FILE_SYSTEM_REQUEST_FILE_SYSTEM_DIALOG_ALLOW_BUTTON" desc="Label on the button to grant permissions.">
+    Allow
+  </message>
+  <message name="IDS_FILE_SYSTEM_REQUEST_FILE_SYSTEM_DIALOG_DENY_BUTTON" desc="Label on the button to reject permissions.">
+    Deny
+  </message>
+  <message name="IDS_FILE_SYSTEM_REQUEST_FILE_SYSTEM_NOTIFICATION_MESSAGE" desc="Message in a notification about granted read-only pemissions (read, write, delete, create files and directories) to a volume (eg. USB drive, SD card, MTP device) with the specified name to the extension.">
+    Read-only access to <ph name="VOLUME_NAME">$1<ex>FooBar 4GB</ex></ph> has been granted.
+  </message>
+  <message name="IDS_FILE_SYSTEM_REQUEST_FILE_SYSTEM_NOTIFICATION_WRITABLE_MESSAGE" desc="Message in a notification about granted full permissions (read, write, delete, create files and directories) to a volume (eg. USB drive, SD card, MTP device) with the specified name to the extension.">
+    Read and write access to <ph name="VOLUME_NAME">$1<ex>FooBar 4GB</ex></ph> has been granted.
+  </message>
+</grit-part>
diff --git a/chrome/app/generated_resources.grd b/chrome/app/generated_resources.grd
index e9e240b603d23..77c8f094789d0 100644
--- a/chrome/app/generated_resources.grd
+++ b/chrome/app/generated_resources.grd
@@ -179,6 +179,12 @@ are declared in tools/grit/grit_rule.gni.
       <!-- Bookmarks specific strings -->
       <part file="bookmarks_strings.grdp" />
 
+      <!-- file manager strings -->
+      <if expr="is_linux">
+        <part file="file_manager_strings.grdp" />
+        <part file="webstore_widget_strings.grdp" />
+      </if>
+
       <!-- Media Router specific strings -->
       <part file="media_router_strings.grdp" />
 
diff --git a/chrome/app/webstore_widget_strings.grdp b/chrome/app/webstore_widget_strings.grdp
new file mode 100644
index 0000000000000..b1a38100dace4
--- /dev/null
+++ b/chrome/app/webstore_widget_strings.grdp
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- WebStore widget strings (included from generated_resources.grd). -->
+<grit-part>
+  <!-- Webstore widget app -->
+  <message name="IDS_WEBSTORE_WIDGET_APP_NAME" desc="App name for Webstore Gallery Widget app. The app shows a filtered list of extensions from Chrome Web Store. Extensions from the list can be installed directly from the app.">
+    Chrome Web Store Gallery
+  </message>
+  <message name="IDS_WEBSTORE_WIDGET_APP_DESC" desc="Description of Chrome Webstore Gallery Widget app.">
+    An app that shows a filtered list of extensions from Chrome Web Store. Extensions in the list can be installed directly from the app.
+  </message>
+  <message name="IDS_WEBSTORE_WIDGET_TITLE_PRINTER_PROVIDERS" desc="Title for Chrome Web Store Gallery Widget which lists all print driver apps from Chrome Web Store for a specific printer.">
+    Select a printer driver app
+  </message>
+  <message name="IDS_WEBSTORE_WIDGET_DEFAULT_ERROR" desc="Default message shown when Chrome Web Store Widget app window content fails to load (e.g. if it fails to load Chrome Web Store Gallery in a webview).">
+    Could not connect to the Chrome Web Store.
+  </message>
+  <message name="IDS_WEBSTORE_WIDGET_LOADING_SPINNER_ALT" desc="Alt text for spinner shown in Chrome Web Store Gallery widget while the widget contents is loading. This is the text that will be read by screen reader when the spinner is focused. The string should be translated as a verb.">
+    Loading
+  </message>
+  <message name="IDS_WEBSTORE_WIDGET_INSTALLING_SPINNER_ALT" desc="Alt text for spinner shown in Chrome Web Store Gallery widget while an app is being installed from the widget. This is the text that will be read by screen reader when the spinner has focus. The string should be translated as a verb.">
+    Installing
+  </message>
+
+</grit-part>

From 5a9e00057bf1b8eae35b07052f6e0e2c70a08d65 Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Wed, 22 Aug 2018 17:29:27 +0900
Subject: [PATCH 19/32] Add file_manager folder and files for extenions APIs to
 chrome/browser/extensions/api/

It adds file_manager folder and files for extensions APIs to share
them with Linux/Ozone build.

File manager was used only for ChromeOS and the original code is
from chrome/browser/chromeos/extensions/file_manager.
---
 .../browser/extensions/api/file_manager/DEPS  |    3 +
 .../extensions/api/file_manager/OWNERS        |    1 +
 .../api/file_manager/device_event_router.cc   |  180 ++
 .../api/file_manager/device_event_router.h    |  107 ++
 .../device_event_router_unittest.cc           |  146 ++
 .../api/file_manager/drivefs_event_router.cc  |  196 +++
 .../api/file_manager/drivefs_event_router.h   |   82 +
 .../drivefs_event_router_unittest.cc          |  594 +++++++
 .../api/file_manager/event_router.cc          | 1095 ++++++++++++
 .../api/file_manager/event_router.h           |  237 +++
 .../api/file_manager/event_router_factory.cc  |   62 +
 .../api/file_manager/event_router_factory.h   |   46 +
 .../file_manager/file_browser_handler_api.cc  |  379 ++++
 .../file_manager/file_browser_handler_api.h   |  145 ++
 .../file_browser_handler_api_test.cc          |  379 ++++
 .../file_manager_private_api_functions.h      |   20 +
 .../file_manager_private_apitest.cc           |  554 ++++++
 .../file_manager/file_stream_md5_digester.cc  |   70 +
 .../file_manager/file_stream_md5_digester.h   |   57 +
 .../api/file_manager/job_event_router.cc      |  148 ++
 .../api/file_manager/job_event_router.h       |  113 ++
 .../file_manager/job_event_router_unittest.cc |  254 +++
 .../api/file_manager/private_api_base.cc      |   46 +
 .../api/file_manager/private_api_base.h       |   45 +
 .../api/file_manager/private_api_dialog.cc    |  134 ++
 .../api/file_manager/private_api_dialog.h     |   75 +
 .../api/file_manager/private_api_drive.cc     | 1565 +++++++++++++++++
 .../api/file_manager/private_api_drive.h      |  286 +++
 .../file_manager/private_api_file_system.cc   | 1076 ++++++++++++
 .../file_manager/private_api_file_system.h    |  400 +++++
 .../api/file_manager/private_api_misc.cc      |  910 ++++++++++
 .../api/file_manager/private_api_misc.h       |  382 ++++
 .../api/file_manager/private_api_mount.cc     |  391 ++++
 .../api/file_manager/private_api_mount.h      |  114 ++
 .../api/file_manager/private_api_strings.cc   |  845 +++++++++
 .../api/file_manager/private_api_strings.h    |   32 +
 .../api/file_manager/private_api_tasks.cc     |  251 +++
 .../api/file_manager/private_api_tasks.h      |   98 ++
 .../api/file_manager/private_api_util.cc      |  411 +++++
 .../api/file_manager/private_api_util.h       |  108 ++
 40 files changed, 12037 insertions(+)
 create mode 100644 chrome/browser/extensions/api/file_manager/DEPS
 create mode 100644 chrome/browser/extensions/api/file_manager/OWNERS
 create mode 100644 chrome/browser/extensions/api/file_manager/device_event_router.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/device_event_router.h
 create mode 100644 chrome/browser/extensions/api/file_manager/device_event_router_unittest.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/drivefs_event_router.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/drivefs_event_router.h
 create mode 100644 chrome/browser/extensions/api/file_manager/drivefs_event_router_unittest.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/event_router.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/event_router.h
 create mode 100644 chrome/browser/extensions/api/file_manager/event_router_factory.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/event_router_factory.h
 create mode 100644 chrome/browser/extensions/api/file_manager/file_browser_handler_api.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/file_browser_handler_api.h
 create mode 100644 chrome/browser/extensions/api/file_manager/file_browser_handler_api_test.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/file_manager_private_api_functions.h
 create mode 100644 chrome/browser/extensions/api/file_manager/file_manager_private_apitest.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/file_stream_md5_digester.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/file_stream_md5_digester.h
 create mode 100644 chrome/browser/extensions/api/file_manager/job_event_router.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/job_event_router.h
 create mode 100644 chrome/browser/extensions/api/file_manager/job_event_router_unittest.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/private_api_base.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/private_api_base.h
 create mode 100644 chrome/browser/extensions/api/file_manager/private_api_dialog.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/private_api_dialog.h
 create mode 100644 chrome/browser/extensions/api/file_manager/private_api_drive.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/private_api_drive.h
 create mode 100644 chrome/browser/extensions/api/file_manager/private_api_file_system.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/private_api_file_system.h
 create mode 100644 chrome/browser/extensions/api/file_manager/private_api_misc.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/private_api_misc.h
 create mode 100644 chrome/browser/extensions/api/file_manager/private_api_mount.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/private_api_mount.h
 create mode 100644 chrome/browser/extensions/api/file_manager/private_api_strings.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/private_api_strings.h
 create mode 100644 chrome/browser/extensions/api/file_manager/private_api_tasks.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/private_api_tasks.h
 create mode 100644 chrome/browser/extensions/api/file_manager/private_api_util.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/private_api_util.h

diff --git a/chrome/browser/extensions/api/file_manager/DEPS b/chrome/browser/extensions/api/file_manager/DEPS
new file mode 100644
index 0000000000000..cdad3c26c29a9
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/DEPS
@@ -0,0 +1,3 @@
+include_rules = [
+  "+components/drive",
+]
diff --git a/chrome/browser/extensions/api/file_manager/OWNERS b/chrome/browser/extensions/api/file_manager/OWNERS
new file mode 100644
index 0000000000000..73220a827d8dc
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/OWNERS
@@ -0,0 +1 @@
+file://ui/file_manager/OWNERS
diff --git a/chrome/browser/extensions/api/file_manager/device_event_router.cc b/chrome/browser/extensions/api/file_manager/device_event_router.cc
new file mode 100644
index 0000000000000..edf30cf45576c
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/device_event_router.cc
@@ -0,0 +1,180 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/device_event_router.h"
+
+#include "base/bind.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chromeos/disks/disk.h"
+#include "content/public/browser/browser_thread.h"
+
+namespace file_manager {
+namespace {
+namespace file_manager_private = extensions::api::file_manager_private;
+using content::BrowserThread;
+}  // namespace
+
+DeviceEventRouter::DeviceEventRouter()
+    : resume_time_delta_(base::TimeDelta::FromSeconds(10)),
+      startup_time_delta_(base::TimeDelta::FromSeconds(10)),
+      is_starting_up_(false),
+      is_resuming_(false),
+      weak_factory_(this) {
+}
+
+DeviceEventRouter::DeviceEventRouter(base::TimeDelta overriding_time_delta)
+    : resume_time_delta_(overriding_time_delta),
+      startup_time_delta_(overriding_time_delta),
+      is_starting_up_(false),
+      is_resuming_(false),
+      weak_factory_(this) {
+}
+
+DeviceEventRouter::~DeviceEventRouter() = default;
+
+void DeviceEventRouter::Startup() {
+  is_starting_up_ = true;
+  base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(
+      FROM_HERE,
+      base::BindOnce(&DeviceEventRouter::StartupDelayed,
+                     weak_factory_.GetWeakPtr()),
+      startup_time_delta_);
+}
+
+void DeviceEventRouter::StartupDelayed() {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  is_starting_up_ = false;
+}
+
+void DeviceEventRouter::OnDeviceAdded(const std::string& device_path) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+
+  SetDeviceState(device_path, DEVICE_STATE_USUAL);
+  if (IsExternalStorageDisabled()) {
+    OnDeviceEvent(file_manager_private::DEVICE_EVENT_TYPE_DISABLED,
+                  device_path);
+    return;
+  }
+}
+
+void DeviceEventRouter::OnDeviceRemoved(const std::string& device_path) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  SetDeviceState(device_path, DEVICE_STATE_USUAL);
+  OnDeviceEvent(file_manager_private::DEVICE_EVENT_TYPE_REMOVED, device_path);
+}
+
+void DeviceEventRouter::OnDiskAdded(const chromeos::disks::Disk& disk,
+                                    bool mounting) {
+  // Do nothing.
+}
+
+void DeviceEventRouter::OnDiskRemoved(const chromeos::disks::Disk& disk) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+
+  if (is_resuming_ || is_starting_up_)
+    return;
+
+  const std::string& device_path = disk.system_path_prefix();
+  if (!disk.is_read_only() && disk.is_mounted() &&
+      GetDeviceState(device_path) != DEVICE_HARD_UNPLUGGED_AND_REPORTED) {
+    OnDeviceEvent(file_manager_private::DEVICE_EVENT_TYPE_HARD_UNPLUGGED,
+                  device_path);
+    SetDeviceState(device_path, DEVICE_HARD_UNPLUGGED_AND_REPORTED);
+  }
+}
+
+void DeviceEventRouter::OnVolumeMounted(chromeos::MountError error_code,
+                                        const Volume& volume) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+
+  const std::string& device_path = volume.system_path_prefix().AsUTF8Unsafe();
+  SetDeviceState(device_path, DEVICE_STATE_USUAL);
+}
+
+void DeviceEventRouter::OnVolumeUnmounted(chromeos::MountError error_code,
+                                          const Volume& volume) {
+  // Do nothing.
+}
+
+void DeviceEventRouter::OnFormatStarted(const std::string& device_path,
+                                        bool success) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+
+  if (success) {
+    OnDeviceEvent(file_manager_private::DEVICE_EVENT_TYPE_FORMAT_START,
+                  device_path);
+  } else {
+    OnDeviceEvent(file_manager_private::DEVICE_EVENT_TYPE_FORMAT_FAIL,
+                  device_path);
+  }
+}
+
+void DeviceEventRouter::OnFormatCompleted(const std::string& device_path,
+                                          bool success) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+
+  OnDeviceEvent(success ? file_manager_private::DEVICE_EVENT_TYPE_FORMAT_SUCCESS
+                        : file_manager_private::DEVICE_EVENT_TYPE_FORMAT_FAIL,
+                device_path);
+}
+
+void DeviceEventRouter::OnRenameStarted(const std::string& device_path,
+                                        bool success) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+
+  OnDeviceEvent(success ? file_manager_private::DEVICE_EVENT_TYPE_RENAME_START
+                        : file_manager_private::DEVICE_EVENT_TYPE_RENAME_FAIL,
+                device_path);
+}
+
+void DeviceEventRouter::OnRenameCompleted(const std::string& device_path,
+                                          bool success) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+
+  OnDeviceEvent(success ? file_manager_private::DEVICE_EVENT_TYPE_RENAME_SUCCESS
+                        : file_manager_private::DEVICE_EVENT_TYPE_RENAME_FAIL,
+                device_path);
+}
+
+void DeviceEventRouter::SuspendImminent(
+    power_manager::SuspendImminent::Reason reason) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  is_resuming_ = true;
+}
+
+void DeviceEventRouter::SuspendDone(const base::TimeDelta& sleep_duration) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(
+      FROM_HERE,
+      base::BindOnce(&DeviceEventRouter::SuspendDoneDelayed,
+                     weak_factory_.GetWeakPtr()),
+      resume_time_delta_);
+}
+
+void DeviceEventRouter::SuspendDoneDelayed() {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  is_resuming_ = false;
+}
+
+DeviceState DeviceEventRouter::GetDeviceState(
+    const std::string& device_path) const {
+  const std::map<std::string, DeviceState>::const_iterator it =
+      device_states_.find(device_path);
+  return it != device_states_.end() ? it->second : DEVICE_STATE_USUAL;
+}
+
+void DeviceEventRouter::SetDeviceState(const std::string& device_path,
+                                       DeviceState state) {
+  if (state != DEVICE_STATE_USUAL) {
+    device_states_[device_path] = state;
+  } else {
+    const std::map<std::string, DeviceState>::iterator it =
+        device_states_.find(device_path);
+    if (it != device_states_.end())
+      device_states_.erase(it);
+  }
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/extensions/api/file_manager/device_event_router.h b/chrome/browser/extensions/api/file_manager/device_event_router.h
new file mode 100644
index 0000000000000..20693a9d614db
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/device_event_router.h
@@ -0,0 +1,107 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_DEVICE_EVENT_ROUTER_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_DEVICE_EVENT_ROUTER_H_
+
+#include <map>
+#include <string>
+
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/threading/thread_checker.h"
+#include "chrome/browser/file_manager/volume_manager_observer.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "chromeos/dbus/power_manager_client.h"
+
+namespace file_manager {
+
+enum DeviceState {
+  // Device is not being hard unplugged.
+  DEVICE_STATE_USUAL,
+  // Device is hard unplugged.
+  DEVICE_HARD_UNPLUGGED,
+  // Device is hard unplugged and reported to the JavaScript side.
+  DEVICE_HARD_UNPLUGGED_AND_REPORTED
+};
+
+// Event router for device events.
+class DeviceEventRouter : public VolumeManagerObserver,
+                          public chromeos::PowerManagerClient::Observer {
+ public:
+  DeviceEventRouter();
+
+  // |overriding_time_delta| overrides time delta of delayed tasks for testing
+  // |so that the tasks are executed by RunLoop::RunUntilIdle.
+  explicit DeviceEventRouter(base::TimeDelta overriding_time_delta);
+
+  ~DeviceEventRouter() override;
+
+  // Turns the startup flag on, and then turns it off after few seconds.
+  void Startup();
+
+  // VolumeManagerObserver overrides.
+  void OnDiskAdded(const chromeos::disks::Disk& disk, bool mounting) override;
+  void OnDiskRemoved(const chromeos::disks::Disk& disk) override;
+  void OnDeviceAdded(const std::string& device_path) override;
+  void OnDeviceRemoved(const std::string& device_path) override;
+  void OnVolumeMounted(chromeos::MountError error_code,
+                       const Volume& volume) override;
+  void OnVolumeUnmounted(chromeos::MountError error_code,
+                         const Volume& volume) override;
+  void OnFormatStarted(const std::string& device_path, bool success) override;
+  void OnFormatCompleted(const std::string& device_path, bool success) override;
+  void OnRenameStarted(const std::string& device_path, bool success) override;
+  void OnRenameCompleted(const std::string& device_path, bool success) override;
+
+  // PowerManagerClient::Observer overrides.
+  void SuspendImminent(power_manager::SuspendImminent::Reason reason) override;
+  void SuspendDone(const base::TimeDelta& sleep_duration) override;
+
+  bool is_resuming() const { return is_resuming_; }
+  bool is_starting_up() const { return is_starting_up_; }
+
+ protected:
+  // Handles a device event containing |type| and |device_path|.
+  virtual void OnDeviceEvent(
+      extensions::api::file_manager_private::DeviceEventType type,
+      const std::string& device_path) = 0;
+  // Returns external storage is disabled or not.
+  virtual bool IsExternalStorageDisabled() = 0;
+
+ private:
+  void StartupDelayed();
+  void OnDeviceAddedDelayed(const std::string& device_path);
+  void SuspendDoneDelayed();
+
+  // Obtains device state of the device having |device_path|.
+  DeviceState GetDeviceState(const std::string& device_path) const;
+
+  // Sets device state to the device having |device_path|.
+  void SetDeviceState(const std::string& device_path, DeviceState state);
+
+  // Whther to use zero time delta for testing or not.
+  const base::TimeDelta resume_time_delta_;
+  const base::TimeDelta startup_time_delta_;
+
+  // Whether the profile is starting up or not.
+  bool is_starting_up_;
+
+  // Whether the system is resuming or not.
+  bool is_resuming_;
+
+  // Map of device path and device state.
+  std::map<std::string, DeviceState> device_states_;
+
+  // Thread checker.
+  THREAD_CHECKER(thread_checker_);
+
+  // Note: This should remain the last member so it'll be destroyed and
+  // invalidate the weak pointers before any other members are destroyed.
+  base::WeakPtrFactory<DeviceEventRouter> weak_factory_;
+  DISALLOW_COPY_AND_ASSIGN(DeviceEventRouter);
+};
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_DEVICE_EVENT_ROUTER_H_
diff --git a/chrome/browser/extensions/api/file_manager/device_event_router_unittest.cc b/chrome/browser/extensions/api/file_manager/device_event_router_unittest.cc
new file mode 100644
index 0000000000000..ecbaa82adbd25
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/device_event_router_unittest.cc
@@ -0,0 +1,146 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/device_event_router.h"
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/message_loop/message_loop.h"
+#include "base/run_loop.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chromeos/disks/disk.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace file_manager {
+namespace {
+
+namespace file_manager_private = extensions::api::file_manager_private;
+using chromeos::disks::Disk;
+
+const char kTestDevicePath[] = "/device/test";
+
+struct DeviceEvent {
+  extensions::api::file_manager_private::DeviceEventType type;
+  std::string device_path;
+};
+
+// DeviceEventRouter implementation for testing.
+class DeviceEventRouterImpl : public DeviceEventRouter {
+ public:
+  DeviceEventRouterImpl()
+      : DeviceEventRouter(base::TimeDelta::FromSeconds(0)),
+        external_storage_disabled(false) {}
+  ~DeviceEventRouterImpl() override = default;
+
+  // DeviceEventRouter overrides.
+  void OnDeviceEvent(file_manager_private::DeviceEventType type,
+                     const std::string& device_path) override {
+    DeviceEvent event;
+    event.type = type;
+    event.device_path = device_path;
+    events.push_back(event);
+  }
+
+  // DeviceEventRouter overrides.
+  bool IsExternalStorageDisabled() override {
+    return external_storage_disabled;
+  }
+
+  // List of dispatched events.
+  std::vector<DeviceEvent> events;
+
+  // Flag returned by |IsExternalStorageDisabled|.
+  bool external_storage_disabled;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(DeviceEventRouterImpl);
+};
+
+}  // namespace
+
+class DeviceEventRouterTest : public testing::Test {
+ protected:
+  void SetUp() override {
+    device_event_router = std::make_unique<DeviceEventRouterImpl>();
+  }
+
+  // Creates a disk instance with |device_path| and |mount_path| for testing.
+  Disk CreateTestDisk(const std::string& device_path,
+                      const std::string& mount_path,
+                      bool is_read_only_hardware) {
+    return *Disk::Builder()
+                .SetDevicePath(device_path)
+                .SetMountPath(mount_path)
+                .SetSystemPathPrefix(device_path)
+                .SetIsReadOnlyHardware(is_read_only_hardware)
+                .SetFileSystemType("vfat")
+                .Build();
+  }
+
+  std::unique_ptr<DeviceEventRouterImpl> device_event_router;
+
+ private:
+  base::MessageLoop message_loop_;
+};
+
+TEST_F(DeviceEventRouterTest, AddAndRemoveDevice) {
+  const Disk disk1 = CreateTestDisk("/device/test", "/mount/path1", false);
+  const Disk disk1_unmounted = CreateTestDisk("/device/test", "", false);
+  std::unique_ptr<Volume> volume(Volume::CreateForTesting(
+      base::FilePath(FILE_PATH_LITERAL("/device/test")),
+      base::FilePath(FILE_PATH_LITERAL("/mount/path1"))));
+  device_event_router->OnDeviceAdded("/device/test");
+  device_event_router->OnDiskAdded(disk1, true);
+  device_event_router->OnVolumeMounted(chromeos::MOUNT_ERROR_NONE,
+                                       *volume.get());
+  device_event_router->OnVolumeUnmounted(chromeos::MOUNT_ERROR_NONE,
+                                         *volume.get());
+  device_event_router->OnDiskRemoved(disk1_unmounted);
+  device_event_router->OnDeviceRemoved("/device/test");
+  ASSERT_EQ(1u, device_event_router->events.size());
+  EXPECT_EQ(file_manager_private::DEVICE_EVENT_TYPE_REMOVED,
+            device_event_router->events[0].type);
+  EXPECT_EQ("/device/test", device_event_router->events[0].device_path);
+}
+
+TEST_F(DeviceEventRouterTest, HardUnplugged) {
+  const Disk disk1 = CreateTestDisk("/device/test", "/mount/path1", false);
+  const Disk disk2 = CreateTestDisk("/device/test", "/mount/path2", false);
+  device_event_router->OnDeviceAdded("/device/test");
+  device_event_router->OnDiskAdded(disk1, true);
+  device_event_router->OnDiskAdded(disk2, true);
+  device_event_router->OnDiskRemoved(disk1);
+  device_event_router->OnDiskRemoved(disk2);
+  device_event_router->OnDeviceRemoved(kTestDevicePath);
+  base::RunLoop().RunUntilIdle();
+  ASSERT_EQ(2u, device_event_router->events.size());
+  EXPECT_EQ(file_manager_private::DEVICE_EVENT_TYPE_HARD_UNPLUGGED,
+            device_event_router->events[0].type);
+  EXPECT_EQ("/device/test", device_event_router->events[0].device_path);
+  EXPECT_EQ(file_manager_private::DEVICE_EVENT_TYPE_REMOVED,
+            device_event_router->events[1].type);
+  EXPECT_EQ("/device/test", device_event_router->events[1].device_path);
+}
+
+TEST_F(DeviceEventRouterTest, HardUnplugReadOnlyVolume) {
+  const Disk disk1 = CreateTestDisk("/device/test", "/mount/path1", true);
+  const Disk disk2 = CreateTestDisk("/device/test", "/mount/path2", true);
+  device_event_router->OnDeviceAdded("/device/test");
+  device_event_router->OnDiskAdded(disk1, true);
+  device_event_router->OnDiskAdded(disk2, true);
+  device_event_router->OnDiskRemoved(disk1);
+  device_event_router->OnDiskRemoved(disk2);
+  device_event_router->OnDeviceRemoved(kTestDevicePath);
+  base::RunLoop().RunUntilIdle();
+  ASSERT_EQ(1u, device_event_router->events.size());
+  EXPECT_EQ(file_manager_private::DEVICE_EVENT_TYPE_REMOVED,
+            device_event_router->events[0].type);
+  EXPECT_EQ("/device/test", device_event_router->events[0].device_path);
+  // Should not warn hard unplug because the volumes are read-only.
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/extensions/api/file_manager/drivefs_event_router.cc b/chrome/browser/extensions/api/file_manager/drivefs_event_router.cc
new file mode 100644
index 0000000000000..cdafe9f8172fe
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/drivefs_event_router.cc
@@ -0,0 +1,196 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/drivefs_event_router.h"
+
+#include "base/files/file_path.h"
+#include "base/strings/strcat.h"
+#include "base/values.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "chromeos/components/drivefs/mojom/drivefs.mojom.h"
+
+namespace file_manager {
+namespace file_manager_private = extensions::api::file_manager_private;
+
+namespace {
+
+file_manager_private::TransferState ConvertItemEventState(
+    drivefs::mojom::ItemEvent::State state) {
+  switch (state) {
+    case drivefs::mojom::ItemEvent::State::kQueued:
+    case drivefs::mojom::ItemEvent::State::kInProgress:
+      return file_manager_private::TRANSFER_STATE_IN_PROGRESS;
+    case drivefs::mojom::ItemEvent::State::kCompleted:
+      return file_manager_private::TRANSFER_STATE_COMPLETED;
+    case drivefs::mojom::ItemEvent::State::kFailed:
+      return file_manager_private::TRANSFER_STATE_FAILED;
+  }
+}
+
+bool IsItemEventCompleted(drivefs::mojom::ItemEvent::State state) {
+  switch (state) {
+    case drivefs::mojom::ItemEvent::State::kQueued:
+    case drivefs::mojom::ItemEvent::State::kInProgress:
+      return false;
+    case drivefs::mojom::ItemEvent::State::kCompleted:
+    case drivefs::mojom::ItemEvent::State::kFailed:
+      return true;
+  }
+  return false;
+}
+
+}  // namespace
+
+DriveFsEventRouter::DriveFsEventRouter() = default;
+DriveFsEventRouter::~DriveFsEventRouter() = default;
+
+void DriveFsEventRouter::OnUnmounted() {
+  completed_bytes_ = 0;
+  group_id_to_bytes_to_transfer_.clear();
+
+  // Ensure any existing sync progress indicator is cleared.
+  file_manager_private::FileTransferStatus status;
+  status.transfer_state = file_manager_private::TRANSFER_STATE_FAILED;
+  status.hide_when_zero_jobs = true;
+
+  DispatchOnFileTransfersUpdatedEvent(status);
+}
+
+void DriveFsEventRouter::OnSyncingStatusUpdate(
+    const drivefs::mojom::SyncingStatus& syncing_status) {
+  int64_t total_bytes_transferred = 0;
+  int64_t total_bytes_to_transfer = 0;
+  int num_files_syncing = 0;
+  bool any_in_progress = false;
+  for (const auto& item : syncing_status.item_events) {
+    if (IsItemEventCompleted(item->state)) {
+      auto it = group_id_to_bytes_to_transfer_.find(item->group_id);
+      if (it != group_id_to_bytes_to_transfer_.end()) {
+        completed_bytes_ += it->second;
+        group_id_to_bytes_to_transfer_.erase(it);
+      }
+    } else {
+      total_bytes_transferred += item->bytes_transferred;
+      total_bytes_to_transfer += item->bytes_to_transfer;
+      ++num_files_syncing;
+      if (item->state == drivefs::mojom::ItemEvent::State::kInProgress) {
+        any_in_progress = true;
+      }
+      if (item->bytes_to_transfer) {
+        group_id_to_bytes_to_transfer_[item->group_id] =
+            item->bytes_to_transfer;
+      }
+    }
+  }
+  auto completed_bytes = completed_bytes_;
+  if (num_files_syncing == 0) {
+    completed_bytes_ = 0;
+    group_id_to_bytes_to_transfer_.clear();
+  }
+
+  file_manager_private::FileTransferStatus status;
+  status.hide_when_zero_jobs = true;
+
+  if ((completed_bytes == 0 && !any_in_progress) ||
+      syncing_status.item_events.empty()) {
+    status.transfer_state = file_manager_private::TRANSFER_STATE_COMPLETED;
+    DispatchOnFileTransfersUpdatedEvent(status);
+    // If the progress bar is not already visible, don't show it if no sync task
+    // has actually started.
+    return;
+  }
+
+  total_bytes_transferred += completed_bytes;
+  total_bytes_to_transfer += completed_bytes;
+
+  status.num_total_jobs = num_files_syncing;
+  status.processed = total_bytes_transferred;
+  status.total = total_bytes_to_transfer;
+
+  auto extension_ids = GetEventListenerExtensionIds(
+      file_manager_private::OnFileTransfersUpdated::kEventName);
+
+  for (const auto& item : syncing_status.item_events) {
+    status.transfer_state = ConvertItemEventState(item->state);
+
+    base::FilePath path(item->path);
+    for (const auto& extension_id : extension_ids) {
+      status.file_url =
+          ConvertDrivePathToFileSystemUrl(path, extension_id).spec();
+      DispatchOnFileTransfersUpdatedEventToExtension(extension_id, status);
+    }
+  }
+}
+
+void DriveFsEventRouter::OnFilesChanged(
+    const std::vector<drivefs::mojom::FileChange>& changes) {
+  // Maps from parent directory to event for that directory.
+  std::map<base::FilePath,
+           extensions::api::file_manager_private::FileWatchEvent>
+      events;
+  for (const auto& extension_id : GetEventListenerExtensionIds(
+           file_manager_private::OnDirectoryChanged::kEventName)) {
+    for (const auto& change : changes) {
+      auto& event = events[change.path.DirName()];
+      if (!event.changed_files) {
+        event.event_type = extensions::api::file_manager_private::
+            FILE_WATCH_EVENT_TYPE_CHANGED;
+        event.changed_files = std::make_unique<
+            std::vector<extensions::api::file_manager_private::FileChange>>();
+        event.entry.additional_properties.SetString(
+            "fileSystemRoot", base::StrCat({ConvertDrivePathToFileSystemUrl(
+                                                base::FilePath(), extension_id)
+                                                .spec(),
+                                            "/"}));
+        event.entry.additional_properties.SetString("fileSystemName",
+                                                    GetDriveFileSystemName());
+        event.entry.additional_properties.SetString(
+            "fileFullPath", change.path.DirName().value());
+        event.entry.additional_properties.SetBoolean("fileIsDirectory", true);
+      }
+      event.changed_files->emplace_back();
+      auto& file_manager_change = event.changed_files->back();
+      file_manager_change.url =
+          ConvertDrivePathToFileSystemUrl(change.path, extension_id).spec();
+      file_manager_change.changes.push_back(
+          change.type == drivefs::mojom::FileChange::Type::kDelete
+              ? extensions::api::file_manager_private::CHANGE_TYPE_DELETE
+              : extensions::api::file_manager_private::
+                    CHANGE_TYPE_ADD_OR_UPDATE);
+    }
+    for (auto& event : events) {
+      DispatchOnDirectoryChangedEventToExtension(extension_id, event.second);
+    }
+  }
+}
+
+void DriveFsEventRouter::DispatchOnFileTransfersUpdatedEvent(
+    const extensions::api::file_manager_private::FileTransferStatus& status) {
+  for (const auto& extension_id : GetEventListenerExtensionIds(
+           file_manager_private::OnFileTransfersUpdated::kEventName)) {
+    DispatchOnFileTransfersUpdatedEventToExtension(extension_id, status);
+  }
+}
+
+void DriveFsEventRouter::DispatchOnFileTransfersUpdatedEventToExtension(
+    const std::string& extension_id,
+    const extensions::api::file_manager_private::FileTransferStatus& status) {
+  DispatchEventToExtension(
+      extension_id,
+      extensions::events::FILE_MANAGER_PRIVATE_ON_FILE_TRANSFERS_UPDATED,
+      file_manager_private::OnFileTransfersUpdated::kEventName,
+      file_manager_private::OnFileTransfersUpdated::Create(status));
+}
+
+void DriveFsEventRouter::DispatchOnDirectoryChangedEventToExtension(
+    const std::string& extension_id,
+    const extensions::api::file_manager_private::FileWatchEvent& event) {
+  DispatchEventToExtension(
+      extension_id,
+      extensions::events::FILE_MANAGER_PRIVATE_ON_DIRECTORY_CHANGED,
+      file_manager_private::OnDirectoryChanged::kEventName,
+      file_manager_private::OnDirectoryChanged::Create(event));
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/extensions/api/file_manager/drivefs_event_router.h b/chrome/browser/extensions/api/file_manager/drivefs_event_router.h
new file mode 100644
index 0000000000000..15a35510adb6d
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/drivefs_event_router.h
@@ -0,0 +1,82 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_DRIVEFS_EVENT_ROUTER_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_DRIVEFS_EVENT_ROUTER_H_
+
+#include <map>
+#include <set>
+#include <string>
+
+#include "base/macros.h"
+#include "chromeos/components/drivefs/drivefs_host_observer.h"
+#include "extensions/browser/extension_event_histogram_value.h"
+#include "url/gurl.h"
+
+namespace base {
+class FilePath;
+class ListValue;
+}
+
+namespace extensions {
+namespace api {
+namespace file_manager_private {
+struct FileTransferStatus;
+struct FileWatchEvent;
+}  // namespace file_manager_private
+}  // namespace api
+}  // namespace extensions
+
+namespace file_manager {
+
+// Files app's event router handling DriveFS-related events.
+class DriveFsEventRouter : public drivefs::DriveFsHostObserver {
+ public:
+  DriveFsEventRouter();
+  virtual ~DriveFsEventRouter();
+
+ private:
+  // DriveFsHostObserver:
+  void OnUnmounted() override;
+  void OnSyncingStatusUpdate(
+      const drivefs::mojom::SyncingStatus& status) override;
+  void OnFilesChanged(
+      const std::vector<drivefs::mojom::FileChange>& changes) override;
+
+  void DispatchOnFileTransfersUpdatedEvent(
+      const extensions::api::file_manager_private::FileTransferStatus& status);
+
+  virtual std::set<std::string> GetEventListenerExtensionIds(
+      const std::string& event_name) = 0;
+
+  virtual GURL ConvertDrivePathToFileSystemUrl(
+      const base::FilePath& file_path,
+      const std::string& extension_id) = 0;
+
+  virtual std::string GetDriveFileSystemName() = 0;
+
+  void DispatchOnFileTransfersUpdatedEventToExtension(
+      const std::string& extension_id,
+      const extensions::api::file_manager_private::FileTransferStatus& status);
+
+  void DispatchOnDirectoryChangedEventToExtension(
+      const std::string& extension_id,
+      const extensions::api::file_manager_private::FileWatchEvent& event);
+
+  // Helper method for dispatching an event to an extension.
+  virtual void DispatchEventToExtension(
+      const std::string& extension_id,
+      extensions::events::HistogramValue histogram_value,
+      const std::string& event_name,
+      std::unique_ptr<base::ListValue> event_args) = 0;
+
+  std::map<int64_t, int64_t> group_id_to_bytes_to_transfer_;
+  int64_t completed_bytes_ = 0;
+
+  DISALLOW_COPY_AND_ASSIGN(DriveFsEventRouter);
+};
+
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_DRIVEFS_EVENT_ROUTER_H_
diff --git a/chrome/browser/extensions/api/file_manager/drivefs_event_router_unittest.cc b/chrome/browser/extensions/api/file_manager/drivefs_event_router_unittest.cc
new file mode 100644
index 0000000000000..0470d4e3fb01f
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/drivefs_event_router_unittest.cc
@@ -0,0 +1,594 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/chromeos/extensions/file_manager/drivefs_event_router.h"
+
+#include <memory>
+#include <string>
+#include <utility>
+
+#include "base/macros.h"
+#include "base/strings/strcat.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "chromeos/components/drivefs/mojom/drivefs.mojom.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace file_manager {
+namespace file_manager_private = extensions::api::file_manager_private;
+
+using file_manager_private::FileTransferStatus;
+using file_manager_private::FileWatchEvent;
+using testing::_;
+
+namespace {
+
+class ListValueMatcher
+    : public testing::MatcherInterface<const base::ListValue&> {
+ public:
+  explicit ListValueMatcher(base::ListValue expected)
+      : expected_(std::move(expected)) {}
+
+  bool MatchAndExplain(const base::ListValue& actual,
+                       testing::MatchResultListener* listener) const override {
+    *listener << actual;
+    return actual == expected_;
+  }
+
+  void DescribeTo(::std::ostream* os) const override { *os << expected_; }
+
+ private:
+  base::ListValue expected_;
+};
+
+testing::Matcher<const base::ListValue&> MatchFileTransferStatus(
+    std::string file_url,
+    file_manager_private::TransferState transfer_state,
+    double processed,
+    double total,
+    int num_total_jobs) {
+  FileTransferStatus status;
+  status.file_url = std::move(file_url);
+  status.transfer_state = transfer_state;
+  status.processed = processed;
+  status.total = total;
+  status.num_total_jobs = num_total_jobs;
+  status.hide_when_zero_jobs = true;
+  return testing::MakeMatcher(new ListValueMatcher(std::move(
+      *file_manager_private::OnFileTransfersUpdated::Create(status))));
+}
+
+testing::Matcher<const base::ListValue&> MatchFileWatchEvent(
+    const FileWatchEvent& event) {
+  return testing::MakeMatcher(new ListValueMatcher(
+      std::move(*file_manager_private::OnDirectoryChanged::Create(event))));
+}
+
+class TestDriveFsEventRouter : public DriveFsEventRouter {
+ public:
+  TestDriveFsEventRouter() = default;
+
+  void DispatchEventToExtension(
+      const std::string& extension_id,
+      extensions::events::HistogramValue histogram_value,
+      const std::string& event_name,
+      std::unique_ptr<base::ListValue> event_args) override {
+    DispatchEventToExtensionImpl(extension_id, event_name, *event_args);
+  }
+
+  MOCK_METHOD3(DispatchEventToExtensionImpl,
+               void(const std::string& extension_id,
+                    const std::string& name,
+                    const base::ListValue& event));
+
+  GURL ConvertDrivePathToFileSystemUrl(
+      const base::FilePath& file_path,
+      const std::string& extension_id) override {
+    return GURL(base::StrCat({extension_id, ":", file_path.value()}));
+  }
+
+  std::string GetDriveFileSystemName() override { return "drivefs"; }
+
+  std::set<std::string> GetEventListenerExtensionIds(
+      const std::string& event_name) override {
+    return {"ext"};
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(TestDriveFsEventRouter);
+};
+
+class DriveFsEventRouterTest : public testing::Test {
+ protected:
+  void SetUp() override {
+    event_router_ = std::make_unique<TestDriveFsEventRouter>();
+  }
+
+  drivefs::DriveFsHostObserver& observer() { return *event_router_; }
+  TestDriveFsEventRouter& mock() { return *event_router_; }
+
+ private:
+  std::unique_ptr<TestDriveFsEventRouter> event_router_;
+};
+
+TEST_F(DriveFsEventRouterTest, OnSyncingStatusUpdate_Basic) {
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName,
+          MatchFileTransferStatus(
+              "ext:a", file_manager_private::TRANSFER_STATE_IN_PROGRESS, 50,
+              200, 2)));
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName,
+          MatchFileTransferStatus(
+              "ext:b", file_manager_private::TRANSFER_STATE_IN_PROGRESS, 50,
+              200, 2)));
+
+  drivefs::mojom::SyncingStatus syncing_status;
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kInProgress,
+      50, 100);
+  syncing_status.item_events.emplace_back(
+      base::in_place, 2, 3, "b", drivefs::mojom::ItemEvent::State::kQueued, 0,
+      100);
+  observer().OnSyncingStatusUpdate(syncing_status);
+}
+
+TEST_F(DriveFsEventRouterTest, OnSyncingStatusUpdate_EmptyStatus) {
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName,
+          MatchFileTransferStatus(
+              "", file_manager_private::TRANSFER_STATE_COMPLETED, 0, 0, 0)));
+
+  drivefs::mojom::SyncingStatus syncing_status;
+  observer().OnSyncingStatusUpdate(syncing_status);
+}
+
+TEST_F(DriveFsEventRouterTest,
+       OnSyncingStatusUpdate_EmptyStatus_ClearsInProgressOrCompleted) {
+  drivefs::mojom::SyncingStatus syncing_status;
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kInProgress,
+      50, 100);
+  syncing_status.item_events.emplace_back(
+      base::in_place, 2, 3, "b", drivefs::mojom::ItemEvent::State::kQueued, 0,
+      100);
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName, _))
+      .Times(4);
+  observer().OnSyncingStatusUpdate(syncing_status);
+
+  syncing_status.item_events.clear();
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kCompleted,
+      -1, -1);
+  syncing_status.item_events.emplace_back(
+      base::in_place, 2, 3, "b", drivefs::mojom::ItemEvent::State::kInProgress,
+      10, 100);
+  observer().OnSyncingStatusUpdate(syncing_status);
+  testing::Mock::VerifyAndClear(&observer());
+
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName,
+          MatchFileTransferStatus(
+              "", file_manager_private::TRANSFER_STATE_COMPLETED, 0, 0, 0)));
+
+  syncing_status.item_events.clear();
+  observer().OnSyncingStatusUpdate(syncing_status);
+
+  testing::Mock::VerifyAndClear(&observer());
+
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName,
+          MatchFileTransferStatus(
+              "ext:c", file_manager_private::TRANSFER_STATE_IN_PROGRESS, 60, 70,
+              1)));
+
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "c", drivefs::mojom::ItemEvent::State::kInProgress,
+      60, 70);
+  observer().OnSyncingStatusUpdate(syncing_status);
+}
+
+TEST_F(DriveFsEventRouterTest, OnSyncingStatusUpdate_FailedSync) {
+  drivefs::mojom::SyncingStatus syncing_status;
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kInProgress,
+      50, 100);
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName, _))
+      .Times(2);
+  observer().OnSyncingStatusUpdate(syncing_status);
+
+  syncing_status.item_events.clear();
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kInProgress,
+      80, 100);
+  observer().OnSyncingStatusUpdate(syncing_status);
+
+  testing::Mock::VerifyAndClear(&observer());
+
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName,
+          MatchFileTransferStatus("ext:a",
+                                  file_manager_private::TRANSFER_STATE_FAILED,
+                                  100, 100, 0)));
+  syncing_status.item_events.clear();
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kFailed, -1,
+      -1);
+  observer().OnSyncingStatusUpdate(syncing_status);
+}
+
+TEST_F(DriveFsEventRouterTest, OnSyncingStatusUpdate_CompletedSync) {
+  drivefs::mojom::SyncingStatus syncing_status;
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kInProgress,
+      50, 100);
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName, _))
+      .Times(2);
+  observer().OnSyncingStatusUpdate(syncing_status);
+
+  syncing_status.item_events.clear();
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kInProgress,
+      80, 100);
+  observer().OnSyncingStatusUpdate(syncing_status);
+
+  testing::Mock::VerifyAndClear(&observer());
+
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName,
+          MatchFileTransferStatus(
+              "ext:a", file_manager_private::TRANSFER_STATE_COMPLETED, 100, 100,
+              0)));
+  syncing_status.item_events.clear();
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kCompleted,
+      -1, -1);
+  observer().OnSyncingStatusUpdate(syncing_status);
+}
+
+TEST_F(DriveFsEventRouterTest,
+       OnSyncingStatusUpdate_CompletedSync_WithInProgress) {
+  drivefs::mojom::SyncingStatus syncing_status;
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kInProgress,
+      50, 100);
+  syncing_status.item_events.emplace_back(
+      base::in_place, 2, 3, "b", drivefs::mojom::ItemEvent::State::kQueued, 0,
+      100);
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName, _))
+      .Times(2);
+  observer().OnSyncingStatusUpdate(syncing_status);
+
+  testing::Mock::VerifyAndClear(&observer());
+
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName,
+          MatchFileTransferStatus(
+              "ext:a", file_manager_private::TRANSFER_STATE_COMPLETED, 110, 200,
+              1)));
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName,
+          MatchFileTransferStatus(
+              "ext:b", file_manager_private::TRANSFER_STATE_IN_PROGRESS, 110,
+              200, 1)));
+  syncing_status.item_events.clear();
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kCompleted,
+      -1, -1);
+  syncing_status.item_events.emplace_back(
+      base::in_place, 2, 3, "b", drivefs::mojom::ItemEvent::State::kInProgress,
+      10, 100);
+  observer().OnSyncingStatusUpdate(syncing_status);
+}
+
+TEST_F(DriveFsEventRouterTest, OnSyncingStatusUpdate_CompletedSync_WithQueued) {
+  drivefs::mojom::SyncingStatus syncing_status;
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kInProgress,
+      50, 100);
+  syncing_status.item_events.emplace_back(
+      base::in_place, 2, 3, "b", drivefs::mojom::ItemEvent::State::kQueued, 0,
+      100);
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName, _))
+      .Times(2);
+  observer().OnSyncingStatusUpdate(syncing_status);
+
+  testing::Mock::VerifyAndClear(&observer());
+
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName,
+          MatchFileTransferStatus(
+              "ext:a", file_manager_private::TRANSFER_STATE_COMPLETED, 110, 200,
+              1)));
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName,
+          MatchFileTransferStatus(
+              "ext:b", file_manager_private::TRANSFER_STATE_IN_PROGRESS, 110,
+              200, 1)));
+  syncing_status.item_events.clear();
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kCompleted,
+      -1, -1);
+  syncing_status.item_events.emplace_back(
+      base::in_place, 2, 3, "b", drivefs::mojom::ItemEvent::State::kQueued, 10,
+      100);
+  observer().OnSyncingStatusUpdate(syncing_status);
+}
+
+TEST_F(DriveFsEventRouterTest,
+       OnSyncingStatusUpdate_CompletedSync_OtherQueued) {
+  drivefs::mojom::SyncingStatus syncing_status;
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kInProgress,
+      50, 100);
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName, _))
+      .Times(1);
+  observer().OnSyncingStatusUpdate(syncing_status);
+
+  testing::Mock::VerifyAndClear(&observer());
+
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName,
+          MatchFileTransferStatus(
+              "ext:a", file_manager_private::TRANSFER_STATE_COMPLETED, 110, 200,
+              1)));
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName,
+          MatchFileTransferStatus(
+              "ext:b", file_manager_private::TRANSFER_STATE_IN_PROGRESS, 110,
+              200, 1)));
+  syncing_status.item_events.clear();
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kCompleted,
+      -1, -1);
+  syncing_status.item_events.emplace_back(
+      base::in_place, 2, 3, "b", drivefs::mojom::ItemEvent::State::kQueued, 10,
+      100);
+  observer().OnSyncingStatusUpdate(syncing_status);
+}
+
+TEST_F(DriveFsEventRouterTest, OnSyncingStatusUpdate_CompletedSync_ThenQueued) {
+  drivefs::mojom::SyncingStatus syncing_status;
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kInProgress,
+      50, 100);
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName, _))
+      .Times(2);
+  observer().OnSyncingStatusUpdate(syncing_status);
+
+  syncing_status.item_events.clear();
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kCompleted,
+      -1, -1);
+  observer().OnSyncingStatusUpdate(syncing_status);
+
+  testing::Mock::VerifyAndClear(&observer());
+
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName,
+          MatchFileTransferStatus(
+              "", file_manager_private::TRANSFER_STATE_COMPLETED, 0, 0, 0)));
+  syncing_status.item_events.clear();
+  syncing_status.item_events.emplace_back(
+      base::in_place, 2, 3, "b", drivefs::mojom::ItemEvent::State::kQueued, 10,
+      100);
+  observer().OnSyncingStatusUpdate(syncing_status);
+}
+
+TEST_F(DriveFsEventRouterTest,
+       OnSyncingStatusUpdate_CompletedSync_ThenInProgress) {
+  drivefs::mojom::SyncingStatus syncing_status;
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kInProgress,
+      50, 100);
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName, _))
+      .Times(1);
+  observer().OnSyncingStatusUpdate(syncing_status);
+
+  testing::Mock::VerifyAndClear(&observer());
+
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName, _));
+  syncing_status.item_events.clear();
+  syncing_status.item_events.emplace_back(
+      base::in_place, 1, 1, "a", drivefs::mojom::ItemEvent::State::kCompleted,
+      -1, -1);
+  observer().OnSyncingStatusUpdate(syncing_status);
+
+  testing::Mock::VerifyAndClear(&observer());
+
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName,
+          MatchFileTransferStatus(
+              "ext:b", file_manager_private::TRANSFER_STATE_IN_PROGRESS, 10,
+              500, 1)));
+  syncing_status.item_events.clear();
+  syncing_status.item_events.emplace_back(
+      base::in_place, 2, 3, "b", drivefs::mojom::ItemEvent::State::kInProgress,
+      10, 500);
+  observer().OnSyncingStatusUpdate(syncing_status);
+}
+
+TEST_F(DriveFsEventRouterTest, OnSyncingStatusUpdate_QueuedOnly) {
+  drivefs::mojom::SyncingStatus syncing_status;
+  syncing_status.item_events.emplace_back(
+      base::in_place, 2, 3, "b", drivefs::mojom::ItemEvent::State::kQueued, 0,
+      100);
+
+  testing::Mock::VerifyAndClear(&observer());
+
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName,
+          MatchFileTransferStatus(
+              "", file_manager_private::TRANSFER_STATE_COMPLETED, 0, 0, 0)));
+  syncing_status.item_events.clear();
+  syncing_status.item_events.emplace_back(
+      base::in_place, 2, 3, "b", drivefs::mojom::ItemEvent::State::kQueued, 10,
+      100);
+  observer().OnSyncingStatusUpdate(syncing_status);
+}
+
+TEST_F(DriveFsEventRouterTest, OnSyncingStatusUpdate_OnUnmounted) {
+  EXPECT_CALL(
+      mock(),
+      DispatchEventToExtensionImpl(
+          "ext", file_manager_private::OnFileTransfersUpdated::kEventName,
+          MatchFileTransferStatus(
+              "", file_manager_private::TRANSFER_STATE_FAILED, 0, 0, 0)));
+
+  observer().OnUnmounted();
+}
+
+TEST_F(DriveFsEventRouterTest, OnFilesChanged_Basic) {
+  FileWatchEvent event;
+  event.event_type = file_manager_private::FILE_WATCH_EVENT_TYPE_CHANGED;
+  event.entry.additional_properties.SetString("fileSystemRoot", "ext:/");
+  event.entry.additional_properties.SetString("fileSystemName", "drivefs");
+  event.entry.additional_properties.SetString("fileFullPath", "/root");
+  event.entry.additional_properties.SetBoolean("fileIsDirectory", true);
+  event.changed_files =
+      std::make_unique<std::vector<file_manager_private::FileChange>>();
+  event.changed_files->emplace_back();
+  {
+    auto& changed_file = event.changed_files->back();
+    changed_file.url = "ext:/root/a";
+    changed_file.changes.push_back(file_manager_private::CHANGE_TYPE_DELETE);
+  }
+  event.changed_files->emplace_back();
+  {
+    auto& changed_file = event.changed_files->back();
+    changed_file.url = "ext:/root/b";
+    changed_file.changes.push_back(
+        file_manager_private::CHANGE_TYPE_ADD_OR_UPDATE);
+  }
+  event.changed_files->emplace_back();
+  {
+    auto& changed_file = event.changed_files->back();
+    changed_file.url = "ext:/root/c";
+    changed_file.changes.push_back(
+        file_manager_private::CHANGE_TYPE_ADD_OR_UPDATE);
+  }
+
+  EXPECT_CALL(mock(),
+              DispatchEventToExtensionImpl(
+                  "ext", file_manager_private::OnDirectoryChanged::kEventName,
+                  MatchFileWatchEvent(event)));
+
+  std::vector<drivefs::mojom::FileChange> changes;
+  changes.emplace_back(base::FilePath("/root/a"),
+                       drivefs::mojom::FileChange::Type::kDelete);
+  changes.emplace_back(base::FilePath("/root/b"),
+                       drivefs::mojom::FileChange::Type::kCreate);
+  changes.emplace_back(base::FilePath("/root/c"),
+                       drivefs::mojom::FileChange::Type::kModify);
+  observer().OnFilesChanged(changes);
+}
+
+TEST_F(DriveFsEventRouterTest, OnFilesChanged_MultipleDirectories) {
+  FileWatchEvent event;
+  event.event_type = file_manager_private::FILE_WATCH_EVENT_TYPE_CHANGED;
+  event.entry.additional_properties.SetString("fileSystemRoot", "ext:/");
+  event.entry.additional_properties.SetString("fileSystemName", "drivefs");
+  event.entry.additional_properties.SetString("fileFullPath", "/root/a");
+  event.entry.additional_properties.SetBoolean("fileIsDirectory", true);
+  event.changed_files =
+      std::make_unique<std::vector<file_manager_private::FileChange>>();
+  event.changed_files->emplace_back();
+  {
+    auto& changed_file = event.changed_files->back();
+    changed_file.url = "ext:/root/a/file";
+    changed_file.changes.push_back(file_manager_private::CHANGE_TYPE_DELETE);
+  }
+  EXPECT_CALL(mock(),
+              DispatchEventToExtensionImpl(
+                  "ext", file_manager_private::OnDirectoryChanged::kEventName,
+                  MatchFileWatchEvent(event)));
+
+  event.event_type = file_manager_private::FILE_WATCH_EVENT_TYPE_CHANGED;
+  event.entry.additional_properties.SetString("fileSystemRoot", "ext:/");
+  event.entry.additional_properties.SetString("fileSystemName", "drivefs");
+  event.entry.additional_properties.SetString("fileFullPath", "/root/b");
+  event.entry.additional_properties.SetBoolean("fileIsDirectory", true);
+  event.changed_files =
+      std::make_unique<std::vector<file_manager_private::FileChange>>();
+  event.changed_files->emplace_back();
+  {
+    auto& changed_file = event.changed_files->back();
+    changed_file.url = "ext:/root/b/file";
+    changed_file.changes.push_back(
+        file_manager_private::CHANGE_TYPE_ADD_OR_UPDATE);
+  }
+  EXPECT_CALL(mock(),
+              DispatchEventToExtensionImpl(
+                  "ext", file_manager_private::OnDirectoryChanged::kEventName,
+                  MatchFileWatchEvent(event)));
+
+  std::vector<drivefs::mojom::FileChange> changes;
+  changes.emplace_back(base::FilePath("/root/a/file"),
+                       drivefs::mojom::FileChange::Type::kDelete);
+  changes.emplace_back(base::FilePath("/root/b/file"),
+                       drivefs::mojom::FileChange::Type::kCreate);
+  observer().OnFilesChanged(changes);
+}
+
+}  // namespace
+}  // namespace file_manager
diff --git a/chrome/browser/extensions/api/file_manager/event_router.cc b/chrome/browser/extensions/api/file_manager/event_router.cc
new file mode 100644
index 0000000000000..81eed862882c7
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/event_router.cc
@@ -0,0 +1,1095 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/event_router.h"
+
+#include <stddef.h>
+
+#include <memory>
+#include <set>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/command_line.h"
+#include "base/files/file_util.h"
+#include "base/macros.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "base/values.h"
+#include "chrome/browser/app_mode/app_mode_utils.h"
+#include "chrome/browser/chromeos/arc/arc_util.h"
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/open_util.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/browser/chromeos/login/lock/screen_locker.h"
+#include "chrome/browser/chromeos/login/ui/login_display_host.h"
+#include "chrome/browser/extensions/api/file_system/chrome_file_system_delegate.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/extensions/extension_util.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/common/chrome_switches.h"
+#include "chrome/common/pref_names.h"
+#include "chromeos/components/drivefs/drivefs_host.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
+#include "chromeos/disks/disk.h"
+#include "chromeos/login/login_state.h"
+#include "chromeos/network/network_handler.h"
+#include "chromeos/network/network_state_handler.h"
+#include "components/arc/intent_helper/arc_intent_helper_bridge.h"
+#include "components/drive/chromeos/file_system_interface.h"
+#include "components/drive/drive_pref_names.h"
+#include "components/drive/file_change.h"
+#include "components/drive/service/drive_service_interface.h"
+#include "components/prefs/pref_change_registrar.h"
+#include "components/prefs/pref_service.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/storage_partition.h"
+#include "extensions/browser/event_router.h"
+#include "extensions/browser/extension_host.h"
+#include "extensions/browser/extension_prefs.h"
+#include "storage/common/fileapi/file_system_types.h"
+#include "storage/common/fileapi/file_system_util.h"
+
+using chromeos::disks::Disk;
+using chromeos::disks::DiskMountManager;
+using chromeos::NetworkHandler;
+using content::BrowserThread;
+using drive::DriveIntegrationService;
+using drive::DriveIntegrationServiceFactory;
+using file_manager::util::EntryDefinition;
+using file_manager::util::FileDefinition;
+
+namespace file_manager_private = extensions::api::file_manager_private;
+
+namespace file_manager {
+namespace {
+
+// Frequency of sending onFileTransferUpdated.
+const int64_t kProgressEventFrequencyInMilliseconds = 1000;
+
+// Maximim size of detailed change info on directory change event. If the size
+// exceeds the maximum size, the detailed info is omitted and the force refresh
+// is kicked.
+const size_t kDirectoryChangeEventMaxDetailInfoSize = 1000;
+
+// This time(millisecond) is used for confirm following event exists.
+const int64_t kFileTransferEventDelayTimeInMilliseconds = 300;
+
+// Checks if the Recovery Tool is running. This is a temporary solution.
+// TODO(mtomasz): Replace with crbug.com/341902 solution.
+bool IsRecoveryToolRunning(Profile* profile) {
+  extensions::ExtensionPrefs* extension_prefs =
+      extensions::ExtensionPrefs::Get(profile);
+  if (!extension_prefs)
+    return false;
+
+  const std::string kRecoveryToolIds[] = {
+      "kkebgepbbgbcmghedmmdfcbdcodlkngh",  // Recovery tool staging
+      "jndclpdbaamdhonoechobihbbiimdgai"   // Recovery tool prod
+  };
+
+  for (size_t i = 0; i < arraysize(kRecoveryToolIds); ++i) {
+    const std::string extension_id = kRecoveryToolIds[i];
+    if (extension_prefs->IsExtensionRunning(extension_id))
+      return true;
+  }
+
+  return false;
+}
+
+// Sends an event named |event_name| with arguments |event_args| to extensions.
+void BroadcastEvent(Profile* profile,
+                    extensions::events::HistogramValue histogram_value,
+                    const std::string& event_name,
+                    std::unique_ptr<base::ListValue> event_args) {
+  extensions::EventRouter::Get(profile)->BroadcastEvent(
+      std::make_unique<extensions::Event>(histogram_value, event_name,
+                                          std::move(event_args)));
+}
+
+// Sends an event named |event_name| with arguments |event_args| to an extension
+// of |extention_id|.
+void DispatchEventToExtension(
+    Profile* profile,
+    const std::string& extension_id,
+    extensions::events::HistogramValue histogram_value,
+    const std::string& event_name,
+    std::unique_ptr<base::ListValue> event_args) {
+  extensions::EventRouter::Get(profile)->DispatchEventToExtension(
+      extension_id, std::make_unique<extensions::Event>(
+                        histogram_value, event_name, std::move(event_args)));
+}
+
+file_manager_private::MountCompletedStatus
+MountErrorToMountCompletedStatus(chromeos::MountError error) {
+  switch (error) {
+    case chromeos::MOUNT_ERROR_NONE:
+      return file_manager_private::MOUNT_COMPLETED_STATUS_SUCCESS;
+    case chromeos::MOUNT_ERROR_UNKNOWN:
+      return file_manager_private::MOUNT_COMPLETED_STATUS_ERROR_UNKNOWN;
+    case chromeos::MOUNT_ERROR_INTERNAL:
+      return file_manager_private::MOUNT_COMPLETED_STATUS_ERROR_INTERNAL;
+    case chromeos::MOUNT_ERROR_INVALID_ARGUMENT:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_INVALID_ARGUMENT;
+    case chromeos::MOUNT_ERROR_INVALID_PATH:
+      return file_manager_private::MOUNT_COMPLETED_STATUS_ERROR_INVALID_PATH;
+    case chromeos::MOUNT_ERROR_PATH_ALREADY_MOUNTED:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_PATH_ALREADY_MOUNTED;
+    case chromeos::MOUNT_ERROR_PATH_NOT_MOUNTED:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_PATH_NOT_MOUNTED;
+    case chromeos::MOUNT_ERROR_DIRECTORY_CREATION_FAILED:
+      return file_manager_private
+          ::MOUNT_COMPLETED_STATUS_ERROR_DIRECTORY_CREATION_FAILED;
+    case chromeos::MOUNT_ERROR_INVALID_MOUNT_OPTIONS:
+      return file_manager_private
+          ::MOUNT_COMPLETED_STATUS_ERROR_INVALID_MOUNT_OPTIONS;
+    case chromeos::MOUNT_ERROR_INVALID_UNMOUNT_OPTIONS:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_INVALID_UNMOUNT_OPTIONS;
+    case chromeos::MOUNT_ERROR_INSUFFICIENT_PERMISSIONS:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_INSUFFICIENT_PERMISSIONS;
+    case chromeos::MOUNT_ERROR_MOUNT_PROGRAM_NOT_FOUND:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_MOUNT_PROGRAM_NOT_FOUND;
+    case chromeos::MOUNT_ERROR_MOUNT_PROGRAM_FAILED:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_MOUNT_PROGRAM_FAILED;
+    case chromeos::MOUNT_ERROR_INVALID_DEVICE_PATH:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_INVALID_DEVICE_PATH;
+    case chromeos::MOUNT_ERROR_UNKNOWN_FILESYSTEM:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_UNKNOWN_FILESYSTEM;
+    case chromeos::MOUNT_ERROR_UNSUPPORTED_FILESYSTEM:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_UNSUPPORTED_FILESYSTEM;
+    case chromeos::MOUNT_ERROR_INVALID_ARCHIVE:
+      return file_manager_private::MOUNT_COMPLETED_STATUS_ERROR_INVALID_ARCHIVE;
+    // Not a real error.
+    case chromeos::MOUNT_ERROR_COUNT:
+      NOTREACHED();
+  }
+  NOTREACHED();
+  return file_manager_private::MOUNT_COMPLETED_STATUS_NONE;
+}
+
+file_manager_private::CopyProgressStatusType
+CopyProgressTypeToCopyProgressStatusType(
+    storage::FileSystemOperation::CopyProgressType type) {
+  switch (type) {
+    case storage::FileSystemOperation::BEGIN_COPY_ENTRY:
+      return file_manager_private::COPY_PROGRESS_STATUS_TYPE_BEGIN_COPY_ENTRY;
+    case storage::FileSystemOperation::END_COPY_ENTRY:
+      return file_manager_private::COPY_PROGRESS_STATUS_TYPE_END_COPY_ENTRY;
+    case storage::FileSystemOperation::PROGRESS:
+      return file_manager_private::COPY_PROGRESS_STATUS_TYPE_PROGRESS;
+    case storage::FileSystemOperation::ERROR_COPY_ENTRY:
+      return file_manager_private::COPY_PROGRESS_STATUS_TYPE_ERROR;
+  }
+  NOTREACHED();
+  return file_manager_private::COPY_PROGRESS_STATUS_TYPE_NONE;
+}
+
+file_manager_private::ChangeType ConvertChangeTypeFromDriveToApi(
+    drive::FileChange::ChangeType type) {
+  switch (type) {
+    case drive::FileChange::CHANGE_TYPE_ADD_OR_UPDATE:
+      return file_manager_private::CHANGE_TYPE_ADD_OR_UPDATE;
+    case drive::FileChange::CHANGE_TYPE_DELETE:
+      return file_manager_private::CHANGE_TYPE_DELETE;
+  }
+  NOTREACHED();
+  return file_manager_private::CHANGE_TYPE_ADD_OR_UPDATE;
+}
+
+std::string FileErrorToErrorName(base::File::Error error_code) {
+  namespace js = extensions::api::file_manager_private;
+  switch (error_code) {
+    case base::File::FILE_ERROR_NOT_FOUND:
+      return "NotFoundError";
+    case base::File::FILE_ERROR_INVALID_OPERATION:
+    case base::File::FILE_ERROR_EXISTS:
+    case base::File::FILE_ERROR_NOT_EMPTY:
+      return "InvalidModificationError";
+    case base::File::FILE_ERROR_NOT_A_DIRECTORY:
+    case base::File::FILE_ERROR_NOT_A_FILE:
+      return "TypeMismatchError";
+    case base::File::FILE_ERROR_ACCESS_DENIED:
+      return "NoModificationAllowedError";
+    case base::File::FILE_ERROR_FAILED:
+      return "InvalidStateError";
+    case base::File::FILE_ERROR_ABORT:
+      return "AbortError";
+    case base::File::FILE_ERROR_SECURITY:
+      return "SecurityError";
+    case base::File::FILE_ERROR_NO_SPACE:
+      return "QuotaExceededError";
+    case base::File::FILE_ERROR_INVALID_URL:
+      return "EncodingError";
+    default:
+      return "InvalidModificationError";
+  }
+}
+
+// Checks if we should send a progress event or not according to the
+// |last_time| of sending an event. If |always| is true, the function always
+// returns true. If the function returns true, the function also updates
+// |last_time|.
+bool ShouldSendProgressEvent(bool always, base::Time* last_time) {
+  const base::Time now = base::Time::Now();
+  const int64_t delta = (now - *last_time).InMilliseconds();
+  // delta < 0 may rarely happen if system clock is synced and rewinded.
+  // To be conservative, we don't skip in that case.
+  if (!always && 0 <= delta && delta < kProgressEventFrequencyInMilliseconds) {
+    return false;
+  } else {
+    *last_time = now;
+    return true;
+  }
+}
+
+// Obtains whether the Files app should handle the volume or not.
+bool ShouldShowNotificationForVolume(
+    Profile* profile,
+    const DeviceEventRouter& device_event_router,
+    const Volume& volume) {
+  if (volume.type() != VOLUME_TYPE_MTP &&
+      volume.type() != VOLUME_TYPE_REMOVABLE_DISK_PARTITION) {
+    return false;
+  }
+
+  if (device_event_router.is_resuming() || device_event_router.is_starting_up())
+    return false;
+
+  // Do not attempt to open File Manager while the login is in progress or
+  // the screen is locked or running in kiosk app mode and make sure the file
+  // manager is opened only for the active user.
+  if (chromeos::LoginDisplayHost::default_host() ||
+      chromeos::ScreenLocker::default_screen_locker() ||
+      chrome::IsRunningInForcedAppMode() ||
+      profile != ProfileManager::GetActiveUserProfile()) {
+    return false;
+  }
+
+  // Do not pop-up the File Manager, if the recovery tool is running.
+  if (IsRecoveryToolRunning(profile))
+    return false;
+
+  // If the disable-default-apps flag is on, the Files app is not opened
+  // automatically on device mount not to obstruct the manual test.
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kDisableDefaultApps)) {
+    return false;
+  }
+
+  // We suppress notifications about HP Elite USB-C Dock's internal storage.
+  // chrome-os-partner:58309.
+  // TODO(fukino): Remove this workaround when the root cause is fixed.
+  if (volume.type() == VOLUME_TYPE_REMOVABLE_DISK_PARTITION) {
+    const Disk* disk = DiskMountManager::GetInstance()->FindDiskBySourcePath(
+        volume.source_path().AsUTF8Unsafe());
+    if (disk && disk->vendor_id() == "0ea0" && disk->product_id() == "2272")
+      return false;
+  }
+
+  return true;
+}
+
+// Sub-part of the event router for handling device events.
+class DeviceEventRouterImpl : public DeviceEventRouter {
+ public:
+  explicit DeviceEventRouterImpl(Profile* profile) : profile_(profile) {}
+
+  // DeviceEventRouter overrides.
+  void OnDeviceEvent(file_manager_private::DeviceEventType type,
+                     const std::string& device_path) override {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    file_manager_private::DeviceEvent event;
+    event.type = type;
+    event.device_path = device_path;
+
+    BroadcastEvent(profile_,
+                   extensions::events::FILE_MANAGER_PRIVATE_ON_DEVICE_CHANGED,
+                   file_manager_private::OnDeviceChanged::kEventName,
+                   file_manager_private::OnDeviceChanged::Create(event));
+  }
+
+  // DeviceEventRouter overrides.
+  bool IsExternalStorageDisabled() override {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+    return profile_->GetPrefs()->GetBoolean(prefs::kExternalStorageDisabled);
+  }
+
+ private:
+  Profile* const profile_;
+
+  DISALLOW_COPY_AND_ASSIGN(DeviceEventRouterImpl);
+};
+
+class JobEventRouterImpl : public JobEventRouter {
+ public:
+  explicit JobEventRouterImpl(Profile* profile)
+      : JobEventRouter(base::TimeDelta::FromMilliseconds(
+            kFileTransferEventDelayTimeInMilliseconds)),
+        profile_(profile) {}
+
+ protected:
+  std::set<std::string> GetFileTransfersUpdateEventListenerExtensionIds()
+      override {
+    const extensions::EventListenerMap::ListenerList& listeners =
+        extensions::EventRouter::Get(profile_)
+            ->listeners()
+            .GetEventListenersByName(
+                file_manager_private::OnFileTransfersUpdated::kEventName);
+
+    std::set<std::string> extension_ids;
+
+    for (const auto& listener : listeners) {
+      extension_ids.insert(listener->extension_id());
+    }
+
+    return extension_ids;
+  }
+
+  GURL ConvertDrivePathToFileSystemUrl(
+      const base::FilePath& file_path,
+      const std::string& extension_id) override {
+    return file_manager::util::ConvertDrivePathToFileSystemUrl(
+        profile_, file_path, extension_id);
+  }
+
+  void DispatchEventToExtension(
+      const std::string& extension_id,
+      extensions::events::HistogramValue histogram_value,
+      const std::string& event_name,
+      std::unique_ptr<base::ListValue> event_args) override {
+    ::file_manager::DispatchEventToExtension(profile_, extension_id,
+                                             histogram_value, event_name,
+                                             std::move(event_args));
+  }
+
+ private:
+  Profile* const profile_;
+
+  DISALLOW_COPY_AND_ASSIGN(JobEventRouterImpl);
+};
+
+class DriveFsEventRouterImpl : public DriveFsEventRouter {
+ public:
+  explicit DriveFsEventRouterImpl(Profile* profile) : profile_(profile) {}
+
+ private:
+  std::set<std::string> GetEventListenerExtensionIds(
+      const std::string& event_name) override {
+    const extensions::EventListenerMap::ListenerList& listeners =
+        extensions::EventRouter::Get(profile_)
+            ->listeners()
+            .GetEventListenersByName(event_name);
+
+    std::set<std::string> extension_ids;
+
+    for (const auto& listener : listeners) {
+      extension_ids.insert(listener->extension_id());
+    }
+
+    return extension_ids;
+  }
+
+  GURL ConvertDrivePathToFileSystemUrl(
+      const base::FilePath& file_path,
+      const std::string& extension_id) override {
+    GURL url;
+    file_manager::util::ConvertAbsoluteFilePathToFileSystemUrl(
+        profile_,
+        base::FilePath(DriveIntegrationServiceFactory::FindForProfile(profile_)
+                           ->GetMountPointPath()
+                           .value() +
+                       file_path.value()),
+        extension_id, &url);
+    return url;
+  }
+
+  std::string GetDriveFileSystemName() override {
+    return DriveIntegrationServiceFactory::FindForProfile(profile_)
+        ->GetMountPointPath()
+        .BaseName()
+        .value();
+  }
+
+  void DispatchEventToExtension(
+      const std::string& extension_id,
+      extensions::events::HistogramValue histogram_value,
+      const std::string& event_name,
+      std::unique_ptr<base::ListValue> event_args) override {
+    extensions::EventRouter::Get(profile_)->DispatchEventToExtension(
+        extension_id, std::make_unique<extensions::Event>(
+                          histogram_value, event_name, std::move(event_args)));
+  }
+
+  Profile* const profile_;
+
+  DISALLOW_COPY_AND_ASSIGN(DriveFsEventRouterImpl);
+};
+
+}  // namespace
+
+EventRouter::EventRouter(Profile* profile)
+    : pref_change_registrar_(std::make_unique<PrefChangeRegistrar>()),
+      profile_(profile),
+      device_event_router_(std::make_unique<DeviceEventRouterImpl>(profile)),
+      job_event_router_(std::make_unique<JobEventRouterImpl>(profile)),
+      drivefs_event_router_(std::make_unique<DriveFsEventRouterImpl>(profile)),
+      dispatch_directory_change_event_impl_(
+          base::Bind(&EventRouter::DispatchDirectoryChangeEventImpl,
+                     base::Unretained(this))),
+      weak_factory_(this) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  ObserveEvents();
+}
+
+EventRouter::~EventRouter() = default;
+
+void EventRouter::OnIntentFiltersUpdated() {
+  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
+  BroadcastEvent(profile_,
+                 extensions::events::FILE_MANAGER_PRIVATE_ON_APPS_UPDATED,
+                 file_manager_private::OnAppsUpdated::kEventName,
+                 file_manager_private::OnAppsUpdated::Create());
+}
+
+void EventRouter::Shutdown() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  auto* intent_helper =
+      arc::ArcIntentHelperBridge::GetForBrowserContext(profile_);
+  if (intent_helper)
+    intent_helper->RemoveObserver(this);
+
+  chromeos::system::TimezoneSettings::GetInstance()->RemoveObserver(this);
+
+  DLOG_IF(WARNING, !file_watchers_.empty())
+      << "Not all file watchers are "
+      << "removed. This can happen when the Files app is open during shutdown.";
+  file_watchers_.clear();
+  if (!profile_) {
+    NOTREACHED();
+    return;
+  }
+
+  pref_change_registrar_->RemoveAll();
+
+  if (NetworkHandler::IsInitialized()) {
+    NetworkHandler::Get()->network_state_handler()->RemoveObserver(this,
+                                                                   FROM_HERE);
+  }
+
+  DriveIntegrationService* const integration_service =
+      DriveIntegrationServiceFactory::FindForProfile(profile_);
+  if (integration_service) {
+    if (integration_service->GetDriveFsHost()) {
+      integration_service->GetDriveFsHost()->RemoveObserver(
+          drivefs_event_router_.get());
+    } else {
+      integration_service->file_system()->RemoveObserver(this);
+      integration_service->drive_service()->RemoveObserver(this);
+      integration_service->job_list()->RemoveObserver(job_event_router_.get());
+    }
+  }
+
+  VolumeManager* const volume_manager = VolumeManager::Get(profile_);
+  if (volume_manager) {
+    volume_manager->RemoveObserver(this);
+    volume_manager->RemoveObserver(device_event_router_.get());
+  }
+
+  chromeos::PowerManagerClient* const power_manager_client =
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
+  power_manager_client->RemoveObserver(device_event_router_.get());
+
+  profile_ = nullptr;
+}
+
+void EventRouter::ObserveEvents() {
+  if (!profile_) {
+    NOTREACHED();
+    return;
+  }
+  if (!chromeos::LoginState::IsInitialized() ||
+      !chromeos::LoginState::Get()->IsUserLoggedIn()) {
+    return;
+  }
+
+  // Ignore device events for the first few seconds.
+  device_event_router_->Startup();
+
+  // VolumeManager's construction triggers DriveIntegrationService's
+  // construction, so it is necessary to call VolumeManager's Get before
+  // accessing DriveIntegrationService.
+  VolumeManager* const volume_manager = VolumeManager::Get(profile_);
+  if (volume_manager) {
+    volume_manager->AddObserver(this);
+    volume_manager->AddObserver(device_event_router_.get());
+  }
+
+  chromeos::PowerManagerClient* const power_manager_client =
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
+  power_manager_client->AddObserver(device_event_router_.get());
+
+  DriveIntegrationService* const integration_service =
+      DriveIntegrationServiceFactory::FindForProfile(profile_);
+  if (integration_service) {
+    if (integration_service->GetDriveFsHost()) {
+      integration_service->GetDriveFsHost()->AddObserver(
+          drivefs_event_router_.get());
+    } else {
+      integration_service->drive_service()->AddObserver(this);
+      integration_service->file_system()->AddObserver(this);
+      integration_service->job_list()->AddObserver(job_event_router_.get());
+    }
+  }
+
+  if (NetworkHandler::IsInitialized()) {
+    NetworkHandler::Get()->network_state_handler()->AddObserver(this,
+                                                                FROM_HERE);
+  }
+
+  pref_change_registrar_->Init(profile_->GetPrefs());
+  base::Closure callback =
+      base::Bind(&EventRouter::OnFileManagerPrefsChanged,
+                 weak_factory_.GetWeakPtr());
+  pref_change_registrar_->Add(drive::prefs::kDisableDriveOverCellular,
+                              callback);
+  pref_change_registrar_->Add(drive::prefs::kDisableDriveHostedFiles, callback);
+  pref_change_registrar_->Add(drive::prefs::kDisableDrive, callback);
+  pref_change_registrar_->Add(prefs::kSearchSuggestEnabled, callback);
+  pref_change_registrar_->Add(prefs::kUse24HourClock, callback);
+
+  chromeos::system::TimezoneSettings::GetInstance()->AddObserver(this);
+
+  auto* intent_helper =
+      arc::ArcIntentHelperBridge::GetForBrowserContext(profile_);
+  if (intent_helper)
+    intent_helper->AddObserver(this);
+}
+
+// File watch setup routines.
+void EventRouter::AddFileWatch(const base::FilePath& local_path,
+                               const base::FilePath& virtual_path,
+                               const std::string& extension_id,
+                               const BoolCallback& callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(!callback.is_null());
+
+  base::FilePath watch_path = local_path;
+  bool is_on_drive = drive::util::IsUnderDriveMountPoint(watch_path);
+  // Tweak watch path for remote sources - we need to drop leading /special
+  // directory from there in order to be able to pair these events with
+  // their change notifications.
+  if (is_on_drive)
+    watch_path = drive::util::ExtractDrivePath(watch_path);
+
+  auto iter = file_watchers_.find(watch_path);
+  if (iter == file_watchers_.end()) {
+    std::unique_ptr<FileWatcher> watcher(new FileWatcher(virtual_path));
+    watcher->AddExtension(extension_id);
+
+    if (is_on_drive) {
+      // For Drive, file watching is done via OnDirectoryChanged().
+      base::ThreadTaskRunnerHandle::Get()->PostTask(
+          FROM_HERE, base::BindOnce(callback, true));
+    } else {
+      // For local files, start watching using FileWatcher.
+      watcher->WatchLocalFile(
+          watch_path,
+          base::Bind(&EventRouter::HandleFileWatchNotification,
+                     weak_factory_.GetWeakPtr(),
+                     static_cast<drive::FileChange*>(nullptr)),
+          callback);
+    }
+
+    file_watchers_[watch_path] = std::move(watcher);
+  } else {
+    iter->second->AddExtension(extension_id);
+    base::ThreadTaskRunnerHandle::Get()->PostTask(
+        FROM_HERE, base::BindOnce(callback, true));
+  }
+}
+
+void EventRouter::RemoveFileWatch(const base::FilePath& local_path,
+                                  const std::string& extension_id) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  base::FilePath watch_path = local_path;
+  // Tweak watch path for remote sources - we need to drop leading /special
+  // directory from there in order to be able to pair these events with
+  // their change notifications.
+  if (drive::util::IsUnderDriveMountPoint(watch_path)) {
+    watch_path = drive::util::ExtractDrivePath(watch_path);
+  }
+  auto iter = file_watchers_.find(watch_path);
+  if (iter == file_watchers_.end())
+    return;
+  // Remove the watcher if |watch_path| is no longer watched by any extensions.
+  iter->second->RemoveExtension(extension_id);
+  if (iter->second->GetExtensionIds().empty())
+    file_watchers_.erase(iter);
+}
+
+void EventRouter::OnCopyCompleted(int copy_id,
+                                  const GURL& source_url,
+                                  const GURL& destination_url,
+                                  base::File::Error error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  file_manager_private::CopyProgressStatus status;
+  if (error == base::File::FILE_OK) {
+    // Send success event.
+    status.type = file_manager_private::COPY_PROGRESS_STATUS_TYPE_SUCCESS;
+    status.source_url = std::make_unique<std::string>(source_url.spec());
+    status.destination_url =
+        std::make_unique<std::string>(destination_url.spec());
+  } else {
+    // Send error event.
+    status.type = file_manager_private::COPY_PROGRESS_STATUS_TYPE_ERROR;
+    status.error = std::make_unique<std::string>(FileErrorToErrorName(error));
+  }
+
+  BroadcastEvent(profile_,
+                 extensions::events::FILE_MANAGER_PRIVATE_ON_COPY_PROGRESS,
+                 file_manager_private::OnCopyProgress::kEventName,
+                 file_manager_private::OnCopyProgress::Create(copy_id, status));
+}
+
+void EventRouter::OnCopyProgress(
+    int copy_id,
+    storage::FileSystemOperation::CopyProgressType type,
+    const GURL& source_url,
+    const GURL& destination_url,
+    int64_t size) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  file_manager_private::CopyProgressStatus status;
+  status.type = CopyProgressTypeToCopyProgressStatusType(type);
+  status.source_url = std::make_unique<std::string>(source_url.spec());
+  if (type == storage::FileSystemOperation::END_COPY_ENTRY ||
+      type == storage::FileSystemOperation::ERROR_COPY_ENTRY)
+    status.destination_url =
+        std::make_unique<std::string>(destination_url.spec());
+  if (type == storage::FileSystemOperation::ERROR_COPY_ENTRY)
+    status.error = std::make_unique<std::string>(
+        FileErrorToErrorName(base::File::FILE_ERROR_FAILED));
+  if (type == storage::FileSystemOperation::PROGRESS)
+    status.size = std::make_unique<double>(size);
+
+  // Discard error progress since current JS code cannot handle this properly.
+  // TODO(yawano): Remove this after JS side is implemented correctly.
+  if (type == storage::FileSystemOperation::ERROR_COPY_ENTRY)
+    return;
+
+  // Should not skip events other than TYPE_PROGRESS.
+  const bool always =
+      status.type != file_manager_private::COPY_PROGRESS_STATUS_TYPE_PROGRESS;
+  if (!ShouldSendProgressEvent(always, &last_copy_progress_event_))
+    return;
+
+  BroadcastEvent(profile_,
+                 extensions::events::FILE_MANAGER_PRIVATE_ON_COPY_PROGRESS,
+                 file_manager_private::OnCopyProgress::kEventName,
+                 file_manager_private::OnCopyProgress::Create(copy_id, status));
+}
+
+void EventRouter::OnWatcherManagerNotification(
+    const storage::FileSystemURL& file_system_url,
+    const std::string& extension_id,
+    storage::WatcherManager::ChangeType /* change_type */) {
+  std::vector<std::string> extension_ids;
+  extension_ids.push_back(extension_id);
+
+  DispatchDirectoryChangeEvent(file_system_url.virtual_path(), nullptr,
+                               false /* error */, extension_ids);
+}
+
+void EventRouter::DefaultNetworkChanged(const chromeos::NetworkState* network) {
+  if (!profile_ || !extensions::EventRouter::Get(profile_)) {
+    NOTREACHED();
+    return;
+  }
+
+  BroadcastEvent(
+      profile_, extensions::events::
+                    FILE_MANAGER_PRIVATE_ON_DRIVE_CONNECTION_STATUS_CHANGED,
+      file_manager_private::OnDriveConnectionStatusChanged::kEventName,
+      file_manager_private::OnDriveConnectionStatusChanged::Create());
+}
+
+void EventRouter::TimezoneChanged(const icu::TimeZone& timezone) {
+  OnFileManagerPrefsChanged();
+}
+
+void EventRouter::OnFileManagerPrefsChanged() {
+  if (!profile_ || !extensions::EventRouter::Get(profile_)) {
+    NOTREACHED();
+    return;
+  }
+
+  BroadcastEvent(
+      profile_, extensions::events::FILE_MANAGER_PRIVATE_ON_PREFERENCES_CHANGED,
+      file_manager_private::OnPreferencesChanged::kEventName,
+      file_manager_private::OnPreferencesChanged::Create());
+}
+
+void EventRouter::OnDirectoryChanged(const base::FilePath& drive_path) {
+  HandleFileWatchNotification(nullptr, drive_path, false);
+}
+
+void EventRouter::OnFileChanged(const drive::FileChange& changed_files) {
+  // In this method, we convert changed_files to a map which can be handled by
+  // HandleFileWatchNotification.
+  //
+  // e.g.
+  // /a/b DIRECTORY:DELETE
+  //
+  // map[/a] = /a/b DIRECTORY:DELETE
+  // map[/a/b] = /a/b DIRECTORY:DELETE
+  //
+  // We used the key of map to match the watched directories of file watchers.
+  typedef std::map<base::FilePath, drive::FileChange> FileChangeMap;
+  typedef drive::FileChange::ChangeList::List FileChangeList;
+
+  FileChangeMap map;
+  const drive::FileChange::Map& changed_file_map = changed_files.map();
+  for (auto const& file_change_key_value : changed_file_map) {
+    // Check whether the FileChangeList contains directory deletion.
+    bool contains_directory_deletion = false;
+    const FileChangeList list = file_change_key_value.second.list();
+    for (drive::FileChange::Change const& change : list) {
+      if (change.IsDirectory() && change.IsDelete()) {
+        contains_directory_deletion = true;
+        break;
+      }
+    }
+
+    const base::FilePath& path = file_change_key_value.first;
+    map[path.DirName()].Update(path, file_change_key_value.second);
+
+    // For deletion of a directory, onFileChanged gets different changed_files.
+    // We solve the difference here.
+    //
+    // /a/b is watched, and /a is deleted from Drive (e.g. from Web).
+    // 1. /a/b DELETE:DIRECTORY
+    // 2. /a DELETE:DIRECTORY
+    //
+    // /a/b is watched, and /a is deleted from the Files app.
+    // 1. /a DELETE:DIRECTORY
+    if (contains_directory_deletion) {
+      // Expand the deleted directory path with watched paths.
+      for (auto file_watchers_it = file_watchers_.lower_bound(path);
+           file_watchers_it != file_watchers_.end(); ++file_watchers_it) {
+        if (path == file_watchers_it->first ||
+            path.IsParent(file_watchers_it->first)) {
+          map[file_watchers_it->first].Update(
+              file_watchers_it->first,
+              drive::FileChange::FileType::FILE_TYPE_DIRECTORY,
+              drive::FileChange::ChangeType::CHANGE_TYPE_DELETE);
+        }
+      }
+    }
+  }
+
+  for (auto const& file_change_key_value : map) {
+    HandleFileWatchNotification(&(file_change_key_value.second),
+                                file_change_key_value.first, false);
+  }
+}
+
+void EventRouter::OnDriveSyncError(drive::file_system::DriveSyncErrorType type,
+                                   const base::FilePath& drive_path) {
+  file_manager_private::DriveSyncErrorEvent event;
+  switch (type) {
+    case drive::file_system::DRIVE_SYNC_ERROR_DELETE_WITHOUT_PERMISSION:
+      event.type =
+          file_manager_private::DRIVE_SYNC_ERROR_TYPE_DELETE_WITHOUT_PERMISSION;
+      break;
+    case drive::file_system::DRIVE_SYNC_ERROR_SERVICE_UNAVAILABLE:
+      event.type =
+          file_manager_private::DRIVE_SYNC_ERROR_TYPE_SERVICE_UNAVAILABLE;
+      break;
+    case drive::file_system::DRIVE_SYNC_ERROR_NO_SERVER_SPACE:
+      event.type = file_manager_private::DRIVE_SYNC_ERROR_TYPE_NO_SERVER_SPACE;
+      break;
+    case drive::file_system::DRIVE_SYNC_ERROR_MISC:
+      event.type =
+          file_manager_private::DRIVE_SYNC_ERROR_TYPE_MISC;
+      break;
+  }
+  event.file_url = util::ConvertDrivePathToFileSystemUrl(
+      profile_, drive_path, kFileManagerAppId).spec();
+  BroadcastEvent(profile_,
+                 extensions::events::FILE_MANAGER_PRIVATE_ON_DRIVE_SYNC_ERROR,
+                 file_manager_private::OnDriveSyncError::kEventName,
+                 file_manager_private::OnDriveSyncError::Create(event));
+}
+
+void EventRouter::OnRefreshTokenInvalid() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  // Raise a DriveConnectionStatusChanged event to notify the status offline.
+  BroadcastEvent(
+      profile_, extensions::events::
+                    FILE_MANAGER_PRIVATE_ON_DRIVE_CONNECTION_STATUS_CHANGED,
+      file_manager_private::OnDriveConnectionStatusChanged::kEventName,
+      file_manager_private::OnDriveConnectionStatusChanged::Create());
+}
+
+void EventRouter::OnReadyToSendRequests() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  // Raise a DriveConnectionStatusChanged event to notify the status online.
+  BroadcastEvent(
+      profile_, extensions::events::
+                    FILE_MANAGER_PRIVATE_ON_DRIVE_CONNECTION_STATUS_CHANGED,
+      file_manager_private::OnDriveConnectionStatusChanged::kEventName,
+      file_manager_private::OnDriveConnectionStatusChanged::Create());
+}
+
+void EventRouter::HandleFileWatchNotification(const drive::FileChange* list,
+                                              const base::FilePath& local_path,
+                                              bool got_error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  auto iter = file_watchers_.find(local_path);
+  if (iter == file_watchers_.end()) {
+    return;
+  }
+
+  if (list && list->size() > kDirectoryChangeEventMaxDetailInfoSize) {
+    // Removes the detailed information, if the list size is more than
+    // kDirectoryChangeEventMaxDetailInfoSize, since passing large list
+    // and processing it may cause more itme.
+    // This will be invoked full-refresh in the Files app.
+    list = nullptr;
+  }
+
+  DispatchDirectoryChangeEvent(iter->second->virtual_path(),
+                               list,
+                               got_error,
+                               iter->second->GetExtensionIds());
+}
+
+void EventRouter::DispatchDirectoryChangeEvent(
+    const base::FilePath& virtual_path,
+    const drive::FileChange* list,
+    bool got_error,
+    const std::vector<std::string>& extension_ids) {
+  dispatch_directory_change_event_impl_.Run(virtual_path, list, got_error,
+                                            extension_ids);
+}
+
+void EventRouter::DispatchDirectoryChangeEventImpl(
+    const base::FilePath& virtual_path,
+    const drive::FileChange* list,
+    bool got_error,
+    const std::vector<std::string>& extension_ids) {
+  if (!profile_) {
+    NOTREACHED();
+    return;
+  }
+  linked_ptr<drive::FileChange> changes;
+  if (list)
+    changes.reset(new drive::FileChange(*list));  // Copy
+
+  for (size_t i = 0; i < extension_ids.size(); ++i) {
+    std::string* extension_id = new std::string(extension_ids[i]);
+
+    FileDefinition file_definition;
+    file_definition.virtual_path = virtual_path;
+    // TODO(mtomasz): Add support for watching files in File System Provider
+    // API.
+    file_definition.is_directory = true;
+
+    file_manager::util::ConvertFileDefinitionToEntryDefinition(
+        profile_,
+        *extension_id,
+        file_definition,
+        base::Bind(
+            &EventRouter::DispatchDirectoryChangeEventWithEntryDefinition,
+            weak_factory_.GetWeakPtr(),
+            changes,
+            base::Owned(extension_id),
+            got_error));
+  }
+}
+
+void EventRouter::DispatchDirectoryChangeEventWithEntryDefinition(
+    const linked_ptr<drive::FileChange> list,
+    const std::string* extension_id,
+    bool watcher_error,
+    const EntryDefinition& entry_definition) {
+  // TODO(mtomasz): Add support for watching files in File System Provider API.
+  if (entry_definition.error != base::File::FILE_OK ||
+      !entry_definition.is_directory) {
+    DVLOG(1) << "Unable to dispatch event because resolving the directory "
+             << "entry definition failed.";
+    return;
+  }
+
+  file_manager_private::FileWatchEvent event;
+  event.event_type = watcher_error
+      ? file_manager_private::FILE_WATCH_EVENT_TYPE_ERROR
+      : file_manager_private::FILE_WATCH_EVENT_TYPE_CHANGED;
+
+  // Detailed information is available.
+  if (list.get()) {
+    event.changed_files =
+        std::make_unique<std::vector<file_manager_private::FileChange>>();
+
+    if (list->map().empty())
+      return;
+
+    for (drive::FileChange::Map::const_iterator it = list->map().begin();
+         it != list->map().end();
+         it++) {
+      file_manager_private::FileChange change_list;
+
+      GURL url = util::ConvertDrivePathToFileSystemUrl(
+          profile_, it->first, *extension_id);
+      change_list.url = url.spec();
+
+      for (drive::FileChange::ChangeList::List::const_iterator change =
+               it->second.list().begin();
+           change != it->second.list().end();
+           change++) {
+        change_list.changes.push_back(
+            ConvertChangeTypeFromDriveToApi(change->change()));
+      }
+
+      event.changed_files->push_back(std::move(change_list));
+    }
+  }
+
+  event.entry.additional_properties.SetString(
+      "fileSystemName", entry_definition.file_system_name);
+  event.entry.additional_properties.SetString(
+      "fileSystemRoot", entry_definition.file_system_root_url);
+  event.entry.additional_properties.SetString(
+      "fileFullPath", "/" + entry_definition.full_path.value());
+  event.entry.additional_properties.SetBoolean("fileIsDirectory",
+                                               entry_definition.is_directory);
+
+  DispatchEventToExtension(
+      profile_, *extension_id,
+      extensions::events::FILE_MANAGER_PRIVATE_ON_DIRECTORY_CHANGED,
+      file_manager_private::OnDirectoryChanged::kEventName,
+      file_manager_private::OnDirectoryChanged::Create(event));
+}
+
+void EventRouter::OnDiskAdded(const Disk& disk, bool mounting) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // Do nothing.
+}
+
+void EventRouter::OnDiskRemoved(const Disk& disk) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // Do nothing.
+}
+
+void EventRouter::OnDeviceAdded(const std::string& device_path) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // Do nothing.
+}
+
+void EventRouter::OnDeviceRemoved(const std::string& device_path) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // Do nothing.
+}
+
+void EventRouter::OnVolumeMounted(chromeos::MountError error_code,
+                                  const Volume& volume) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // profile_ is NULL if ShutdownOnUIThread() is called earlier. This can
+  // happen at shutdown. This should be removed after removing Drive mounting
+  // code in addMount. (addMount -> OnFileSystemMounted -> OnVolumeMounted is
+  // the only path to come here after Shutdown is called).
+  if (!profile_)
+    return;
+
+  DispatchMountCompletedEvent(
+      file_manager_private::MOUNT_COMPLETED_EVENT_TYPE_MOUNT, error_code,
+      volume);
+
+  // TODO(mtomasz): Move VolumeManager and part of the event router outside of
+  // file_manager, so there is no dependency between File System API and the
+  // file_manager code.
+  extensions::file_system_api::DispatchVolumeListChangeEvent(profile_);
+}
+
+void EventRouter::OnVolumeUnmounted(chromeos::MountError error_code,
+                                    const Volume& volume) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DispatchMountCompletedEvent(
+      file_manager_private::MOUNT_COMPLETED_EVENT_TYPE_UNMOUNT, error_code,
+      volume);
+}
+
+void EventRouter::DispatchMountCompletedEvent(
+    file_manager_private::MountCompletedEventType event_type,
+    chromeos::MountError error,
+    const Volume& volume) {
+  // Build an event object.
+  file_manager_private::MountCompletedEvent event;
+  event.event_type = event_type;
+  event.status = MountErrorToMountCompletedStatus(error);
+  util::VolumeToVolumeMetadata(profile_, volume, &event.volume_metadata);
+  event.should_notify =
+      ShouldShowNotificationForVolume(profile_, *device_event_router_, volume);
+  BroadcastEvent(profile_,
+                 extensions::events::FILE_MANAGER_PRIVATE_ON_MOUNT_COMPLETED,
+                 file_manager_private::OnMountCompleted::kEventName,
+                 file_manager_private::OnMountCompleted::Create(event));
+}
+
+void EventRouter::OnFormatStarted(const std::string& device_path,
+                                  bool success) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // Do nothing.
+}
+
+void EventRouter::OnFormatCompleted(const std::string& device_path,
+                                    bool success) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // Do nothing.
+}
+
+void EventRouter::OnRenameStarted(const std::string& device_path,
+                                  bool success) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // Do nothing.
+}
+
+void EventRouter::OnRenameCompleted(const std::string& device_path,
+                                    bool success) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // Do nothing.
+}
+
+void EventRouter::SetDispatchDirectoryChangeEventImplForTesting(
+    const DispatchDirectoryChangeEventImplCallback& callback) {
+  dispatch_directory_change_event_impl_ = callback;
+}
+
+base::WeakPtr<EventRouter> EventRouter::GetWeakPtr() {
+  return weak_factory_.GetWeakPtr();
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/extensions/api/file_manager/event_router.h b/chrome/browser/extensions/api/file_manager/event_router.h
new file mode 100644
index 0000000000000..1714bd0385bdd
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/event_router.h
@@ -0,0 +1,237 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_EVENT_ROUTER_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_EVENT_ROUTER_H_
+
+#include <stdint.h>
+
+#include <map>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/compiler_specific.h"
+#include "base/files/file_path_watcher.h"
+#include "base/macros.h"
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/extensions/api/file_manager/device_event_router.h"
+#include "chrome/browser/extensions/api/file_manager/drivefs_event_router.h"
+#include "chrome/browser/extensions/api/file_manager/job_event_router.h"
+#include "chrome/browser/file_manager/file_watcher.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/browser/file_manager/volume_manager_observer.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "chromeos/disks/disk_mount_manager.h"
+#include "chromeos/network/network_state_handler_observer.h"
+#include "chromeos/settings/timezone_settings.h"
+#include "components/arc/arc_service_manager.h"
+#include "components/arc/intent_helper/arc_intent_helper_observer.h"
+#include "components/drive/chromeos/file_system_observer.h"
+#include "components/drive/chromeos/sync_client.h"
+#include "components/drive/service/drive_service_interface.h"
+#include "components/keyed_service/core/keyed_service.h"
+#include "storage/browser/fileapi/file_system_operation.h"
+
+class PrefChangeRegistrar;
+class Profile;
+
+using file_manager::util::EntryDefinition;
+
+namespace chromeos {
+class NetworkState;
+}
+
+namespace drive {
+class FileChange;
+}
+
+namespace file_manager {
+
+// Monitors changes in disk mounts, network connection state and preferences
+// affecting File Manager. Dispatches appropriate File Browser events.
+class EventRouter : public KeyedService,
+                    public chromeos::NetworkStateHandlerObserver,
+                    public chromeos::system::TimezoneSettings::Observer,
+                    public drive::FileSystemObserver,
+                    public drive::DriveServiceObserver,
+                    public VolumeManagerObserver,
+                    public arc::ArcIntentHelperObserver {
+ public:
+  typedef base::Callback<void(const base::FilePath& virtual_path,
+                              const drive::FileChange* list,
+                              bool got_error,
+                              const std::vector<std::string>& extension_ids)>
+      DispatchDirectoryChangeEventImplCallback;
+
+  explicit EventRouter(Profile* profile);
+  ~EventRouter() override;
+
+  // arc::ArcIntentHelperObserver overrides.
+  void OnIntentFiltersUpdated() override;
+
+  // KeyedService overrides.
+  void Shutdown() override;
+
+  typedef base::Callback<void(bool success)> BoolCallback;
+
+  // Adds a file watch at |local_path|, associated with |virtual_path|, for
+  // an extension with |extension_id|.
+  //
+  // |callback| will be called with true on success, or false on failure.
+  // |callback| must not be null.
+  //
+  // Obsolete. Used as fallback for files which backends do not implement the
+  // storage::WatcherManager interface.
+  void AddFileWatch(const base::FilePath& local_path,
+                    const base::FilePath& virtual_path,
+                    const std::string& extension_id,
+                    const BoolCallback& callback);
+
+  // Removes a file watch at |local_path| for an extension with |extension_id|.
+  //
+  // Obsolete. Used as fallback for files which backends do not implement the
+  // storage::WatcherManager interface.
+  void RemoveFileWatch(const base::FilePath& local_path,
+                       const std::string& extension_id);
+
+  // Called when a copy task is completed.
+  void OnCopyCompleted(
+      int copy_id, const GURL& source_url, const GURL& destination_url,
+      base::File::Error error);
+
+  // Called when a copy task progress is updated.
+  void OnCopyProgress(int copy_id,
+                      storage::FileSystemOperation::CopyProgressType type,
+                      const GURL& source_url,
+                      const GURL& destination_url,
+                      int64_t size);
+
+  // Called when a notification from a watcher manager arrives.
+  void OnWatcherManagerNotification(
+      const storage::FileSystemURL& file_system_url,
+      const std::string& extension_id,
+      storage::WatcherManager::ChangeType change_type);
+
+  // chromeos::NetworkStateHandlerObserver overrides.
+  void DefaultNetworkChanged(const chromeos::NetworkState* network) override;
+
+  // chromeos::system::TimezoneSettings::Observer overrides.
+  void TimezoneChanged(const icu::TimeZone& timezone) override;
+
+  // drive::DriveServiceObserver overrides.
+  void OnRefreshTokenInvalid() override;
+  void OnReadyToSendRequests() override;
+
+  // drive::FileSystemObserver overrides.
+  void OnDirectoryChanged(const base::FilePath& drive_path) override;
+  void OnFileChanged(const drive::FileChange& changed_files) override;
+  void OnDriveSyncError(drive::file_system::DriveSyncErrorType type,
+                        const base::FilePath& drive_path) override;
+
+  // VolumeManagerObserver overrides.
+  void OnDiskAdded(const chromeos::disks::Disk& disk, bool mounting) override;
+  void OnDiskRemoved(const chromeos::disks::Disk& disk) override;
+  void OnDeviceAdded(const std::string& device_path) override;
+  void OnDeviceRemoved(const std::string& device_path) override;
+  void OnVolumeMounted(chromeos::MountError error_code,
+                       const Volume& volume) override;
+  void OnVolumeUnmounted(chromeos::MountError error_code,
+                         const Volume& volume) override;
+  void OnFormatStarted(const std::string& device_path, bool success) override;
+  void OnFormatCompleted(const std::string& device_path, bool success) override;
+  void OnRenameStarted(const std::string& device_path, bool success) override;
+  void OnRenameCompleted(const std::string& device_path, bool success) override;
+  // Set custom dispatch directory change event implementation for testing.
+  void SetDispatchDirectoryChangeEventImplForTesting(
+      const DispatchDirectoryChangeEventImplCallback& callback);
+
+  // Returns a weak pointer for the event router.
+  base::WeakPtr<EventRouter> GetWeakPtr();
+
+ private:
+  // Starts observing file system change events.
+  void ObserveEvents();
+
+  // Called when prefs related to file manager change.
+  void OnFileManagerPrefsChanged();
+
+  // Process file watch notifications.
+  void HandleFileWatchNotification(const drive::FileChange* list,
+                                   const base::FilePath& path,
+                                   bool got_error);
+
+  // Sends directory change event.
+  void DispatchDirectoryChangeEvent(
+      const base::FilePath& path,
+      const drive::FileChange* list,
+      bool got_error,
+      const std::vector<std::string>& extension_ids);
+
+  // Default implementation of DispatchDirectoryChangeEvent.
+  void DispatchDirectoryChangeEventImpl(
+      const base::FilePath& path,
+      const drive::FileChange* list,
+      bool got_error,
+      const std::vector<std::string>& extension_ids);
+
+  // Sends directory change event, after converting the file definition to entry
+  // definition.
+  void DispatchDirectoryChangeEventWithEntryDefinition(
+      const linked_ptr<drive::FileChange> list,
+      const std::string* extension_id,
+      bool watcher_error,
+      const EntryDefinition& entry_definition);
+
+  // Dispatches the mount completed event.
+  void DispatchMountCompletedEvent(
+      extensions::api::file_manager_private::MountCompletedEventType event_type,
+      chromeos::MountError error,
+      const Volume& volume);
+
+  // If needed, opens a file manager window for the removable device mounted at
+  // |mount_path|. Disk.mount_path() is empty, since it is being filled out
+  // after calling notifying observers by DiskMountManager.
+  void ShowRemovableDeviceInFileManager(VolumeType type,
+                                        const base::FilePath& mount_path);
+
+  // Sends onFileTransferUpdate event right now if |immediate| is set. Otherwise
+  // it refrains from sending for a short while, and after that it sends the
+  // most recently scheduled event once.
+  // The delay is for waiting subsequent 'added' events to come after the first
+  // one when multiple tasks are added. This way, we can avoid frequent UI
+  // update caused by differences between singular and plural cases.
+  void ScheduleDriveFileTransferEvent(const drive::JobInfo& job_info,
+                                      const std::string& status,
+                                      bool immediate);
+
+  // Sends the most recently scheduled onFileTransferUpdated event to
+  // extensions.
+  // This is used for implementing ScheduledDriveFileTransferEvent().
+  void SendDriveFileTransferEvent();
+
+  base::Time last_copy_progress_event_;
+
+  std::map<base::FilePath, std::unique_ptr<FileWatcher>> file_watchers_;
+  std::unique_ptr<PrefChangeRegistrar> pref_change_registrar_;
+  Profile* profile_;
+
+  std::unique_ptr<DeviceEventRouter> device_event_router_;
+  std::unique_ptr<JobEventRouter> job_event_router_;
+  std::unique_ptr<DriveFsEventRouter> drivefs_event_router_;
+
+  DispatchDirectoryChangeEventImplCallback
+      dispatch_directory_change_event_impl_;
+
+  // Note: This should remain the last member so it'll be destroyed and
+  // invalidate the weak pointers before any other members are destroyed.
+  base::WeakPtrFactory<EventRouter> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(EventRouter);
+};
+
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_EVENT_ROUTER_H_
diff --git a/chrome/browser/extensions/api/file_manager/event_router_factory.cc b/chrome/browser/extensions/api/file_manager/event_router_factory.cc
new file mode 100644
index 0000000000000..253997c1a549f
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/event_router_factory.cc
@@ -0,0 +1,62 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/event_router_factory.h"
+
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/extensions/api/file_manager/event_router.h"
+#include "chrome/browser/file_manager/volume_manager_factory.h"
+#include "chrome/browser/profiles/incognito_helpers.h"
+#include "chrome/browser/profiles/profile.h"
+#include "components/arc/intent_helper/arc_intent_helper_bridge.h"
+#include "components/keyed_service/content/browser_context_dependency_manager.h"
+#include "extensions/browser/extension_system_provider.h"
+#include "extensions/browser/extensions_browser_client.h"
+
+namespace file_manager {
+
+// static
+EventRouter* EventRouterFactory::GetForProfile(Profile* profile) {
+  return static_cast<EventRouter*>(
+      GetInstance()->GetServiceForBrowserContext(profile, true));
+}
+
+// static
+EventRouterFactory* EventRouterFactory::GetInstance() {
+  return base::Singleton<EventRouterFactory>::get();
+}
+
+EventRouterFactory::EventRouterFactory()
+    : BrowserContextKeyedServiceFactory(
+          "EventRouter",
+          BrowserContextDependencyManager::GetInstance()) {
+  DependsOn(drive::DriveIntegrationServiceFactory::GetInstance());
+  DependsOn(
+      extensions::ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
+  DependsOn(VolumeManagerFactory::GetInstance());
+  DependsOn(arc::ArcIntentHelperBridge::GetFactory());
+}
+
+EventRouterFactory::~EventRouterFactory() = default;
+
+KeyedService* EventRouterFactory::BuildServiceInstanceFor(
+    content::BrowserContext* context) const {
+  return new EventRouter(Profile::FromBrowserContext(context));
+}
+
+content::BrowserContext* EventRouterFactory::GetBrowserContextToUse(
+    content::BrowserContext* context) const {
+  // Explicitly and always allow this router in guest login mode.
+  return chrome::GetBrowserContextOwnInstanceInIncognito(context);
+}
+
+bool EventRouterFactory::ServiceIsCreatedWithBrowserContext() const {
+  return true;
+}
+
+bool EventRouterFactory::ServiceIsNULLWhileTesting() const {
+  return true;
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/extensions/api/file_manager/event_router_factory.h b/chrome/browser/extensions/api/file_manager/event_router_factory.h
new file mode 100644
index 0000000000000..61b184de733c3
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/event_router_factory.h
@@ -0,0 +1,46 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_EVENT_ROUTER_FACTORY_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_EVENT_ROUTER_FACTORY_H_
+
+#include "base/memory/singleton.h"
+#include "components/keyed_service/content/browser_context_keyed_service_factory.h"
+
+class Profile;
+
+namespace file_manager {
+
+class EventRouter;
+
+class EventRouterFactory : public BrowserContextKeyedServiceFactory {
+ public:
+  // Returns the EventRouter for |profile|, creating it if
+  // it is not yet created.
+  static EventRouter* GetForProfile(Profile* profile);
+
+  // Returns the EventRouterFactory instance.
+  static EventRouterFactory* GetInstance();
+
+ protected:
+  // BrowserContextKeyedBaseFactory overrides:
+  content::BrowserContext* GetBrowserContextToUse(
+      content::BrowserContext* context) const override;
+  bool ServiceIsCreatedWithBrowserContext() const override;
+  bool ServiceIsNULLWhileTesting() const override;
+
+ private:
+  friend struct base::DefaultSingletonTraits<EventRouterFactory>;
+
+  EventRouterFactory();
+  ~EventRouterFactory() override;
+
+  // BrowserContextKeyedServiceFactory:
+  KeyedService* BuildServiceInstanceFor(
+      content::BrowserContext* context) const override;
+};
+
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_EVENT_ROUTER_FACTORY_H_
diff --git a/chrome/browser/extensions/api/file_manager/file_browser_handler_api.cc b/chrome/browser/extensions/api/file_manager/file_browser_handler_api.cc
new file mode 100644
index 0000000000000..e67bf1de4a769
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/file_browser_handler_api.cc
@@ -0,0 +1,379 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// The file contains the implementation of
+// fileBrowserHandlerInternal.selectFile extension function.
+// When invoked, the function does the following:
+//  - Verifies that the extension function was invoked as a result of user
+//    gesture.
+//  - Display 'save as' dialog using FileSelectorImpl which waits for the user
+//    feedback.
+//  - Once the user selects the file path (or cancels the selection),
+//    FileSelectorImpl notifies FileBrowserHandlerInternalSelectFileFunction of
+//    the selection result by calling FileHandlerSelectFile::OnFilePathSelected.
+//  - If the selection was canceled,
+//    FileBrowserHandlerInternalSelectFileFunction returns reporting failure.
+//  - If the file path was selected, the function opens external file system
+//    needed to create FileEntry object for the selected path
+//    (opening file system will create file system name and root url for the
+//    caller's external file system).
+//  - The function grants permissions needed to read/write/create file under the
+//    selected path. To grant permissions to the caller, caller's extension ID
+//    has to be allowed to access the files virtual path (e.g. /Downloads/foo)
+//    in ExternalFileSystemBackend. Additionally, the callers render
+//    process ID has to be granted read, write and create permissions for the
+//    selected file's full filesystem path (e.g.
+//    /home/chronos/user/Downloads/foo) in ChildProcessSecurityPolicy.
+//  - After the required file access permissions are granted, result object is
+//    created and returned back.
+
+#include "chrome/browser/extensions/api/file_manager/file_browser_handler_api.h"
+
+#include <stddef.h>
+
+#include <memory>
+
+#include "base/bind.h"
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/extensions/chrome_extension_function_details.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/browser_window.h"
+#include "chrome/browser/ui/chrome_select_file_policy.h"
+#include "chrome/browser/ui/tabs/tab_strip_model.h"
+#include "chrome/common/extensions/api/file_browser_handler_internal.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/child_process_security_policy.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/render_process_host.h"
+#include "storage/browser/fileapi/file_system_backend.h"
+#include "storage/browser/fileapi/file_system_context.h"
+#include "storage/common/fileapi/file_system_info.h"
+#include "storage/common/fileapi/file_system_util.h"
+#include "ui/shell_dialogs/select_file_dialog.h"
+
+using content::BrowserThread;
+using extensions::api::file_browser_handler_internal::FileEntryInfo;
+using file_manager::FileSelector;
+using file_manager::FileSelectorFactory;
+using file_manager::util::EntryDefinition;
+using file_manager::util::FileDefinition;
+
+namespace SelectFile =
+    extensions::api::file_browser_handler_internal::SelectFile;
+
+namespace {
+
+const char kNoUserGestureError[] =
+    "This method can only be called in response to user gesture, such as a "
+    "mouse click or key press.";
+
+// Converts file extensions to a ui::SelectFileDialog::FileTypeInfo.
+ui::SelectFileDialog::FileTypeInfo ConvertExtensionsToFileTypeInfo(
+    const std::vector<std::string>& extensions) {
+  ui::SelectFileDialog::FileTypeInfo file_type_info;
+
+  for (size_t i = 0; i < extensions.size(); ++i) {
+    base::FilePath::StringType allowed_extension =
+        base::FilePath::FromUTF8Unsafe(extensions[i]).value();
+
+    // FileTypeInfo takes a nested vector like [["htm", "html"], ["txt"]] to
+    // group equivalent extensions, but we don't use this feature here.
+    std::vector<base::FilePath::StringType> inner_vector;
+    inner_vector.push_back(allowed_extension);
+    file_type_info.extensions.push_back(inner_vector);
+  }
+
+  return file_type_info;
+}
+
+// File selector implementation.
+// When |SelectFile| is invoked, it will show save as dialog and listen for user
+// action. When user selects the file (or closes the dialog), the function's
+// |OnFilePathSelected| method will be called with the result.
+// SelectFile should be called only once, because the class instance takes
+// ownership of itself after the first call. It will delete itself after the
+// extension function is notified of file selection result.
+// Since the extension function object is ref counted, FileSelectorImpl holds
+// a reference to it to ensure that the extension function doesn't go away while
+// waiting for user action. The reference is released after the function is
+// notified of the selection result.
+class FileSelectorImpl : public FileSelector,
+                         public ui::SelectFileDialog::Listener {
+ public:
+  FileSelectorImpl();
+  ~FileSelectorImpl() override;
+
+ protected:
+  // file_manager::FileSelectr overrides.
+  // Shows save as dialog with suggested name in window bound to |browser|.
+  // |allowed_extensions| specifies the file extensions allowed to be shown,
+  // and selected. Extensions should not include '.'.
+  //
+  // After this method is called, the selector implementation should not be
+  // deleted by the caller. It will delete itself after it receives response
+  // from SelectFielDialog.
+  void SelectFile(
+      const base::FilePath& suggested_name,
+      const std::vector<std::string>& allowed_extensions,
+      Browser* browser,
+      FileBrowserHandlerInternalSelectFileFunction* function) override;
+
+  // ui::SelectFileDialog::Listener overrides.
+  void FileSelected(const base::FilePath& path,
+                    int index,
+                    void* params) override;
+  void MultiFilesSelected(const std::vector<base::FilePath>& files,
+                          void* params) override;
+  void FileSelectionCanceled(void* params) override;
+
+ private:
+  // Initiates and shows 'save as' dialog which will be used to prompt user to
+  // select a file path. The initial selected file name in the dialog will be
+  // set to |suggested_name|. The dialog will be bound to the tab active in
+  // |browser|.
+  // |allowed_extensions| specifies the file extensions allowed to be shown,
+  // and selected. Extensions should not include '.'.
+  //
+  // Returns boolean indicating whether the dialog has been successfully shown
+  // to the user.
+  bool StartSelectFile(const base::FilePath& suggested_name,
+                       const std::vector<std::string>& allowed_extensions,
+                       Browser* browser);
+
+  // Reacts to the user action reported by the dialog and notifies |function_|
+  // about file selection result (by calling |OnFilePathSelected()|).
+  // The |this| object is self destruct after the function is notified.
+  // |success| indicates whether user has selected the file.
+  // |selected_path| is path that was selected. It is empty if the file wasn't
+  // selected.
+  void SendResponse(bool success, const base::FilePath& selected_path);
+
+  // Dialog that is shown by selector.
+  scoped_refptr<ui::SelectFileDialog> dialog_;
+
+  // Extension function that uses the selector.
+  scoped_refptr<FileBrowserHandlerInternalSelectFileFunction> function_;
+
+  DISALLOW_COPY_AND_ASSIGN(FileSelectorImpl);
+};
+
+FileSelectorImpl::FileSelectorImpl() = default;
+
+FileSelectorImpl::~FileSelectorImpl() {
+  if (dialog_.get())
+    dialog_->ListenerDestroyed();
+  // Send response if needed.
+  if (function_.get())
+    SendResponse(false, base::FilePath());
+}
+
+void FileSelectorImpl::SelectFile(
+    const base::FilePath& suggested_name,
+    const std::vector<std::string>& allowed_extensions,
+    Browser* browser,
+    FileBrowserHandlerInternalSelectFileFunction* function) {
+  // We will hold reference to the function until it is notified of selection
+  // result.
+  function_ = function;
+
+  if (!StartSelectFile(suggested_name, allowed_extensions, browser)) {
+    // If the dialog wasn't launched, let's asynchronously report failure to the
+    // function.
+    base::ThreadTaskRunnerHandle::Get()->PostTask(
+        FROM_HERE,
+        base::BindOnce(&FileSelectorImpl::FileSelectionCanceled,
+                       base::Unretained(this), static_cast<void*>(nullptr)));
+  }
+}
+
+bool FileSelectorImpl::StartSelectFile(
+    const base::FilePath& suggested_name,
+    const std::vector<std::string>& allowed_extensions,
+    Browser* browser) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(!dialog_.get());
+  DCHECK(browser);
+
+  if (!browser->window())
+    return false;
+
+  content::WebContents* web_contents =
+      browser->tab_strip_model()->GetActiveWebContents();
+  if (!web_contents)
+    return false;
+
+  dialog_ = ui::SelectFileDialog::Create(
+      this, std::make_unique<ChromeSelectFilePolicy>(web_contents));
+
+  // Convert |allowed_extensions| to ui::SelectFileDialog::FileTypeInfo.
+  ui::SelectFileDialog::FileTypeInfo allowed_file_info =
+      ConvertExtensionsToFileTypeInfo(allowed_extensions);
+  allowed_file_info.allowed_paths =
+      ui::SelectFileDialog::FileTypeInfo::ANY_PATH;
+
+  dialog_->SelectFile(
+      ui::SelectFileDialog::SELECT_SAVEAS_FILE,
+      base::string16() /* dialog title*/, suggested_name, &allowed_file_info,
+      0 /* file type index */, std::string() /* default file extension */,
+      browser->window()->GetNativeWindow(), nullptr /* params */);
+
+  return dialog_->IsRunning(browser->window()->GetNativeWindow());
+}
+
+void FileSelectorImpl::FileSelected(
+    const base::FilePath& path, int index, void* params) {
+  SendResponse(true, path);
+  delete this;
+}
+
+void FileSelectorImpl::MultiFilesSelected(
+    const std::vector<base::FilePath>& files,
+    void* params) {
+  // Only single file should be selected in save-as dialog.
+  NOTREACHED();
+}
+
+void FileSelectorImpl::FileSelectionCanceled(
+    void* params) {
+  SendResponse(false, base::FilePath());
+  delete this;
+}
+
+void FileSelectorImpl::SendResponse(bool success,
+                                    const base::FilePath& selected_path) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  // We don't want to send multiple responses.
+  if (function_.get())
+    function_->OnFilePathSelected(success, selected_path);
+  function_ = nullptr;
+}
+
+// FileSelectorFactory implementation.
+class FileSelectorFactoryImpl : public FileSelectorFactory {
+ public:
+  FileSelectorFactoryImpl() = default;
+  ~FileSelectorFactoryImpl() override = default;
+
+  // FileSelectorFactory implementation.
+  // Creates new FileSelectorImplementation for the function.
+  FileSelector* CreateFileSelector() const override {
+    return new FileSelectorImpl();
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(FileSelectorFactoryImpl);
+};
+
+}  // namespace
+
+FileBrowserHandlerInternalSelectFileFunction::
+    FileBrowserHandlerInternalSelectFileFunction()
+        : file_selector_factory_(new FileSelectorFactoryImpl()),
+          user_gesture_check_enabled_(true) {
+}
+
+FileBrowserHandlerInternalSelectFileFunction::
+    FileBrowserHandlerInternalSelectFileFunction(
+        FileSelectorFactory* file_selector_factory,
+        bool enable_user_gesture_check)
+        : file_selector_factory_(file_selector_factory),
+          user_gesture_check_enabled_(enable_user_gesture_check) {
+  DCHECK(file_selector_factory);
+}
+
+FileBrowserHandlerInternalSelectFileFunction::
+    ~FileBrowserHandlerInternalSelectFileFunction() = default;
+
+bool FileBrowserHandlerInternalSelectFileFunction::RunAsync() {
+  std::unique_ptr<SelectFile::Params> params(
+      SelectFile::Params::Create(*args_));
+
+  base::FilePath suggested_name(params->selection_params.suggested_name);
+  std::vector<std::string> allowed_extensions;
+  if (params->selection_params.allowed_file_extensions.get())
+    allowed_extensions = *params->selection_params.allowed_file_extensions;
+
+  if (!user_gesture() && user_gesture_check_enabled_) {
+    SetError(kNoUserGestureError);
+    return false;
+  }
+
+  FileSelector* file_selector = file_selector_factory_->CreateFileSelector();
+  file_selector->SelectFile(
+      suggested_name.BaseName(), allowed_extensions,
+      ChromeExtensionFunctionDetails(this).GetCurrentBrowser(), this);
+  return true;
+}
+
+void FileBrowserHandlerInternalSelectFileFunction::OnFilePathSelected(
+    bool success,
+    const base::FilePath& full_path) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (!success) {
+    Respond(EntryDefinition(), false);
+    return;
+  }
+
+  storage::ExternalFileSystemBackend* external_backend =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host())->external_backend();
+  DCHECK(external_backend);
+
+  FileDefinition file_definition;
+  file_definition.is_directory = false;
+
+  external_backend->GetVirtualPath(full_path, &file_definition.virtual_path);
+  DCHECK(!file_definition.virtual_path.empty());
+
+  // Grant access to this particular file to target extension. This will
+  // ensure that the target extension can access only this FS entry and
+  // prevent from traversing FS hierarchy upward.
+  external_backend->GrantFileAccessToExtension(extension_id(),
+                                               file_definition.virtual_path);
+
+  // Grant access to the selected file to target extensions render view process.
+  content::ChildProcessSecurityPolicy::GetInstance()->GrantCreateReadWriteFile(
+      render_frame_host()->GetProcess()->GetID(), full_path);
+
+  file_manager::util::ConvertFileDefinitionToEntryDefinition(
+      GetProfile(),
+      extension_id(),
+      file_definition,
+      base::Bind(
+          &FileBrowserHandlerInternalSelectFileFunction::RespondEntryDefinition,
+          this));
+}
+
+void FileBrowserHandlerInternalSelectFileFunction::RespondEntryDefinition(
+    const EntryDefinition& entry_definition) {
+  Respond(entry_definition, true);
+}
+
+void FileBrowserHandlerInternalSelectFileFunction::Respond(
+    const EntryDefinition& entry_definition,
+    bool success) {
+  std::unique_ptr<SelectFile::Results::Result> result(
+      new SelectFile::Results::Result());
+  result->success = success;
+
+  // If the file was selected, add 'entry' object which will be later used to
+  // create a FileEntry instance for the selected file.
+  if (success && entry_definition.error == base::File::FILE_OK) {
+    result->entry = std::make_unique<FileEntryInfo>();
+    // TODO(mtomasz): Make the response fields consistent with other files.
+    result->entry->file_system_name = entry_definition.file_system_name;
+    result->entry->file_system_root = entry_definition.file_system_root_url;
+    result->entry->file_full_path =
+        "/" + entry_definition.full_path.AsUTF8Unsafe();
+    result->entry->file_is_directory = entry_definition.is_directory;
+  }
+
+  results_ = SelectFile::Results::Create(*result);
+  SendResponse(true);
+}
diff --git a/chrome/browser/extensions/api/file_manager/file_browser_handler_api.h b/chrome/browser/extensions/api/file_manager/file_browser_handler_api.h
new file mode 100644
index 0000000000000..b82523bd9f6ad
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/file_browser_handler_api.h
@@ -0,0 +1,145 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// File contains the fileBrowserHandlerInternal.selectFile extension function.
+// The function prompts user to select a file path to be used by the caller. It
+// will fail if it isn't invoked by a user gesture (e.g. a mouse click or a
+// keyboard key press).
+// Note that the target file is never actually created by this function, even
+// if the selected path doesn't exist.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_FILE_BROWSER_HANDLER_API_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_FILE_BROWSER_HANDLER_API_H_
+
+#include <string>
+#include <vector>
+
+#include "base/files/file_path.h"
+#include "chrome/browser/extensions/chrome_extension_function.h"
+
+class Browser;
+class FileBrowserHandlerInternalSelectFileFunction;
+
+namespace file_manager {
+
+namespace util {
+struct EntryDefinition;
+}
+
+// Interface that is used by FileBrowserHandlerInternalSelectFileFunction to
+// select the file path that should be reported back to the extension function
+// caller.  Nobody will take the ownership of the interface implementation, so
+// it should delete itself once it's done.
+class FileSelector {
+ public:
+  virtual ~FileSelector() = default;
+
+  // Starts the file selection. It should prompt user to select a file path.
+  // Once the selection is made it should asynchronously call
+  // |function_->OnFilePathSelected| with the selection information.
+  // User should be initially suggested to select file named |suggested_name|.
+  // |allowed_extensions| specifies the file extensions allowed to be shown,
+  // and selected. Extensions should not include '.'. This spec comes from
+  // ui::SelectFileDialog() which takes extensions without '.'.
+  //
+  // Selection UI should be displayed using |browser|. |browser| should outlive
+  // the interface implementation.
+  // |function| if the extension function that called the method and needs to
+  // be notified of user action. The interface implementation should keep a
+  // reference to the function until it is notified (extension function
+  // implementations are ref counted).
+  // |SelectFile| will be called at most once by a single extension function.
+  // The interface implementation should delete itself after the extension
+  // function is notified of file selection result.
+  virtual void SelectFile(
+      const base::FilePath& suggested_name,
+      const std::vector<std::string>& allowed_extensions,
+      Browser* browser,
+      FileBrowserHandlerInternalSelectFileFunction* function) = 0;
+};
+
+// Interface that is used by FileBrowserHandlerInternalSelectFileFunction to
+// create a FileSelector it can use to select a file path.
+class FileSelectorFactory {
+ public:
+  virtual ~FileSelectorFactory() = default;
+
+  // Creates a FileSelector instance for the
+  // FileBrowserHandlerInternalSelectFileFunction.
+  virtual FileSelector* CreateFileSelector() const = 0;
+};
+
+}  // namespace file_manager
+
+
+// Note that this class is not in 'file_manager' class to be consistent with
+// all other extension functions registered in
+// chrome/common/extensions/api/generated_api.cc being in the global namespace.
+//
+// The fileBrowserHandlerInternal.selectFile extension function implementation.
+// See the file description for more info.
+class FileBrowserHandlerInternalSelectFileFunction
+    : public ChromeAsyncExtensionFunction {
+ public:
+  // Default constructor used in production code.
+  // It will create its own FileSelectorFactory implementation, and set the
+  // value of |user_gesture_check_enabled| to true.
+  FileBrowserHandlerInternalSelectFileFunction();
+
+  // This constructor should be used only in tests to inject test file selector
+  // factory and to allow extension function to run even if it hasn't been
+  // invoked by user gesture.
+  // Created object will take the ownership of the |file_selector_factory|.
+  FileBrowserHandlerInternalSelectFileFunction(
+      file_manager::FileSelectorFactory* file_selector_factory,
+      bool enable_user_gesture_check);
+
+  // Called by FileSelector implementation when the user selects the file's
+  // file path. File access permissions for the selected file are granted and
+  // caller is notified of the selection result after this method is called.
+  // |success| Whether the path was selected.
+  // |full_path| The selected file path if one was selected. It is ignored if
+  // the selection did not succeed.
+  void OnFilePathSelected(bool success, const base::FilePath& full_path);
+
+ protected:
+  // The class is ref counted, so destructor should not be public.
+  ~FileBrowserHandlerInternalSelectFileFunction() override;
+
+  // ChromeAsyncExtensionFunction implementation.
+  // Runs the extension function implementation.
+  bool RunAsync() override;
+
+ private:
+  // Respond to the API with selected entry definition.
+  void RespondEntryDefinition(
+      const file_manager::util::EntryDefinition& entry_definition);
+
+  // Creates dictionary value that will be used to as the extension function's
+  // callback argument and ends extension function execution by calling
+  // |SendResponse(true)|.
+  // The |results_| value will be set to dictionary containing two properties:
+  // * boolean 'success', which will be equal to |success|.
+  // * object 'entry', which will be set only when |success| is true, and the
+  //   conversion to |entry_definition| was successful. In such case, it will
+  //   contain information needed to create a FileEntry object for the selected
+  //   file.
+  void Respond(const file_manager::util::EntryDefinition& entry_definition,
+               bool success);
+
+  // Factory used to create FileSelector to be used for prompting user to select
+  // file.
+  std::unique_ptr<file_manager::FileSelectorFactory> file_selector_factory_;
+  // Whether user gesture check is disabled. This should be true only in tests.
+  bool user_gesture_check_enabled_;
+
+  // List of permissions and paths that have to be granted for the selected
+  // files.
+  std::vector<std::pair<base::FilePath, int> > permissions_to_grant_;
+
+  DECLARE_EXTENSION_FUNCTION("fileBrowserHandlerInternal.selectFile",
+                             FILEBROWSERHANDLERINTERNAL_SELECTFILE)
+};
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_FILE_BROWSER_HANDLER_API_H_
diff --git a/chrome/browser/extensions/api/file_manager/file_browser_handler_api_test.cc b/chrome/browser/extensions/api/file_manager/file_browser_handler_api_test.cc
new file mode 100644
index 0000000000000..f7ee4bbd2db0d
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/file_browser_handler_api_test.cc
@@ -0,0 +1,379 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// File contains browser tests for the fileBrowserHandler api.
+
+#include "chrome/browser/extensions/api/file_manager/file_browser_handler_api.h"
+
+#include <stddef.h>
+
+#include <vector>
+
+#include "base/bind.h"
+#include "base/files/scoped_temp_dir.h"
+#include "base/macros.h"
+#include "base/run_loop.h"
+#include "base/task/post_task.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "base/values.h"
+#include "chrome/browser/extensions/extension_apitest.h"
+#include "chrome/browser/extensions/extension_function_test_utils.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "content/public/browser/browser_context.h"
+#include "extensions/browser/api_test_utils.h"
+#include "extensions/browser/extension_function_registry.h"
+#include "extensions/common/extension.h"
+#include "extensions/test/result_catcher.h"
+#include "storage/browser/fileapi/external_mount_points.h"
+#include "storage/common/fileapi/file_system_types.h"
+
+namespace utils = extension_function_test_utils;
+
+using content::BrowserContext;
+using extensions::Extension;
+
+namespace {
+
+// Data that defines FileSelector behaviour in each test case.
+struct TestCase {
+  TestCase(const base::FilePath& suggested_name,
+           const std::vector<std::string>& allowed_extensions,
+           bool success,
+           const base::FilePath& selected_path)
+      : suggested_name(suggested_name),
+        allowed_extensions(allowed_extensions),
+        success(success),
+        selected_path(selected_path) {
+  }
+  ~TestCase() = default;
+
+  // Path that we expect to be suggested to the file selector.
+  base::FilePath suggested_name;
+
+  // Extensions that we expect to be allowed to the file selector.
+  std::vector<std::string> allowed_extensions;
+
+  // Whether file selector should fail.
+  bool success;
+  // The path file selector should return back to the function.
+  base::FilePath selected_path;
+};
+
+bool OverrideFunction(const std::string& name,
+                      extensions::ExtensionFunctionFactory factory) {
+  return ExtensionFunctionRegistry::GetInstance().OverrideFunctionForTesting(
+      name, factory);
+}
+
+// Mocks FileSelector used by FileBrowserHandlerInternalSelectFileFunction.
+// When |SelectFile| is called, it will check that file name suggestion is as
+// expected, and respond to the extension function with specified selection
+// results.
+class MockFileSelector : public file_manager::FileSelector {
+ public:
+  MockFileSelector(const base::FilePath& suggested_name,
+                   const std::vector<std::string>& allowed_extensions,
+                   bool success,
+                   const base::FilePath& selected_path)
+      : suggested_name_(suggested_name),
+        allowed_extensions_(allowed_extensions),
+        success_(success),
+        selected_path_(selected_path) {
+  }
+  ~MockFileSelector() override = default;
+
+  // file_manager::FileSelector implementation.
+  // |browser| is not used.
+  void SelectFile(
+      const base::FilePath& suggested_name,
+      const std::vector<std::string>& allowed_extensions,
+      Browser* browser,
+      FileBrowserHandlerInternalSelectFileFunction* function) override {
+    // Confirm that the function suggested us the right name.
+    EXPECT_EQ(suggested_name_, suggested_name);
+    // Confirm that the function allowed us the right extensions.
+    EXPECT_EQ(allowed_extensions_.size(), allowed_extensions.size());
+    if (allowed_extensions_.size() == allowed_extensions.size()) {
+      for (size_t i = 0; i < allowed_extensions_.size(); ++i) {
+        EXPECT_EQ(allowed_extensions_[i], allowed_extensions[i]);
+      }
+    }
+
+    // Send response to the extension function.
+    // The callback will take a reference to the function and keep it alive.
+    base::ThreadTaskRunnerHandle::Get()->PostTask(
+        FROM_HERE,
+        base::BindOnce(
+            &FileBrowserHandlerInternalSelectFileFunction::OnFilePathSelected,
+            function, success_, selected_path_));
+    delete this;
+  }
+
+ private:
+  // File name that is expected to be suggested by the function.
+  base::FilePath suggested_name_;
+
+  // Extensions that is expected to be allowed by the function.
+  std::vector<std::string> allowed_extensions_;
+
+  // Whether the selection should succeed.
+  bool success_;
+  // File path that should be returned to the function.
+  base::FilePath selected_path_;
+
+  DISALLOW_COPY_AND_ASSIGN(MockFileSelector);
+};
+
+// Mocks file selector factory for the test.
+// When |CreateFileSelector| is invoked it will create mock file selector for
+// the extension function with test parameters from the object ctor.
+class MockFileSelectorFactory : public file_manager::FileSelectorFactory {
+ public:
+  explicit MockFileSelectorFactory(const TestCase& test_case)
+      : suggested_name_(test_case.suggested_name),
+        allowed_extensions_(test_case.allowed_extensions),
+        success_(test_case.success),
+        selected_path_(test_case.selected_path) {
+  }
+  ~MockFileSelectorFactory() override = default;
+
+  // file_manager::FileSelectorFactory implementation.
+  file_manager::FileSelector* CreateFileSelector() const override {
+    return new MockFileSelector(suggested_name_,
+                                allowed_extensions_,
+                                success_,
+                                selected_path_);
+  }
+
+ private:
+  // File name that is expected to be suggested by the function.
+  base::FilePath suggested_name_;
+  // Extensions that is expected to be allowed by the function.
+  std::vector<std::string> allowed_extensions_;
+  // Whether the selection should succeed.
+  bool success_;
+  // File path that should be returned to the function.
+  base::FilePath selected_path_;
+
+  DISALLOW_COPY_AND_ASSIGN(MockFileSelectorFactory);
+};
+
+// Extension api test for the fileBrowserHandler extension API.
+class FileBrowserHandlerExtensionTest : public extensions::ExtensionApiTest {
+ protected:
+  void SetUp() override {
+    // Create mount point directory that will be used in the test.
+    // Mount point will be called "tmp", and it will be located in a tmp
+    // directory with an unique name.
+    ASSERT_TRUE(scoped_tmp_dir_.CreateUniqueTempDir());
+    tmp_mount_point_ = scoped_tmp_dir_.GetPath().Append("tmp");
+    base::CreateDirectory(tmp_mount_point_);
+
+    extensions::ExtensionApiTest::SetUp();
+  }
+
+  // Creates new, test mount point.
+  void AddTmpMountPoint(const std::string& extension_id) {
+    BrowserContext::GetMountPoints(browser()->profile())
+        ->RegisterFileSystem("tmp",
+                             storage::kFileSystemTypeNativeLocal,
+                             storage::FileSystemMountOption(),
+                             tmp_mount_point_);
+  }
+
+  base::FilePath GetFullPathOnTmpMountPoint(
+      const base::FilePath& relative_path) {
+    return tmp_mount_point_.Append(relative_path);
+  }
+
+  // Creates a new FileBrowserHandlerInternalSelectFileFunction to be used in
+  // the test.  This function will be called from ExtensionFunctinoDispatcher
+  // whenever an extension function for fileBrowserHandlerInternal.selectFile
+  // will be needed.
+  static ExtensionFunction* TestSelectFileFunctionFactory() {
+    EXPECT_TRUE(test_cases_);
+    EXPECT_TRUE(!test_cases_ || current_test_case_ < test_cases_->size());
+
+    // If this happens, test failed. But, we still don't want to crash, so
+    // return valid extension function.
+    if (!test_cases_ || current_test_case_ >= test_cases_->size())
+      return new FileBrowserHandlerInternalSelectFileFunction();
+
+    // Create file creator factory for the current test case.
+    MockFileSelectorFactory* mock_factory =
+        new MockFileSelectorFactory(test_cases_->at(current_test_case_));
+    current_test_case_++;
+
+    return new FileBrowserHandlerInternalSelectFileFunction(
+        mock_factory, false);
+  }
+
+  // Sets up test parameters for extension function invocations that will be
+  // made during the test.
+  void SetTestCases(const std::vector<TestCase>* test_cases) {
+    test_cases_ = test_cases;
+    current_test_case_ = 0;
+  }
+
+ private:
+  // List of test parameters for each extension function invocation that will be
+  // made during a test.
+  // Should be owned by the test code.
+  static const std::vector<TestCase>* test_cases_;
+  static size_t current_test_case_;
+
+  base::ScopedTempDir scoped_tmp_dir_;
+  // Our test mount point path.
+  base::FilePath tmp_mount_point_;
+};
+
+const std::vector<TestCase>* FileBrowserHandlerExtensionTest::test_cases_ =
+    nullptr;
+size_t FileBrowserHandlerExtensionTest::current_test_case_ = 0;
+
+// End to end test that verifies that fileBrowserHandler.selectFile works as
+// expected. It will run test extension under
+// chrome/test/data/extensions/api_test/file_browser/filehandler_create.
+// The extension will invoke fileBrowserHandler.selectFile function twice.
+// Once with suggested name "some_file_name.txt", and once with suggested name
+// "fail". The file selection should succeed the first time, but fail the second
+// time. When the file is selected the test extension will verify that it can
+// create, read and write the file under the selected file path.
+IN_PROC_BROWSER_TEST_F(FileBrowserHandlerExtensionTest, EndToEnd) {
+  // Path that will be "selected" by file selector.
+  const base::FilePath selected_path =
+      GetFullPathOnTmpMountPoint(base::FilePath("test_file.txt"));
+
+  std::vector<std::string> allowed_extensions;
+  allowed_extensions.emplace_back("txt");
+  allowed_extensions.emplace_back("html");
+
+  std::vector<TestCase> test_cases;
+  test_cases.emplace_back(base::FilePath("some_file_name.txt"),
+                          allowed_extensions, true, selected_path);
+  test_cases.emplace_back(base::FilePath("fail"), std::vector<std::string>(),
+                          false, base::FilePath());
+
+  SetTestCases(&test_cases);
+
+  // Override extension function that will be used during the test.
+  ASSERT_TRUE(OverrideFunction(
+      "fileBrowserHandlerInternal.selectFile",
+      FileBrowserHandlerExtensionTest::TestSelectFileFunctionFactory));
+
+  // Selected path should still not exist.
+  ASSERT_FALSE(base::PathExists(selected_path));
+
+  const Extension* extension = LoadExtension(
+      test_data_dir_.AppendASCII("file_browser/filehandler_create"));
+  ASSERT_TRUE(extension) << message_;
+
+  AddTmpMountPoint(extension->id());
+
+  extensions::ResultCatcher catcher;
+
+  GURL url = extension->GetResourceURL("test.html");
+  ui_test_utils::NavigateToURL(browser(), url);
+
+  ASSERT_TRUE(catcher.GetNextResult()) << message_;
+
+  // Selected path should have been created by the test extension after the
+  // extension function call.
+  ASSERT_TRUE(base::PathExists(selected_path));
+
+  // Let's check that the file has the expected content.
+  const std::string kExpectedContents = "hello from test extension.";
+  base::RunLoop run_loop;
+  std::string contents;
+  base::PostTaskWithTraitsAndReply(
+      FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_VISIBLE},
+      base::BindOnce(base::IgnoreResult(base::ReadFileToString), selected_path,
+                     &contents),
+      run_loop.QuitClosure());
+  run_loop.Run();
+  EXPECT_EQ(kExpectedContents, contents);
+
+  SetTestCases(nullptr);
+}
+
+// Tests that verifies the fileBrowserHandlerInternal.selectFile function fails
+// when invoked without user gesture.
+IN_PROC_BROWSER_TEST_F(FileBrowserHandlerExtensionTest, NoUserGesture) {
+  scoped_refptr<FileBrowserHandlerInternalSelectFileFunction>
+      select_file_function(
+          new FileBrowserHandlerInternalSelectFileFunction());
+
+  std::string error =
+      utils::RunFunctionAndReturnError(
+          select_file_function.get(),
+          "[{\"suggestedName\": \"foo\"}]",
+          browser());
+
+  const std::string expected_error =
+      "This method can only be called in response to user gesture, such as a "
+      "mouse click or key press.";
+  EXPECT_EQ(expected_error, error);
+}
+
+// Tests that checks that the fileHandlerInternal.selectFile function returns
+// dictionary with |success == false| and no file entry when user cancels file
+// selection.
+IN_PROC_BROWSER_TEST_F(FileBrowserHandlerExtensionTest, SelectionFailed) {
+  TestCase test_case(base::FilePath("some_file_name.txt"),
+                     std::vector<std::string>(),
+                     false,
+                     base::FilePath());
+
+  scoped_refptr<FileBrowserHandlerInternalSelectFileFunction>
+      select_file_function(
+          new FileBrowserHandlerInternalSelectFileFunction(
+              new MockFileSelectorFactory(test_case),
+              false));
+
+  select_file_function->set_has_callback(true);
+  select_file_function->set_user_gesture(true);
+
+  std::unique_ptr<base::DictionaryValue> result(
+      utils::ToDictionary(utils::RunFunctionAndReturnSingleResult(
+          select_file_function.get(),
+          "[{\"suggestedName\": \"some_file_name.txt\"}]", browser())));
+
+  EXPECT_FALSE(extensions::api_test_utils::GetBoolean(result.get(), "success"));
+  base::DictionaryValue* entry_info;
+  EXPECT_FALSE(result->GetDictionary("entry", &entry_info));
+}
+
+// Tests that user cannot be suggested a full file path when selecting a file,
+// only a file name (i.e. that extension function caller has no influence on
+// which directory contents will be initially displayed in selection dialog).
+IN_PROC_BROWSER_TEST_F(FileBrowserHandlerExtensionTest, SuggestedFullPath) {
+  TestCase test_case(base::FilePath("some_file_name.txt"),
+                     std::vector<std::string>(),
+                     false,
+                     base::FilePath());
+
+  scoped_refptr<FileBrowserHandlerInternalSelectFileFunction>
+      select_file_function(
+          new FileBrowserHandlerInternalSelectFileFunction(
+              new MockFileSelectorFactory(test_case),
+              false));
+
+  select_file_function->set_has_callback(true);
+  select_file_function->set_user_gesture(true);
+
+  std::unique_ptr<base::DictionaryValue> result(
+      utils::ToDictionary(utils::RunFunctionAndReturnSingleResult(
+          select_file_function.get(),
+          "[{\"suggestedName\": \"/path_to_file/some_file_name.txt\"}]",
+          browser())));
+
+  EXPECT_FALSE(extensions::api_test_utils::GetBoolean(result.get(), "success"));
+  base::DictionaryValue* entry_info;
+  EXPECT_FALSE(result->GetDictionary("entry", &entry_info));
+}
+
+}  // namespace
diff --git a/chrome/browser/extensions/api/file_manager/file_manager_private_api_functions.h b/chrome/browser/extensions/api/file_manager/file_manager_private_api_functions.h
new file mode 100644
index 0000000000000..8dbfb8f6f7fab
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/file_manager_private_api_functions.h
@@ -0,0 +1,20 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_FILE_MANAGER_PRIVATE_API_FUNCTIONS_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_FILE_MANAGER_PRIVATE_API_FUNCTIONS_H_
+
+// This header file is included from the auto generated code by the extension
+// API scheme compiler.
+// See also chrome/common/extensions/api/file_manager_private.idl.
+
+#include "chrome/browser/extensions/api/file_manager/private_api_dialog.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_drive.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_file_system.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_misc.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_mount.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_strings.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_tasks.h"
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_FILE_MANAGER_PRIVATE_API_FUNCTIONS_H_
diff --git a/chrome/browser/extensions/api/file_manager/file_manager_private_apitest.cc b/chrome/browser/extensions/api/file_manager/file_manager_private_apitest.cc
new file mode 100644
index 0000000000000..f72139d05006d
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/file_manager_private_apitest.cc
@@ -0,0 +1,554 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <memory>
+
+#include "base/base64.h"
+#include "base/macros.h"
+#include "base/run_loop.h"
+#include "base/test/scoped_feature_list.h"
+#include "chrome/browser/chromeos/crostini/crostini_manager.h"
+#include "chrome/browser/chromeos/crostini/crostini_pref_names.h"
+#include "chrome/browser/extensions/api/file_manager/event_router.h"
+#include "chrome/browser/file_manager/file_watcher.h"
+#include "chrome/browser/file_manager/mount_test_util.h"
+#include "chrome/browser/chromeos/file_system_provider/icon_set.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_info.h"
+#include "chrome/browser/extensions/extension_apitest.h"
+#include "chrome/browser/signin/identity_manager_factory.h"
+#include "chrome/browser/signin/signin_manager_factory.h"
+#include "chrome/common/chrome_features.h"
+#include "chrome/common/extensions/api/file_system_provider_capabilities/file_system_provider_capabilities_handler.h"
+#include "chrome/test/base/testing_profile.h"
+#include "chromeos/dbus/cros_disks_client.h"
+#include "chromeos/disks/disk.h"
+#include "chromeos/disks/mock_disk_mount_manager.h"
+#include "components/drive/file_change.h"
+#include "components/prefs/pref_service.h"
+#include "components/signin/core/browser/signin_manager_base.h"
+#include "extensions/common/extension.h"
+#include "extensions/common/install_warning.h"
+#include "google_apis/drive/test_util.h"
+#include "services/identity/public/cpp/identity_test_utils.h"
+#include "storage/browser/fileapi/external_mount_points.h"
+
+using ::testing::_;
+using ::testing::ReturnRef;
+
+using chromeos::disks::Disk;
+using chromeos::disks::DiskMountManager;
+
+namespace {
+
+struct TestDiskInfo {
+  const char* system_path;
+  const char* file_path;
+  bool write_disabled_by_policy;
+  const char* device_label;
+  const char* drive_label;
+  const char* vendor_id;
+  const char* vendor_name;
+  const char* product_id;
+  const char* product_name;
+  const char* fs_uuid;
+  const char* system_path_prefix;
+  chromeos::DeviceType device_type;
+  uint64_t size_in_bytes;
+  bool is_parent;
+  bool is_read_only_hardware;
+  bool has_media;
+  bool on_boot_device;
+  bool on_removable_device;
+  bool is_hidden;
+  const char* file_system_type;
+  const char* base_mount_path;
+};
+
+struct TestMountPoint {
+  std::string source_path;
+  std::string mount_path;
+  chromeos::MountType mount_type;
+  chromeos::disks::MountCondition mount_condition;
+
+  // -1 if there is no disk info.
+  int disk_info_index;
+};
+
+TestDiskInfo kTestDisks[] = {{"system_path1",
+                              "file_path1",
+                              false,
+                              "device_label1",
+                              "drive_label1",
+                              "0123",
+                              "vendor1",
+                              "abcd",
+                              "product1",
+                              "FFFF-FFFF",
+                              "system_path_prefix1",
+                              chromeos::DEVICE_TYPE_USB,
+                              1073741824,
+                              false,
+                              false,
+                              false,
+                              false,
+                              false,
+                              false,
+                              "exfat",
+                              ""},
+                             {"system_path2",
+                              "file_path2",
+                              false,
+                              "device_label2",
+                              "drive_label2",
+                              "4567",
+                              "vendor2",
+                              "cdef",
+                              "product2",
+                              "0FFF-FFFF",
+                              "system_path_prefix2",
+                              chromeos::DEVICE_TYPE_MOBILE,
+                              47723,
+                              true,
+                              true,
+                              true,
+                              true,
+                              false,
+                              false,
+                              "exfat",
+                              ""},
+                             {"system_path3",
+                              "file_path3",
+                              true,  // write_disabled_by_policy
+                              "device_label3",
+                              "drive_label3",
+                              "89ab",
+                              "vendor3",
+                              "ef01",
+                              "product3",
+                              "00FF-FFFF",
+                              "system_path_prefix3",
+                              chromeos::DEVICE_TYPE_OPTICAL_DISC,
+                              0,
+                              true,
+                              false,  // is_hardware_read_only
+                              false,
+                              true,
+                              false,
+                              false,
+                              "exfat",
+                              ""}};
+
+void DispatchDirectoryChangeEventImpl(
+    int* counter,
+    const base::FilePath& virtual_path,
+    const drive::FileChange* list,
+    bool got_error,
+    const std::vector<std::string>& extension_ids) {
+  ++(*counter);
+}
+
+void AddFileWatchCallback(bool success) {}
+
+bool InitializeLocalFileSystem(std::string mount_point_name,
+                               base::ScopedTempDir* temp_dir,
+                               base::FilePath* mount_point_dir) {
+  const char kTestFileContent[] = "The five boxing wizards jumped quickly";
+  if (!temp_dir->CreateUniqueTempDir())
+    return false;
+
+  *mount_point_dir = temp_dir->GetPath().AppendASCII(mount_point_name);
+  // Create the mount point.
+  if (!base::CreateDirectory(*mount_point_dir))
+    return false;
+
+  const base::FilePath test_dir = mount_point_dir->AppendASCII("test_dir");
+  if (!base::CreateDirectory(test_dir))
+    return false;
+
+  const base::FilePath test_file = test_dir.AppendASCII("test_file.txt");
+  if (!google_apis::test_util::WriteStringToFile(test_file, kTestFileContent))
+    return false;
+
+  return true;
+}
+
+}  // namespace
+
+class FileManagerPrivateApiTest : public extensions::ExtensionApiTest {
+ public:
+  FileManagerPrivateApiTest() : disk_mount_manager_mock_(nullptr) {
+    InitMountPoints();
+  }
+
+  ~FileManagerPrivateApiTest() override {
+    DCHECK(!disk_mount_manager_mock_);
+    DCHECK(!testing_profile_);
+    DCHECK(!event_router_);
+  }
+
+  void SetUpOnMainThread() override {
+    extensions::ExtensionApiTest::SetUpOnMainThread();
+
+    testing_profile_ = std::make_unique<TestingProfile>();
+    event_router_ =
+        std::make_unique<file_manager::EventRouter>(testing_profile_.get());
+  }
+
+  void TearDownOnMainThread() override {
+    event_router_->Shutdown();
+
+    event_router_.reset();
+    testing_profile_.reset();
+
+    extensions::ExtensionApiTest::TearDownOnMainThread();
+  }
+
+  // ExtensionApiTest override
+  void SetUpInProcessBrowserTestFixture() override {
+    extensions::ExtensionApiTest::SetUpInProcessBrowserTestFixture();
+    disk_mount_manager_mock_ = new chromeos::disks::MockDiskMountManager;
+    chromeos::disks::DiskMountManager::InitializeForTesting(
+        disk_mount_manager_mock_);
+    disk_mount_manager_mock_->SetupDefaultReplies();
+
+    // override mock functions.
+    ON_CALL(*disk_mount_manager_mock_, FindDiskBySourcePath(_)).WillByDefault(
+        Invoke(this, &FileManagerPrivateApiTest::FindVolumeBySourcePath));
+    EXPECT_CALL(*disk_mount_manager_mock_, disks())
+        .WillRepeatedly(ReturnRef(volumes_));
+    EXPECT_CALL(*disk_mount_manager_mock_, mount_points())
+        .WillRepeatedly(ReturnRef(mount_points_));
+  }
+
+  // ExtensionApiTest override
+  void TearDownInProcessBrowserTestFixture() override {
+    chromeos::disks::DiskMountManager::Shutdown();
+    disk_mount_manager_mock_ = nullptr;
+
+    extensions::ExtensionApiTest::TearDownInProcessBrowserTestFixture();
+  }
+
+ private:
+  void InitMountPoints() {
+    const TestMountPoint kTestMountPoints[] = {
+      {
+        "device_path1",
+        chromeos::CrosDisksClient::GetRemovableDiskMountPoint().AppendASCII(
+            "mount_path1").AsUTF8Unsafe(),
+        chromeos::MOUNT_TYPE_DEVICE,
+        chromeos::disks::MOUNT_CONDITION_NONE,
+        0
+      },
+      {
+        "device_path2",
+        chromeos::CrosDisksClient::GetRemovableDiskMountPoint().AppendASCII(
+            "mount_path2").AsUTF8Unsafe(),
+        chromeos::MOUNT_TYPE_DEVICE,
+        chromeos::disks::MOUNT_CONDITION_NONE,
+        1
+      },
+      {
+        "device_path3",
+        chromeos::CrosDisksClient::GetRemovableDiskMountPoint().AppendASCII(
+            "mount_path3").AsUTF8Unsafe(),
+        chromeos::MOUNT_TYPE_DEVICE,
+        chromeos::disks::MOUNT_CONDITION_NONE,
+        2
+      },
+      {
+        // Set source path inside another mounted volume.
+        chromeos::CrosDisksClient::GetRemovableDiskMountPoint().AppendASCII(
+            "mount_path3/archive.zip").AsUTF8Unsafe(),
+        chromeos::CrosDisksClient::GetArchiveMountPoint().AppendASCII(
+            "archive_mount_path").AsUTF8Unsafe(),
+        chromeos::MOUNT_TYPE_ARCHIVE,
+        chromeos::disks::MOUNT_CONDITION_NONE,
+        -1
+      }
+    };
+
+    for (size_t i = 0; i < arraysize(kTestMountPoints); i++) {
+      mount_points_.insert(DiskMountManager::MountPointMap::value_type(
+          kTestMountPoints[i].mount_path,
+          DiskMountManager::MountPointInfo(kTestMountPoints[i].source_path,
+                                           kTestMountPoints[i].mount_path,
+                                           kTestMountPoints[i].mount_type,
+                                           kTestMountPoints[i].mount_condition)
+      ));
+      int disk_info_index = kTestMountPoints[i].disk_info_index;
+      if (kTestMountPoints[i].disk_info_index >= 0) {
+        EXPECT_GT(arraysize(kTestDisks), static_cast<size_t>(disk_info_index));
+        if (static_cast<size_t>(disk_info_index) >= arraysize(kTestDisks))
+          return;
+
+        std::unique_ptr<Disk> disk =
+            Disk::Builder()
+                .SetDevicePath(kTestMountPoints[i].source_path)
+                .SetMountPath(kTestMountPoints[i].mount_path)
+                .SetWriteDisabledByPolicy(
+                    kTestDisks[disk_info_index].write_disabled_by_policy)
+                .SetSystemPath(kTestDisks[disk_info_index].system_path)
+                .SetFilePath(kTestDisks[disk_info_index].file_path)
+                .SetDeviceLabel(kTestDisks[disk_info_index].device_label)
+                .SetDriveLabel(kTestDisks[disk_info_index].drive_label)
+                .SetVendorId(kTestDisks[disk_info_index].vendor_id)
+                .SetVendorName(kTestDisks[disk_info_index].vendor_name)
+                .SetProductId(kTestDisks[disk_info_index].product_id)
+                .SetProductName(kTestDisks[disk_info_index].product_name)
+                .SetFileSystemUUID(kTestDisks[disk_info_index].fs_uuid)
+                .SetSystemPathPrefix(
+                    kTestDisks[disk_info_index].system_path_prefix)
+                .SetDeviceType(kTestDisks[disk_info_index].device_type)
+                .SetSizeInBytes(kTestDisks[disk_info_index].size_in_bytes)
+                .SetIsParent(kTestDisks[disk_info_index].is_parent)
+                .SetIsReadOnlyHardware(
+                    kTestDisks[disk_info_index].is_read_only_hardware)
+                .SetHasMedia(kTestDisks[disk_info_index].has_media)
+                .SetOnBootDevice(kTestDisks[disk_info_index].on_boot_device)
+                .SetOnRemovableDevice(
+                    kTestDisks[disk_info_index].on_removable_device)
+                .SetIsHidden(kTestDisks[disk_info_index].is_hidden)
+                .SetFileSystemType(kTestDisks[disk_info_index].file_system_type)
+                .SetBaseMountPath(kTestDisks[disk_info_index].base_mount_path)
+                .Build();
+
+        volumes_.insert(DiskMountManager::DiskMap::value_type(
+            kTestMountPoints[i].source_path, std::move(disk)));
+      }
+    }
+  }
+
+  const Disk* FindVolumeBySourcePath(const std::string& source_path) {
+    auto volume_it = volumes_.find(source_path);
+    return (volume_it == volumes_.end()) ? nullptr : volume_it->second.get();
+  }
+
+ protected:
+  void SshfsMount(const std::string& source_path,
+                  const std::string& source_format,
+                  const std::string& mount_label,
+                  const std::vector<std::string>& mount_options,
+                  chromeos::MountType type,
+                  chromeos::MountAccessMode access_mode) {
+    disk_mount_manager_mock_->NotifyMountEvent(
+        chromeos::disks::DiskMountManager::MountEvent::MOUNTING,
+        chromeos::MountError::MOUNT_ERROR_NONE,
+        chromeos::disks::DiskMountManager::MountPointInfo(
+            source_path, "/media/fuse/" + mount_label,
+            chromeos::MountType::MOUNT_TYPE_NETWORK_STORAGE,
+            chromeos::disks::MountCondition::MOUNT_CONDITION_NONE));
+  }
+
+  chromeos::disks::MockDiskMountManager* disk_mount_manager_mock_;
+  DiskMountManager::DiskMap volumes_;
+  DiskMountManager::MountPointMap mount_points_;
+  std::unique_ptr<TestingProfile> testing_profile_;
+  std::unique_ptr<file_manager::EventRouter> event_router_;
+};
+
+IN_PROC_BROWSER_TEST_F(FileManagerPrivateApiTest, Mount) {
+  using chromeos::file_system_provider::IconSet;
+  file_manager::test_util::WaitUntilDriveMountPointIsAdded(
+      browser()->profile());
+
+  // Add a provided file system, to test passing the |configurable| and
+  // |source| flags properly down to Files app.
+  IconSet icon_set;
+  icon_set.SetIcon(IconSet::IconSize::SIZE_16x16,
+                   GURL("chrome://resources/testing-provider-id-16.jpg"));
+  icon_set.SetIcon(IconSet::IconSize::SIZE_32x32,
+                   GURL("chrome://resources/testing-provider-id-32.jpg"));
+  chromeos::file_system_provider::ProvidedFileSystemInfo info(
+      "testing-provider-id", chromeos::file_system_provider::MountOptions(),
+      base::FilePath(), true /* configurable */, false /* watchable */,
+      extensions::SOURCE_NETWORK, icon_set);
+
+  file_manager::VolumeManager::Get(browser()->profile())
+      ->AddVolumeForTesting(file_manager::Volume::CreateForProvidedFileSystem(
+          info, file_manager::MOUNT_CONTEXT_AUTO));
+
+  // We will call fileManagerPrivate.unmountVolume once. To test that method, we
+  // check that UnmountPath is really called with the same value.
+  EXPECT_CALL(*disk_mount_manager_mock_, UnmountPath(_, _, _))
+      .Times(0);
+  EXPECT_CALL(
+      *disk_mount_manager_mock_,
+      UnmountPath(chromeos::CrosDisksClient::GetRemovableDiskMountPoint()
+                      .AppendASCII("mount_path1")
+                      .AsUTF8Unsafe(),
+                  chromeos::UNMOUNT_OPTIONS_NONE, _))
+      .Times(1);
+  EXPECT_CALL(*disk_mount_manager_mock_,
+              UnmountPath(chromeos::CrosDisksClient::GetArchiveMountPoint()
+                              .AppendASCII("archive_mount_path")
+                              .AsUTF8Unsafe(),
+                          chromeos::UNMOUNT_OPTIONS_LAZY, _))
+      .Times(1);
+
+  ASSERT_TRUE(RunComponentExtensionTest("file_browser/mount_test"))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerPrivateApiTest, Permissions) {
+  EXPECT_TRUE(
+      RunExtensionTestIgnoreManifestWarnings("file_browser/permissions"));
+  const extensions::Extension* extension = GetSingleLoadedExtension();
+  ASSERT_TRUE(extension);
+  ASSERT_EQ(1u, extension->install_warnings().size());
+  const extensions::InstallWarning& warning = extension->install_warnings()[0];
+  EXPECT_EQ("fileManagerPrivate", warning.key);
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerPrivateApiTest, OnFileChanged) {
+  // In drive volume, deletion of a directory is notified via OnFileChanged.
+  // Local changes directly come to HandleFileWatchNotification from
+  // FileWatcher.
+  typedef drive::FileChange FileChange;
+  typedef drive::FileChange::FileType FileType;
+  typedef drive::FileChange::ChangeType ChangeType;
+
+  int counter = 0;
+  event_router_->SetDispatchDirectoryChangeEventImplForTesting(
+      base::Bind(&DispatchDirectoryChangeEventImpl, &counter));
+
+  // /a/b/c and /a/d/e are being watched.
+  event_router_->AddFileWatch(
+      base::FilePath(FILE_PATH_LITERAL("/no-existing-fs/root/a/b/c")),
+      base::FilePath(FILE_PATH_LITERAL("/no-existing-fs-virtual/root/a/b/c")),
+      "extension_1", base::Bind(&AddFileWatchCallback));
+
+  event_router_->AddFileWatch(
+      base::FilePath(FILE_PATH_LITERAL("/no-existing-fs/root/a/d/e")),
+      base::FilePath(FILE_PATH_LITERAL("/no-existing-fs-hash/root/a/d/e")),
+      "extension_2", base::Bind(&AddFileWatchCallback));
+
+  event_router_->AddFileWatch(
+      base::FilePath(FILE_PATH_LITERAL("/no-existing-fs/root/aaa")),
+      base::FilePath(FILE_PATH_LITERAL("/no-existing-fs-hash/root/aaa")),
+      "extension_3", base::Bind(&AddFileWatchCallback));
+
+  // event_router->addFileWatch create some tasks which are performed on
+  // TaskScheduler. Wait until they are done.
+  base::TaskScheduler::GetInstance()->FlushForTesting();
+  // We also wait the UI thread here, since some tasks which are performed
+  // above message loop back results to the UI thread.
+  base::RunLoop().RunUntilIdle();
+
+  // When /a is deleted (1 and 2 is notified).
+  FileChange first_change;
+  first_change.Update(
+      base::FilePath(FILE_PATH_LITERAL("/no-existing-fs/root/a")),
+      FileType::FILE_TYPE_DIRECTORY, ChangeType::CHANGE_TYPE_DELETE);
+  event_router_->OnFileChanged(first_change);
+  EXPECT_EQ(2, counter);
+
+  // When /a/b/c is deleted (1 is notified).
+  FileChange second_change;
+  second_change.Update(
+      base::FilePath(FILE_PATH_LITERAL("/no-existing-fs/root/a/b/c")),
+      FileType::FILE_TYPE_DIRECTORY, ChangeType::CHANGE_TYPE_DELETE);
+  event_router_->OnFileChanged(second_change);
+  EXPECT_EQ(3, counter);
+
+  // When /z/y is deleted (Not notified).
+  FileChange third_change;
+  third_change.Update(
+      base::FilePath(FILE_PATH_LITERAL("/no-existing-fs/root/z/y")),
+      FileType::FILE_TYPE_DIRECTORY, ChangeType::CHANGE_TYPE_DELETE);
+  event_router_->OnFileChanged(third_change);
+  EXPECT_EQ(3, counter);
+
+  // Remove file watchers.
+  event_router_->RemoveFileWatch(
+      base::FilePath(FILE_PATH_LITERAL("/no-existing-fs/root/a/b/c")),
+      "extension_1");
+  event_router_->RemoveFileWatch(
+      base::FilePath(FILE_PATH_LITERAL("/no-existing-fs/root/a/d/e")),
+      "extension_2");
+  event_router_->RemoveFileWatch(
+      base::FilePath(FILE_PATH_LITERAL("/no-existing-fs/root/aaa")),
+      "extension_3");
+
+  // event_router->addFileWatch create some tasks which are performed on
+  // TaskScheduler. Wait until they are done.
+  base::TaskScheduler::GetInstance()->FlushForTesting();
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerPrivateApiTest, ContentChecksum) {
+  base::ScopedTempDir temp_dir;
+  base::FilePath mount_point_dir;
+  const char kLocalMountPointName[] = "local";
+
+  ASSERT_TRUE(InitializeLocalFileSystem(kLocalMountPointName, &temp_dir,
+                                        &mount_point_dir))
+      << "Failed to initialize test file system";
+
+  EXPECT_TRUE(content::BrowserContext::GetMountPoints(browser()->profile())
+                  ->RegisterFileSystem(
+                      kLocalMountPointName, storage::kFileSystemTypeNativeLocal,
+                      storage::FileSystemMountOption(), mount_point_dir));
+  file_manager::VolumeManager::Get(browser()->profile())
+      ->AddVolumeForTesting(mount_point_dir, file_manager::VOLUME_TYPE_TESTING,
+                            chromeos::DEVICE_TYPE_UNKNOWN,
+                            false /* read_only */);
+
+  ASSERT_TRUE(RunComponentExtensionTest("file_browser/content_checksum_test"));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerPrivateApiTest, Recent) {
+  base::ScopedTempDir temp_dir;
+  ASSERT_TRUE(temp_dir.CreateUniqueTempDir());
+  const base::FilePath downloads_dir = temp_dir.GetPath();
+
+  ASSERT_TRUE(file_manager::VolumeManager::Get(browser()->profile())
+                  ->RegisterDownloadsDirectoryForTesting(downloads_dir));
+
+  // Create an empty file.
+  {
+    base::File file(downloads_dir.Append("all-justice.jpg"),
+                    base::File::FLAG_CREATE | base::File::FLAG_WRITE);
+    ASSERT_TRUE(file.IsValid());
+  }
+
+  ASSERT_TRUE(RunComponentExtensionTest("file_browser/recent_test"));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerPrivateApiTest, Crostini) {
+  // TODO(joelhockey): Setting prefs and features to allow crostini is not
+  // ideal.  It would be better if the crostini interface allowed for testing
+  // without such tight coupling.
+  browser()->profile()->GetPrefs()->SetBoolean(
+      crostini::prefs::kCrostiniEnabled, true);
+  base::test::ScopedFeatureList scoped_feature_list;
+  scoped_feature_list.InitWithFeatures(
+      {features::kCrostini, features::kExperimentalCrostiniUI}, {});
+  crostini::CrostiniManager::GetInstance()->set_skip_restart_for_testing();
+
+  // Profile must be signed in with email for crostini.
+  identity::SetPrimaryAccount(
+      SigninManagerFactory::GetForProfileIfExists(browser()->profile()),
+      IdentityManagerFactory::GetForProfileIfExists(browser()->profile()),
+      "testuser@gmail.com");
+
+  // DiskMountManager mock.
+  std::string known_hosts;
+  base::Base64Encode("[hostname]:2222 pubkey", &known_hosts);
+  std::string identity;
+  base::Base64Encode("privkey", &identity);
+  std::vector<std::string> mount_options = {
+      "UserKnownHostsBase64=" + known_hosts, "IdentityBase64=" + identity,
+      "Port=2222"};
+  EXPECT_CALL(*disk_mount_manager_mock_,
+              MountPath("sshfs://testuser@hostname:", "",
+                        "crostini_user_termina_penguin", mount_options,
+                        chromeos::MOUNT_TYPE_NETWORK_STORAGE,
+                        chromeos::MOUNT_ACCESS_MODE_READ_WRITE))
+      .WillOnce(
+          Invoke(this, &FileManagerPrivateApiTest_Crostini_Test::SshfsMount));
+
+  ASSERT_TRUE(RunComponentExtensionTest("file_browser/crostini_test"));
+}
diff --git a/chrome/browser/extensions/api/file_manager/file_stream_md5_digester.cc b/chrome/browser/extensions/api/file_manager/file_stream_md5_digester.cc
new file mode 100644
index 0000000000000..b19989e515b90
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/file_stream_md5_digester.cc
@@ -0,0 +1,70 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/file_stream_md5_digester.h"
+
+#include <utility>
+
+#include "base/callback.h"
+#include "net/base/net_errors.h"
+#include "storage/browser/fileapi/file_stream_reader.h"
+
+namespace drive {
+namespace util {
+
+namespace {
+
+const int kMd5DigestBufferSize = 512 * 1024;  // 512 kB.
+
+}  // namespace
+
+FileStreamMd5Digester::FileStreamMd5Digester()
+    : buffer_(new net::IOBuffer(kMd5DigestBufferSize)) {}
+
+FileStreamMd5Digester::~FileStreamMd5Digester() = default;
+
+void FileStreamMd5Digester::GetMd5Digest(
+    std::unique_ptr<storage::FileStreamReader> stream_reader,
+    const ResultCallback& callback) {
+  reader_ = std::move(stream_reader);
+  base::MD5Init(&md5_context_);
+
+  // Start the read/hash.
+  ReadNextChunk(callback);
+}
+
+void FileStreamMd5Digester::ReadNextChunk(const ResultCallback& callback) {
+  const int result =
+      reader_->Read(buffer_.get(), kMd5DigestBufferSize,
+                    base::Bind(&FileStreamMd5Digester::OnChunkRead,
+                               base::Unretained(this), callback));
+  if (result != net::ERR_IO_PENDING)
+    OnChunkRead(callback, result);
+}
+
+void FileStreamMd5Digester::OnChunkRead(const ResultCallback& callback,
+                                        int bytes_read) {
+  if (bytes_read < 0) {
+    // Error - just return empty string.
+    callback.Run("");
+    return;
+  } else if (bytes_read == 0) {
+    // EOF.
+    base::MD5Digest digest;
+    base::MD5Final(&digest, &md5_context_);
+    std::string result = base::MD5DigestToBase16(digest);
+    callback.Run(result);
+    return;
+  }
+
+  // Read data and digest it.
+  base::MD5Update(&md5_context_,
+                  base::StringPiece(buffer_->data(), bytes_read));
+
+  // Kick off the next read.
+  ReadNextChunk(callback);
+}
+
+}  // namespace util
+}  // namespace drive
diff --git a/chrome/browser/extensions/api/file_manager/file_stream_md5_digester.h b/chrome/browser/extensions/api/file_manager/file_stream_md5_digester.h
new file mode 100644
index 0000000000000..aa9ec60af4e36
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/file_stream_md5_digester.h
@@ -0,0 +1,57 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_FILE_STREAM_MD5_DIGESTER_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_FILE_STREAM_MD5_DIGESTER_H_
+
+#include <memory>
+
+#include "base/callback_forward.h"
+#include "base/macros.h"
+#include "base/md5.h"
+#include "base/memory/ref_counted.h"
+#include "net/base/io_buffer.h"
+
+namespace storage {
+class FileStreamReader;
+}
+
+namespace drive {
+namespace util {
+
+// Computes the (base-16 encoded) MD5 digest of data extracted from a file
+// stream.
+class FileStreamMd5Digester {
+ public:
+  typedef base::Callback<void(const std::string&)> ResultCallback;
+
+  FileStreamMd5Digester();
+  ~FileStreamMd5Digester();
+
+  // Computes an MD5 digest of data read from the given |streamReader|.  The
+  // work occurs asynchronously, and the resulting hash is returned via the
+  // |callback|.  If an error occurs, |callback| is called with an empty string.
+  // Only one stream can be processed at a time by each digester.  Do not call
+  // GetMd5Digest before the results of a previous call have been returned.
+  void GetMd5Digest(std::unique_ptr<storage::FileStreamReader> stream_reader,
+                    const ResultCallback& callback);
+
+ private:
+  // Kicks off a read of the next chunk from the stream.
+  void ReadNextChunk(const ResultCallback& callback);
+  // Handles the incoming chunk of data from a stream read.
+  void OnChunkRead(const ResultCallback& callback, int bytes_read);
+
+  // Maximum chunk size for read operations.
+  std::unique_ptr<storage::FileStreamReader> reader_;
+  scoped_refptr<net::IOBuffer> buffer_;
+  base::MD5Context md5_context_;
+
+  DISALLOW_COPY_AND_ASSIGN(FileStreamMd5Digester);
+};
+
+}  // namespace util
+}  // namespace drive
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_FILE_STREAM_MD5_DIGESTER_H_
diff --git a/chrome/browser/extensions/api/file_manager/job_event_router.cc b/chrome/browser/extensions/api/file_manager/job_event_router.cc
new file mode 100644
index 0000000000000..1e7d8a6090d5a
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/job_event_router.cc
@@ -0,0 +1,148 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/job_event_router.h"
+
+#include <cmath>
+#include <memory>
+
+#include "base/threading/thread_task_runner_handle.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/profiles/profile.h"
+#include "components/drive/file_system_core_util.h"
+#include "content/public/browser/browser_thread.h"
+
+using content::BrowserThread;
+namespace file_manager_private = extensions::api::file_manager_private;
+
+namespace file_manager {
+
+JobEventRouter::JobEventRouter(const base::TimeDelta& event_delay)
+    : event_delay_(event_delay),
+      num_completed_bytes_(0),
+      num_total_bytes_(0),
+      weak_factory_(this) {
+}
+
+JobEventRouter::~JobEventRouter() = default;
+
+void JobEventRouter::OnJobAdded(const drive::JobInfo& job_info) {
+  OnJobUpdated(job_info);
+}
+
+void JobEventRouter::OnJobUpdated(const drive::JobInfo& job_info) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  if (!drive::IsActiveFileTransferJobInfo(job_info))
+    return;
+
+  // Add new job info.
+  UpdateBytes(job_info);
+  drive_jobs_[job_info.job_id] = std::make_unique<drive::JobInfo>(job_info);
+
+  ScheduleDriveFileTransferEvent(
+      job_info, file_manager_private::TRANSFER_STATE_IN_PROGRESS,
+      false /* immediate */);
+}
+
+void JobEventRouter::OnJobDone(const drive::JobInfo& job_info,
+                               drive::FileError error) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  if (!drive::IsActiveFileTransferJobInfo(job_info))
+    return;
+
+  const file_manager_private::TransferState state =
+      error == drive::FILE_ERROR_OK
+          ? file_manager_private::TRANSFER_STATE_COMPLETED
+          : file_manager_private::TRANSFER_STATE_FAILED;
+
+  drive::JobInfo completed_job = job_info;
+  completed_job.num_completed_bytes = completed_job.num_total_bytes;
+  UpdateBytes(completed_job);
+
+  ScheduleDriveFileTransferEvent(job_info, state, true /* immediate */);
+
+  // Forget about the job.
+  drive_jobs_.erase(job_info.job_id);
+  if (drive_jobs_.empty()) {
+    num_completed_bytes_ = 0L;
+    num_total_bytes_ = 0L;
+  }
+}
+
+void JobEventRouter::UpdateBytes(const drive::JobInfo& job_info) {
+  int64_t last_completed_bytes = 0;
+  int64_t last_total_bytes = 0;
+  if (drive_jobs_.count(job_info.job_id)) {
+    last_completed_bytes = drive_jobs_[job_info.job_id]->num_completed_bytes;
+    last_total_bytes = drive_jobs_[job_info.job_id]->num_total_bytes;
+  }
+  num_completed_bytes_ += job_info.num_completed_bytes - last_completed_bytes;
+  num_total_bytes_ += job_info.num_total_bytes - last_total_bytes;
+}
+
+void JobEventRouter::ScheduleDriveFileTransferEvent(
+    const drive::JobInfo& job_info,
+    file_manager_private::TransferState state,
+    bool immediate) {
+  const bool no_pending_task = !pending_job_info_;
+
+  pending_job_info_ = std::make_unique<drive::JobInfo>(job_info);
+  pending_state_ = state;
+
+  if (immediate) {
+    SendDriveFileTransferEvent();
+  } else if (no_pending_task) {
+    base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(
+        FROM_HERE,
+        base::BindOnce(&JobEventRouter::SendDriveFileTransferEvent,
+                       weak_factory_.GetWeakPtr()),
+        event_delay_);
+  }
+}
+
+void JobEventRouter::SendDriveFileTransferEvent() {
+  if (!pending_job_info_)
+    return;
+
+  const std::set<std::string>& extension_ids =
+      GetFileTransfersUpdateEventListenerExtensionIds();
+
+  for (const auto extension_id : extension_ids) {
+    DispatchFileTransfersUpdateEventToExtension(
+        extension_id, *pending_job_info_, pending_state_, drive_jobs_.size(),
+        num_completed_bytes_, num_total_bytes_);
+  }
+
+  pending_job_info_.reset();
+}
+
+void JobEventRouter::DispatchFileTransfersUpdateEventToExtension(
+    const std::string& extension_id,
+    const drive::JobInfo& job_info,
+    const file_manager_private::TransferState& state,
+    const int64_t num_total_jobs,
+    const int64_t num_completed_bytes,
+    const int64_t num_total_bytes) {
+  file_manager_private::FileTransferStatus status;
+
+  const GURL url =
+      ConvertDrivePathToFileSystemUrl(job_info.file_path, extension_id);
+  status.file_url = url.spec();
+  status.transfer_state = state;
+  // JavaScript does not have 64-bit integers. Instead we use double, which
+  // is in IEEE 754 formant and accurate up to 52-bits in JS, and in practice
+  // in C++. Larger values are rounded.
+  status.num_total_jobs = num_total_jobs;
+  status.processed = num_completed_bytes;
+  status.total = num_total_bytes;
+  status.hide_when_zero_jobs = false;
+
+  DispatchEventToExtension(
+      extension_id,
+      extensions::events::FILE_MANAGER_PRIVATE_ON_FILE_TRANSFERS_UPDATED,
+      file_manager_private::OnFileTransfersUpdated::kEventName,
+      file_manager_private::OnFileTransfersUpdated::Create(status));
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/extensions/api/file_manager/job_event_router.h b/chrome/browser/extensions/api/file_manager/job_event_router.h
new file mode 100644
index 0000000000000..65decda31f077
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/job_event_router.h
@@ -0,0 +1,113 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_JOB_EVENT_ROUTER_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_JOB_EVENT_ROUTER_H_
+
+#include <stdint.h>
+
+#include <map>
+#include <memory>
+#include <set>
+#include <string>
+
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/threading/thread_checker.h"
+#include "base/time/time.h"
+#include "base/values.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "components/drive/job_list.h"
+#include "extensions/browser/extension_event_histogram_value.h"
+#include "url/gurl.h"
+
+namespace file_manager {
+
+// Files app's event router handling job related events.
+class JobEventRouter : public drive::JobListObserver {
+ public:
+  explicit JobEventRouter(const base::TimeDelta& event_delay);
+  ~JobEventRouter() override;
+
+  // drive::JobListObserver overrides.
+  void OnJobAdded(const drive::JobInfo& job_info) override;
+  void OnJobUpdated(const drive::JobInfo& job_info) override;
+  void OnJobDone(const drive::JobInfo& job_info,
+                 drive::FileError error) override;
+
+ protected:
+  // Helper method for getting set of listener extension ids.
+  virtual std::set<std::string>
+  GetFileTransfersUpdateEventListenerExtensionIds() = 0;
+
+  // Helper method for converting drive path to file system url.
+  virtual GURL ConvertDrivePathToFileSystemUrl(
+      const base::FilePath& file_path,
+      const std::string& extension_id) = 0;
+
+  // Helper method for dispatching an event to an extension.
+  virtual void DispatchEventToExtension(
+      const std::string& extension_id,
+      extensions::events::HistogramValue histogram_value,
+      const std::string& event_name,
+      std::unique_ptr<base::ListValue> event_args) = 0;
+
+ private:
+  // Request sending transfer event with |job_info| and |state|.
+  // If |immediate| is true, the event will be dispatched synchronously.
+  // Otherwise, the event is throttled, or may be skipped.
+  void ScheduleDriveFileTransferEvent(
+      const drive::JobInfo& job_info,
+      extensions::api::file_manager_private::TransferState state,
+      bool immediate);
+
+  // Send transfer event requested by ScheduleDriveFileTransferEvent at last.
+  void SendDriveFileTransferEvent();
+
+  // Update |num_completed_bytes_| and |num_total_bytes_| depends on |job|.
+  void UpdateBytes(const drive::JobInfo& job_info);
+
+  // Dispatches FileTransfersUpdate event to an extension.
+  void DispatchFileTransfersUpdateEventToExtension(
+      const std::string& extension_id,
+      const drive::JobInfo& job_info,
+      const extensions::api::file_manager_private::TransferState& state,
+      const int64_t num_total_jobs,
+      const int64_t num_completed_bytes,
+      const int64_t num_total_bytes);
+
+  // Delay time before sending progress events.
+  base::TimeDelta event_delay_;
+
+  // Set of job that are in the job schedular.
+  std::map<drive::JobID, std::unique_ptr<drive::JobInfo>> drive_jobs_;
+
+  // Job info of pending event. |ScheduleDriveFileTransferEvent| registers
+  // timeout callback to dispatch this.
+  std::unique_ptr<drive::JobInfo> pending_job_info_;
+
+  // Transfer state of pending event.
+  extensions::api::file_manager_private::TransferState pending_state_;
+
+  // Computed bytes of tasks that have been processed. Once it completes all
+  // tasks, it clears the variable.
+  int64_t num_completed_bytes_;
+
+  // Total bytes of tasks that have been processed. Once it completes all tasks,
+  // it clears the variable.
+  int64_t num_total_bytes_;
+
+  // Thread checker.
+  THREAD_CHECKER(thread_checker_);
+
+  // Note: This should remain the last member so it'll be destroyed and
+  // invalidate the weak pointers before any other members are destroyed.
+  base::WeakPtrFactory<JobEventRouter> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(JobEventRouter);
+};
+
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_JOB_EVENT_ROUTER_H_
diff --git a/chrome/browser/extensions/api/file_manager/job_event_router_unittest.cc b/chrome/browser/extensions/api/file_manager/job_event_router_unittest.cc
new file mode 100644
index 0000000000000..2a3c8937668bd
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/job_event_router_unittest.cc
@@ -0,0 +1,254 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/job_event_router.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <memory>
+
+#include "base/macros.h"
+#include "base/memory/ptr_util.h"
+#include "base/message_loop/message_loop.h"
+#include "base/run_loop.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace file_manager {
+namespace {
+
+class JobEventRouterImpl : public JobEventRouter {
+ public:
+  JobEventRouterImpl() : JobEventRouter(base::TimeDelta::FromMilliseconds(0)) {
+    listener_extension_ids_.insert("extension_a");
+  }
+  std::vector<std::unique_ptr<base::DictionaryValue>> events;
+
+  void SetListenerExtensionIds(std::set<std::string> extension_ids) {
+    listener_extension_ids_ = extension_ids;
+  }
+
+ protected:
+  std::set<std::string> GetFileTransfersUpdateEventListenerExtensionIds()
+      override {
+    return listener_extension_ids_;
+  }
+
+  GURL ConvertDrivePathToFileSystemUrl(
+      const base::FilePath& file_path,
+      const std::string& extension_id) override {
+    std::string url;
+    url.append("filesystem:chrome-extension://");
+    url.append(extension_id);
+    url.append(file_path.value());
+    return GURL(url);
+  }
+
+  void DispatchEventToExtension(
+      const std::string& extension_id,
+      extensions::events::HistogramValue histogram_value,
+      const std::string& event_name,
+      std::unique_ptr<base::ListValue> event_args) override {
+    const base::DictionaryValue* event;
+    event_args->GetDictionary(0, &event);
+    events.push_back(base::WrapUnique(event->DeepCopy()));
+  }
+
+ private:
+  std::set<std::string> listener_extension_ids_;
+
+  DISALLOW_COPY_AND_ASSIGN(JobEventRouterImpl);
+};
+
+class JobEventRouterTest : public testing::Test {
+ protected:
+  void SetUp() override {
+    job_event_router = std::make_unique<JobEventRouterImpl>();
+  }
+
+  drive::JobInfo CreateJobInfo(drive::JobID id,
+                               int64_t num_completed_bytes,
+                               int64_t num_total_bytes,
+                               const base::FilePath& file_path) {
+    drive::JobInfo job(drive::TYPE_DOWNLOAD_FILE);
+    job.job_id = id;
+    job.num_total_bytes = num_total_bytes;
+    job.num_completed_bytes = num_completed_bytes;
+    job.file_path = file_path;
+    return job;
+  }
+
+  std::string GetEventString(size_t index, const std::string& name) {
+    std::string value;
+    job_event_router->events[index]->GetString(name, &value);
+    return value;
+  }
+
+  double GetEventDouble(size_t index, const std::string& name) {
+    double value = NAN;
+    job_event_router->events[index]->GetDouble(name, &value);
+    return value;
+  }
+
+  std::unique_ptr<JobEventRouterImpl> job_event_router;
+
+ private:
+  base::MessageLoop message_loop_;
+};
+
+TEST_F(JobEventRouterTest, Basic) {
+  // Add a job.
+  job_event_router->OnJobAdded(
+      CreateJobInfo(0, 0, 100, base::FilePath("/test/a")));
+  // Event should be throttled.
+  ASSERT_EQ(0u, job_event_router->events.size());
+  base::RunLoop().RunUntilIdle();
+  ASSERT_EQ(1u, job_event_router->events.size());
+  EXPECT_EQ("in_progress", GetEventString(0, "transferState"));
+  EXPECT_EQ(0.0f, GetEventDouble(0, "processed"));
+  EXPECT_EQ(100.0f, GetEventDouble(0, "total"));
+  job_event_router->events.clear();
+
+  // Job is updated.
+  job_event_router->OnJobUpdated(
+      CreateJobInfo(0, 50, 100, base::FilePath("/test/a")));
+  job_event_router->OnJobUpdated(
+      CreateJobInfo(0, 100, 100, base::FilePath("/test/a")));
+  // Event should be throttled.
+  ASSERT_EQ(0u, job_event_router->events.size());
+  base::RunLoop().RunUntilIdle();
+  ASSERT_EQ(1u, job_event_router->events.size());
+  EXPECT_EQ("in_progress", GetEventString(0, "transferState"));
+  EXPECT_EQ(100.0f, GetEventDouble(0, "processed"));
+  EXPECT_EQ(100.0f, GetEventDouble(0, "total"));
+  job_event_router->events.clear();
+
+  // Complete first job.
+  job_event_router->OnJobDone(
+      CreateJobInfo(0, 100, 100, base::FilePath("/test/a")),
+      drive::FILE_ERROR_OK);
+  // Complete event should not be throttled.
+  ASSERT_EQ(1u, job_event_router->events.size());
+  EXPECT_EQ("completed", GetEventString(0, "transferState"));
+  EXPECT_EQ(100.0f, GetEventDouble(0, "processed"));
+  EXPECT_EQ(100.0f, GetEventDouble(0, "total"));
+  job_event_router->events.clear();
+}
+
+TEST_F(JobEventRouterTest, CompleteWithInvalidCompletedBytes) {
+  job_event_router->OnJobDone(
+      CreateJobInfo(0, 50, 100, base::FilePath("/test/a")),
+      drive::FILE_ERROR_OK);
+  ASSERT_EQ(1u, job_event_router->events.size());
+  EXPECT_EQ("completed", GetEventString(0, "transferState"));
+  EXPECT_EQ(100.0f, GetEventDouble(0, "processed"));
+  EXPECT_EQ(100.0f, GetEventDouble(0, "total"));
+}
+
+TEST_F(JobEventRouterTest, AnotherJobAddedBeforeComplete) {
+  job_event_router->OnJobAdded(
+      CreateJobInfo(0, 0, 100, base::FilePath("/test/a")));
+  job_event_router->OnJobUpdated(
+      CreateJobInfo(0, 50, 100, base::FilePath("/test/a")));
+  job_event_router->OnJobAdded(
+      CreateJobInfo(1, 0, 100, base::FilePath("/test/b")));
+
+  // Event should be throttled.
+  ASSERT_EQ(0u, job_event_router->events.size());
+  base::RunLoop().RunUntilIdle();
+  ASSERT_EQ(1u, job_event_router->events.size());
+  EXPECT_EQ("in_progress", GetEventString(0, "transferState"));
+  EXPECT_EQ(50.0f, GetEventDouble(0, "processed"));
+  EXPECT_EQ(200.0f, GetEventDouble(0, "total"));
+  job_event_router->events.clear();
+
+  job_event_router->OnJobDone(
+      CreateJobInfo(0, 100, 100, base::FilePath("/test/a")),
+      drive::FILE_ERROR_OK);
+  job_event_router->OnJobDone(
+      CreateJobInfo(1, 100, 100, base::FilePath("/test/b")),
+      drive::FILE_ERROR_OK);
+  // Complete event should not be throttled.
+  ASSERT_EQ(2u, job_event_router->events.size());
+  EXPECT_EQ("completed", GetEventString(0, "transferState"));
+  EXPECT_EQ(100.0f, GetEventDouble(0, "processed"));
+  EXPECT_EQ(200.0f, GetEventDouble(0, "total"));
+  EXPECT_EQ("completed", GetEventString(1, "transferState"));
+  EXPECT_EQ(200.0f, GetEventDouble(1, "processed"));
+  EXPECT_EQ(200.0f, GetEventDouble(1, "total"));
+}
+
+TEST_F(JobEventRouterTest, AnotherJobAddedAfterComplete) {
+  job_event_router->OnJobAdded(
+      CreateJobInfo(0, 0, 100, base::FilePath("/test/a")));
+  job_event_router->OnJobUpdated(
+      CreateJobInfo(0, 50, 100, base::FilePath("/test/a")));
+  job_event_router->OnJobDone(
+      CreateJobInfo(0, 100, 100, base::FilePath("/test/a")),
+      drive::FILE_ERROR_OK);
+  job_event_router->OnJobAdded(
+      CreateJobInfo(1, 0, 100, base::FilePath("/test/b")));
+  job_event_router->OnJobDone(
+      CreateJobInfo(1, 100, 100, base::FilePath("/test/b")),
+      drive::FILE_ERROR_OK);
+
+  // Complete event should not be throttled.
+  ASSERT_EQ(2u, job_event_router->events.size());
+  EXPECT_EQ("completed", GetEventString(0, "transferState"));
+  EXPECT_EQ(100.0f, GetEventDouble(0, "processed"));
+  // Total byte shold be reset when all tasks complete.
+  EXPECT_EQ(100.0f, GetEventDouble(0, "total"));
+  EXPECT_EQ("completed", GetEventString(1, "transferState"));
+  EXPECT_EQ(100.0f, GetEventDouble(1, "processed"));
+  EXPECT_EQ(100.0f, GetEventDouble(1, "total"));
+}
+
+TEST_F(JobEventRouterTest, UpdateTotalSizeAfterAdded) {
+  job_event_router->OnJobAdded(
+      CreateJobInfo(0, 0, 0, base::FilePath("/test/a")));
+  base::RunLoop().RunUntilIdle();
+  job_event_router->OnJobUpdated(
+      CreateJobInfo(0, 0, 100, base::FilePath("/test/a")));
+  base::RunLoop().RunUntilIdle();
+
+  ASSERT_EQ(2u, job_event_router->events.size());
+
+  EXPECT_EQ("in_progress", GetEventString(0, "transferState"));
+  EXPECT_EQ(0.0f, GetEventDouble(0, "processed"));
+  EXPECT_EQ(0.0f, GetEventDouble(0, "total"));
+
+  EXPECT_EQ("in_progress", GetEventString(1, "transferState"));
+  EXPECT_EQ(0.0f, GetEventDouble(1, "processed"));
+  EXPECT_EQ(100.0f, GetEventDouble(1, "total"));
+}
+
+TEST_F(JobEventRouterTest, MultipleListenerExtensions) {
+  std::set<std::string> extension_ids;
+  extension_ids.insert("extension_a");
+  extension_ids.insert("extension_b");
+  job_event_router->SetListenerExtensionIds(extension_ids);
+
+  // Add a job.
+  job_event_router->OnJobAdded(
+      CreateJobInfo(0, 0, 100, base::FilePath("/test/a")));
+  base::RunLoop().RunUntilIdle();
+  ASSERT_EQ(2u, job_event_router->events.size());
+
+  // Check event for extension_a.
+  EXPECT_EQ("in_progress", GetEventString(0, "transferState"));
+  EXPECT_EQ(0.0f, GetEventDouble(0, "processed"));
+  EXPECT_EQ(100.0f, GetEventDouble(0, "total"));
+  EXPECT_EQ("filesystem:chrome-extension://extension_a/test/a",
+            GetEventString(0, "fileUrl"));
+
+  // Check event for extension_b.
+  EXPECT_EQ("in_progress", GetEventString(1, "transferState"));
+  EXPECT_EQ(0.0f, GetEventDouble(1, "processed"));
+  EXPECT_EQ(100.0f, GetEventDouble(1, "total"));
+  EXPECT_EQ("filesystem:chrome-extension://extension_b/test/a",
+            GetEventString(1, "fileUrl"));
+}
+
+}  // namespace
+}  // namespace file_manager
diff --git a/chrome/browser/extensions/api/file_manager/private_api_base.cc b/chrome/browser/extensions/api/file_manager/private_api_base.cc
new file mode 100644
index 0000000000000..71178d9e3943c
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/private_api_base.cc
@@ -0,0 +1,46 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/private_api_base.h"
+
+#include <stdint.h>
+
+#include "base/strings/string_number_conversions.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+#include "components/drive/event_logger.h"
+
+namespace extensions {
+namespace {
+
+const int kSlowOperationThresholdMs = 500;  // In ms.
+
+}  // namespace
+
+LoggedAsyncExtensionFunction::LoggedAsyncExtensionFunction()
+    : log_on_completion_(false) {
+  start_time_  = base::Time::Now();
+}
+
+LoggedAsyncExtensionFunction::~LoggedAsyncExtensionFunction() = default;
+
+void LoggedAsyncExtensionFunction::OnResponded() {
+  drive::EventLogger* logger = file_manager::util::GetLogger(GetProfile());
+  if (logger) {
+    int64_t elapsed = (base::Time::Now() - start_time_).InMilliseconds();
+    DCHECK(response_type());
+    bool success = *response_type() == SUCCEEDED;
+    if (log_on_completion_) {
+      logger->Log(logging::LOG_INFO, "%s[%d] %s. (elapsed time: %sms)", name(),
+                  request_id(), success ? "succeeded" : "failed",
+                  base::Int64ToString(elapsed).c_str());
+    } else if (elapsed >= kSlowOperationThresholdMs) {
+      logger->Log(logging::LOG_WARNING,
+                  "PEFORMANCE WARNING: %s[%d] was slow. (elapsed time: %sms)",
+                  name(), request_id(), base::Int64ToString(elapsed).c_str());
+    }
+  }
+  ChromeAsyncExtensionFunction::OnResponded();
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_manager/private_api_base.h b/chrome/browser/extensions/api/file_manager/private_api_base.h
new file mode 100644
index 0000000000000..83d404bedd1b6
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/private_api_base.h
@@ -0,0 +1,45 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file contains base classes for fileManagerPrivate API.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_BASE_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_BASE_H_
+
+#include "base/time/time.h"
+#include "chrome/browser/extensions/chrome_extension_function.h"
+
+namespace extensions {
+
+// This class adds a logging feature to ChromeAsyncExtensionFunction. Logging is
+// done when sending the response to JavaScript, using drive::util::Log().
+// Async API functions of fileManagerPrivate should inherit this class.
+//
+// By default, logging is turned off, hence sub classes should call
+// set_log_on_completion(true) to enable it, if they want. However, even if
+// the logging is turned off, a warning is emitted when a function call is
+// very slow. See the implementation of OnResponded() for details.
+class LoggedAsyncExtensionFunction : public ChromeAsyncExtensionFunction {
+ public:
+  LoggedAsyncExtensionFunction();
+
+ protected:
+  ~LoggedAsyncExtensionFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  void OnResponded() override;
+
+  // Sets the logging on completion flag. By default, logging is turned off.
+  void set_log_on_completion(bool log_on_completion) {
+    log_on_completion_ = log_on_completion;
+  }
+
+ private:
+  base::Time start_time_;
+  bool log_on_completion_;
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_BASE_H_
diff --git a/chrome/browser/extensions/api/file_manager/private_api_dialog.cc b/chrome/browser/extensions/api/file_manager/private_api_dialog.cc
new file mode 100644
index 0000000000000..19717c5893a9e
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/private_api_dialog.cc
@@ -0,0 +1,134 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/private_api_dialog.h"
+
+#include <stddef.h>
+
+#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/tabs/tab_strip_model.h"
+#include "chrome/browser/ui/views/select_file_dialog_extension.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "content/public/browser/browser_thread.h"
+#include "extensions/browser/extension_function_dispatcher.h"
+#include "ui/shell_dialogs/selected_file_info.h"
+
+using content::BrowserThread;
+
+namespace extensions {
+
+namespace {
+
+// TODO(https://crbug.com/844654): This should be using something more
+// deterministic.
+content::WebContents* GetAssociatedWebContentsDeprecated(
+    ChromeAsyncExtensionFunction* function) {
+  if (function->dispatcher()) {
+    content::WebContents* web_contents =
+        function->dispatcher()->GetAssociatedWebContents();
+    if (web_contents)
+      return web_contents;
+  }
+
+  Browser* browser =
+      ChromeExtensionFunctionDetails(function).GetCurrentBrowser();
+  if (!browser)
+    return nullptr;
+  return browser->tab_strip_model()->GetActiveWebContents();
+}
+
+// Computes the routing ID for SelectFileDialogExtension from the |function|.
+SelectFileDialogExtension::RoutingID GetFileDialogRoutingID(
+    ChromeAsyncExtensionFunction* function) {
+  return SelectFileDialogExtension::GetRoutingIDFromWebContents(
+      GetAssociatedWebContentsDeprecated(function));
+}
+
+}  // namespace
+
+bool FileManagerPrivateCancelDialogFunction::RunAsync() {
+  SelectFileDialogExtension::OnFileSelectionCanceled(
+      GetFileDialogRoutingID(this));
+  SendResponse(true);
+  return true;
+}
+
+bool FileManagerPrivateSelectFileFunction::RunAsync() {
+  using extensions::api::file_manager_private::SelectFile::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  std::vector<GURL> file_paths;
+  file_paths.emplace_back(params->selected_path);
+
+  file_manager::util::GetSelectedFileInfoLocalPathOption option =
+      file_manager::util::NO_LOCAL_PATH_RESOLUTION;
+  if (params->should_return_local_path) {
+    option = params->for_opening ?
+        file_manager::util::NEED_LOCAL_PATH_FOR_OPENING :
+        file_manager::util::NEED_LOCAL_PATH_FOR_SAVING;
+  }
+
+  file_manager::util::GetSelectedFileInfo(
+      render_frame_host(),
+      GetProfile(),
+      file_paths,
+      option,
+      base::Bind(
+          &FileManagerPrivateSelectFileFunction::GetSelectedFileInfoResponse,
+          this,
+          params->index));
+  return true;
+}
+
+void FileManagerPrivateSelectFileFunction::GetSelectedFileInfoResponse(
+    int index,
+    const std::vector<ui::SelectedFileInfo>& files) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  if (files.size() != 1) {
+    SendResponse(false);
+    return;
+  }
+  SelectFileDialogExtension::OnFileSelected(GetFileDialogRoutingID(this),
+                                            files[0], index);
+  SendResponse(true);
+}
+
+bool FileManagerPrivateSelectFilesFunction::RunAsync() {
+  using extensions::api::file_manager_private::SelectFiles::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  std::vector<GURL> file_urls;
+  for (size_t i = 0; i < params->selected_paths.size(); ++i)
+    file_urls.emplace_back(params->selected_paths[i]);
+
+  file_manager::util::GetSelectedFileInfo(
+      render_frame_host(),
+      GetProfile(),
+      file_urls,
+      params->should_return_local_path ?
+          file_manager::util::NEED_LOCAL_PATH_FOR_OPENING :
+          file_manager::util::NO_LOCAL_PATH_RESOLUTION,
+      base::Bind(
+          &FileManagerPrivateSelectFilesFunction::GetSelectedFileInfoResponse,
+          this));
+  return true;
+}
+
+void FileManagerPrivateSelectFilesFunction::GetSelectedFileInfoResponse(
+    const std::vector<ui::SelectedFileInfo>& files) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  if (files.empty()) {
+    SendResponse(false);
+    return;
+  }
+
+  SelectFileDialogExtension::OnMultiFilesSelected(GetFileDialogRoutingID(this),
+                                                  files);
+  SendResponse(true);
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_manager/private_api_dialog.h b/chrome/browser/extensions/api/file_manager/private_api_dialog.h
new file mode 100644
index 0000000000000..201a009bd12bc
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/private_api_dialog.h
@@ -0,0 +1,75 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides API functions for the file manager to act as the file
+// dialog for opening and saving files.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_DIALOG_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_DIALOG_H_
+
+#include <vector>
+
+#include "chrome/browser/extensions/api/file_manager/private_api_base.h"
+
+namespace ui {
+struct SelectedFileInfo;
+}
+
+namespace extensions {
+
+// Cancel file selection Dialog.  Closes the dialog window.
+class FileManagerPrivateCancelDialogFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.cancelDialog",
+                             FILEMANAGERPRIVATE_CANCELDIALOG)
+
+ protected:
+  ~FileManagerPrivateCancelDialogFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+class FileManagerPrivateSelectFileFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.selectFile",
+                             FILEMANAGERPRIVATE_SELECTFILE)
+
+ protected:
+  ~FileManagerPrivateSelectFileFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  // A callback method to handle the result of GetSelectedFileInfo.
+  void GetSelectedFileInfoResponse(
+      int index,
+      const std::vector<ui::SelectedFileInfo>& files);
+};
+
+// Select multiple files.  Closes the dialog window.
+class FileManagerPrivateSelectFilesFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.selectFiles",
+                             FILEMANAGERPRIVATE_SELECTFILES)
+
+ protected:
+  ~FileManagerPrivateSelectFilesFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  // A callback method to handle the result of GetSelectedFileInfo.
+  void GetSelectedFileInfoResponse(
+      const std::vector<ui::SelectedFileInfo>& files);
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_DIALOG_H_
diff --git a/chrome/browser/extensions/api/file_manager/private_api_drive.cc b/chrome/browser/extensions/api/file_manager/private_api_drive.cc
new file mode 100644
index 0000000000000..61184c32c9690
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/private_api_drive.cc
@@ -0,0 +1,1565 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/private_api_drive.h"
+
+#include <map>
+#include <memory>
+#include <set>
+#include <utility>
+
+#include "base/base64.h"
+#include "base/command_line.h"
+#include "base/memory/ptr_util.h"
+#include "base/strings/strcat.h"
+#include "base/task/post_task.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/chromeos/file_system_provider/mount_path_util.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_interface.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+#include "chrome/browser/file_manager/file_tasks.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/url_util.h"
+#include "chrome/browser/fileapi/external_file_url_util.h"
+#include "chrome/browser/fileapi/file_system_backend.h"
+#include "chrome/browser/chromeos/profiles/profile_helper.h"
+#include "chrome/browser/net/system_network_context_manager.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/browser/signin/profile_oauth2_token_service_factory.h"
+#include "chrome/browser/signin/signin_manager_factory.h"
+#include "chrome/common/extensions/api/file_manager_private_internal.h"
+#include "chromeos/chromeos_switches.h"
+#include "chromeos/network/network_handler.h"
+#include "chromeos/network/network_state_handler.h"
+#include "components/drive/drive_app_registry.h"
+#include "components/drive/event_logger.h"
+#include "components/signin/core/browser/profile_oauth2_token_service.h"
+#include "components/signin/core/browser/signin_manager.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/storage_partition.h"
+#include "google_apis/drive/auth_service.h"
+#include "google_apis/drive/drive_api_url_generator.h"
+#include "google_apis/drive/drive_switches.h"
+#include "mojo/public/cpp/bindings/callback_helpers.h"
+#include "services/network/public/cpp/shared_url_loader_factory.h"
+#include "storage/common/fileapi/file_system_info.h"
+#include "storage/common/fileapi/file_system_util.h"
+#include "url/gurl.h"
+
+using content::BrowserThread;
+
+using chromeos::file_system_provider::EntryMetadata;
+using chromeos::file_system_provider::ProvidedFileSystemInterface;
+using chromeos::file_system_provider::util::FileSystemURLParser;
+using extensions::api::file_manager_private::EntryProperties;
+using extensions::api::file_manager_private::EntryPropertyName;
+using file_manager::util::EntryDefinition;
+using file_manager::util::EntryDefinitionCallback;
+using file_manager::util::EntryDefinitionList;
+using file_manager::util::EntryDefinitionListCallback;
+using file_manager::util::FileDefinition;
+using file_manager::util::FileDefinitionList;
+using google_apis::DriveApiUrlGenerator;
+
+namespace extensions {
+namespace {
+
+// List of connection types of drive.
+// Keep this in sync with the DriveConnectionType in common/js/util.js.
+const char kDriveConnectionTypeOffline[] = "offline";
+const char kDriveConnectionTypeMetered[] = "metered";
+const char kDriveConnectionTypeOnline[] = "online";
+
+// List of reasons of kDriveConnectionType*.
+// Keep this in sync with the DriveConnectionReason in common/js/util.js.
+const char kDriveConnectionReasonNotReady[] = "not_ready";
+const char kDriveConnectionReasonNoNetwork[] = "no_network";
+const char kDriveConnectionReasonNoService[] = "no_service";
+
+// Maximum dimension of thumbnail in file manager. File manager shows 180x180
+// thumbnail. Given that we support hdpi devices, maximum dimension is 360.
+const int kFileManagerMaximumThumbnailDimension = 360;
+
+std::unique_ptr<std::string> GetShareUrlFromAlternateUrl(
+    const GURL& alternate_url) {
+  // Set |share_url| to a modified version of |alternate_url| that opens the
+  // sharing dialog for files and folders (add ?userstoinvite="" to the URL).
+  // TODO(sashab): Add an endpoint to the Drive API that generates this URL,
+  // instead of manually modifying it here.
+  GURL::Replacements replacements;
+  std::string new_query =
+      (alternate_url.has_query() ? alternate_url.query() + "&" : "") +
+      "userstoinvite=%22%22";
+  replacements.SetQueryStr(new_query);
+
+  return std::make_unique<std::string>(
+      alternate_url.ReplaceComponents(replacements).spec());
+}
+
+// Copies properties from |entry_proto| to |properties|. |shared_with_me| is
+// given from the running profile.
+void FillEntryPropertiesValueForDrive(const drive::ResourceEntry& entry_proto,
+                                      bool shared_with_me,
+                                      EntryProperties* properties) {
+  properties->shared_with_me = std::make_unique<bool>(shared_with_me);
+  properties->shared = std::make_unique<bool>(entry_proto.shared());
+  properties->starred = std::make_unique<bool>(entry_proto.starred());
+
+  const drive::PlatformFileInfoProto& file_info = entry_proto.file_info();
+  properties->size = std::make_unique<double>(file_info.size());
+  properties->modification_time = std::make_unique<double>(
+      base::Time::FromInternalValue(file_info.last_modified()).ToJsTime());
+  properties->modification_by_me_time = std::make_unique<double>(
+      base::Time::FromInternalValue(entry_proto.last_modified_by_me())
+          .ToJsTime());
+
+  if (entry_proto.has_alternate_url()) {
+    properties->alternate_url =
+        std::make_unique<std::string>(entry_proto.alternate_url());
+    properties->share_url =
+        GetShareUrlFromAlternateUrl(GURL(entry_proto.alternate_url()));
+  }
+
+  if (entry_proto.has_file_specific_info()) {
+    const drive::FileSpecificInfo& file_specific_info =
+        entry_proto.file_specific_info();
+
+    if (!entry_proto.resource_id().empty()) {
+      DriveApiUrlGenerator url_generator(
+          (GURL(google_apis::DriveApiUrlGenerator::kBaseUrlForProduction)),
+          (GURL(google_apis::DriveApiUrlGenerator::
+                    kBaseThumbnailUrlForProduction)),
+          google_apis::GetTeamDrivesIntegrationSwitch());
+      properties->thumbnail_url = std::make_unique<std::string>(
+          url_generator
+              .GetThumbnailUrl(entry_proto.resource_id(), 500 /* width */,
+                               500 /* height */, false /* not cropped */)
+              .spec());
+      properties->cropped_thumbnail_url = std::make_unique<std::string>(
+          url_generator
+              .GetThumbnailUrl(
+                  entry_proto.resource_id(),
+                  kFileManagerMaximumThumbnailDimension /* width */,
+                  kFileManagerMaximumThumbnailDimension /* height */,
+                  true /* cropped */)
+              .spec());
+    }
+    if (file_specific_info.has_image_width()) {
+      properties->image_width =
+          std::make_unique<int>(file_specific_info.image_width());
+    }
+    if (file_specific_info.has_image_height()) {
+      properties->image_height =
+          std::make_unique<int>(file_specific_info.image_height());
+    }
+    if (file_specific_info.has_image_rotation()) {
+      properties->image_rotation =
+          std::make_unique<int>(file_specific_info.image_rotation());
+    }
+    properties->hosted =
+        std::make_unique<bool>(file_specific_info.is_hosted_document());
+    properties->content_mime_type =
+        std::make_unique<std::string>(file_specific_info.content_mime_type());
+    properties->pinned =
+        std::make_unique<bool>(file_specific_info.cache_state().is_pinned());
+    properties->dirty =
+        std::make_unique<bool>(file_specific_info.cache_state().is_dirty());
+    properties->present =
+        std::make_unique<bool>(file_specific_info.cache_state().is_present());
+
+    if (file_specific_info.cache_state().is_present()) {
+      properties->available_offline = std::make_unique<bool>(true);
+    } else if (file_specific_info.is_hosted_document() &&
+               file_specific_info.has_document_extension()) {
+      const std::string file_extension =
+          file_specific_info.document_extension();
+      // What's available offline? See the 'Web' column at:
+      // https://support.google.com/drive/answer/1628467
+      properties->available_offline = std::make_unique<bool>(
+          file_extension == ".gdoc" || file_extension == ".gdraw" ||
+          file_extension == ".gsheet" || file_extension == ".gslides");
+    } else {
+      properties->available_offline = std::make_unique<bool>(false);
+    }
+
+    properties->available_when_metered =
+        std::make_unique<bool>(file_specific_info.cache_state().is_present() ||
+                               file_specific_info.is_hosted_document());
+  }
+
+  if (entry_proto.has_capabilities_info()) {
+    const drive::CapabilitiesInfo& capabilities_info =
+        entry_proto.capabilities_info();
+
+    // Only set the |can_copy| capability for hosted documents; for other files,
+    // we must have read access, so |can_copy| is implicitly true.
+    bool can_copy = true;
+    if (entry_proto.has_file_specific_info() &&
+        entry_proto.file_specific_info().is_hosted_document() &&
+        capabilities_info.has_can_copy()) {
+      can_copy = capabilities_info.can_copy();
+    }
+    properties->can_copy = std::make_unique<bool>(can_copy);
+
+    properties->can_delete = std::make_unique<bool>(
+        capabilities_info.has_can_delete() ? capabilities_info.can_delete()
+                                           : true);
+    properties->can_rename = std::make_unique<bool>(
+        capabilities_info.has_can_rename() ? capabilities_info.can_rename()
+                                           : true);
+
+    // |can_add_children| defaults to true for directories, and false for files.
+    properties->can_add_children =
+        std::make_unique<bool>(capabilities_info.has_can_add_children()
+                                   ? capabilities_info.can_add_children()
+                                   : file_info.is_directory());
+
+    properties->can_share = std::make_unique<bool>(
+        capabilities_info.has_can_share() ? capabilities_info.can_share()
+                                          : true);
+  }
+}
+
+// Creates entry definition list for (metadata) search result info list.
+template <class T>
+void ConvertSearchResultInfoListToEntryDefinitionList(
+    Profile* profile,
+    const std::string& extension_id,
+    const std::vector<T>& search_result_info_list,
+    const EntryDefinitionListCallback& callback) {
+  FileDefinitionList file_definition_list;
+
+  for (size_t i = 0; i < search_result_info_list.size(); ++i) {
+    FileDefinition file_definition;
+    file_definition.virtual_path =
+        file_manager::util::ConvertDrivePathToRelativeFileSystemPath(
+            profile, extension_id, search_result_info_list.at(i).path);
+    file_definition.is_directory = search_result_info_list.at(i).is_directory;
+    file_definition_list.push_back(file_definition);
+  }
+
+  file_manager::util::ConvertFileDefinitionListToEntryDefinitionList(
+      profile,
+      extension_id,
+      file_definition_list,  // Safe, since copied internally.
+      callback);
+}
+
+class SingleEntryPropertiesGetterForDrive {
+ public:
+  typedef base::Callback<void(std::unique_ptr<EntryProperties> properties,
+                              base::File::Error error)>
+      ResultCallback;
+
+  // Creates an instance and starts the process.
+  static void Start(const base::FilePath local_path,
+                    const std::set<EntryPropertyName>& names,
+                    Profile* const profile,
+                    const ResultCallback& callback) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    SingleEntryPropertiesGetterForDrive* instance =
+        new SingleEntryPropertiesGetterForDrive(local_path, names, profile,
+                                                callback);
+    instance->StartProcess();
+
+    // The instance will be destroyed by itself.
+  }
+
+  virtual ~SingleEntryPropertiesGetterForDrive() = default;
+
+ private:
+  SingleEntryPropertiesGetterForDrive(
+      const base::FilePath local_path,
+      const std::set<EntryPropertyName>& /* names */,
+      Profile* const profile,
+      const ResultCallback& callback)
+      : callback_(callback),
+        local_path_(local_path),
+        running_profile_(profile),
+        properties_(new EntryProperties),
+        file_owner_profile_(nullptr),
+        weak_ptr_factory_(this) {
+    DCHECK(!callback_.is_null());
+    DCHECK(profile);
+  }
+
+  void StartProcess() {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    file_path_ = drive::util::ExtractDrivePath(local_path_);
+    file_owner_profile_ = drive::util::ExtractProfileFromPath(local_path_);
+
+    if (!file_owner_profile_ ||
+        !g_browser_process->profile_manager()->IsValidProfile(
+            file_owner_profile_)) {
+      CompleteGetEntryProperties(drive::FILE_ERROR_FAILED);
+      return;
+    }
+
+    // Start getting the file info.
+    drive::FileSystemInterface* const file_system =
+        drive::util::GetFileSystemByProfile(file_owner_profile_);
+    if (!file_system) {
+      // |file_system| is NULL if Drive is disabled or not mounted.
+      CompleteGetEntryProperties(drive::FILE_ERROR_FAILED);
+      return;
+    }
+
+    file_system->GetResourceEntry(
+        file_path_,
+        base::BindOnce(&SingleEntryPropertiesGetterForDrive::OnGetFileInfo,
+                       weak_ptr_factory_.GetWeakPtr()));
+  }
+
+  void OnGetFileInfo(drive::FileError error,
+                     std::unique_ptr<drive::ResourceEntry> entry) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    if (error != drive::FILE_ERROR_OK) {
+      CompleteGetEntryProperties(error);
+      return;
+    }
+
+    DCHECK(entry);
+    owner_resource_entry_.swap(entry);
+
+    if (running_profile_->IsSameProfile(file_owner_profile_)) {
+      StartParseFileInfo(owner_resource_entry_->shared_with_me());
+      return;
+    }
+
+    // If the running profile does not own the file, obtain the shared_with_me
+    // flag from the running profile's value.
+    drive::FileSystemInterface* const file_system =
+        drive::util::GetFileSystemByProfile(running_profile_);
+    if (!file_system) {
+      CompleteGetEntryProperties(drive::FILE_ERROR_FAILED);
+      return;
+    }
+    file_system->GetPathFromResourceId(
+        owner_resource_entry_->resource_id(),
+        base::Bind(&SingleEntryPropertiesGetterForDrive::OnGetRunningPath,
+                   weak_ptr_factory_.GetWeakPtr()));
+  }
+
+  void OnGetRunningPath(drive::FileError error,
+                        const base::FilePath& file_path) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    if (error != drive::FILE_ERROR_OK) {
+      // The running profile does not know the file.
+      StartParseFileInfo(false);
+      return;
+    }
+
+    drive::FileSystemInterface* const file_system =
+        drive::util::GetFileSystemByProfile(running_profile_);
+    if (!file_system) {
+      // The drive is disable for the running profile.
+      StartParseFileInfo(false);
+      return;
+    }
+
+    file_system->GetResourceEntry(
+        file_path,
+        base::BindOnce(&SingleEntryPropertiesGetterForDrive::OnGetShareInfo,
+                       weak_ptr_factory_.GetWeakPtr()));
+  }
+
+  void OnGetShareInfo(drive::FileError error,
+                      std::unique_ptr<drive::ResourceEntry> entry) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    if (error != drive::FILE_ERROR_OK) {
+      CompleteGetEntryProperties(error);
+      return;
+    }
+
+    DCHECK(entry.get());
+    StartParseFileInfo(entry->shared_with_me());
+  }
+
+  void StartParseFileInfo(bool shared_with_me) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    FillEntryPropertiesValueForDrive(
+        *owner_resource_entry_, shared_with_me, properties_.get());
+
+    drive::FileSystemInterface* const file_system =
+        drive::util::GetFileSystemByProfile(file_owner_profile_);
+    drive::DriveAppRegistry* const app_registry =
+        drive::util::GetDriveAppRegistryByProfile(file_owner_profile_);
+    if (!file_system || !app_registry) {
+      // |file_system| or |app_registry| is NULL if Drive is disabled.
+      CompleteGetEntryProperties(drive::FILE_ERROR_FAILED);
+      return;
+    }
+
+    // The properties meaningful for directories are already filled in
+    // FillEntryPropertiesValueForDrive().
+    if (!owner_resource_entry_->has_file_specific_info()) {
+      CompleteGetEntryProperties(drive::FILE_ERROR_OK);
+      return;
+    }
+
+    const drive::FileSpecificInfo& file_specific_info =
+        owner_resource_entry_->file_specific_info();
+
+    // Get drive WebApps that can accept this file. We just need to extract the
+    // doc icon for the drive app, which is set as default.
+    std::vector<drive::DriveAppInfo> drive_apps;
+    app_registry->GetAppsForFile(file_path_.Extension(),
+                                 file_specific_info.content_mime_type(),
+                                 &drive_apps);
+    if (!drive_apps.empty()) {
+      std::string default_task_id =
+          file_manager::file_tasks::GetDefaultTaskIdFromPrefs(
+              *file_owner_profile_->GetPrefs(),
+              file_specific_info.content_mime_type(),
+              file_path_.Extension());
+      file_manager::file_tasks::TaskDescriptor default_task;
+      file_manager::file_tasks::ParseTaskID(default_task_id, &default_task);
+      DCHECK(default_task_id.empty() || !default_task.app_id.empty());
+      for (size_t i = 0; i < drive_apps.size(); ++i) {
+        const drive::DriveAppInfo& app_info = drive_apps[i];
+        if (default_task.app_id == app_info.app_id) {
+          // The drive app is set as default. The Files app should use the doc
+          // icon.
+          const GURL doc_icon = drive::util::FindPreferredIcon(
+              app_info.document_icons, drive::util::kPreferredIconSize);
+          properties_->custom_icon_url =
+              std::make_unique<std::string>(doc_icon.spec());
+        }
+      }
+    }
+
+    CompleteGetEntryProperties(drive::FILE_ERROR_OK);
+  }
+
+  void CompleteGetEntryProperties(drive::FileError error) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+    DCHECK(!callback_.is_null());
+
+    callback_.Run(std::move(properties_),
+                  drive::FileErrorToBaseFileError(error));
+    BrowserThread::DeleteSoon(BrowserThread::UI, FROM_HERE, this);
+  }
+
+  // Given parameters.
+  const ResultCallback callback_;
+  const base::FilePath local_path_;
+  Profile* const running_profile_;
+
+  // Values used in the process.
+  std::unique_ptr<EntryProperties> properties_;
+  Profile* file_owner_profile_;
+  base::FilePath file_path_;
+  std::unique_ptr<drive::ResourceEntry> owner_resource_entry_;
+
+  base::WeakPtrFactory<SingleEntryPropertiesGetterForDrive> weak_ptr_factory_;
+};  // class SingleEntryPropertiesGetterForDrive
+
+class SingleEntryPropertiesGetterForFileSystemProvider {
+ public:
+  typedef base::Callback<void(std::unique_ptr<EntryProperties> properties,
+                              base::File::Error error)>
+      ResultCallback;
+
+  // Creates an instance and starts the process.
+  static void Start(const storage::FileSystemURL file_system_url,
+                    const std::set<EntryPropertyName>& names,
+                    const ResultCallback& callback) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    SingleEntryPropertiesGetterForFileSystemProvider* instance =
+        new SingleEntryPropertiesGetterForFileSystemProvider(file_system_url,
+                                                             names, callback);
+    instance->StartProcess();
+
+    // The instance will be destroyed by itself.
+  }
+
+  virtual ~SingleEntryPropertiesGetterForFileSystemProvider() = default;
+
+ private:
+  SingleEntryPropertiesGetterForFileSystemProvider(
+      const storage::FileSystemURL& file_system_url,
+      const std::set<EntryPropertyName>& names,
+      const ResultCallback& callback)
+      : callback_(callback),
+        file_system_url_(file_system_url),
+        names_(names),
+        properties_(new EntryProperties),
+        weak_ptr_factory_(this) {
+    DCHECK(!callback_.is_null());
+  }
+
+  void StartProcess() {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    FileSystemURLParser parser(file_system_url_);
+    if (!parser.Parse()) {
+      CompleteGetEntryProperties(base::File::FILE_ERROR_NOT_FOUND);
+      return;
+    }
+
+    ProvidedFileSystemInterface::MetadataFieldMask field_mask =
+        ProvidedFileSystemInterface::METADATA_FIELD_NONE;
+    if (names_.find(api::file_manager_private::ENTRY_PROPERTY_NAME_SIZE) !=
+        names_.end()) {
+      field_mask |= ProvidedFileSystemInterface::METADATA_FIELD_SIZE;
+    }
+    if (names_.find(
+            api::file_manager_private::ENTRY_PROPERTY_NAME_MODIFICATIONTIME) !=
+        names_.end()) {
+      field_mask |=
+          ProvidedFileSystemInterface::METADATA_FIELD_MODIFICATION_TIME;
+    }
+    if (names_.find(
+            api::file_manager_private::ENTRY_PROPERTY_NAME_CONTENTMIMETYPE) !=
+        names_.end()) {
+      field_mask |= ProvidedFileSystemInterface::METADATA_FIELD_MIME_TYPE;
+    }
+    if (names_.find(
+            api::file_manager_private::ENTRY_PROPERTY_NAME_THUMBNAILURL) !=
+        names_.end()) {
+      field_mask |= ProvidedFileSystemInterface::METADATA_FIELD_THUMBNAIL;
+    }
+
+    parser.file_system()->GetMetadata(
+        parser.file_path(), field_mask,
+        base::BindOnce(&SingleEntryPropertiesGetterForFileSystemProvider::
+                           OnGetMetadataCompleted,
+                       weak_ptr_factory_.GetWeakPtr()));
+  }
+
+  void OnGetMetadataCompleted(std::unique_ptr<EntryMetadata> metadata,
+                              base::File::Error result) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    if (result != base::File::FILE_OK) {
+      CompleteGetEntryProperties(result);
+      return;
+    }
+
+    if (names_.find(api::file_manager_private::ENTRY_PROPERTY_NAME_SIZE) !=
+        names_.end()) {
+      properties_->size = std::make_unique<double>(*metadata->size.get());
+    }
+
+    if (names_.find(
+            api::file_manager_private::ENTRY_PROPERTY_NAME_MODIFICATIONTIME) !=
+        names_.end()) {
+      properties_->modification_time =
+          std::make_unique<double>(metadata->modification_time->ToJsTime());
+    }
+
+    if (names_.find(
+            api::file_manager_private::ENTRY_PROPERTY_NAME_CONTENTMIMETYPE) !=
+            names_.end() &&
+        metadata->mime_type.get()) {
+      properties_->content_mime_type =
+          std::make_unique<std::string>(*metadata->mime_type);
+    }
+
+    if (names_.find(
+            api::file_manager_private::ENTRY_PROPERTY_NAME_THUMBNAILURL) !=
+            names_.end() &&
+        metadata->thumbnail.get()) {
+      properties_->thumbnail_url =
+          std::make_unique<std::string>(*metadata->thumbnail);
+    }
+
+    CompleteGetEntryProperties(base::File::FILE_OK);
+  }
+
+  void CompleteGetEntryProperties(base::File::Error result) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+    DCHECK(!callback_.is_null());
+
+    callback_.Run(std::move(properties_), result);
+    BrowserThread::DeleteSoon(BrowserThread::UI, FROM_HERE, this);
+  }
+
+  // Given parameters.
+  const ResultCallback callback_;
+  const storage::FileSystemURL file_system_url_;
+  const std::set<EntryPropertyName> names_;
+
+  // Values used in the process.
+  std::unique_ptr<EntryProperties> properties_;
+
+  base::WeakPtrFactory<SingleEntryPropertiesGetterForFileSystemProvider>
+      weak_ptr_factory_;
+};  // class SingleEntryPropertiesGetterForDrive
+
+class SingleEntryPropertiesGetterForDriveFs {
+ public:
+  using ResultCallback =
+      base::OnceCallback<void(std::unique_ptr<EntryProperties> properties,
+                              base::File::Error error)>;
+
+  // Creates an instance and starts the process.
+  static void Start(base::FilePath local_path,
+                    bool want_thumbnail,
+                    Profile* const profile,
+                    ResultCallback callback) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    SingleEntryPropertiesGetterForDriveFs* instance =
+        new SingleEntryPropertiesGetterForDriveFs(std::move(local_path),
+                                                  want_thumbnail, profile,
+                                                  std::move(callback));
+    instance->StartProcess();
+
+    // The instance will be destroyed by itself.
+  }
+
+ private:
+  SingleEntryPropertiesGetterForDriveFs(base::FilePath local_path,
+                                        bool want_thumbnail,
+                                        Profile* const profile,
+                                        ResultCallback callback)
+      : callback_(std::move(callback)),
+        local_path_(std::move(local_path)),
+        want_thumbnail_(want_thumbnail),
+        running_profile_(profile),
+        properties_(std::make_unique<EntryProperties>()),
+        weak_ptr_factory_(this) {
+    DCHECK(callback_);
+    DCHECK(profile);
+  }
+
+  void StartProcess() {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    drive::DriveIntegrationService* integration_service =
+        drive::DriveIntegrationServiceFactory::FindForProfile(running_profile_);
+    if (!integration_service || !integration_service->IsMounted()) {
+      CompleteGetEntryProperties(drive::FILE_ERROR_SERVICE_UNAVAILABLE);
+      return;
+    }
+    base::FilePath path;
+    if (!integration_service->GetRelativeDrivePath(local_path_, &path)) {
+      CompleteGetEntryProperties(drive::FILE_ERROR_INVALID_OPERATION);
+      return;
+    }
+
+    auto* drivefs_interface = integration_service->GetDriveFsInterface();
+    if (!drivefs_interface) {
+      CompleteGetEntryProperties(drive::FILE_ERROR_SERVICE_UNAVAILABLE);
+      return;
+    }
+
+    drivefs_interface->GetMetadata(
+        path, want_thumbnail_,
+        mojo::WrapCallbackWithDefaultInvokeIfNotRun(
+            base::BindOnce(
+                &SingleEntryPropertiesGetterForDriveFs::OnGetFileInfo,
+                weak_ptr_factory_.GetWeakPtr()),
+            drive::FILE_ERROR_SERVICE_UNAVAILABLE, nullptr));
+  }
+
+  void OnGetFileInfo(drive::FileError error,
+                     drivefs::mojom::FileMetadataPtr metadata) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    if (!metadata) {
+      CompleteGetEntryProperties(error);
+      return;
+    }
+
+    properties_->size = std::make_unique<double>(metadata->size);
+    properties_->available_offline =
+        std::make_unique<bool>(metadata->available_offline);
+    properties_->present = std::make_unique<bool>(metadata->available_offline);
+    properties_->dirty = std::make_unique<bool>(metadata->dirty);
+    properties_->hosted = std::make_unique<bool>(
+        metadata->type == drivefs::mojom::FileMetadata::Type::kHosted);
+    properties_->present = std::make_unique<bool>(metadata->available_offline ||
+                                                  *properties_->hosted);
+    properties_->available_when_metered = std::make_unique<bool>(
+        metadata->available_offline || *properties_->hosted);
+    properties_->pinned = std::make_unique<bool>(metadata->pinned);
+    properties_->shared = std::make_unique<bool>(metadata->shared);
+    properties_->starred = std::make_unique<bool>(metadata->starred);
+
+    if (metadata->modification_time != base::Time()) {
+      properties_->modification_time =
+          std::make_unique<double>(metadata->modification_time.ToJsTime());
+    }
+    if (metadata->modification_by_me_time != base::Time()) {
+      properties_->modification_by_me_time = std::make_unique<double>(
+          metadata->modification_by_me_time.ToJsTime());
+    }
+    if (!metadata->content_mime_type.empty()) {
+      properties_->content_mime_type =
+          std::make_unique<std::string>(metadata->content_mime_type);
+    }
+    if (!metadata->custom_icon_url.empty()) {
+      properties_->custom_icon_url =
+          std::make_unique<std::string>(std::move(metadata->custom_icon_url));
+    }
+    if (!metadata->alternate_url.empty()) {
+      properties_->alternate_url =
+          std::make_unique<std::string>(std::move(metadata->alternate_url));
+      properties_->share_url =
+          GetShareUrlFromAlternateUrl(GURL(*properties_->alternate_url));
+    }
+    if (metadata->image_metadata) {
+      if (metadata->image_metadata->height) {
+        properties_->image_height =
+            std::make_unique<int32_t>(metadata->image_metadata->height);
+      }
+      if (metadata->image_metadata->width) {
+        properties_->image_width =
+            std::make_unique<int32_t>(metadata->image_metadata->width);
+      }
+      if (metadata->image_metadata->rotation) {
+        properties_->image_rotation =
+            std::make_unique<int32_t>(metadata->image_metadata->rotation);
+      }
+    }
+
+    properties_->can_delete =
+        std::make_unique<bool>(metadata->capabilities->can_delete);
+    properties_->can_rename =
+        std::make_unique<bool>(metadata->capabilities->can_rename);
+    properties_->can_add_children =
+        std::make_unique<bool>(metadata->capabilities->can_add_children);
+
+    // Only set the |can_copy| capability for hosted documents; for other files,
+    // we must have read access, so |can_copy| is implicitly true.
+    properties_->can_copy = std::make_unique<bool>(
+        !*properties_->hosted || metadata->capabilities->can_copy);
+    properties_->can_share =
+        std::make_unique<bool>(metadata->capabilities->can_share);
+
+    if (metadata->thumbnail) {
+      base::PostTaskAndReplyWithResult(
+          FROM_HERE,
+          base::BindOnce(&SingleEntryPropertiesGetterForDriveFs::
+                             MakeThumbnailDataUrlOnSequence,
+                         std::move(*metadata->thumbnail)),
+          base::BindOnce(
+              &SingleEntryPropertiesGetterForDriveFs::SetThumbnailAndComplete,
+              weak_ptr_factory_.GetWeakPtr()));
+      return;
+    }
+
+    CompleteGetEntryProperties(drive::FILE_ERROR_OK);
+  }
+
+  static std::string MakeThumbnailDataUrlOnSequence(
+      const std::vector<uint8_t>& png_data) {
+    std::string encoded;
+    base::Base64Encode(
+        base::StringPiece(reinterpret_cast<const char*>(png_data.data()),
+                          png_data.size()),
+        &encoded);
+    return base::StrCat({"data:image/png;base64,", encoded});
+  }
+
+  void SetThumbnailAndComplete(std::string thumbnail_data_url) {
+    properties_->thumbnail_url =
+        std::make_unique<std::string>(std::move(thumbnail_data_url));
+
+    CompleteGetEntryProperties(drive::FILE_ERROR_OK);
+  }
+
+  void CompleteGetEntryProperties(drive::FileError error) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+    DCHECK(callback_);
+
+    std::move(callback_).Run(std::move(properties_),
+                             drive::FileErrorToBaseFileError(error));
+    BrowserThread::DeleteSoon(BrowserThread::UI, FROM_HERE, this);
+  }
+
+  // Given parameters.
+  ResultCallback callback_;
+  const base::FilePath local_path_;
+  const bool want_thumbnail_;
+  Profile* const running_profile_;
+
+  // Values used in the process.
+  std::unique_ptr<EntryProperties> properties_;
+
+  base::WeakPtrFactory<SingleEntryPropertiesGetterForDriveFs> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(SingleEntryPropertiesGetterForDriveFs);
+};
+
+}  // namespace
+
+FileManagerPrivateInternalGetEntryPropertiesFunction::
+    FileManagerPrivateInternalGetEntryPropertiesFunction()
+    : processed_count_(0) {
+}
+
+FileManagerPrivateInternalGetEntryPropertiesFunction::
+    ~FileManagerPrivateInternalGetEntryPropertiesFunction() = default;
+
+bool FileManagerPrivateInternalGetEntryPropertiesFunction::RunAsync() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  using api::file_manager_private_internal::GetEntryProperties::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  properties_list_.resize(params->urls.size());
+  const std::set<EntryPropertyName> names_as_set(params->names.begin(),
+                                                 params->names.end());
+  for (size_t i = 0; i < params->urls.size(); i++) {
+    const GURL url = GURL(params->urls[i]);
+    const storage::FileSystemURL file_system_url =
+        file_system_context->CrackURL(url);
+    switch (file_system_url.type()) {
+      case storage::kFileSystemTypeDrive:
+        SingleEntryPropertiesGetterForDrive::Start(
+            file_system_url.path(), names_as_set, GetProfile(),
+            base::Bind(&FileManagerPrivateInternalGetEntryPropertiesFunction::
+                           CompleteGetEntryProperties,
+                       this, i, file_system_url));
+        break;
+      case storage::kFileSystemTypeProvided:
+        SingleEntryPropertiesGetterForFileSystemProvider::Start(
+            file_system_url, names_as_set,
+            base::Bind(&FileManagerPrivateInternalGetEntryPropertiesFunction::
+                           CompleteGetEntryProperties,
+                       this, i, file_system_url));
+        break;
+      case storage::kFileSystemTypeDriveFs:
+        SingleEntryPropertiesGetterForDriveFs::Start(
+            file_system_url.path(),
+            names_as_set.count(
+                api::file_manager_private::ENTRY_PROPERTY_NAME_THUMBNAILURL),
+            GetProfile(),
+            base::BindOnce(
+                &FileManagerPrivateInternalGetEntryPropertiesFunction::
+                    CompleteGetEntryProperties,
+                this, i, file_system_url));
+        break;
+      default:
+        // TODO(yawano) Change this to support other voluems (e.g. local) ,and
+        // integrate fileManagerPrivate.getMimeType to this method.
+        LOG(ERROR) << "Not supported file system type.";
+        CompleteGetEntryProperties(i, file_system_url,
+                                   base::WrapUnique(new EntryProperties),
+                                   base::File::FILE_ERROR_INVALID_OPERATION);
+    }
+  }
+
+  return true;
+}
+
+void FileManagerPrivateInternalGetEntryPropertiesFunction::
+    CompleteGetEntryProperties(size_t index,
+                               const storage::FileSystemURL& url,
+                               std::unique_ptr<EntryProperties> properties,
+                               base::File::Error error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(0 <= processed_count_ && processed_count_ < properties_list_.size());
+
+  if (error == base::File::FILE_OK) {
+    properties->external_file_url = std::make_unique<std::string>(
+        chromeos::FileSystemURLToExternalFileURL(url).spec());
+  }
+  properties_list_[index] = std::move(*properties);
+
+  processed_count_++;
+  if (processed_count_ < properties_list_.size())
+    return;
+
+  results_ = extensions::api::file_manager_private_internal::
+      GetEntryProperties::Results::Create(properties_list_);
+  SendResponse(true);
+}
+
+bool FileManagerPrivateInternalPinDriveFileFunction::RunAsync() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  using extensions::api::file_manager_private_internal::PinDriveFile::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+  const GURL url = GURL(params->url);
+  const storage::FileSystemURL file_system_url =
+      file_system_context->CrackURL(url);
+
+  switch (file_system_url.type()) {
+    case storage::kFileSystemTypeDrive:
+      return RunAsyncForDrive(url, params->pin);
+
+    case storage::kFileSystemTypeDriveFs:
+      return RunAsyncForDriveFs(file_system_url, params->pin);
+
+    default:
+      return false;
+  }
+}
+
+bool FileManagerPrivateInternalPinDriveFileFunction::RunAsyncForDrive(
+    const GURL& url,
+    bool pin) {
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system)  // |file_system| is NULL if Drive is disabled.
+    return false;
+
+  const base::FilePath drive_path =
+      drive::util::ExtractDrivePath(file_manager::util::GetLocalPathFromURL(
+          render_frame_host(), GetProfile(), url));
+  if (pin) {
+    file_system->Pin(
+        drive_path,
+        base::Bind(
+            &FileManagerPrivateInternalPinDriveFileFunction::OnPinStateSet,
+            this));
+  } else {
+    file_system->Unpin(
+        drive_path,
+        base::Bind(
+            &FileManagerPrivateInternalPinDriveFileFunction::OnPinStateSet,
+            this));
+  }
+  return true;
+}
+
+bool FileManagerPrivateInternalPinDriveFileFunction::RunAsyncForDriveFs(
+    const storage::FileSystemURL& file_system_url,
+    bool pin) {
+  drive::DriveIntegrationService* integration_service =
+      drive::DriveIntegrationServiceFactory::FindForProfile(GetProfile());
+  base::FilePath path;
+  if (!integration_service || !integration_service->GetRelativeDrivePath(
+                                  file_system_url.path(), &path)) {
+    return false;
+  }
+
+  auto* drivefs_interface = integration_service->GetDriveFsInterface();
+  if (!drivefs_interface)
+    return false;
+
+  drivefs_interface->SetPinned(
+      path, pin,
+      mojo::WrapCallbackWithDefaultInvokeIfNotRun(
+          base::BindOnce(
+              &FileManagerPrivateInternalPinDriveFileFunction::OnPinStateSet,
+              this),
+          drive::FILE_ERROR_SERVICE_UNAVAILABLE));
+  return true;
+}
+void FileManagerPrivateInternalPinDriveFileFunction::OnPinStateSet(
+    drive::FileError error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (error == drive::FILE_ERROR_OK) {
+    SendResponse(true);
+  } else {
+    SetError(drive::FileErrorToString(error));
+    SendResponse(false);
+  }
+}
+
+bool FileManagerPrivateInternalEnsureFileDownloadedFunction::RunAsync() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  using extensions::api::file_manager_private_internal::EnsureFileDownloaded::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const base::FilePath drive_path =
+      drive::util::ExtractDrivePath(file_manager::util::GetLocalPathFromURL(
+          render_frame_host(), GetProfile(), GURL(params->url)));
+  if (drive_path.empty()) {
+    // Not under Drive. No need to fill the cache.
+    SendResponse(true);
+    return true;
+  }
+
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system)  // |file_system| is NULL if Drive is disabled.
+    return false;
+
+  file_system->GetFile(
+      drive_path,
+      base::BindOnce(&FileManagerPrivateInternalEnsureFileDownloadedFunction::
+                         OnDownloadFinished,
+                     this));
+  return true;
+}
+
+void FileManagerPrivateInternalEnsureFileDownloadedFunction::OnDownloadFinished(
+    drive::FileError error,
+    const base::FilePath& file_path,
+    std::unique_ptr<drive::ResourceEntry> entry) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (error == drive::FILE_ERROR_OK) {
+    SendResponse(true);
+  } else {
+    SetError(drive::FileErrorToString(error));
+    SendResponse(false);
+  }
+}
+
+bool FileManagerPrivateInternalCancelFileTransfersFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::CancelFileTransfers::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  drive::DriveIntegrationService* integration_service =
+      drive::DriveIntegrationServiceFactory::FindForProfile(GetProfile());
+  if (!integration_service || !integration_service->IsMounted())
+    return false;
+
+  drive::JobListInterface* const job_list = integration_service->job_list();
+  DCHECK(job_list);
+  const std::vector<drive::JobInfo> jobs = job_list->GetJobInfoList();
+
+  // Create the mapping from file path to job ID.
+  typedef std::map<base::FilePath, std::vector<drive::JobID>> PathToIdMap;
+  PathToIdMap path_to_id_map;
+  for (size_t i = 0; i < jobs.size(); ++i) {
+    if (drive::IsActiveFileTransferJobInfo(jobs[i]))
+      path_to_id_map[jobs[i].file_path].push_back(jobs[i].job_id);
+  }
+
+  for (size_t i = 0; i < params->urls.size(); ++i) {
+    base::FilePath file_path = file_manager::util::GetLocalPathFromURL(
+        render_frame_host(), GetProfile(), GURL(params->urls[i]));
+    if (file_path.empty())
+      continue;
+
+    file_path = drive::util::ExtractDrivePath(file_path);
+    DCHECK(file_path.empty());
+
+    // Cancel all the jobs for the file.
+    PathToIdMap::iterator it = path_to_id_map.find(file_path);
+    if (it != path_to_id_map.end()) {
+      for (size_t i = 0; i < it->second.size(); ++i)
+        job_list->CancelJob(it->second[i]);
+    }
+  }
+
+  SendResponse(true);
+  return true;
+}
+
+bool FileManagerPrivateSearchDriveFunction::RunAsync() {
+  using extensions::api::file_manager_private::SearchDrive::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system) {
+    // |file_system| is NULL if Drive is disabled.
+    return false;
+  }
+
+  file_system->Search(
+      params->search_params.query, GURL(params->search_params.next_feed),
+      base::Bind(&FileManagerPrivateSearchDriveFunction::OnSearch, this));
+  return true;
+}
+
+void FileManagerPrivateSearchDriveFunction::OnSearch(
+    drive::FileError error,
+    const GURL& next_link,
+    std::unique_ptr<SearchResultInfoList> results) {
+  if (error != drive::FILE_ERROR_OK) {
+    SendResponse(false);
+    return;
+  }
+
+  // Outlives the following conversion, since the pointer is bound to the
+  // callback.
+  DCHECK(results.get());
+  const SearchResultInfoList& results_ref = *results.get();
+
+  ConvertSearchResultInfoListToEntryDefinitionList(
+      GetProfile(),
+      extension_->id(),
+      results_ref,
+      base::Bind(&FileManagerPrivateSearchDriveFunction::OnEntryDefinitionList,
+                 this,
+                 next_link,
+                 base::Passed(&results)));
+}
+
+void FileManagerPrivateSearchDriveFunction::OnEntryDefinitionList(
+    const GURL& next_link,
+    std::unique_ptr<SearchResultInfoList> search_result_info_list,
+    std::unique_ptr<EntryDefinitionList> entry_definition_list) {
+  DCHECK_EQ(search_result_info_list->size(), entry_definition_list->size());
+  auto entries = std::make_unique<base::ListValue>();
+
+  // Convert Drive files to something File API stack can understand.
+  for (EntryDefinitionList::const_iterator it = entry_definition_list->begin();
+       it != entry_definition_list->end();
+       ++it) {
+    auto entry = std::make_unique<base::DictionaryValue>();
+    entry->SetString("fileSystemName", it->file_system_name);
+    entry->SetString("fileSystemRoot", it->file_system_root_url);
+    entry->SetString("fileFullPath", "/" + it->full_path.AsUTF8Unsafe());
+    entry->SetBoolean("fileIsDirectory", it->is_directory);
+    entries->Append(std::move(entry));
+  }
+
+  std::unique_ptr<base::DictionaryValue> result(new base::DictionaryValue());
+  result->Set("entries", std::move(entries));
+  result->SetString("nextFeed", next_link.spec());
+
+  SetResult(std::move(result));
+  SendResponse(true);
+}
+
+bool FileManagerPrivateSearchDriveMetadataFunction::RunAsync() {
+  using api::file_manager_private::SearchDriveMetadata::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  drive::EventLogger* logger = file_manager::util::GetLogger(GetProfile());
+  if (logger) {
+    logger->Log(
+        logging::LOG_INFO, "%s[%d] called. (types: '%s', maxResults: '%d')",
+        name(), request_id(),
+        api::file_manager_private::ToString(params->search_params.types),
+        params->search_params.max_results);
+  }
+  set_log_on_completion(true);
+
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system) {
+    // |file_system| is NULL if Drive is disabled.
+    return false;
+  }
+
+  int options = -1;
+  switch (params->search_params.types) {
+    case api::file_manager_private::SEARCH_TYPE_EXCLUDE_DIRECTORIES:
+      options = drive::SEARCH_METADATA_EXCLUDE_DIRECTORIES;
+      break;
+    case api::file_manager_private::SEARCH_TYPE_SHARED_WITH_ME:
+      options = drive::SEARCH_METADATA_SHARED_WITH_ME;
+      break;
+    case api::file_manager_private::SEARCH_TYPE_OFFLINE:
+      options = drive::SEARCH_METADATA_OFFLINE;
+      break;
+    case api::file_manager_private::SEARCH_TYPE_ALL:
+      options = drive::SEARCH_METADATA_ALL;
+      break;
+    case api::file_manager_private::SEARCH_TYPE_NONE:
+      break;
+  }
+  DCHECK_NE(options, -1);
+
+  file_system->SearchMetadata(
+      params->search_params.query, options, params->search_params.max_results,
+      drive::MetadataSearchOrder::LAST_ACCESSED,
+      base::Bind(
+          &FileManagerPrivateSearchDriveMetadataFunction::OnSearchMetadata,
+          this));
+  return true;
+}
+
+void FileManagerPrivateSearchDriveMetadataFunction::OnSearchMetadata(
+    drive::FileError error,
+    std::unique_ptr<drive::MetadataSearchResultVector> results) {
+  if (error != drive::FILE_ERROR_OK) {
+    SendResponse(false);
+    return;
+  }
+
+  // Outlives the following conversion, since the pointer is bound to the
+  // callback.
+  DCHECK(results.get());
+  const drive::MetadataSearchResultVector& results_ref = *results.get();
+
+  ConvertSearchResultInfoListToEntryDefinitionList(
+      GetProfile(),
+      extension_->id(),
+      results_ref,
+      base::Bind(
+          &FileManagerPrivateSearchDriveMetadataFunction::OnEntryDefinitionList,
+          this,
+          base::Passed(&results)));
+}
+
+void FileManagerPrivateSearchDriveMetadataFunction::OnEntryDefinitionList(
+    std::unique_ptr<drive::MetadataSearchResultVector> search_result_info_list,
+    std::unique_ptr<EntryDefinitionList> entry_definition_list) {
+  DCHECK_EQ(search_result_info_list->size(), entry_definition_list->size());
+  std::unique_ptr<base::ListValue> results_list(new base::ListValue());
+
+  // Convert Drive files to something File API stack can understand.  See
+  // file_browser_handler_custom_bindings.cc and
+  // file_manager_private_custom_bindings.js for how this is magically
+  // converted to a FileEntry.
+  for (size_t i = 0; i < entry_definition_list->size(); ++i) {
+    auto result_dict = std::make_unique<base::DictionaryValue>();
+
+    // FileEntry fields.
+    auto entry = std::make_unique<base::DictionaryValue>();
+    entry->SetString(
+        "fileSystemName", entry_definition_list->at(i).file_system_name);
+    entry->SetString(
+        "fileSystemRoot", entry_definition_list->at(i).file_system_root_url);
+    entry->SetString(
+        "fileFullPath",
+        "/" + entry_definition_list->at(i).full_path.AsUTF8Unsafe());
+    entry->SetBoolean("fileIsDirectory",
+                      entry_definition_list->at(i).is_directory);
+
+    result_dict->Set("entry", std::move(entry));
+    result_dict->SetString(
+        "highlightedBaseName",
+        search_result_info_list->at(i).highlighted_base_name);
+    results_list->Append(std::move(result_dict));
+  }
+
+  SetResult(std::move(results_list));
+  SendResponse(true);
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateGetDriveConnectionStateFunction::Run() {
+  api::file_manager_private::DriveConnectionState result;
+
+  switch (drive::util::GetDriveConnectionStatus(
+      Profile::FromBrowserContext(browser_context()))) {
+    case drive::util::DRIVE_DISCONNECTED_NOSERVICE:
+      result.type = kDriveConnectionTypeOffline;
+      result.reason =
+          std::make_unique<std::string>(kDriveConnectionReasonNoService);
+      break;
+    case drive::util::DRIVE_DISCONNECTED_NONETWORK:
+      result.type = kDriveConnectionTypeOffline;
+      result.reason =
+          std::make_unique<std::string>(kDriveConnectionReasonNoNetwork);
+      break;
+    case drive::util::DRIVE_DISCONNECTED_NOTREADY:
+      result.type = kDriveConnectionTypeOffline;
+      result.reason =
+          std::make_unique<std::string>(kDriveConnectionReasonNotReady);
+      break;
+    case drive::util::DRIVE_CONNECTED_METERED:
+      result.type = kDriveConnectionTypeMetered;
+      break;
+    case drive::util::DRIVE_CONNECTED:
+      result.type = kDriveConnectionTypeOnline;
+      break;
+  }
+
+  result.has_cellular_network_access =
+      chromeos::NetworkHandler::Get()
+          ->network_state_handler()
+          ->FirstNetworkByType(chromeos::NetworkTypePattern::Mobile());
+
+  drive::EventLogger* logger = file_manager::util::GetLogger(
+      Profile::FromBrowserContext(browser_context()));
+  if (logger)
+    logger->Log(logging::LOG_INFO, "%s succeeded.", name());
+  return RespondNow(ArgumentList(
+      api::file_manager_private::GetDriveConnectionState::Results::Create(
+          result)));
+}
+
+bool FileManagerPrivateRequestAccessTokenFunction::RunAsync() {
+  using extensions::api::file_manager_private::RequestAccessToken::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  drive::DriveServiceInterface* const drive_service =
+      drive::util::GetDriveServiceByProfile(GetProfile());
+
+  if (!drive_service) {
+    // DriveService is not available.
+    SetResult(std::make_unique<base::Value>(std::string()));
+    SendResponse(true);
+    return true;
+  }
+
+  // If refreshing is requested, then clear the token to refetch it.
+  if (params->refresh)
+    drive_service->ClearAccessToken();
+
+  // Retrieve the cached auth token (if available), otherwise the AuthService
+  // instance will try to refetch it.
+  drive_service->RequestAccessToken(
+      base::Bind(&FileManagerPrivateRequestAccessTokenFunction::
+                      OnAccessTokenFetched, this));
+  return true;
+}
+
+void FileManagerPrivateRequestAccessTokenFunction::OnAccessTokenFetched(
+    google_apis::DriveApiErrorCode code,
+    const std::string& access_token) {
+  SetResult(std::make_unique<base::Value>(access_token));
+  SendResponse(true);
+}
+
+bool FileManagerPrivateInternalGetShareUrlFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::GetShareUrl::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const base::FilePath path = file_manager::util::GetLocalPathFromURL(
+      render_frame_host(), GetProfile(), GURL(params->url));
+  DCHECK(drive::util::IsUnderDriveMountPoint(path));
+
+  const base::FilePath drive_path = drive::util::ExtractDrivePath(path);
+
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system) {
+    // |file_system| is NULL if Drive is disabled.
+    return false;
+  }
+
+  file_system->GetShareUrl(
+      drive_path,
+      GURL("chrome-extension://" + extension_id()),  // embed origin
+      base::Bind(&FileManagerPrivateInternalGetShareUrlFunction::OnGetShareUrl,
+                 this));
+  return true;
+}
+
+void FileManagerPrivateInternalGetShareUrlFunction::OnGetShareUrl(
+    drive::FileError error,
+    const GURL& share_url) {
+  if (error != drive::FILE_ERROR_OK) {
+    SetError("Share Url for this item is not available.");
+    SendResponse(false);
+    return;
+  }
+
+  SetResult(std::make_unique<base::Value>(share_url.spec()));
+  SendResponse(true);
+}
+
+bool FileManagerPrivateInternalRequestDriveShareFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::RequestDriveShare::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const base::FilePath path = file_manager::util::GetLocalPathFromURL(
+      render_frame_host(), GetProfile(), GURL(params->url));
+  const base::FilePath drive_path = drive::util::ExtractDrivePath(path);
+  Profile* const owner_profile = drive::util::ExtractProfileFromPath(path);
+
+  if (!owner_profile)
+    return false;
+
+  drive::FileSystemInterface* const owner_file_system =
+      drive::util::GetFileSystemByProfile(owner_profile);
+  if (!owner_file_system)
+    return false;
+
+  const user_manager::User* const user =
+      chromeos::ProfileHelper::Get()->GetUserByProfile(GetProfile());
+  if (!user || !user->is_logged_in())
+    return false;
+
+  google_apis::drive::PermissionRole role =
+      google_apis::drive::PERMISSION_ROLE_READER;
+  switch (params->share_type) {
+    case api::file_manager_private::DRIVE_SHARE_TYPE_NONE:
+      NOTREACHED();
+      return false;
+    case api::file_manager_private::DRIVE_SHARE_TYPE_CAN_EDIT:
+      role = google_apis::drive::PERMISSION_ROLE_WRITER;
+      break;
+    case api::file_manager_private::DRIVE_SHARE_TYPE_CAN_COMMENT:
+      role = google_apis::drive::PERMISSION_ROLE_COMMENTER;
+      break;
+    case api::file_manager_private::DRIVE_SHARE_TYPE_CAN_VIEW:
+      role = google_apis::drive::PERMISSION_ROLE_READER;
+      break;
+  }
+
+  // Share |drive_path| in |owner_file_system| to
+  // |user->GetAccountId().GetUserEmail()|.
+  owner_file_system->AddPermission(
+      drive_path, user->GetAccountId().GetUserEmail(), role,
+      base::Bind(
+          &FileManagerPrivateInternalRequestDriveShareFunction::OnAddPermission,
+          this));
+  return true;
+}
+
+void FileManagerPrivateInternalRequestDriveShareFunction::OnAddPermission(
+    drive::FileError error) {
+  SendResponse(error == drive::FILE_ERROR_OK);
+}
+
+FileManagerPrivateInternalGetDownloadUrlFunction::
+    FileManagerPrivateInternalGetDownloadUrlFunction() = default;
+
+FileManagerPrivateInternalGetDownloadUrlFunction::
+    ~FileManagerPrivateInternalGetDownloadUrlFunction() = default;
+
+bool FileManagerPrivateInternalGetDownloadUrlFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::GetShareUrl::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+  const GURL url = GURL(params->url);
+  const storage::FileSystemURL file_system_url =
+      file_system_context->CrackURL(url);
+
+  switch (file_system_url.type()) {
+    case storage::kFileSystemTypeDrive:
+      return RunAsyncForDrive(url);
+    case storage::kFileSystemTypeDriveFs:
+      return RunAsyncForDriveFs(file_system_url);
+    default:
+      return false;
+  }
+}
+
+bool FileManagerPrivateInternalGetDownloadUrlFunction::RunAsyncForDrive(
+    const GURL& url) {
+  // Start getting the file info.
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system) {
+    // |file_system| is NULL if Drive is disabled or not mounted.
+    SetError("Drive is disabled or not mounted.");
+    // Intentionally returns a blank.
+    SetResult(std::make_unique<base::Value>(std::string()));
+    return false;
+  }
+
+  const base::FilePath path = file_manager::util::GetLocalPathFromURL(
+      render_frame_host(), GetProfile(), url);
+  if (!drive::util::IsUnderDriveMountPoint(path)) {
+    SetError("The given file is not in Drive.");
+    // Intentionally returns a blank.
+    SetResult(std::make_unique<base::Value>(std::string()));
+    return false;
+  }
+  base::FilePath file_path = drive::util::ExtractDrivePath(path);
+
+  file_system->GetResourceEntry(
+      file_path,
+      base::BindOnce(
+          &FileManagerPrivateInternalGetDownloadUrlFunction::OnGetResourceEntry,
+          this));
+  return true;
+}
+
+void FileManagerPrivateInternalGetDownloadUrlFunction::OnGetResourceEntry(
+    drive::FileError error,
+    std::unique_ptr<drive::ResourceEntry> entry) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (error != drive::FILE_ERROR_OK) {
+    OnGotDownloadUrl(GURL());
+    return;
+  }
+
+  DriveApiUrlGenerator url_generator(
+      (GURL(google_apis::DriveApiUrlGenerator::kBaseUrlForProduction)),
+      (GURL(google_apis::DriveApiUrlGenerator::kBaseThumbnailUrlForProduction)),
+      google_apis::GetTeamDrivesIntegrationSwitch());
+  OnGotDownloadUrl(url_generator.GenerateDownloadFileUrl(entry->resource_id()));
+}
+
+void FileManagerPrivateInternalGetDownloadUrlFunction::OnGotDownloadUrl(
+    GURL download_url) {
+  if (download_url.is_empty()) {
+    SetError("Download Url for this item is not available.");
+    // Intentionally returns a blank.
+    SetResult(std::make_unique<base::Value>(std::string()));
+    SendResponse(false);
+    return;
+  }
+  download_url_ = std::move(download_url);
+  ProfileOAuth2TokenService* oauth2_token_service =
+      ProfileOAuth2TokenServiceFactory::GetForProfile(GetProfile());
+  SigninManagerBase* signin_manager =
+      SigninManagerFactory::GetForProfile(GetProfile());
+  const std::string& account_id = signin_manager->GetAuthenticatedAccountId();
+  std::vector<std::string> scopes;
+  scopes.emplace_back("https://www.googleapis.com/auth/drive.readonly");
+
+  scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory =
+      content::BrowserContext::GetDefaultStoragePartition(GetProfile())
+          ->GetURLLoaderFactoryForBrowserProcess();
+  auth_service_ = std::make_unique<google_apis::AuthService>(
+      oauth2_token_service, account_id, url_loader_factory, scopes);
+  auth_service_->StartAuthentication(base::Bind(
+      &FileManagerPrivateInternalGetDownloadUrlFunction::OnTokenFetched, this));
+}
+
+void FileManagerPrivateInternalGetDownloadUrlFunction::OnTokenFetched(
+    google_apis::DriveApiErrorCode code,
+    const std::string& access_token) {
+  if (code != google_apis::HTTP_SUCCESS) {
+    SetError("Not able to fetch the token.");
+    // Intentionally returns a blank.
+    SetResult(std::make_unique<base::Value>(std::string()));
+    SendResponse(false);
+    return;
+  }
+
+  SetResult(std::make_unique<base::Value>(
+      download_url_.Resolve("?alt=media&access_token=" + access_token).spec()));
+
+  SendResponse(true);
+}
+
+bool FileManagerPrivateInternalGetDownloadUrlFunction::RunAsyncForDriveFs(
+    const storage::FileSystemURL& file_system_url) {
+  drive::DriveIntegrationService* integration_service =
+      drive::DriveIntegrationServiceFactory::FindForProfile(GetProfile());
+  base::FilePath path;
+  if (!integration_service || !integration_service->GetRelativeDrivePath(
+                                  file_system_url.path(), &path)) {
+    return false;
+  }
+
+  auto* drivefs_interface = integration_service->GetDriveFsInterface();
+  if (!drivefs_interface)
+    return false;
+
+  drivefs_interface->GetMetadata(
+      path, false,
+      mojo::WrapCallbackWithDefaultInvokeIfNotRun(
+          base::BindOnce(
+              &FileManagerPrivateInternalGetDownloadUrlFunction::OnGotMetadata,
+              this),
+          drive::FILE_ERROR_SERVICE_UNAVAILABLE, nullptr));
+  return true;
+}
+
+void FileManagerPrivateInternalGetDownloadUrlFunction::OnGotMetadata(
+    drive::FileError error,
+    drivefs::mojom::FileMetadataPtr metadata) {
+  OnGotDownloadUrl(metadata ? GURL(metadata->download_url) : GURL());
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_manager/private_api_drive.h b/chrome/browser/extensions/api/file_manager/private_api_drive.h
new file mode 100644
index 0000000000000..ed27453b8cb50
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/private_api_drive.h
@@ -0,0 +1,286 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides Drive specific API functions.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_DRIVE_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_DRIVE_H_
+
+#include <stddef.h>
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/files/file.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_base.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chromeos/components/drivefs/mojom/drivefs.mojom.h"
+#include "components/drive/chromeos/file_system_interface.h"
+#include "components/drive/file_errors.h"
+
+namespace drive {
+class ResourceEntry;
+struct SearchResultInfo;
+}
+
+namespace google_apis {
+class AuthService;
+}
+
+namespace extensions {
+
+namespace api {
+namespace file_manager_private {
+struct EntryProperties;
+}  // namespace file_manager_private
+}  // namespace api
+
+// Implements the chrome.fileManagerPrivate.ensureFileDownloaded method.
+class FileManagerPrivateInternalEnsureFileDownloadedFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.ensureFileDownloaded",
+                             FILEMANAGERPRIVATE_ENSUREFILEDOWNLOADED)
+
+ protected:
+  ~FileManagerPrivateInternalEnsureFileDownloadedFunction() override = default;
+
+  // AsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  // Callback for RunAsync().
+  void OnDownloadFinished(drive::FileError error,
+                          const base::FilePath& file_path,
+                          std::unique_ptr<drive::ResourceEntry> entry);
+};
+
+// Retrieves property information for an entry and returns it as a dictionary.
+// On error, returns a dictionary with the key "error" set to the error number
+// (base::File::Error).
+class FileManagerPrivateInternalGetEntryPropertiesFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getEntryProperties",
+                             FILEMANAGERPRIVATEINTERNAL_GETENTRYPROPERTIES)
+
+  FileManagerPrivateInternalGetEntryPropertiesFunction();
+
+ protected:
+  ~FileManagerPrivateInternalGetEntryPropertiesFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  void CompleteGetEntryProperties(
+      size_t index,
+      const storage::FileSystemURL& url,
+      std::unique_ptr<api::file_manager_private::EntryProperties> properties,
+      base::File::Error error);
+
+  size_t processed_count_;
+  std::vector<api::file_manager_private::EntryProperties> properties_list_;
+};
+
+// Implements the chrome.fileManagerPrivate.pinDriveFile method.
+class FileManagerPrivateInternalPinDriveFileFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.pinDriveFile",
+                             FILEMANAGERPRIVATEINTERNAL_PINDRIVEFILE)
+
+ protected:
+  ~FileManagerPrivateInternalPinDriveFileFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  bool RunAsyncForDrive(const GURL& url, bool pin);
+  bool RunAsyncForDriveFs(const storage::FileSystemURL& file_system_url,
+                          bool pin);
+
+  // Callback for RunAsyncForDrive() and RunAsyncForDriveFs.
+  void OnPinStateSet(drive::FileError error);
+};
+
+// Implements the chrome.fileManagerPrivate.cancelFileTransfers method.
+class FileManagerPrivateInternalCancelFileTransfersFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.cancelFileTransfers",
+                             FILEMANAGERPRIVATEINTERNAL_CANCELFILETRANSFERS)
+
+ protected:
+  ~FileManagerPrivateInternalCancelFileTransfersFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+class FileManagerPrivateSearchDriveFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  typedef std::vector<drive::SearchResultInfo> SearchResultInfoList;
+
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.searchDrive",
+                             FILEMANAGERPRIVATE_SEARCHDRIVE)
+
+ protected:
+  ~FileManagerPrivateSearchDriveFunction() override = default;
+
+  bool RunAsync() override;
+
+ private:
+  // Callback for Search().
+  void OnSearch(
+      drive::FileError error,
+      const GURL& next_link,
+      std::unique_ptr<std::vector<drive::SearchResultInfo>> result_paths);
+
+  // Called when |result_paths| in OnSearch() are converted to a list of
+  // entry definitions.
+  void OnEntryDefinitionList(
+      const GURL& next_link,
+      std::unique_ptr<SearchResultInfoList> search_result_info_list,
+      std::unique_ptr<file_manager::util::EntryDefinitionList>
+          entry_definition_list);
+};
+
+// Similar to FileManagerPrivateSearchDriveFunction but this one is used for
+// searching drive metadata which is stored locally.
+class FileManagerPrivateSearchDriveMetadataFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.searchDriveMetadata",
+                             FILEMANAGERPRIVATE_SEARCHDRIVEMETADATA)
+
+ protected:
+  ~FileManagerPrivateSearchDriveMetadataFunction() override = default;
+
+  bool RunAsync() override;
+
+ private:
+  // Callback for SearchMetadata();
+  void OnSearchMetadata(
+      drive::FileError error,
+      std::unique_ptr<drive::MetadataSearchResultVector> results);
+
+  // Called when |results| in OnSearchMetadata() are converted to a list of
+  // entry definitions.
+  void OnEntryDefinitionList(
+      std::unique_ptr<drive::MetadataSearchResultVector>
+          search_result_info_list,
+      std::unique_ptr<file_manager::util::EntryDefinitionList>
+          entry_definition_list);
+};
+
+// Implements the chrome.fileManagerPrivate.getDriveConnectionState method.
+class FileManagerPrivateGetDriveConnectionStateFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileManagerPrivate.getDriveConnectionState",
+      FILEMANAGERPRIVATE_GETDRIVECONNECTIONSTATE);
+
+ protected:
+  ~FileManagerPrivateGetDriveConnectionStateFunction() override = default;
+
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.requestAccessToken method.
+class FileManagerPrivateRequestAccessTokenFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.requestAccessToken",
+                             FILEMANAGERPRIVATE_REQUESTACCESSTOKEN)
+
+ protected:
+  ~FileManagerPrivateRequestAccessTokenFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+  // Callback with a cached auth token (if available) or a fetched one.
+  void OnAccessTokenFetched(google_apis::DriveApiErrorCode code,
+                            const std::string& access_token);
+};
+
+// Implements the chrome.fileManagerPrivate.getShareUrl method.
+class FileManagerPrivateInternalGetShareUrlFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getShareUrl",
+                             FILEMANAGERPRIVATEINTERNAL_GETSHAREURL)
+
+ protected:
+  ~FileManagerPrivateInternalGetShareUrlFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+  // Callback with an url to the sharing dialog as |share_url|, called by
+  // FileSystem::GetShareUrl.
+  void OnGetShareUrl(drive::FileError error, const GURL& share_url);
+};
+
+// Implements the chrome.fileManagerPrivate.requestDriveShare method.
+class FileManagerPrivateInternalRequestDriveShareFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.requestDriveShare",
+                             FILEMANAGERPRIVATEINTERNAL_REQUESTDRIVESHARE);
+
+ protected:
+  ~FileManagerPrivateInternalRequestDriveShareFunction() override = default;
+  bool RunAsync() override;
+
+ private:
+  // Called back after the drive file system operation is finished.
+  void OnAddPermission(drive::FileError error);
+};
+
+// Implements the chrome.fileManagerPrivate.getDownloadUrl method.
+class FileManagerPrivateInternalGetDownloadUrlFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  FileManagerPrivateInternalGetDownloadUrlFunction();
+
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getDownloadUrl",
+                             FILEMANAGERPRIVATEINTERNAL_GETDOWNLOADURL)
+
+ protected:
+  ~FileManagerPrivateInternalGetDownloadUrlFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  bool RunAsyncForDrive(const GURL& url);
+
+  void OnGetResourceEntry(drive::FileError error,
+                          std::unique_ptr<drive::ResourceEntry> entry);
+
+  void OnGotDownloadUrl(GURL download_url);
+
+  // Callback with an |access_token|, called by
+  // drive::DriveReadonlyTokenFetcher.
+  void OnTokenFetched(google_apis::DriveApiErrorCode code,
+                      const std::string& access_token);
+
+  bool RunAsyncForDriveFs(const storage::FileSystemURL& file_system_url);
+  void OnGotMetadata(drive::FileError error,
+                     drivefs::mojom::FileMetadataPtr metadata);
+
+ private:
+  GURL download_url_;
+  std::unique_ptr<google_apis::AuthService> auth_service_;
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_DRIVE_H_
diff --git a/chrome/browser/extensions/api/file_manager/private_api_file_system.cc b/chrome/browser/extensions/api/file_manager/private_api_file_system.cc
new file mode 100644
index 0000000000000..5993e22d03732
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/private_api_file_system.cc
@@ -0,0 +1,1076 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/private_api_file_system.h"
+
+#include <sys/statvfs.h>
+
+#include <algorithm>
+#include <utility>
+
+#include "base/files/file_util.h"
+#include "base/posix/eintr_wrapper.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/sys_info.h"
+#include "base/task/post_task.h"
+#include "base/task_runner_util.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/extensions/api/file_manager/event_router.h"
+#include "chrome/browser/extensions/api/file_manager/event_router_factory.h"
+#include "chrome/browser/extensions/api/file_manager/file_stream_md5_digester.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/path_util.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/browser/fileapi/file_system_backend.h"
+#include "chrome/browser/metrics/chrome_metrics_service_accessor.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "chrome/common/extensions/api/file_manager_private_internal.h"
+#include "chromeos/chromeos_features.h"
+#include "chromeos/disks/disk_mount_manager.h"
+#include "components/drive/chromeos/file_system_interface.h"
+#include "components/drive/drive.pb.h"
+#include "components/drive/event_logger.h"
+#include "components/storage_monitor/storage_info.h"
+#include "components/storage_monitor/storage_monitor.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/child_process_security_policy.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/storage_partition.h"
+#include "content/public/common/url_constants.h"
+#include "extensions/browser/extension_util.h"
+#include "net/base/escape.h"
+#include "services/device/public/mojom/mtp_manager.mojom.h"
+#include "storage/browser/fileapi/file_stream_reader.h"
+#include "storage/browser/fileapi/file_system_context.h"
+#include "storage/browser/fileapi/file_system_file_util.h"
+#include "storage/browser/fileapi/file_system_operation_context.h"
+#include "storage/browser/fileapi/file_system_operation_runner.h"
+#include "storage/common/fileapi/file_system_info.h"
+#include "storage/common/fileapi/file_system_types.h"
+#include "storage/common/fileapi/file_system_util.h"
+#include "third_party/cros_system_api/constants/cryptohome.h"
+
+using chromeos::disks::DiskMountManager;
+using content::BrowserThread;
+using content::ChildProcessSecurityPolicy;
+using file_manager::util::EntryDefinition;
+using file_manager::util::FileDefinition;
+using storage::FileSystemURL;
+
+namespace extensions {
+namespace {
+
+const char kRootPath[] = "/";
+
+// Retrieves total and remaining available size on |mount_path|.
+void GetSizeStatsAsync(const base::FilePath& mount_path,
+                       uint64_t* total_size,
+                       uint64_t* remaining_size) {
+  int64_t size = base::SysInfo::AmountOfTotalDiskSpace(mount_path);
+  if (size >= 0)
+    *total_size = size;
+  size = base::SysInfo::AmountOfFreeDiskSpace(mount_path);
+  if (size >= 0)
+    *remaining_size = size;
+}
+
+// Retrieves the maximum file name length of the file system of |path|.
+// Returns 0 if it could not be queried.
+size_t GetFileNameMaxLengthAsync(const std::string& path) {
+  struct statvfs stat = {};
+  if (HANDLE_EINTR(statvfs(path.c_str(), &stat)) != 0) {
+    // The filesystem seems not supporting statvfs(). Assume it to be a commonly
+    // used bound 255, and log the failure.
+    LOG(ERROR) << "Cannot statvfs() the name length limit for: " << path;
+    return 255;
+  }
+  return stat.f_namemax;
+}
+
+// Returns EventRouter for the |profile_id| if available.
+file_manager::EventRouter* GetEventRouterByProfileId(void* profile_id) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  // |profile_id| needs to be checked with ProfileManager::IsValidProfile
+  // before using it.
+  if (!g_browser_process->profile_manager()->IsValidProfile(profile_id))
+    return nullptr;
+  Profile* profile = reinterpret_cast<Profile*>(profile_id);
+
+  return file_manager::EventRouterFactory::GetForProfile(profile);
+}
+
+// Notifies the copy progress to extensions via event router.
+void NotifyCopyProgress(
+    void* profile_id,
+    storage::FileSystemOperationRunner::OperationID operation_id,
+    storage::FileSystemOperation::CopyProgressType type,
+    const FileSystemURL& source_url,
+    const FileSystemURL& destination_url,
+    int64_t size) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  file_manager::EventRouter* event_router =
+      GetEventRouterByProfileId(profile_id);
+  if (event_router) {
+    event_router->OnCopyProgress(
+        operation_id, type,
+        source_url.ToGURL(), destination_url.ToGURL(), size);
+  }
+}
+
+// Callback invoked periodically on progress update of Copy().
+void OnCopyProgress(
+    void* profile_id,
+    storage::FileSystemOperationRunner::OperationID* operation_id,
+    storage::FileSystemOperation::CopyProgressType type,
+    const FileSystemURL& source_url,
+    const FileSystemURL& destination_url,
+    int64_t size) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  BrowserThread::PostTask(
+      BrowserThread::UI, FROM_HERE,
+      base::BindOnce(&NotifyCopyProgress, profile_id, *operation_id, type,
+                     source_url, destination_url, size));
+}
+
+// Notifies the copy completion to extensions via event router.
+void NotifyCopyCompletion(
+    void* profile_id,
+    storage::FileSystemOperationRunner::OperationID operation_id,
+    const FileSystemURL& source_url,
+    const FileSystemURL& destination_url,
+    base::File::Error error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  file_manager::EventRouter* event_router =
+      GetEventRouterByProfileId(profile_id);
+  if (event_router)
+    event_router->OnCopyCompleted(
+        operation_id,
+        source_url.ToGURL(), destination_url.ToGURL(), error);
+}
+
+// Callback invoked upon completion of Copy() (regardless of succeeded or
+// failed).
+void OnCopyCompleted(
+    void* profile_id,
+    storage::FileSystemOperationRunner::OperationID* operation_id,
+    const FileSystemURL& source_url,
+    const FileSystemURL& destination_url,
+    base::File::Error error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  BrowserThread::PostTask(
+      BrowserThread::UI, FROM_HERE,
+      base::BindOnce(&NotifyCopyCompletion, profile_id, *operation_id,
+                     source_url, destination_url, error));
+}
+
+// Starts the copy operation via FileSystemOperationRunner.
+storage::FileSystemOperationRunner::OperationID StartCopyOnIOThread(
+    void* profile_id,
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const FileSystemURL& source_url,
+    const FileSystemURL& destination_url) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  // Note: |operation_id| is owned by the callback for
+  // FileSystemOperationRunner::Copy(). It is always called in the next message
+  // loop or later, so at least during this invocation it should alive.
+  //
+  // TODO(yawano): change ERROR_BEHAVIOR_ABORT to ERROR_BEHAVIOR_SKIP after
+  //     error messages of individual operations become appear in the Files app
+  //     UI.
+  storage::FileSystemOperationRunner::OperationID* operation_id =
+      new storage::FileSystemOperationRunner::OperationID;
+  *operation_id = file_system_context->operation_runner()->Copy(
+      source_url, destination_url,
+      storage::FileSystemOperation::OPTION_PRESERVE_LAST_MODIFIED,
+      storage::FileSystemOperation::ERROR_BEHAVIOR_ABORT,
+      base::Bind(&OnCopyProgress, profile_id, base::Unretained(operation_id)),
+      base::Bind(&OnCopyCompleted, profile_id, base::Owned(operation_id),
+                 source_url, destination_url));
+  return *operation_id;
+}
+
+void OnCopyCancelled(base::File::Error error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  // We just ignore the status if the copy is actually cancelled or not,
+  // because failing cancellation means the operation is not running now.
+  DLOG_IF(WARNING, error != base::File::FILE_OK)
+      << "Failed to cancel copy: " << error;
+}
+
+// Cancels the running copy operation identified by |operation_id|.
+void CancelCopyOnIOThread(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    storage::FileSystemOperationRunner::OperationID operation_id) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  file_system_context->operation_runner()->Cancel(
+      operation_id, base::Bind(&OnCopyCancelled));
+}
+
+// Converts a status code to a bool value and calls the |callback| with it.
+void StatusCallbackToResponseCallback(
+    const base::Callback<void(bool)>& callback,
+    base::File::Error result) {
+  callback.Run(result == base::File::FILE_OK);
+}
+
+// Calls a response callback (on the UI thread) with a file content hash
+// computed on the IO thread.
+void ComputeChecksumRespondOnUIThread(
+    const base::Callback<void(const std::string&)>& callback,
+    const std::string& hash) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
+                          base::BindOnce(callback, hash));
+}
+
+// Calls a response callback on the UI thread.
+void GetFileMetadataRespondOnUIThread(
+    const storage::FileSystemOperation::GetMetadataCallback& callback,
+    base::File::Error result,
+    const base::File::Info& file_info) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
+                          base::BindOnce(callback, result, file_info));
+}
+
+}  // namespace
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateEnableExternalFileSchemeFunction::Run() {
+  ChildProcessSecurityPolicy::GetInstance()->GrantRequestScheme(
+      render_frame_host()->GetProcess()->GetID(), content::kExternalFileScheme);
+  return RespondNow(NoArguments());
+}
+
+FileManagerPrivateGrantAccessFunction::FileManagerPrivateGrantAccessFunction()
+    : chrome_details_(this) {
+}
+
+ExtensionFunction::ResponseAction FileManagerPrivateGrantAccessFunction::Run() {
+  using extensions::api::file_manager_private::GrantAccess::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          chrome_details_.GetProfile(), render_frame_host());
+
+  storage::ExternalFileSystemBackend* const backend =
+      file_system_context->external_backend();
+  DCHECK(backend);
+
+  const std::vector<Profile*>& profiles =
+      g_browser_process->profile_manager()->GetLoadedProfiles();
+  for (auto* profile : profiles) {
+    if (profile->IsOffTheRecord())
+      continue;
+    const GURL site = util::GetSiteForExtensionId(extension_id(), profile);
+    storage::FileSystemContext* const context =
+        content::BrowserContext::GetStoragePartitionForSite(profile, site)
+            ->GetFileSystemContext();
+    for (const auto& url : params->entry_urls) {
+      const storage::FileSystemURL file_system_url =
+          context->CrackURL(GURL(url));
+      // Grant permissions only to valid urls backed by the external file system
+      // backend.
+      if (!file_system_url.is_valid() ||
+          file_system_url.mount_type() != storage::kFileSystemTypeExternal) {
+        continue;
+      }
+      backend->GrantFileAccessToExtension(extension_->id(),
+                                          file_system_url.virtual_path());
+      content::ChildProcessSecurityPolicy::GetInstance()
+          ->GrantCreateReadWriteFile(render_frame_host()->GetProcess()->GetID(),
+                                     file_system_url.path());
+    }
+  }
+  return RespondNow(NoArguments());
+}
+
+namespace {
+
+void PostResponseCallbackTaskToUIThread(
+    const FileWatchFunctionBase::ResponseCallback& callback,
+    bool success) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
+                          base::BindOnce(callback, success));
+}
+
+void PostNotificationCallbackTaskToUIThread(
+    const storage::WatcherManager::NotificationCallback& callback,
+    storage::WatcherManager::ChangeType type) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
+                          base::BindOnce(callback, type));
+}
+
+}  // namespace
+
+void FileWatchFunctionBase::Respond(bool success) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  SetResult(std::make_unique<base::Value>(success));
+  SendResponse(success);
+}
+
+bool FileWatchFunctionBase::RunAsync() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (!render_frame_host() || !render_frame_host()->GetProcess())
+    return false;
+
+  // First param is url of a file to watch.
+  std::string url;
+  if (!args_->GetString(0, &url) || url.empty())
+    return false;
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  const FileSystemURL file_system_url =
+      file_system_context->CrackURL(GURL(url));
+  if (file_system_url.path().empty()) {
+    Respond(false);
+    return true;
+  }
+
+  file_manager::EventRouter* const event_router =
+      file_manager::EventRouterFactory::GetForProfile(GetProfile());
+
+  BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::BindOnce(&FileWatchFunctionBase::RunAsyncOnIOThread, this,
+                     file_system_context, file_system_url,
+                     event_router->GetWeakPtr()));
+  return true;
+}
+
+void FileWatchFunctionBase::RunAsyncOnIOThread(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const storage::FileSystemURL& file_system_url,
+    base::WeakPtr<file_manager::EventRouter> event_router) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  storage::WatcherManager* const watcher_manager =
+      file_system_context->GetWatcherManager(file_system_url.type());
+
+  if (!watcher_manager) {
+    BrowserThread::PostTask(
+        BrowserThread::UI, FROM_HERE,
+        base::BindOnce(
+            &FileWatchFunctionBase::PerformFallbackFileWatchOperationOnUIThread,
+            this, file_system_url, event_router));
+    return;
+  }
+
+  PerformFileWatchOperationOnIOThread(file_system_context, watcher_manager,
+                                      file_system_url, event_router);
+}
+
+void FileManagerPrivateInternalAddFileWatchFunction::
+    PerformFileWatchOperationOnIOThread(
+        scoped_refptr<storage::FileSystemContext> file_system_context,
+        storage::WatcherManager* watcher_manager,
+        const storage::FileSystemURL& file_system_url,
+        base::WeakPtr<file_manager::EventRouter> event_router) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  watcher_manager->AddWatcher(
+      file_system_url, false /* recursive */,
+      base::Bind(&StatusCallbackToResponseCallback,
+                 base::Bind(&PostResponseCallbackTaskToUIThread,
+                            base::Bind(&FileWatchFunctionBase::Respond, this))),
+      base::Bind(
+          &PostNotificationCallbackTaskToUIThread,
+          base::Bind(&file_manager::EventRouter::OnWatcherManagerNotification,
+                     event_router, file_system_url, extension_id())));
+}
+
+void FileManagerPrivateInternalAddFileWatchFunction::
+    PerformFallbackFileWatchOperationOnUIThread(
+        const storage::FileSystemURL& file_system_url,
+        base::WeakPtr<file_manager::EventRouter> event_router) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(event_router);
+
+  // Obsolete. Fallback code if storage::WatcherManager is not implemented.
+  event_router->AddFileWatch(file_system_url.path(),
+                             file_system_url.virtual_path(), extension_id(),
+                             base::Bind(&FileWatchFunctionBase::Respond, this));
+}
+
+void FileManagerPrivateInternalRemoveFileWatchFunction::
+    PerformFileWatchOperationOnIOThread(
+        scoped_refptr<storage::FileSystemContext> file_system_context,
+        storage::WatcherManager* watcher_manager,
+        const storage::FileSystemURL& file_system_url,
+        base::WeakPtr<file_manager::EventRouter> event_router) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  watcher_manager->RemoveWatcher(
+      file_system_url, false /* recursive */,
+      base::Bind(
+          &StatusCallbackToResponseCallback,
+          base::Bind(&PostResponseCallbackTaskToUIThread,
+                     base::Bind(&FileWatchFunctionBase::Respond, this))));
+}
+
+void FileManagerPrivateInternalRemoveFileWatchFunction::
+    PerformFallbackFileWatchOperationOnUIThread(
+        const storage::FileSystemURL& file_system_url,
+        base::WeakPtr<file_manager::EventRouter> event_router) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(event_router);
+
+  // Obsolete. Fallback code if storage::WatcherManager is not implemented.
+  event_router->RemoveFileWatch(file_system_url.path(), extension_id());
+  Respond(true);
+}
+
+bool FileManagerPrivateGetSizeStatsFunction::RunAsync() {
+  using extensions::api::file_manager_private::GetSizeStats::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  using file_manager::VolumeManager;
+  using file_manager::Volume;
+  VolumeManager* const volume_manager = VolumeManager::Get(GetProfile());
+  if (!volume_manager)
+    return false;
+
+  base::WeakPtr<Volume> volume =
+      volume_manager->FindVolumeById(params->volume_id);
+  if (!volume.get())
+    return false;
+
+  if (volume->type() == file_manager::VOLUME_TYPE_GOOGLE_DRIVE &&
+      !base::FeatureList::IsEnabled(chromeos::features::kDriveFs)) {
+    drive::FileSystemInterface* file_system =
+        drive::util::GetFileSystemByProfile(GetProfile());
+    if (!file_system) {
+      // |file_system| is NULL if Drive is disabled.
+      // If stats couldn't be gotten for drive, result should be left
+      // undefined. See comments in GetDriveAvailableSpaceCallback().
+      SendResponse(true);
+      return true;
+    }
+
+    file_system->GetAvailableSpace(base::Bind(
+        &FileManagerPrivateGetSizeStatsFunction::OnGetDriveAvailableSpace,
+        this));
+  } else if (volume->type() == file_manager::VOLUME_TYPE_MTP) {
+    // Resolve storage_name.
+    storage_monitor::StorageMonitor* storage_monitor =
+        storage_monitor::StorageMonitor::GetInstance();
+    storage_monitor::StorageInfo info;
+    storage_monitor->GetStorageInfoForPath(volume->mount_path(), &info);
+    std::string storage_name;
+    base::RemoveChars(info.location(), kRootPath, &storage_name);
+    DCHECK(!storage_name.empty());
+
+    // Get MTP StorageInfo.
+    auto* manager = storage_monitor->media_transfer_protocol_manager();
+    manager->GetStorageInfoFromDevice(
+        storage_name,
+        base::Bind(
+            &FileManagerPrivateGetSizeStatsFunction::OnGetMtpAvailableSpace,
+            this));
+  } else {
+    uint64_t* total_size = new uint64_t(0);
+    uint64_t* remaining_size = new uint64_t(0);
+    base::PostTaskWithTraitsAndReply(
+        FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_VISIBLE},
+        base::BindOnce(&GetSizeStatsAsync, volume->mount_path(), total_size,
+                       remaining_size),
+        base::BindOnce(&FileManagerPrivateGetSizeStatsFunction::OnGetSizeStats,
+                       this, base::Owned(total_size),
+                       base::Owned(remaining_size)));
+  }
+  return true;
+}
+
+void FileManagerPrivateGetSizeStatsFunction::OnGetDriveAvailableSpace(
+    drive::FileError error,
+    int64_t bytes_total,
+    int64_t bytes_used) {
+  if (error == drive::FILE_ERROR_OK) {
+    const uint64_t bytes_total_unsigned = bytes_total;
+    // bytes_used can be larger than bytes_total (over quota).
+    const uint64_t bytes_remaining_unsigned =
+        std::max(bytes_total - bytes_used, int64_t(0));
+    OnGetSizeStats(&bytes_total_unsigned, &bytes_remaining_unsigned);
+  } else {
+    // If stats couldn't be gotten for drive, result should be left undefined.
+    SendResponse(true);
+  }
+}
+
+void FileManagerPrivateGetSizeStatsFunction::OnGetMtpAvailableSpace(
+    device::mojom::MtpStorageInfoPtr mtp_storage_info,
+    const bool error) {
+  if (error) {
+    // If stats couldn't be gotten from MTP volume, result should be left
+    // undefined same as we do for Drive.
+    SendResponse(true);
+    return;
+  }
+
+  const uint64_t max_capacity = mtp_storage_info->max_capacity;
+  const uint64_t free_space_in_bytes = mtp_storage_info->free_space_in_bytes;
+  OnGetSizeStats(&max_capacity, &free_space_in_bytes);
+}
+
+void FileManagerPrivateGetSizeStatsFunction::OnGetSizeStats(
+    const uint64_t* total_size,
+    const uint64_t* remaining_size) {
+  std::unique_ptr<base::DictionaryValue> sizes(new base::DictionaryValue());
+
+  sizes->SetDouble("totalSize", static_cast<double>(*total_size));
+  sizes->SetDouble("remainingSize", static_cast<double>(*remaining_size));
+
+  SetResult(std::move(sizes));
+  SendResponse(true);
+}
+
+bool FileManagerPrivateInternalValidatePathNameLengthFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::ValidatePathNameLength::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  const storage::FileSystemURL file_system_url(
+      file_system_context->CrackURL(GURL(params->parent_url)));
+  if (!chromeos::FileSystemBackend::CanHandleURL(file_system_url))
+    return false;
+
+  // No explicit limit on the length of Drive file names.
+  if (file_system_url.type() == storage::kFileSystemTypeDrive) {
+    SetResult(std::make_unique<base::Value>(true));
+    SendResponse(true);
+    return true;
+  }
+
+  base::PostTaskWithTraitsAndReplyWithResult(
+      FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_BLOCKING},
+      base::Bind(&GetFileNameMaxLengthAsync,
+                 file_system_url.path().AsUTF8Unsafe()),
+      base::Bind(&FileManagerPrivateInternalValidatePathNameLengthFunction::
+                     OnFilePathLimitRetrieved,
+                 this, params->name.size()));
+  return true;
+}
+
+void FileManagerPrivateInternalValidatePathNameLengthFunction::
+    OnFilePathLimitRetrieved(size_t current_length, size_t max_length) {
+  SetResult(std::make_unique<base::Value>(current_length <= max_length));
+  SendResponse(true);
+}
+
+bool FileManagerPrivateFormatVolumeFunction::RunAsync() {
+  using extensions::api::file_manager_private::FormatVolume::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  using file_manager::VolumeManager;
+  using file_manager::Volume;
+  VolumeManager* const volume_manager = VolumeManager::Get(GetProfile());
+  if (!volume_manager)
+    return false;
+
+  base::WeakPtr<Volume> volume =
+      volume_manager->FindVolumeById(params->volume_id);
+  if (!volume)
+    return false;
+
+  DiskMountManager::GetInstance()->FormatMountedDevice(
+      volume->mount_path().AsUTF8Unsafe());
+  SendResponse(true);
+  return true;
+}
+
+bool FileManagerPrivateRenameVolumeFunction::RunAsync() {
+  using extensions::api::file_manager_private::RenameVolume::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  using file_manager::VolumeManager;
+  using file_manager::Volume;
+  VolumeManager* const volume_manager = VolumeManager::Get(GetProfile());
+  if (!volume_manager)
+    return false;
+
+  base::WeakPtr<Volume> volume =
+      volume_manager->FindVolumeById(params->volume_id);
+  if (!volume)
+    return false;
+
+  DiskMountManager::GetInstance()->RenameMountedDevice(
+      volume->mount_path().AsUTF8Unsafe(), params->new_name);
+  SendResponse(true);
+  return true;
+}
+
+// Obtains file size of URL.
+void GetFileMetadataOnIOThread(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const FileSystemURL& url,
+    int fields,
+    const storage::FileSystemOperation::GetMetadataCallback& callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  file_system_context->operation_runner()->GetMetadata(
+      url, fields, base::Bind(&GetFileMetadataRespondOnUIThread, callback));
+}
+
+// Checks if the available space of the |path| is enough for required |bytes|.
+bool CheckLocalDiskSpace(const base::FilePath& path, int64_t bytes) {
+  return bytes <= base::SysInfo::AmountOfFreeDiskSpace(path) -
+                      cryptohome::kMinFreeSpaceInBytes;
+}
+
+bool FileManagerPrivateInternalStartCopyFunction::RunAsync() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  using extensions::api::file_manager_private_internal::StartCopy::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  if (params->url.empty() || params->parent_url.empty() ||
+      params->new_name.empty()) {
+    // Error code in format of DOMError.name.
+    SetError("EncodingError");
+    return false;
+  }
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  // |parent| may have a trailing slash if it is a root directory.
+  std::string destination_url_string = params->parent_url;
+  if (destination_url_string.back() != '/')
+    destination_url_string += '/';
+  destination_url_string += net::EscapePath(params->new_name);
+
+  source_url_ = file_system_context->CrackURL(GURL(params->url));
+  destination_url_ =
+      file_system_context->CrackURL(GURL(destination_url_string));
+
+  if (!source_url_.is_valid() || !destination_url_.is_valid()) {
+    // Error code in format of DOMError.name.
+    SetError("EncodingError");
+    return false;
+  }
+
+  // Check if the destination directory is downloads. If so, secure available
+  // spece by freeing drive caches.
+  if (destination_url_.filesystem_id() ==
+      file_manager::util::GetDownloadsMountPointName(GetProfile())) {
+    return BrowserThread::PostTask(
+        BrowserThread::IO, FROM_HERE,
+        base::BindOnce(&GetFileMetadataOnIOThread, file_system_context,
+                       source_url_,
+                       storage::FileSystemOperation::GET_METADATA_FIELD_SIZE,
+                       base::Bind(&FileManagerPrivateInternalStartCopyFunction::
+                                      RunAfterGetFileMetadata,
+                                  this)));
+  }
+
+  return BrowserThread::PostTask(
+      BrowserThread::UI, FROM_HERE,
+      base::BindOnce(
+          &FileManagerPrivateInternalStartCopyFunction::RunAfterFreeDiskSpace,
+          this, true));
+}
+
+void FileManagerPrivateInternalStartCopyFunction::RunAfterGetFileMetadata(
+    base::File::Error result,
+    const base::File::Info& file_info) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (result != base::File::FILE_OK) {
+    SetError("NotFoundError");
+    SendResponse(false);
+    return;
+  }
+
+  drive::FileSystemInterface* const drive_file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (drive_file_system) {
+    drive_file_system->FreeDiskSpaceIfNeededFor(
+        file_info.size,
+        base::Bind(
+            &FileManagerPrivateInternalStartCopyFunction::RunAfterFreeDiskSpace,
+            this));
+  } else {
+    base::PostTaskWithTraitsAndReplyWithResult(
+        FROM_HERE, {base::MayBlock()},
+        base::BindOnce(
+            &CheckLocalDiskSpace,
+            file_manager::util::GetDownloadsFolderForProfile(GetProfile()),
+            file_info.size),
+        base::BindOnce(
+            &FileManagerPrivateInternalStartCopyFunction::RunAfterFreeDiskSpace,
+            this));
+  }
+}
+
+void FileManagerPrivateInternalStartCopyFunction::RunAfterFreeDiskSpace(
+    bool available) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (!available) {
+    SetError("QuotaExceededError");
+    SendResponse(false);
+    return;
+  }
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+  const bool result = BrowserThread::PostTaskAndReplyWithResult(
+      BrowserThread::IO, FROM_HERE,
+      base::Bind(&StartCopyOnIOThread, GetProfile(), file_system_context,
+                 source_url_, destination_url_),
+      base::Bind(
+          &FileManagerPrivateInternalStartCopyFunction::RunAfterStartCopy,
+          this));
+  if (!result)
+    SendResponse(false);
+}
+
+void FileManagerPrivateInternalStartCopyFunction::RunAfterStartCopy(
+    int operation_id) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  SetResult(std::make_unique<base::Value>(operation_id));
+  SendResponse(true);
+}
+
+bool FileManagerPrivateCancelCopyFunction::RunAsync() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  using extensions::api::file_manager_private::CancelCopy::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  // We don't much take care about the result of cancellation.
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+                          base::BindOnce(&CancelCopyOnIOThread,
+                                         file_system_context, params->copy_id));
+  SendResponse(true);
+  return true;
+}
+
+bool FileManagerPrivateInternalResolveIsolatedEntriesFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::ResolveIsolatedEntries::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+  DCHECK(file_system_context.get());
+
+  const storage::ExternalFileSystemBackend* external_backend =
+      file_system_context->external_backend();
+  DCHECK(external_backend);
+
+  file_manager::util::FileDefinitionList file_definition_list;
+  for (size_t i = 0; i < params->urls.size(); ++i) {
+    const FileSystemURL file_system_url =
+        file_system_context->CrackURL(GURL(params->urls[i]));
+    DCHECK(external_backend->CanHandleType(file_system_url.type()))
+        << "GURL: " << file_system_url.ToGURL()
+        << "type: " << file_system_url.type();
+    FileDefinition file_definition;
+    const bool result =
+        file_manager::util::ConvertAbsoluteFilePathToRelativeFileSystemPath(
+            GetProfile(), extension_->id(), file_system_url.path(),
+            &file_definition.virtual_path);
+    if (!result)
+      continue;
+    // The API only supports isolated files. It still works for directories,
+    // as the value is ignored for existing entries.
+    file_definition.is_directory = false;
+    file_definition_list.push_back(file_definition);
+  }
+
+  file_manager::util::ConvertFileDefinitionListToEntryDefinitionList(
+      GetProfile(),
+      extension_->id(),
+      file_definition_list,  // Safe, since copied internally.
+      base::Bind(
+          &FileManagerPrivateInternalResolveIsolatedEntriesFunction::
+              RunAsyncAfterConvertFileDefinitionListToEntryDefinitionList,
+          this));
+  return true;
+}
+
+void FileManagerPrivateInternalResolveIsolatedEntriesFunction::
+    RunAsyncAfterConvertFileDefinitionListToEntryDefinitionList(
+        std::unique_ptr<file_manager::util::EntryDefinitionList>
+            entry_definition_list) {
+  using extensions::api::file_manager_private_internal::EntryDescription;
+  std::vector<EntryDescription> entries;
+
+  for (const auto& definition : *entry_definition_list) {
+    if (definition.error != base::File::FILE_OK)
+      continue;
+    EntryDescription entry;
+    entry.file_system_name = definition.file_system_name;
+    entry.file_system_root = definition.file_system_root_url;
+    entry.file_full_path = "/" + definition.full_path.AsUTF8Unsafe();
+    entry.file_is_directory = definition.is_directory;
+    entries.push_back(std::move(entry));
+  }
+
+  results_ = extensions::api::file_manager_private_internal::
+      ResolveIsolatedEntries::Results::Create(entries);
+  SendResponse(true);
+}
+
+FileManagerPrivateInternalComputeChecksumFunction::
+    FileManagerPrivateInternalComputeChecksumFunction()
+    : digester_(new drive::util::FileStreamMd5Digester()) {
+}
+
+FileManagerPrivateInternalComputeChecksumFunction::
+    ~FileManagerPrivateInternalComputeChecksumFunction() = default;
+
+bool FileManagerPrivateInternalComputeChecksumFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::ComputeChecksum::Params;
+  using drive::util::FileStreamMd5Digester;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  if (params->url.empty()) {
+    SetError("File URL must be provided.");
+    return false;
+  }
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  FileSystemURL file_system_url(
+      file_system_context->CrackURL(GURL(params->url)));
+  if (!file_system_url.is_valid()) {
+    SetError("File URL was invalid");
+    return false;
+  }
+
+  std::unique_ptr<storage::FileStreamReader> reader =
+      file_system_context->CreateFileStreamReader(
+          file_system_url, 0, storage::kMaximumLength, base::Time());
+
+  FileStreamMd5Digester::ResultCallback result_callback = base::Bind(
+      &ComputeChecksumRespondOnUIThread,
+      base::Bind(&FileManagerPrivateInternalComputeChecksumFunction::Respond,
+                 this));
+  BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::BindOnce(&FileStreamMd5Digester::GetMd5Digest,
+                     base::Unretained(digester_.get()), base::Passed(&reader),
+                     result_callback));
+
+  return true;
+}
+
+void FileManagerPrivateInternalComputeChecksumFunction::Respond(
+    const std::string& hash) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  SetResult(std::make_unique<base::Value>(hash));
+  SendResponse(true);
+}
+
+bool FileManagerPrivateSearchFilesByHashesFunction::RunAsync() {
+  using api::file_manager_private::SearchFilesByHashes::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  // TODO(hirono): Check the volume ID and fail the function for volumes other
+  // than Drive.
+
+  drive::EventLogger* const logger =
+      file_manager::util::GetLogger(GetProfile());
+  if (logger) {
+    logger->Log(logging::LOG_INFO,
+                "%s[%d] called. (volume id: %s, number of hashes: %zd)", name(),
+                request_id(), params->volume_id.c_str(),
+                params->hash_list.size());
+  }
+  set_log_on_completion(true);
+
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system) {
+    // |file_system| is NULL if Drive is disabled.
+    return false;
+  }
+
+  std::set<std::string> hashes(params->hash_list.begin(),
+                               params->hash_list.end());
+  file_system->SearchByHashes(
+      hashes,
+      base::Bind(
+          &FileManagerPrivateSearchFilesByHashesFunction::OnSearchByHashes,
+          this, hashes));
+  return true;
+}
+
+void FileManagerPrivateSearchFilesByHashesFunction::OnSearchByHashes(
+    const std::set<std::string>& hashes,
+    drive::FileError error,
+    const std::vector<drive::HashAndFilePath>& search_results) {
+  if (error != drive::FileError::FILE_ERROR_OK) {
+    SendResponse(false);
+    return;
+  }
+
+  std::unique_ptr<base::DictionaryValue> result(new base::DictionaryValue());
+  for (const auto& hash : hashes) {
+    result->SetWithoutPathExpansion(hash, std::make_unique<base::ListValue>());
+  }
+
+  for (const auto& hashAndPath : search_results) {
+    DCHECK(result->HasKey(hashAndPath.hash));
+    base::ListValue* list;
+    result->GetListWithoutPathExpansion(hashAndPath.hash, &list);
+    list->AppendString(
+        file_manager::util::ConvertDrivePathToFileSystemUrl(
+            GetProfile(), hashAndPath.path, extension_id()).spec());
+  }
+  SetResult(std::move(result));
+  SendResponse(true);
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateIsUMAEnabledFunction::Run() {
+  return RespondNow(OneArgument(std::make_unique<base::Value>(
+      ChromeMetricsServiceAccessor::IsMetricsAndCrashReportingEnabled())));
+}
+
+FileManagerPrivateInternalSetEntryTagFunction::
+    FileManagerPrivateInternalSetEntryTagFunction()
+    : chrome_details_(this) {}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateInternalSetEntryTagFunction::Run() {
+  using extensions::api::file_manager_private_internal::SetEntryTag::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const base::FilePath local_path = file_manager::util::GetLocalPathFromURL(
+      render_frame_host(), chrome_details_.GetProfile(), GURL(params->url));
+  const base::FilePath drive_path = drive::util::ExtractDrivePath(local_path);
+  if (drive_path.empty())
+    return RespondNow(Error("Only Drive files and directories are supported."));
+
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(chrome_details_.GetProfile());
+  // |file_system| is NULL if Drive is disabled.
+  if (!file_system)
+    return RespondNow(Error("Drive is disabled."));
+
+  google_apis::drive::Property::Visibility visibility;
+  switch (params->visibility) {
+    case extensions::api::file_manager_private::ENTRY_TAG_VISIBILITY_PRIVATE:
+      visibility = google_apis::drive::Property::VISIBILITY_PRIVATE;
+      break;
+    case extensions::api::file_manager_private::ENTRY_TAG_VISIBILITY_PUBLIC:
+      visibility = google_apis::drive::Property::VISIBILITY_PUBLIC;
+      break;
+    default:
+      NOTREACHED();
+      return RespondNow(Error("Invalid visibility."));
+      break;
+  }
+
+  file_system->SetProperty(
+      drive_path, visibility, params->key, params->value,
+      base::Bind(&FileManagerPrivateInternalSetEntryTagFunction::
+                     OnSetEntryPropertyCompleted,
+                 this));
+  return RespondLater();
+}
+
+void FileManagerPrivateInternalSetEntryTagFunction::OnSetEntryPropertyCompleted(
+    drive::FileError result) {
+  Respond(result == drive::FILE_ERROR_OK ? NoArguments()
+                                         : Error("Failed to set a tag."));
+}
+
+bool FileManagerPrivateInternalGetDirectorySizeFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::GetDirectorySize::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  if (params->url.empty()) {
+    SetError("File URL must be provided.");
+    return false;
+  }
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+  const storage::FileSystemURL file_system_url(
+      file_system_context->CrackURL(GURL(params->url)));
+  if (!chromeos::FileSystemBackend::CanHandleURL(file_system_url)) {
+    SetError("FileSystemBackend failed to handle the entry's url.");
+    return false;
+  }
+  if (file_system_url.type() != storage::kFileSystemTypeNativeLocal) {
+    SetError("Only local directories are supported.");
+    return false;
+  }
+
+  const base::FilePath root_path = file_manager::util::GetLocalPathFromURL(
+      render_frame_host(), GetProfile(), GURL(params->url));
+  if (root_path.empty()) {
+    SetError("Failed to get a local path from the entry's url.");
+    return false;
+  }
+
+  base::PostTaskWithTraitsAndReplyWithResult(
+      FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_VISIBLE},
+      base::Bind(&base::ComputeDirectorySize, root_path),
+      base::Bind(&FileManagerPrivateInternalGetDirectorySizeFunction::
+                     OnDirectorySizeRetrieved,
+                 this));
+  return true;
+}
+
+void FileManagerPrivateInternalGetDirectorySizeFunction::
+    OnDirectorySizeRetrieved(int64_t size) {
+  SetResult(std::make_unique<base::Value>(static_cast<double>(size)));
+  SendResponse(true);
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_manager/private_api_file_system.h b/chrome/browser/extensions/api/file_manager/private_api_file_system.h
new file mode 100644
index 0000000000000..0b991f0513237
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/private_api_file_system.h
@@ -0,0 +1,400 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides file system related API functions.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_FILE_SYSTEM_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_FILE_SYSTEM_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <memory>
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/callback_forward.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_base.h"
+#include "chrome/browser/extensions/chrome_extension_function.h"
+#include "chrome/browser/extensions/chrome_extension_function_details.h"
+#include "components/drive/file_errors.h"
+#include "extensions/browser/extension_function.h"
+#include "services/device/public/mojom/mtp_storage_info.mojom.h"
+#include "storage/browser/fileapi/file_system_url.h"
+
+namespace storage {
+class FileSystemContext;
+class FileSystemURL;
+class WatcherManager;
+}  // namespace storage
+
+namespace file_manager {
+class EventRouter;
+namespace util {
+struct EntryDefinition;
+typedef std::vector<EntryDefinition> EntryDefinitionList;
+}  // namespace util
+}  // namespace file_manager
+
+namespace drive {
+namespace util {
+class FileStreamMd5Digester;
+}  // namespace util
+struct HashAndFilePath;
+}  // namespace drive
+
+namespace extensions {
+
+// Grant permission to request externalfile scheme. The permission is needed to
+// start drag for external file URL.
+class FileManagerPrivateEnableExternalFileSchemeFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.enableExternalFileScheme",
+                             FILEMANAGERPRIVATE_ENABLEEXTERNALFILESCHEME);
+
+ protected:
+  ~FileManagerPrivateEnableExternalFileSchemeFunction() override = default;
+
+ private:
+  ExtensionFunction::ResponseAction Run() override;
+};
+
+// Grants R/W permissions to profile-specific directories (Drive, Downloads)
+// from other profiles.
+class FileManagerPrivateGrantAccessFunction : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateGrantAccessFunction();
+
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.grantAccess",
+                             FILEMANAGERPRIVATE_GRANTACCESS)
+
+ protected:
+  ~FileManagerPrivateGrantAccessFunction() override = default;
+
+ private:
+  ExtensionFunction::ResponseAction Run() override;
+  const ChromeExtensionFunctionDetails chrome_details_;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateGrantAccessFunction);
+};
+
+// Base class for FileManagerPrivateInternalAddFileWatchFunction and
+// FileManagerPrivateInternalRemoveFileWatchFunction. Although it's called
+// "FileWatch",
+// the class and its sub classes are used only for watching changes in
+// directories.
+class FileWatchFunctionBase : public LoggedAsyncExtensionFunction {
+ public:
+  using ResponseCallback = base::Callback<void(bool success)>;
+
+  // Calls SendResponse() with |success| converted to base::Value.
+  void Respond(bool success);
+
+ protected:
+  ~FileWatchFunctionBase() override = default;
+
+  // Performs a file watch operation (ex. adds or removes a file watch) on
+  // the IO thread with storage::WatcherManager.
+  virtual void PerformFileWatchOperationOnIOThread(
+      scoped_refptr<storage::FileSystemContext> file_system_context,
+      storage::WatcherManager* watcher_manager,
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router) = 0;
+
+  // Performs a file watch operation (ex. adds or removes a file watch) on
+  // the UI thread with file_manager::EventRouter. This is a fallback operation
+  // called only when WatcherManager is unavailable.
+  virtual void PerformFallbackFileWatchOperationOnUIThread(
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router) = 0;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  void RunAsyncOnIOThread(
+      scoped_refptr<storage::FileSystemContext> file_system_context,
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router);
+};
+
+// Implements the chrome.fileManagerPrivate.addFileWatch method.
+// Starts watching changes in directories.
+class FileManagerPrivateInternalAddFileWatchFunction
+    : public FileWatchFunctionBase {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.addFileWatch",
+                             FILEMANAGERPRIVATEINTERNAL_ADDFILEWATCH)
+
+ protected:
+  ~FileManagerPrivateInternalAddFileWatchFunction() override = default;
+
+  // FileWatchFunctionBase override.
+  void PerformFileWatchOperationOnIOThread(
+      scoped_refptr<storage::FileSystemContext> file_system_context,
+      storage::WatcherManager* watcher_manager,
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router) override;
+  void PerformFallbackFileWatchOperationOnUIThread(
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router) override;
+};
+
+
+// Implements the chrome.fileManagerPrivate.removeFileWatch method.
+// Stops watching changes in directories.
+class FileManagerPrivateInternalRemoveFileWatchFunction
+    : public FileWatchFunctionBase {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.removeFileWatch",
+                             FILEMANAGERPRIVATEINTERNAL_REMOVEFILEWATCH)
+
+ protected:
+  ~FileManagerPrivateInternalRemoveFileWatchFunction() override = default;
+
+  // FileWatchFunctionBase override.
+  void PerformFileWatchOperationOnIOThread(
+      scoped_refptr<storage::FileSystemContext> file_system_context,
+      storage::WatcherManager* watcher_manager,
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router) override;
+  void PerformFallbackFileWatchOperationOnUIThread(
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router) override;
+};
+
+// Implements the chrome.fileManagerPrivate.getSizeStats method.
+class FileManagerPrivateGetSizeStatsFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.getSizeStats",
+                             FILEMANAGERPRIVATE_GETSIZESTATS)
+
+ protected:
+  ~FileManagerPrivateGetSizeStatsFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  void OnGetDriveAvailableSpace(drive::FileError error,
+                                int64_t bytes_total,
+                                int64_t bytes_used);
+
+  void OnGetMtpAvailableSpace(device::mojom::MtpStorageInfoPtr mtp_storage_info,
+                              const bool error);
+
+  void OnGetSizeStats(const uint64_t* total_size,
+                      const uint64_t* remaining_size);
+};
+
+// Implements the chrome.fileManagerPrivate.validatePathNameLength method.
+class FileManagerPrivateInternalValidatePathNameLengthFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileManagerPrivateInternal.validatePathNameLength",
+      FILEMANAGERPRIVATEINTERNAL_VALIDATEPATHNAMELENGTH)
+
+ protected:
+  ~FileManagerPrivateInternalValidatePathNameLengthFunction() override =
+      default;
+
+  void OnFilePathLimitRetrieved(size_t current_length, size_t max_length);
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivate.formatVolume method.
+// Formats Volume given its mount path.
+class FileManagerPrivateFormatVolumeFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.formatVolume",
+                             FILEMANAGERPRIVATE_FORMATVOLUME)
+
+ protected:
+  ~FileManagerPrivateFormatVolumeFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivate.renameVolume method.
+// Renames Volume given its mount path and new Volume name.
+class FileManagerPrivateRenameVolumeFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.renameVolume",
+                             FILEMANAGERPRIVATE_RENAMEVOLUME)
+
+ protected:
+  ~FileManagerPrivateRenameVolumeFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivate.startCopy method.
+class FileManagerPrivateInternalStartCopyFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.startCopy",
+                             FILEMANAGERPRIVATEINTERNAL_STARTCOPY)
+
+ protected:
+  ~FileManagerPrivateInternalStartCopyFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  void RunAfterGetFileMetadata(base::File::Error result,
+                               const base::File::Info& file_info);
+
+  // Part of RunAsync(). Called after FreeDiskSpaceIfNeededFor() is completed on
+  // IO thread.
+  void RunAfterFreeDiskSpace(bool available);
+
+  // Part of RunAsync(). Called after Copy() is started on IO thread.
+  void RunAfterStartCopy(int operation_id);
+
+  storage::FileSystemURL source_url_;
+  storage::FileSystemURL destination_url_;
+};
+
+// Implements the chrome.fileManagerPrivate.cancelCopy method.
+class FileManagerPrivateCancelCopyFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.cancelCopy",
+                             FILEMANAGERPRIVATE_CANCELCOPY)
+
+ protected:
+  ~FileManagerPrivateCancelCopyFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivateInternal.resolveIsolatedEntries
+// method.
+class FileManagerPrivateInternalResolveIsolatedEntriesFunction
+    : public ChromeAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileManagerPrivateInternal.resolveIsolatedEntries",
+      FILEMANAGERPRIVATE_RESOLVEISOLATEDENTRIES)
+
+ protected:
+  ~FileManagerPrivateInternalResolveIsolatedEntriesFunction() override =
+      default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  void RunAsyncAfterConvertFileDefinitionListToEntryDefinitionList(
+      std::unique_ptr<file_manager::util::EntryDefinitionList>
+          entry_definition_list);
+};
+
+class FileManagerPrivateInternalComputeChecksumFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  FileManagerPrivateInternalComputeChecksumFunction();
+
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.computeChecksum",
+                             FILEMANAGERPRIVATEINTERNAL_COMPUTECHECKSUM)
+
+ protected:
+  ~FileManagerPrivateInternalComputeChecksumFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  std::unique_ptr<drive::util::FileStreamMd5Digester> digester_;
+
+  void Respond(const std::string& hash);
+};
+
+// Implements the chrome.fileManagerPrivate.searchFilesByHashes method.
+class FileManagerPrivateSearchFilesByHashesFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.searchFilesByHashes",
+                             FILEMANAGERPRIVATE_SEARCHFILESBYHASHES)
+
+ protected:
+  ~FileManagerPrivateSearchFilesByHashesFunction() override = default;
+
+ private:
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+  // Sends a response with |results| to the extension.
+  void OnSearchByHashes(const std::set<std::string>& hashes,
+                        drive::FileError error,
+                        const std::vector<drive::HashAndFilePath>& results);
+};
+
+// Implements the chrome.fileManagerPrivate.isUMAEnabled method.
+class FileManagerPrivateIsUMAEnabledFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateIsUMAEnabledFunction() = default;
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.isUMAEnabled",
+                             FILEMANAGERPRIVATE_ISUMAENABLED)
+ protected:
+  ~FileManagerPrivateIsUMAEnabledFunction() override = default;
+
+ private:
+  ExtensionFunction::ResponseAction Run() override;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateIsUMAEnabledFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.setEntryTag method.
+class FileManagerPrivateInternalSetEntryTagFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateInternalSetEntryTagFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.setEntryTag",
+                             FILEMANAGERPRIVATEINTERNAL_SETENTRYTAG)
+ protected:
+  ~FileManagerPrivateInternalSetEntryTagFunction() override = default;
+
+ private:
+  const ChromeExtensionFunctionDetails chrome_details_;
+
+  // Called when setting a tag is completed with either a success or an error.
+  void OnSetEntryPropertyCompleted(drive::FileError result);
+
+  ExtensionFunction::ResponseAction Run() override;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateInternalSetEntryTagFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.getDirectorySize method.
+class FileManagerPrivateInternalGetDirectorySizeFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getDirectorySize",
+                             FILEMANAGERPRIVATEINTERNAL_GETDIRECTORYSIZE)
+
+ protected:
+  ~FileManagerPrivateInternalGetDirectorySizeFunction() override = default;
+
+  void OnDirectorySizeRetrieved(int64_t size);
+
+  // ChromeAsyncExtensionFunction overrides
+  bool RunAsync() override;
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_FILE_SYSTEM_H_
diff --git a/chrome/browser/extensions/api/file_manager/private_api_misc.cc b/chrome/browser/extensions/api/file_manager/private_api_misc.cc
new file mode 100644
index 0000000000000..28097bb8f0206
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/private_api_misc.cc
@@ -0,0 +1,910 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/private_api_misc.h"
+
+#include <stddef.h>
+
+#include <algorithm>
+#include <memory>
+#include <set>
+#include <utility>
+#include <vector>
+
+#include "base/base64.h"
+#include "base/command_line.h"
+#include "base/files/file_path.h"
+#include "base/memory/ref_counted.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/chromeos/crostini/crostini_package_installer_service.h"
+#include "chrome/browser/chromeos/crostini/crostini_util.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/chromeos/file_system_provider/mount_path_util.h"
+#include "chrome/browser/chromeos/file_system_provider/service.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/path_util.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/browser/fileapi/recent_file.h"
+#include "chrome/browser/fileapi/recent_model.h"
+#include "chrome/browser/chromeos/profiles/profile_helper.h"
+#include "chrome/browser/chromeos/settings/cros_settings.h"
+#include "chrome/browser/devtools/devtools_window.h"
+#include "chrome/browser/extensions/devtools_util.h"
+#include "chrome/browser/lifetime/application_lifetime.h"
+#include "chrome/browser/net/system_network_context_manager.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/browser/profiles/profiles_state.h"
+#include "chrome/browser/signin/profile_oauth2_token_service_factory.h"
+#include "chrome/browser/signin/signin_manager_factory.h"
+#include "chrome/browser/ui/ash/multi_user/multi_user_util.h"
+#include "chrome/browser/ui/ash/multi_user/multi_user_window_manager.h"
+#include "chrome/browser/ui/chrome_pages.h"
+#include "chrome/common/extensions/api/file_manager_private_internal.h"
+#include "chrome/common/extensions/api/manifest_types.h"
+#include "chrome/common/pref_names.h"
+#include "chrome/services/file_util/public/cpp/zip_file_creator.h"
+#include "chromeos/settings/timezone_settings.h"
+#include "components/account_id/account_id.h"
+#include "components/drive/drive_pref_names.h"
+#include "components/drive/event_logger.h"
+#include "components/prefs/pref_service.h"
+#include "components/signin/core/browser/profile_oauth2_token_service.h"
+#include "components/signin/core/browser/signin_manager.h"
+#include "components/user_manager/user_manager.h"
+#include "components/zoom/page_zoom.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/common/page_zoom.h"
+#include "content/public/common/service_manager_connection.h"
+#include "extensions/browser/api/file_handlers/mime_util.h"
+#include "extensions/browser/app_window/app_window.h"
+#include "extensions/browser/app_window/app_window_registry.h"
+#include "google_apis/drive/auth_service.h"
+#include "services/network/public/cpp/shared_url_loader_factory.h"
+#include "storage/common/fileapi/file_system_types.h"
+#include "ui/base/webui/web_ui_util.h"
+#include "url/gurl.h"
+
+namespace extensions {
+namespace {
+
+using api::file_manager_private::ProfileInfo;
+
+const char kCWSScope[] = "https://www.googleapis.com/auth/chromewebstore";
+
+// Obtains the current app window.
+AppWindow* GetCurrentAppWindow(UIThreadExtensionFunction* function) {
+  content::WebContents* const contents = function->GetSenderWebContents();
+  return contents
+             ? AppWindowRegistry::Get(function->browser_context())
+                   ->GetAppWindowForWebContents(contents)
+             : nullptr;
+}
+
+std::vector<ProfileInfo> GetLoggedInProfileInfoList() {
+  DCHECK(user_manager::UserManager::IsInitialized());
+  const std::vector<Profile*>& profiles =
+      g_browser_process->profile_manager()->GetLoadedProfiles();
+  std::set<Profile*> original_profiles;
+  std::vector<ProfileInfo> result_profiles;
+
+  for (Profile* profile : profiles) {
+    // Filter the profile.
+    profile = profile->GetOriginalProfile();
+    if (original_profiles.count(profile))
+      continue;
+    original_profiles.insert(profile);
+    const user_manager::User* const user =
+        chromeos::ProfileHelper::Get()->GetUserByProfile(profile);
+    if (!user || !user->is_logged_in())
+      continue;
+
+    // Make a ProfileInfo.
+    ProfileInfo profile_info;
+    profile_info.profile_id =
+        multi_user_util::GetAccountIdFromProfile(profile).GetUserEmail();
+    profile_info.display_name = base::UTF16ToUTF8(user->GetDisplayName());
+    // TODO(hirono): Remove the property from the profile_info.
+    profile_info.is_current_profile = true;
+
+    result_profiles.push_back(std::move(profile_info));
+  }
+
+  return result_profiles;
+}
+
+// Converts a list of file system urls (as strings) to a pair of a provided file
+// system object and a list of unique paths on the file system. In case of an
+// error, false is returned and the error message set.
+bool ConvertURLsToProvidedInfo(
+    const scoped_refptr<storage::FileSystemContext>& file_system_context,
+    const std::vector<std::string>& urls,
+    chromeos::file_system_provider::ProvidedFileSystemInterface** file_system,
+    std::vector<base::FilePath>* paths,
+    std::string* error) {
+  DCHECK(file_system);
+  DCHECK(error);
+
+  if (urls.empty()) {
+    *error = "At least one file must be specified.";
+    return false;
+  }
+
+  *file_system = nullptr;
+  for (const auto url : urls) {
+    const storage::FileSystemURL file_system_url(
+        file_system_context->CrackURL(GURL(url)));
+
+    chromeos::file_system_provider::util::FileSystemURLParser parser(
+        file_system_url);
+    if (!parser.Parse()) {
+      *error = "Related provided file system not found.";
+      return false;
+    }
+
+    if (*file_system != nullptr) {
+      if (*file_system != parser.file_system()) {
+        *error = "All entries must be on the same file system.";
+        return false;
+      }
+    } else {
+      *file_system = parser.file_system();
+    }
+    paths->push_back(parser.file_path());
+  }
+
+  // Erase duplicates.
+  std::sort(paths->begin(), paths->end());
+  paths->erase(std::unique(paths->begin(), paths->end()), paths->end());
+
+  return true;
+}
+
+bool IsAllowedSource(storage::FileSystemType type,
+                     api::file_manager_private::SourceRestriction restriction) {
+  switch (restriction) {
+    case api::file_manager_private::SOURCE_RESTRICTION_NONE:
+      NOTREACHED();
+      return false;
+
+    case api::file_manager_private::SOURCE_RESTRICTION_ANY_SOURCE:
+      return true;
+
+    case api::file_manager_private::SOURCE_RESTRICTION_NATIVE_SOURCE:
+      return type == storage::kFileSystemTypeNativeLocal;
+
+    case api::file_manager_private::SOURCE_RESTRICTION_NATIVE_OR_DRIVE_SOURCE:
+      return type == storage::kFileSystemTypeNativeLocal ||
+             type == storage::kFileSystemTypeDrive;
+  }
+}
+
+}  // namespace
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateLogoutUserForReauthenticationFunction::Run() {
+  const user_manager::User* user =
+      chromeos::ProfileHelper::Get()->GetUserByProfile(
+          Profile::FromBrowserContext(browser_context()));
+  if (user) {
+    user_manager::UserManager::Get()->SaveUserOAuthStatus(
+        user->GetAccountId(), user_manager::User::OAUTH2_TOKEN_STATUS_INVALID);
+  }
+
+  chrome::AttemptUserExit();
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateGetPreferencesFunction::Run() {
+  api::file_manager_private::Preferences result;
+  Profile* profile = Profile::FromBrowserContext(browser_context());
+  const PrefService* const service = profile->GetPrefs();
+
+  result.drive_enabled = drive::util::IsDriveEnabledForProfile(profile);
+  result.cellular_disabled =
+      service->GetBoolean(drive::prefs::kDisableDriveOverCellular);
+  result.hosted_files_disabled =
+      service->GetBoolean(drive::prefs::kDisableDriveHostedFiles);
+  result.search_suggest_enabled =
+      service->GetBoolean(prefs::kSearchSuggestEnabled);
+  result.use24hour_clock = service->GetBoolean(prefs::kUse24HourClock);
+  result.allow_redeem_offers = true;
+  if (!chromeos::CrosSettings::Get()->GetBoolean(
+          chromeos::kAllowRedeemChromeOsRegistrationOffers,
+          &result.allow_redeem_offers)) {
+    result.allow_redeem_offers = true;
+  }
+  result.timezone =
+      base::UTF16ToUTF8(chromeos::system::TimezoneSettings::GetInstance()
+                            ->GetCurrentTimezoneID());
+
+  drive::EventLogger* logger = file_manager::util::GetLogger(profile);
+  if (logger)
+    logger->Log(logging::LOG_INFO, "%s succeeded.", name());
+
+  return RespondNow(OneArgument(result.ToValue()));
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateSetPreferencesFunction::Run() {
+  using extensions::api::file_manager_private::SetPreferences::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  Profile* profile = Profile::FromBrowserContext(browser_context());
+  PrefService* const service = profile->GetPrefs();
+
+  if (params->change_info.cellular_disabled)
+    service->SetBoolean(drive::prefs::kDisableDriveOverCellular,
+                        *params->change_info.cellular_disabled);
+
+  if (params->change_info.hosted_files_disabled)
+    service->SetBoolean(drive::prefs::kDisableDriveHostedFiles,
+                        *params->change_info.hosted_files_disabled);
+
+  drive::EventLogger* logger = file_manager::util::GetLogger(profile);
+  if (logger)
+    logger->Log(logging::LOG_INFO, "%s succeeded.", name());
+  return RespondNow(NoArguments());
+}
+
+FileManagerPrivateInternalZipSelectionFunction::
+    FileManagerPrivateInternalZipSelectionFunction() = default;
+
+FileManagerPrivateInternalZipSelectionFunction::
+    ~FileManagerPrivateInternalZipSelectionFunction() = default;
+
+bool FileManagerPrivateInternalZipSelectionFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::ZipSelection::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  // First param is the parent directory URL.
+  if (params->parent_url.empty())
+    return false;
+
+  base::FilePath src_dir = file_manager::util::GetLocalPathFromURL(
+      render_frame_host(), GetProfile(), GURL(params->parent_url));
+  if (src_dir.empty())
+    return false;
+
+  // Second param is the list of selected file URLs to be zipped.
+  if (params->urls.empty())
+    return false;
+
+  std::vector<base::FilePath> files;
+  for (size_t i = 0; i < params->urls.size(); ++i) {
+    base::FilePath path = file_manager::util::GetLocalPathFromURL(
+        render_frame_host(), GetProfile(), GURL(params->urls[i]));
+    if (path.empty())
+      return false;
+    files.push_back(path);
+  }
+
+  // Third param is the name of the output zip file.
+  if (params->dest_name.empty())
+    return false;
+
+  // Check if the dir path is under Drive mount point.
+  // TODO(hshi): support create zip file on Drive (crbug.com/158690).
+  if (drive::util::IsUnderDriveMountPoint(src_dir))
+    return false;
+
+  base::FilePath dest_file = src_dir.Append(params->dest_name);
+  std::vector<base::FilePath> src_relative_paths;
+  for (size_t i = 0; i != files.size(); ++i) {
+    const base::FilePath& file_path = files[i];
+
+    // Obtain the relative path of |file_path| under |src_dir|.
+    base::FilePath relative_path;
+    if (!src_dir.AppendRelativePath(file_path, &relative_path))
+      return false;
+    src_relative_paths.push_back(relative_path);
+  }
+
+  (new ZipFileCreator(
+       base::Bind(&FileManagerPrivateInternalZipSelectionFunction::OnZipDone,
+                  this),
+       src_dir, src_relative_paths, dest_file))
+      ->Start(
+          content::ServiceManagerConnection::GetForProcess()->GetConnector());
+  return true;
+}
+
+void FileManagerPrivateInternalZipSelectionFunction::OnZipDone(bool success) {
+  SetResult(std::make_unique<base::Value>(success));
+  SendResponse(true);
+}
+
+ExtensionFunction::ResponseAction FileManagerPrivateZoomFunction::Run() {
+  using extensions::api::file_manager_private::Zoom::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  content::PageZoom zoom_type;
+  switch (params->operation) {
+    case api::file_manager_private::ZOOM_OPERATION_TYPE_IN:
+      zoom_type = content::PAGE_ZOOM_IN;
+      break;
+    case api::file_manager_private::ZOOM_OPERATION_TYPE_OUT:
+      zoom_type = content::PAGE_ZOOM_OUT;
+      break;
+    case api::file_manager_private::ZOOM_OPERATION_TYPE_RESET:
+      zoom_type = content::PAGE_ZOOM_RESET;
+      break;
+    default:
+      NOTREACHED();
+      return RespondNow(Error(kUnknownErrorDoNotUse));
+  }
+  zoom::PageZoom::Zoom(GetSenderWebContents(), zoom_type);
+  return RespondNow(NoArguments());
+}
+
+FileManagerPrivateRequestWebStoreAccessTokenFunction::
+    FileManagerPrivateRequestWebStoreAccessTokenFunction() = default;
+
+FileManagerPrivateRequestWebStoreAccessTokenFunction::
+    ~FileManagerPrivateRequestWebStoreAccessTokenFunction() = default;
+
+bool FileManagerPrivateRequestWebStoreAccessTokenFunction::RunAsync() {
+  std::vector<std::string> scopes;
+  scopes.emplace_back(kCWSScope);
+
+  ProfileOAuth2TokenService* oauth_service =
+      ProfileOAuth2TokenServiceFactory::GetForProfile(GetProfile());
+
+  if (!oauth_service) {
+    drive::EventLogger* logger = file_manager::util::GetLogger(GetProfile());
+    if (logger) {
+      logger->Log(logging::LOG_ERROR,
+                  "CWS OAuth token fetch failed. OAuth2TokenService can't "
+                  "be retrieved.");
+    }
+    SetResult(std::make_unique<base::Value>());
+    return false;
+  }
+
+  SigninManagerBase* signin_manager =
+      SigninManagerFactory::GetForProfile(GetProfile());
+  auth_service_ = std::make_unique<google_apis::AuthService>(
+      oauth_service, signin_manager->GetAuthenticatedAccountId(),
+      g_browser_process->system_network_context_manager()
+          ->GetSharedURLLoaderFactory(),
+      scopes);
+  auth_service_->StartAuthentication(base::Bind(
+      &FileManagerPrivateRequestWebStoreAccessTokenFunction::
+          OnAccessTokenFetched,
+      this));
+
+  return true;
+}
+
+void FileManagerPrivateRequestWebStoreAccessTokenFunction::OnAccessTokenFetched(
+    google_apis::DriveApiErrorCode code,
+    const std::string& access_token) {
+  drive::EventLogger* logger = file_manager::util::GetLogger(GetProfile());
+
+  if (code == google_apis::HTTP_SUCCESS) {
+    DCHECK(auth_service_->HasAccessToken());
+    DCHECK(access_token == auth_service_->access_token());
+    if (logger)
+      logger->Log(logging::LOG_INFO, "CWS OAuth token fetch succeeded.");
+    SetResult(std::make_unique<base::Value>(access_token));
+    SendResponse(true);
+  } else {
+    if (logger) {
+      logger->Log(logging::LOG_ERROR,
+                  "CWS OAuth token fetch failed. (DriveApiErrorCode: %s)",
+                  google_apis::DriveApiErrorCodeToString(code).c_str());
+    }
+    SetResult(std::make_unique<base::Value>());
+    SendResponse(false);
+  }
+}
+
+ExtensionFunction::ResponseAction FileManagerPrivateGetProfilesFunction::Run() {
+  const std::vector<ProfileInfo>& profiles = GetLoggedInProfileInfoList();
+
+  // Obtains the display profile ID.
+  AppWindow* const app_window = GetCurrentAppWindow(this);
+  MultiUserWindowManager* const window_manager =
+      MultiUserWindowManager::GetInstance();
+  const AccountId current_profile_id = multi_user_util::GetAccountIdFromProfile(
+      Profile::FromBrowserContext(browser_context()));
+  const AccountId display_profile_id =
+      window_manager && app_window
+          ? window_manager->GetUserPresentingWindow(
+                app_window->GetNativeWindow())
+          : EmptyAccountId();
+
+  return RespondNow(
+      ArgumentList(api::file_manager_private::GetProfiles::Results::Create(
+          profiles, current_profile_id.GetUserEmail(),
+          display_profile_id.is_valid() ? display_profile_id.GetUserEmail()
+                                        : current_profile_id.GetUserEmail())));
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateOpenInspectorFunction::Run() {
+  using extensions::api::file_manager_private::OpenInspector::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  switch (params->type) {
+    case extensions::api::file_manager_private::INSPECTION_TYPE_NORMAL:
+      // Open inspector for foreground page.
+      DevToolsWindow::OpenDevToolsWindow(GetSenderWebContents());
+      break;
+    case extensions::api::file_manager_private::INSPECTION_TYPE_CONSOLE:
+      // Open inspector for foreground page and bring focus to the console.
+      DevToolsWindow::OpenDevToolsWindow(
+          GetSenderWebContents(), DevToolsToggleAction::ShowConsolePanel());
+      break;
+    case extensions::api::file_manager_private::INSPECTION_TYPE_ELEMENT:
+      // Open inspector for foreground page in inspect element mode.
+      DevToolsWindow::OpenDevToolsWindow(GetSenderWebContents(),
+                                         DevToolsToggleAction::Inspect());
+      break;
+    case extensions::api::file_manager_private::INSPECTION_TYPE_BACKGROUND:
+      // Open inspector for background page.
+      extensions::devtools_util::InspectBackgroundPage(
+          extension(), Profile::FromBrowserContext(browser_context()));
+      break;
+    default:
+      NOTREACHED();
+      return RespondNow(Error(
+          base::StringPrintf("Unexpected inspection type(%d) is specified.",
+                             static_cast<int>(params->type))));
+  }
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateOpenSettingsSubpageFunction::Run() {
+  using extensions::api::file_manager_private::OpenSettingsSubpage::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  chrome::ShowSettingsSubPageForProfile(ProfileManager::GetActiveUserProfile(),
+                                        params->sub_page);
+  return RespondNow(NoArguments());
+}
+
+FileManagerPrivateInternalGetMimeTypeFunction::
+    FileManagerPrivateInternalGetMimeTypeFunction() = default;
+
+FileManagerPrivateInternalGetMimeTypeFunction::
+    ~FileManagerPrivateInternalGetMimeTypeFunction() = default;
+
+bool FileManagerPrivateInternalGetMimeTypeFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::GetMimeType::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  // Convert file url to local path.
+  const scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  storage::FileSystemURL file_system_url(
+      file_system_context->CrackURL(GURL(params->url)));
+
+  app_file_handler_util::GetMimeTypeForLocalPath(
+      GetProfile(), file_system_url.path(),
+      base::Bind(&FileManagerPrivateInternalGetMimeTypeFunction::OnGetMimeType,
+                 this));
+
+  return true;
+}
+
+void FileManagerPrivateInternalGetMimeTypeFunction::OnGetMimeType(
+    const std::string& mimeType) {
+  SetResult(std::make_unique<base::Value>(mimeType));
+  SendResponse(true);
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateIsPiexLoaderEnabledFunction::Run() {
+#if defined(OFFICIAL_BUILD)
+  return RespondNow(OneArgument(std::make_unique<base::Value>(true)));
+#else
+  return RespondNow(OneArgument(std::make_unique<base::Value>(false)));
+#endif
+}
+
+FileManagerPrivateGetProvidersFunction::FileManagerPrivateGetProvidersFunction()
+    : chrome_details_(this) {}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateGetProvidersFunction::Run() {
+  using chromeos::file_system_provider::Capabilities;
+  using chromeos::file_system_provider::IconSet;
+  using chromeos::file_system_provider::ProviderId;
+  using chromeos::file_system_provider::ProviderInterface;
+  using chromeos::file_system_provider::Service;
+  const Service* const service = Service::Get(chrome_details_.GetProfile());
+
+  using api::file_manager_private::Provider;
+  std::vector<Provider> result;
+  for (const auto& pair : service->GetProviders()) {
+    const ProviderInterface* const provider = pair.second.get();
+    const ProviderId provider_id = provider->GetId();
+
+    Provider result_item;
+    result_item.provider_id = provider->GetId().ToString();
+    const IconSet& icon_set = provider->GetIconSet();
+    file_manager::util::FillIconSet(&result_item.icon_set, icon_set);
+    result_item.name = provider->GetName();
+
+    const Capabilities capabilities = provider->GetCapabilities();
+    result_item.configurable = capabilities.configurable;
+    result_item.watchable = capabilities.watchable;
+    result_item.multiple_mounts = capabilities.multiple_mounts;
+    switch (capabilities.source) {
+      case SOURCE_FILE:
+        result_item.source =
+            api::manifest_types::FILE_SYSTEM_PROVIDER_SOURCE_FILE;
+        break;
+      case SOURCE_DEVICE:
+        result_item.source =
+            api::manifest_types::FILE_SYSTEM_PROVIDER_SOURCE_DEVICE;
+        break;
+      case SOURCE_NETWORK:
+        result_item.source =
+            api::manifest_types::FILE_SYSTEM_PROVIDER_SOURCE_NETWORK;
+        break;
+    }
+    result.push_back(std::move(result_item));
+  }
+
+  return RespondNow(ArgumentList(
+      api::file_manager_private::GetProviders::Results::Create(result)));
+}
+
+FileManagerPrivateAddProvidedFileSystemFunction::
+    FileManagerPrivateAddProvidedFileSystemFunction()
+    : chrome_details_(this) {
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateAddProvidedFileSystemFunction::Run() {
+  using extensions::api::file_manager_private::AddProvidedFileSystem::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  using chromeos::file_system_provider::Service;
+  using chromeos::file_system_provider::ProvidingExtensionInfo;
+  using chromeos::file_system_provider::ProviderId;
+  Service* const service = Service::Get(chrome_details_.GetProfile());
+
+  if (!service->RequestMount(ProviderId::FromString(params->provider_id)))
+    return RespondNow(Error("Failed to request a new mount."));
+
+  return RespondNow(NoArguments());
+}
+
+FileManagerPrivateConfigureVolumeFunction::
+    FileManagerPrivateConfigureVolumeFunction()
+    : chrome_details_(this) {
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateConfigureVolumeFunction::Run() {
+  using extensions::api::file_manager_private::ConfigureVolume::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  using file_manager::VolumeManager;
+  using file_manager::Volume;
+  VolumeManager* const volume_manager =
+      VolumeManager::Get(chrome_details_.GetProfile());
+  base::WeakPtr<Volume> volume =
+      volume_manager->FindVolumeById(params->volume_id);
+  if (!volume.get())
+    return RespondNow(Error("Volume not found."));
+  if (!volume->configurable())
+    return RespondNow(Error("Volume not configurable."));
+
+  switch (volume->type()) {
+    case file_manager::VOLUME_TYPE_PROVIDED: {
+      using chromeos::file_system_provider::Service;
+      Service* const service = Service::Get(chrome_details_.GetProfile());
+      DCHECK(service);
+
+      using chromeos::file_system_provider::ProvidedFileSystemInterface;
+      ProvidedFileSystemInterface* const file_system =
+          service->GetProvidedFileSystem(volume->provider_id(),
+                                         volume->file_system_id());
+      if (file_system)
+        file_system->Configure(base::Bind(
+            &FileManagerPrivateConfigureVolumeFunction::OnCompleted, this));
+      break;
+    }
+    default:
+      NOTIMPLEMENTED();
+  }
+
+  return RespondLater();
+}
+
+void FileManagerPrivateConfigureVolumeFunction::OnCompleted(
+    base::File::Error result) {
+  if (result != base::File::FILE_OK) {
+    Respond(Error("Failed to complete configuration."));
+    return;
+  }
+
+  Respond(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateIsCrostiniEnabledFunction::Run() {
+  return RespondNow(OneArgument(std::make_unique<base::Value>(
+      IsCrostiniEnabled(Profile::FromBrowserContext(browser_context())))));
+}
+
+FileManagerPrivateMountCrostiniContainerFunction::
+    FileManagerPrivateMountCrostiniContainerFunction() = default;
+
+FileManagerPrivateMountCrostiniContainerFunction::
+    ~FileManagerPrivateMountCrostiniContainerFunction() = default;
+
+bool FileManagerPrivateMountCrostiniContainerFunction::RunAsync() {
+  Profile* profile = Profile::FromBrowserContext(browser_context());
+  DCHECK(IsCrostiniEnabled(profile));
+  crostini::CrostiniManager::GetInstance()->RestartCrostini(
+      profile, kCrostiniDefaultVmName, kCrostiniDefaultContainerName,
+      base::BindOnce(
+          &FileManagerPrivateMountCrostiniContainerFunction::RestartCallback,
+          this));
+  return true;
+}
+
+void FileManagerPrivateMountCrostiniContainerFunction::RestartCallback(
+    crostini::ConciergeClientResult result) {
+  if (result != crostini::ConciergeClientResult::SUCCESS) {
+    Respond(Error(
+        base::StringPrintf("Error mounting crostini container: %d", result)));
+    return;
+  }
+  Respond(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateInternalInstallLinuxPackageFunction::Run() {
+  using extensions::api::file_manager_private_internal::InstallLinuxPackage::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  Profile* profile = Profile::FromBrowserContext(browser_context());
+  const scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          profile, render_frame_host());
+
+  std::string url =
+      file_manager::util::ConvertFileSystemURLToPathInsideCrostini(
+          profile, file_system_context->CrackURL(GURL(params->url)));
+  crostini::CrostiniPackageInstallerService::GetForProfile(profile)
+      ->InstallLinuxPackage(
+          kCrostiniDefaultVmName, kCrostiniDefaultContainerName, url,
+          base::BindOnce(
+              &FileManagerPrivateInternalInstallLinuxPackageFunction::
+                  OnInstallLinuxPackage,
+              this));
+  return RespondLater();
+}
+
+void FileManagerPrivateInternalInstallLinuxPackageFunction::
+    OnInstallLinuxPackage(crostini::ConciergeClientResult result,
+                          const std::string& failure_reason) {
+  extensions::api::file_manager_private::InstallLinuxPackageResponse response;
+  switch (result) {
+    case crostini::ConciergeClientResult::SUCCESS:
+      response = extensions::api::file_manager_private::
+          INSTALL_LINUX_PACKAGE_RESPONSE_STARTED;
+      break;
+    case crostini::ConciergeClientResult::INSTALL_LINUX_PACKAGE_FAILED:
+      response = extensions::api::file_manager_private::
+          INSTALL_LINUX_PACKAGE_RESPONSE_FAILED;
+      break;
+    case crostini::ConciergeClientResult::INSTALL_LINUX_PACKAGE_ALREADY_ACTIVE:
+      response = extensions::api::file_manager_private::
+          INSTALL_LINUX_PACKAGE_RESPONSE_INSTALL_ALREADY_ACTIVE;
+      break;
+    default:
+      NOTREACHED();
+  }
+  Respond(ArgumentList(
+      extensions::api::file_manager_private_internal::InstallLinuxPackage::
+          Results::Create(response, failure_reason)));
+}
+
+FileManagerPrivateInternalGetCustomActionsFunction::
+    FileManagerPrivateInternalGetCustomActionsFunction()
+    : chrome_details_(this) {}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateInternalGetCustomActionsFunction::Run() {
+  using extensions::api::file_manager_private_internal::GetCustomActions::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          chrome_details_.GetProfile(), render_frame_host());
+
+  std::vector<base::FilePath> paths;
+  chromeos::file_system_provider::ProvidedFileSystemInterface* file_system =
+      nullptr;
+  std::string error;
+
+  if (!ConvertURLsToProvidedInfo(file_system_context, params->urls,
+                                 &file_system, &paths, &error)) {
+    return RespondNow(Error(error));
+  }
+
+  DCHECK(file_system);
+  file_system->GetActions(
+      paths,
+      base::Bind(
+          &FileManagerPrivateInternalGetCustomActionsFunction::OnCompleted,
+          this));
+  return RespondLater();
+}
+
+void FileManagerPrivateInternalGetCustomActionsFunction::OnCompleted(
+    const chromeos::file_system_provider::Actions& actions,
+    base::File::Error result) {
+  if (result != base::File::FILE_OK) {
+    Respond(Error("Failed to fetch actions."));
+    return;
+  }
+
+  using api::file_system_provider::Action;
+  std::vector<Action> items;
+  for (const auto& action : actions) {
+    Action item;
+    item.id = action.id;
+    item.title = std::make_unique<std::string>(action.title);
+    items.push_back(std::move(item));
+  }
+
+  Respond(ArgumentList(
+      api::file_manager_private_internal::GetCustomActions::Results::Create(
+          items)));
+}
+
+FileManagerPrivateInternalExecuteCustomActionFunction::
+    FileManagerPrivateInternalExecuteCustomActionFunction()
+    : chrome_details_(this) {}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateInternalExecuteCustomActionFunction::Run() {
+  using extensions::api::file_manager_private_internal::ExecuteCustomAction::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          chrome_details_.GetProfile(), render_frame_host());
+
+  std::vector<base::FilePath> paths;
+  chromeos::file_system_provider::ProvidedFileSystemInterface* file_system =
+      nullptr;
+  std::string error;
+
+  if (!ConvertURLsToProvidedInfo(file_system_context, params->urls,
+                                 &file_system, &paths, &error)) {
+    return RespondNow(Error(error));
+  }
+
+  DCHECK(file_system);
+  file_system->ExecuteAction(
+      paths, params->action_id,
+      base::Bind(
+          &FileManagerPrivateInternalExecuteCustomActionFunction::OnCompleted,
+          this));
+  return RespondLater();
+}
+
+void FileManagerPrivateInternalExecuteCustomActionFunction::OnCompleted(
+    base::File::Error result) {
+  if (result != base::File::FILE_OK) {
+    Respond(Error("Failed to execute the action."));
+    return;
+  }
+
+  Respond(NoArguments());
+}
+
+FileManagerPrivateInternalGetRecentFilesFunction::
+    FileManagerPrivateInternalGetRecentFilesFunction()
+    : chrome_details_(this) {}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateInternalGetRecentFilesFunction::Run() {
+  using extensions::api::file_manager_private_internal::GetRecentFiles::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          chrome_details_.GetProfile(), render_frame_host());
+
+  chromeos::RecentModel* model =
+      chromeos::RecentModel::GetForProfile(chrome_details_.GetProfile());
+
+  model->GetRecentFiles(
+      file_system_context.get(),
+      Extension::GetBaseURLFromExtensionId(extension_id()),
+      base::BindOnce(
+          &FileManagerPrivateInternalGetRecentFilesFunction::OnGetRecentFiles,
+          this, params->restriction));
+  return RespondLater();
+}
+
+void FileManagerPrivateInternalGetRecentFilesFunction::OnGetRecentFiles(
+    api::file_manager_private::SourceRestriction restriction,
+    const std::vector<chromeos::RecentFile>& files) {
+  file_manager::util::FileDefinitionList file_definition_list;
+  for (const auto& file : files) {
+    // Filter out files from non-allowed sources.
+    // We do this filtering here rather than in RecentModel so that the set of
+    // files returned with some restriction is a subset of what would be
+    // returned without restriction. Anyway, the maximum number of files
+    // returned from RecentModel is large enough.
+    if (!IsAllowedSource(file.url().type(), restriction))
+      continue;
+
+    file_manager::util::FileDefinition file_definition;
+    const bool result =
+        file_manager::util::ConvertAbsoluteFilePathToRelativeFileSystemPath(
+            chrome_details_.GetProfile(), extension_id(), file.url().path(),
+            &file_definition.virtual_path);
+    if (!result)
+      continue;
+
+    // Recent file system only lists regular files, not directories.
+    file_definition.is_directory = false;
+    file_definition_list.emplace_back(std::move(file_definition));
+  }
+
+  file_manager::util::ConvertFileDefinitionListToEntryDefinitionList(
+      chrome_details_.GetProfile(), extension_id(),
+      file_definition_list,  // Safe, since copied internally.
+      base::Bind(&FileManagerPrivateInternalGetRecentFilesFunction::
+                     OnConvertFileDefinitionListToEntryDefinitionList,
+                 this));
+}
+
+void FileManagerPrivateInternalGetRecentFilesFunction::
+    OnConvertFileDefinitionListToEntryDefinitionList(
+        std::unique_ptr<file_manager::util::EntryDefinitionList>
+            entry_definition_list) {
+  DCHECK(entry_definition_list);
+
+  auto entries = std::make_unique<base::ListValue>();
+
+  for (const auto& definition : *entry_definition_list) {
+    if (definition.error != base::File::FILE_OK)
+      continue;
+    auto entry = std::make_unique<base::DictionaryValue>();
+    entry->SetString("fileSystemName", definition.file_system_name);
+    entry->SetString("fileSystemRoot", definition.file_system_root_url);
+    entry->SetString("fileFullPath", "/" + definition.full_path.AsUTF8Unsafe());
+    entry->SetBoolean("fileIsDirectory", definition.is_directory);
+    entries->Append(std::move(entry));
+  }
+
+  Respond(OneArgument(std::move(entries)));
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_manager/private_api_misc.h b/chrome/browser/extensions/api/file_manager/private_api_misc.h
new file mode 100644
index 0000000000000..ba79ff21f0e14
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/private_api_misc.h
@@ -0,0 +1,382 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides miscellaneous API functions, which don't belong to
+// other files.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_MISC_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_MISC_H_
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/files/file.h"
+#include "base/macros.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_interface.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_base.h"
+#include "chrome/browser/extensions/chrome_extension_function.h"
+#include "chrome/browser/extensions/chrome_extension_function_details.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "google_apis/drive/drive_api_error_codes.h"
+#include "storage/browser/fileapi/file_system_url.h"
+
+namespace chromeos {
+class RecentFile;
+}  // namespace chromeos
+
+namespace crostini {
+enum class ConciergeClientResult;
+}
+
+namespace file_manager {
+namespace util {
+struct EntryDefinition;
+typedef std::vector<EntryDefinition> EntryDefinitionList;
+}  // namespace util
+}  // namespace file_manager
+
+namespace google_apis {
+class AuthServiceInterface;
+}  // namespace google_apis
+
+namespace extensions {
+
+// Implements the chrome.fileManagerPrivate.logoutUserForReauthentication
+// method.
+class FileManagerPrivateLogoutUserForReauthenticationFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.logoutUserForReauthentication",
+                             FILEMANAGERPRIVATE_LOGOUTUSERFORREAUTHENTICATION)
+
+ protected:
+  ~FileManagerPrivateLogoutUserForReauthenticationFunction() override = default;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.getPreferences method.
+// Gets settings for the Files app.
+class FileManagerPrivateGetPreferencesFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.getPreferences",
+                             FILEMANAGERPRIVATE_GETPREFERENCES)
+
+ protected:
+  ~FileManagerPrivateGetPreferencesFunction() override = default;
+
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.setPreferences method.
+// Sets settings for the Files app.
+class FileManagerPrivateSetPreferencesFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.setPreferences",
+                             FILEMANAGERPRIVATE_SETPREFERENCES)
+
+ protected:
+  ~FileManagerPrivateSetPreferencesFunction() override = default;
+
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.zipSelection method.
+// Creates a zip file for the selected files.
+class FileManagerPrivateInternalZipSelectionFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.zipSelection",
+                             FILEMANAGERPRIVATEINTERNAL_ZIPSELECTION)
+
+  FileManagerPrivateInternalZipSelectionFunction();
+
+ protected:
+  ~FileManagerPrivateInternalZipSelectionFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+  // Receives the result from ZipFileCreator.
+  void OnZipDone(bool success);
+};
+
+// Implements the chrome.fileManagerPrivate.zoom method.
+// Changes the zoom level of the file manager by modifying the zoom level of the
+// WebContents.
+// TODO(hirono): Remove this function once the zoom level change is supported
+// for all apps. crbug.com/227175.
+class FileManagerPrivateZoomFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.zoom",
+                             FILEMANAGERPRIVATE_ZOOM);
+
+ protected:
+  ~FileManagerPrivateZoomFunction() override = default;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+};
+
+class FileManagerPrivateRequestWebStoreAccessTokenFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.requestWebStoreAccessToken",
+                             FILEMANAGERPRIVATE_REQUESTWEBSTOREACCESSTOKEN);
+
+  FileManagerPrivateRequestWebStoreAccessTokenFunction();
+
+ protected:
+  ~FileManagerPrivateRequestWebStoreAccessTokenFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  std::unique_ptr<google_apis::AuthServiceInterface> auth_service_;
+
+  void OnAccessTokenFetched(google_apis::DriveApiErrorCode code,
+                            const std::string& access_token);
+};
+
+class FileManagerPrivateGetProfilesFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.getProfiles",
+                             FILEMANAGERPRIVATE_GETPROFILES);
+
+ protected:
+  ~FileManagerPrivateGetProfilesFunction() override = default;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.openInspector method.
+class FileManagerPrivateOpenInspectorFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.openInspector",
+                             FILEMANAGERPRIVATE_OPENINSPECTOR);
+
+ protected:
+  ~FileManagerPrivateOpenInspectorFunction() override = default;
+
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.openSettingsSubpage method.
+class FileManagerPrivateOpenSettingsSubpageFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.openSettingsSubpage",
+                             FILEMANAGERPRIVATE_OPENSETTINGSSUBPAGE);
+
+ protected:
+  ~FileManagerPrivateOpenSettingsSubpageFunction() override = default;
+
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.getMimeType method.
+class FileManagerPrivateInternalGetMimeTypeFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getMimeType",
+                             FILEMANAGERPRIVATEINTERNAL_GETMIMETYPE)
+
+  FileManagerPrivateInternalGetMimeTypeFunction();
+
+ protected:
+  ~FileManagerPrivateInternalGetMimeTypeFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+  void OnGetMimeType(const std::string& mimeType);
+};
+
+// Implements the chrome.fileManagerPrivate.isPiexLoaderEnabled method.
+class FileManagerPrivateIsPiexLoaderEnabledFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateIsPiexLoaderEnabledFunction() = default;
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.isPiexLoaderEnabled",
+                             FILEMANAGERPRIVATE_ISPIEXLOADERENABLED)
+ protected:
+  ~FileManagerPrivateIsPiexLoaderEnabledFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateIsPiexLoaderEnabledFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.getProviders method.
+class FileManagerPrivateGetProvidersFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateGetProvidersFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.getProviders",
+                             FILEMANAGERPRIVATE_GETPROVIDERS)
+ protected:
+  ~FileManagerPrivateGetProvidersFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  const ChromeExtensionFunctionDetails chrome_details_;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateGetProvidersFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.addProvidedFileSystem method.
+class FileManagerPrivateAddProvidedFileSystemFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateAddProvidedFileSystemFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.addProvidedFileSystem",
+                             FILEMANAGERPRIVATE_ADDPROVIDEDFILESYSTEM)
+ protected:
+  ~FileManagerPrivateAddProvidedFileSystemFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  const ChromeExtensionFunctionDetails chrome_details_;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateAddProvidedFileSystemFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.configureVolume method.
+class FileManagerPrivateConfigureVolumeFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateConfigureVolumeFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.configureVolume",
+                             FILEMANAGERPRIVATE_CONFIGUREVOLUME)
+ protected:
+  ~FileManagerPrivateConfigureVolumeFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  void OnCompleted(base::File::Error result);
+
+  const ChromeExtensionFunctionDetails chrome_details_;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateConfigureVolumeFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.isCrostiniEnabled method.
+// Gets crostini sftp mount params.
+class FileManagerPrivateIsCrostiniEnabledFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.isCrostiniEnabled",
+                             FILEMANAGERPRIVATE_ISCROSTINIENABLED)
+
+ protected:
+  ~FileManagerPrivateIsCrostiniEnabledFunction() override = default;
+
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.mountCrostiniContainer method.
+// Starts and mounts crostini container.
+class FileManagerPrivateMountCrostiniContainerFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.mountCrostiniContainer",
+                             FILEMANAGERPRIVATE_MOUNTCROSTINICONTAINER)
+  FileManagerPrivateMountCrostiniContainerFunction();
+
+ protected:
+  ~FileManagerPrivateMountCrostiniContainerFunction() override;
+
+  bool RunAsync() override;
+  void RestartCallback(crostini::ConciergeClientResult);
+
+ private:
+  std::string source_path_;
+  std::string mount_label_;
+};
+
+// Implements the chrome.fileManagerPrivate.installLinuxPackage method.
+// Starts installation of a Linux package.
+class FileManagerPrivateInternalInstallLinuxPackageFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.installLinuxPackage",
+                             FILEMANAGERPRIVATEINTERNAL_INSTALLLINUXPACKAGE)
+
+ protected:
+  ~FileManagerPrivateInternalInstallLinuxPackageFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  void OnInstallLinuxPackage(crostini::ConciergeClientResult result,
+                             const std::string& failure_reason);
+};
+
+// Implements the chrome.fileManagerPrivate.getCustomActions method.
+class FileManagerPrivateInternalGetCustomActionsFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateInternalGetCustomActionsFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getCustomActions",
+                             FILEMANAGERPRIVATEINTERNAL_GETCUSTOMACTIONS)
+ protected:
+  ~FileManagerPrivateInternalGetCustomActionsFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  void OnCompleted(const chromeos::file_system_provider::Actions& actions,
+                   base::File::Error result);
+
+  const ChromeExtensionFunctionDetails chrome_details_;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateInternalGetCustomActionsFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.executeCustomAction method.
+class FileManagerPrivateInternalExecuteCustomActionFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateInternalExecuteCustomActionFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.executeCustomAction",
+                             FILEMANAGERPRIVATEINTERNAL_EXECUTECUSTOMACTION)
+ protected:
+  ~FileManagerPrivateInternalExecuteCustomActionFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  void OnCompleted(base::File::Error result);
+
+  const ChromeExtensionFunctionDetails chrome_details_;
+  DISALLOW_COPY_AND_ASSIGN(
+      FileManagerPrivateInternalExecuteCustomActionFunction);
+};
+
+// Implements the chrome.fileManagerPrivateInternal.getRecentFiles method.
+class FileManagerPrivateInternalGetRecentFilesFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateInternalGetRecentFilesFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getRecentFiles",
+                             FILEMANAGERPRIVATE_GETRECENTFILES)
+ protected:
+  ~FileManagerPrivateInternalGetRecentFilesFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  void OnGetRecentFiles(
+      api::file_manager_private::SourceRestriction restriction,
+      const std::vector<chromeos::RecentFile>& files);
+  void OnConvertFileDefinitionListToEntryDefinitionList(
+      std::unique_ptr<file_manager::util::EntryDefinitionList>
+          entry_definition_list);
+
+  const ChromeExtensionFunctionDetails chrome_details_;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateInternalGetRecentFilesFunction);
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_MISC_H_
diff --git a/chrome/browser/extensions/api/file_manager/private_api_mount.cc b/chrome/browser/extensions/api/file_manager/private_api_mount.cc
new file mode 100644
index 0000000000000..1aea875c6b78e
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/private_api_mount.cc
@@ -0,0 +1,391 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/private_api_mount.h"
+
+#include <memory>
+#include <string>
+
+#include "base/files/file_util.h"
+#include "base/format_macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/task/post_task.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "chromeos/disks/disk_mount_manager.h"
+#include "components/drive/chromeos/file_system_interface.h"
+#include "components/drive/event_logger.h"
+#include "content/public/browser/browser_thread.h"
+#include "google_apis/drive/task_util.h"
+#include "ui/shell_dialogs/selected_file_info.h"
+
+using chromeos::disks::DiskMountManager;
+using content::BrowserThread;
+namespace file_manager_private = extensions::api::file_manager_private;
+
+namespace extensions {
+
+namespace {
+
+// Does chmod o+r for the given path to ensure the file is readable from avfs.
+void EnsureReadableFilePermissionAsync(
+    const base::FilePath& path,
+    const base::Callback<void(drive::FileError, const base::FilePath&)>&
+        callback) {
+  int mode = 0;
+  if (!base::GetPosixFilePermissions(path, &mode) ||
+      !base::SetPosixFilePermissions(path, mode | S_IROTH)) {
+    callback.Run(drive::FILE_ERROR_ACCESS_DENIED, base::FilePath());
+    return;
+  }
+  callback.Run(drive::FILE_ERROR_OK, path);
+}
+
+}  // namespace
+
+bool FileManagerPrivateAddMountFunction::RunAsync() {
+  using file_manager_private::AddMount::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  drive::EventLogger* logger = file_manager::util::GetLogger(GetProfile());
+  if (logger) {
+    logger->Log(logging::LOG_INFO, "%s[%d] called. (source: '%s')", name(),
+                request_id(),
+                params->source.empty() ? "(none)" : params->source.c_str());
+  }
+  set_log_on_completion(true);
+
+  const base::FilePath path = file_manager::util::GetLocalPathFromURL(
+      render_frame_host(), GetProfile(), GURL(params->source));
+
+  if (path.empty())
+    return false;
+
+  // Check if the source path is under Drive cache directory.
+  if (drive::util::IsUnderDriveMountPoint(path)) {
+    drive::FileSystemInterface* file_system =
+        drive::util::GetFileSystemByProfile(GetProfile());
+    if (!file_system)
+      return false;
+
+    // Ensure that the cache file exists.
+    const base::FilePath drive_path = drive::util::ExtractDrivePath(path);
+    file_system->GetFile(
+        drive_path,
+        base::Bind(&FileManagerPrivateAddMountFunction::RunAfterGetDriveFile,
+                   this,
+                   drive_path));
+  } else {
+    file_manager::VolumeManager* volume_manager =
+        file_manager::VolumeManager::Get(GetProfile());
+    DCHECK(volume_manager);
+
+    bool is_under_downloads = false;
+    const std::vector<base::WeakPtr<file_manager::Volume>> volumes =
+        volume_manager->GetVolumeList();
+    for (const auto& volume : volumes) {
+      if (volume->type() == file_manager::VOLUME_TYPE_DOWNLOADS_DIRECTORY &&
+          volume->mount_path().IsParent(path)) {
+        is_under_downloads = true;
+        break;
+      }
+    }
+
+    if (is_under_downloads) {
+      // For files under downloads, change the file permission and make it
+      // readable from avfs/fuse if needed.
+      base::PostTaskWithTraits(
+          FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_BLOCKING},
+          base::BindOnce(&EnsureReadableFilePermissionAsync, path,
+                         google_apis::CreateRelayCallback(
+                             base::Bind(&FileManagerPrivateAddMountFunction::
+                                            RunAfterMarkCacheFileAsMounted,
+                                        this, path.BaseName()))));
+    } else {
+      RunAfterMarkCacheFileAsMounted(
+          path.BaseName(), drive::FILE_ERROR_OK, path);
+    }
+  }
+  return true;
+}
+
+void FileManagerPrivateAddMountFunction::RunAfterGetDriveFile(
+    const base::FilePath& drive_path,
+    drive::FileError error,
+    const base::FilePath& cache_path,
+    std::unique_ptr<drive::ResourceEntry> entry) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (error != drive::FILE_ERROR_OK) {
+    SendResponse(false);
+    return;
+  }
+
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system) {
+    SendResponse(false);
+    return;
+  }
+
+  file_system->IsCacheFileMarkedAsMounted(
+      drive_path, base::Bind(&FileManagerPrivateAddMountFunction::
+                                 RunAfterIsCacheFileMarkedAsMounted,
+                             this, drive_path, cache_path));
+}
+
+void FileManagerPrivateAddMountFunction::RunAfterIsCacheFileMarkedAsMounted(
+    const base::FilePath& drive_path,
+    const base::FilePath& cache_path,
+    drive::FileError error,
+    bool is_marked_as_mounted) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  if (error != drive::FILE_ERROR_OK) {
+    SetError(FileErrorToString(error));
+    SendResponse(false);
+    return;
+  }
+  if (is_marked_as_mounted) {
+    // When the file is already mounted, we call the mount function as usual,
+    // so that it can issue events containing the VolumeInfo, which is
+    // necessary to make the app navigate to the mounted volume.
+    RunAfterMarkCacheFileAsMounted(drive_path.BaseName(), drive::FILE_ERROR_OK,
+                                   cache_path);
+    return;
+  }
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system) {
+    SendResponse(false);
+    return;
+  }
+  file_system->MarkCacheFileAsMounted(
+      drive_path,
+      base::Bind(
+          &FileManagerPrivateAddMountFunction::RunAfterMarkCacheFileAsMounted,
+          this,
+          drive_path.BaseName()));
+}
+
+void FileManagerPrivateAddMountFunction::RunAfterMarkCacheFileAsMounted(
+    const base::FilePath& display_name,
+    drive::FileError error,
+    const base::FilePath& file_path) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (error != drive::FILE_ERROR_OK) {
+    SendResponse(false);
+    return;
+  }
+
+  // Pass back the actual source path of the mount point.
+  SetResult(std::make_unique<base::Value>(file_path.AsUTF8Unsafe()));
+  SendResponse(true);
+
+  // MountPath() takes a std::string.
+  DiskMountManager* disk_mount_manager = DiskMountManager::GetInstance();
+  disk_mount_manager->MountPath(
+      file_path.AsUTF8Unsafe(),
+      base::FilePath(display_name.Extension()).AsUTF8Unsafe(),
+      display_name.AsUTF8Unsafe(), {}, chromeos::MOUNT_TYPE_ARCHIVE,
+      chromeos::MOUNT_ACCESS_MODE_READ_WRITE);
+}
+
+bool FileManagerPrivateRemoveMountFunction::RunAsync() {
+  using file_manager_private::RemoveMount::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  drive::EventLogger* logger = file_manager::util::GetLogger(GetProfile());
+  if (logger) {
+    logger->Log(logging::LOG_INFO, "%s[%d] called. (volume_id: '%s')", name(),
+                request_id(), params->volume_id.c_str());
+  }
+  set_log_on_completion(true);
+
+  using file_manager::VolumeManager;
+  using file_manager::Volume;
+  VolumeManager* const volume_manager = VolumeManager::Get(GetProfile());
+  DCHECK(volume_manager);
+
+  base::WeakPtr<Volume> volume =
+      volume_manager->FindVolumeById(params->volume_id);
+  if (!volume.get())
+    return false;
+
+  // TODO(tbarzic): Send response when callback is received, it would make more
+  // sense than remembering issued unmount requests in file manager and showing
+  // errors for them when MountCompleted event is received.
+  switch (volume->type()) {
+    case file_manager::VOLUME_TYPE_REMOVABLE_DISK_PARTITION:
+    case file_manager::VOLUME_TYPE_MOUNTED_ARCHIVE_FILE: {
+      chromeos::UnmountOptions unmount_options = chromeos::UNMOUNT_OPTIONS_NONE;
+      if (volume->is_read_only())
+        unmount_options = chromeos::UNMOUNT_OPTIONS_LAZY;
+
+      DiskMountManager::GetInstance()->UnmountPath(
+          volume->mount_path().value(), unmount_options,
+          DiskMountManager::UnmountPathCallback());
+      break;
+    }
+    case file_manager::VOLUME_TYPE_PROVIDED: {
+      chromeos::file_system_provider::Service* service =
+          chromeos::file_system_provider::Service::Get(GetProfile());
+      DCHECK(service);
+      // TODO(mtomasz): Pass a more detailed error than just a bool.
+      if (!service->RequestUnmount(volume->provider_id(),
+                                   volume->file_system_id())) {
+        return false;
+      }
+      break;
+    }
+    default:
+      // Requested unmounting a device which is not unmountable.
+      return false;
+  }
+
+  SendResponse(true);
+  return true;
+}
+
+bool FileManagerPrivateMarkCacheAsMountedFunction::RunAsync() {
+  using file_manager_private::MarkCacheAsMounted::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const base::FilePath path(params->source_path);
+  bool is_mounted = params->is_mounted;
+
+  if (path.empty())
+    return false;
+
+  if (!drive::util::IsUnderDriveMountPoint(path)) {
+    // Ignore non-drive files. Treated as success.
+    SendResponse(true);
+    return true;
+  }
+
+  drive::FileSystemInterface* file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system)
+    return false;
+
+  // Ensure that the cache file exists.
+  const base::FilePath drive_path = drive::util::ExtractDrivePath(path);
+  file_system->GetFile(
+      drive_path,
+      base::Bind(
+          &FileManagerPrivateMarkCacheAsMountedFunction::RunAfterGetDriveFile,
+          this, drive_path, is_mounted));
+  return true;
+}
+
+void FileManagerPrivateMarkCacheAsMountedFunction::RunAfterGetDriveFile(
+    const base::FilePath& drive_path,
+    bool is_mounted,
+    drive::FileError error,
+    const base::FilePath& cache_path,
+    std::unique_ptr<drive::ResourceEntry> entry) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (error != drive::FILE_ERROR_OK) {
+    SetError(FileErrorToString(error));
+    SendResponse(false);
+    return;
+  }
+
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system) {
+    SendResponse(false);
+    return;
+  }
+
+  // TODO(yamaguchi): Check the current status of the file.
+  // Currently calling this method twice will result in error, although it
+  // doesn't give bad side effect.
+  if (is_mounted) {
+    file_system->MarkCacheFileAsMounted(
+        drive_path, base::Bind(&FileManagerPrivateMarkCacheAsMountedFunction::
+                                   RunAfterMarkCacheFileAsMounted,
+                               this));
+  } else {
+    file_system->MarkCacheFileAsUnmounted(
+        cache_path, base::Bind(&FileManagerPrivateMarkCacheAsMountedFunction::
+                                   RunAfterMarkCacheFileAsUnmounted,
+                               this));
+  }
+}
+
+void FileManagerPrivateMarkCacheAsMountedFunction::
+    RunAfterMarkCacheFileAsMounted(drive::FileError error,
+                                   const base::FilePath& file_path) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  switch (error) {
+    case drive::FILE_ERROR_INVALID_OPERATION:
+    // The file was already marked as mounted. Ignore and treat as success.
+    case drive::FILE_ERROR_OK:
+      SendResponse(true);
+      break;
+    default:
+      SetError(FileErrorToString(error));
+      SendResponse(false);
+  }
+}
+
+void FileManagerPrivateMarkCacheAsMountedFunction::
+    RunAfterMarkCacheFileAsUnmounted(drive::FileError error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  switch (error) {
+    case drive::FILE_ERROR_INVALID_OPERATION:
+    // The file was already marked as unmounted. Ignore and treat as success.
+    case drive::FILE_ERROR_OK:
+      SendResponse(true);
+      break;
+    default:
+      SetError(FileErrorToString(error));
+      SendResponse(false);
+  }
+}
+
+bool FileManagerPrivateGetVolumeMetadataListFunction::RunAsync() {
+  if (args_->GetSize())
+    return false;
+
+  const std::vector<base::WeakPtr<file_manager::Volume>>& volume_list =
+      file_manager::VolumeManager::Get(GetProfile())->GetVolumeList();
+
+  std::string log_string;
+  std::vector<file_manager_private::VolumeMetadata> result;
+  for (const auto& volume : volume_list) {
+    file_manager_private::VolumeMetadata volume_metadata;
+    file_manager::util::VolumeToVolumeMetadata(GetProfile(), *volume,
+                                               &volume_metadata);
+    result.push_back(std::move(volume_metadata));
+    if (!log_string.empty())
+      log_string += ", ";
+    log_string += volume->mount_path().AsUTF8Unsafe();
+  }
+
+  drive::EventLogger* logger = file_manager::util::GetLogger(GetProfile());
+  if (logger) {
+    logger->Log(logging::LOG_INFO,
+                "%s[%d] succeeded. (results: '[%s]', %" PRIuS " mount points)",
+                name(), request_id(), log_string.c_str(), result.size());
+  }
+
+  results_ =
+      file_manager_private::GetVolumeMetadataList::Results::Create(result);
+  SendResponse(true);
+  return true;
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_manager/private_api_mount.h b/chrome/browser/extensions/api/file_manager/private_api_mount.h
new file mode 100644
index 0000000000000..c148d03123aea
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/private_api_mount.h
@@ -0,0 +1,114 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides task related API functions.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_MOUNT_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_MOUNT_H_
+
+#include <vector>
+
+#include "base/files/file_path.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_base.h"
+#include "components/drive/drive.pb.h"
+#include "components/drive/file_errors.h"
+
+namespace extensions {
+
+// Implements chrome.fileManagerPrivate.addMount method.
+// Mounts removable devices and archive files.
+class FileManagerPrivateAddMountFunction : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.addMount",
+                             FILEMANAGERPRIVATE_ADDMOUNT)
+
+ protected:
+  ~FileManagerPrivateAddMountFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  // Part of Run(). Called after GetFile for Drive File System.
+  void RunAfterGetDriveFile(const base::FilePath& drive_path,
+                            drive::FileError error,
+                            const base::FilePath& cache_path,
+                            std::unique_ptr<drive::ResourceEntry> entry);
+
+  // Part of Run(). Called after IsCacheMarkedAsMounted for Drive File System.
+  void RunAfterIsCacheFileMarkedAsMounted(const base::FilePath& display_name,
+                                          const base::FilePath& cache_path,
+                                          drive::FileError error,
+                                          bool is_marked_as_mounted);
+
+  // Part of Run(). Called after MarkCacheFielAsMounted for Drive File System.
+  // (or directly called from RunAsync() for other file system, or when the
+  // file is already marked as mounted).
+  void RunAfterMarkCacheFileAsMounted(const base::FilePath& display_name,
+                                      drive::FileError error,
+                                      const base::FilePath& file_path);
+};
+
+// Implements chrome.fileManagerPrivate.removeMount method.
+// Unmounts selected volume. Expects volume id as an argument.
+class FileManagerPrivateRemoveMountFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.removeMount",
+                             FILEMANAGERPRIVATE_REMOVEMOUNT)
+
+ protected:
+  ~FileManagerPrivateRemoveMountFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements chrome.fileManagerPrivate.markCacheAsMounted method.
+// Marks a cached file as mounted or unmounted.
+class FileManagerPrivateMarkCacheAsMountedFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.markCacheAsMounted",
+                             FILEMANAGERPRIVATE_MARKCACHEASMOUNTED)
+
+ protected:
+  ~FileManagerPrivateMarkCacheAsMountedFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  // Part of Run(). Called after GetFile for Drive File System.
+  void RunAfterGetDriveFile(const base::FilePath& drive_path,
+                            bool is_mounted,
+                            drive::FileError error,
+                            const base::FilePath& cache_path,
+                            std::unique_ptr<drive::ResourceEntry> entry);
+
+  // Part of Run(). Called after MarkCacheFielAsMounted for Drive File System.
+  void RunAfterMarkCacheFileAsMounted(drive::FileError error,
+                                      const base::FilePath& file_path);
+
+  // Part of Run(). Called after MarkCacheFielAsUnmounted for Drive File System.
+  void RunAfterMarkCacheFileAsUnmounted(drive::FileError error);
+};
+
+// Implements chrome.fileManagerPrivate.getVolumeMetadataList method.
+class FileManagerPrivateGetVolumeMetadataListFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.getVolumeMetadataList",
+                             FILEMANAGERPRIVATE_GETVOLUMEMETADATALIST)
+
+ protected:
+  ~FileManagerPrivateGetVolumeMetadataListFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_MOUNT_H_
diff --git a/chrome/browser/extensions/api/file_manager/private_api_strings.cc b/chrome/browser/extensions/api/file_manager/private_api_strings.cc
new file mode 100644
index 0000000000000..6b1f9197eabb2
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/private_api_strings.cc
@@ -0,0 +1,845 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/private_api_strings.h"
+
+#include <memory>
+#include <utility>
+
+#include "base/strings/stringprintf.h"
+#include "base/sys_info.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/file_manager/open_with_browser.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/grit/generated_resources.h"
+#include "chromeos/system/statistics_provider.h"
+#include "components/strings/grit/components_strings.h"
+#include "extensions/common/extension_l10n_util.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/base/webui/web_ui_util.h"
+
+namespace {
+
+// Location of the page to buy more storage for Google Drive.
+const char kGoogleDriveBuyStorageUrl[] =
+    "https://www.google.com/settings/storage";
+
+// Location of the overview page about Google Drive.
+const char kGoogleDriveOverviewUrl[] =
+    "https://support.google.com/chromebook/?p=filemanager_drive";
+
+// Location of Google drive redeem page.
+const char kGoogleDriveRedeemUrl[] =
+    "http://www.google.com/intl/en/chrome/devices/goodies.html"
+    "?utm_source=filesapp&utm_medium=banner&utm_campaign=gsg";
+
+// Location of Google Drive specific help.
+const char kGoogleDriveHelpUrl[] =
+    "https://support.google.com/chromebook/?p=filemanager_drivehelp";
+
+// Location of Google Drive root.
+const char kGoogleDriveRootUrl[] = "https://drive.google.com";
+
+// Printf format
+const char kHelpURLFormat[] = "https://support.google.com/chromebook/answer/%d";
+
+// Location of the help page for low space warning in the downloads directory.
+const int kDownloadsLowSpaceWarningHelpNumber = 1061547;
+
+// Location of Files App specific help.
+const int kFilesAppHelpNumber = 1056323;
+
+// Location of the help page about connecting to Google Drive.
+const int kGoogleDriveErrorHelpNumber = 2649458;
+
+// Location of the help page about no-action-available files.
+const int kNoActionForFileHelpNumber = 1700055;
+
+#define SET_STRING(id, idr) dict->SetString(id, l10n_util::GetStringUTF16(idr))
+
+void AddStringsForFileTypes(base::DictionaryValue* dict) {
+  // TODO(crbug.com/438921): Rename string IDs to something like
+  // FILE_TYPE_WHATEVER.
+  SET_STRING("AUDIO_FILE_TYPE", IDS_FILE_BROWSER_AUDIO_FILE_TYPE);
+  SET_STRING("EXCEL_FILE_TYPE", IDS_FILE_BROWSER_EXCEL_FILE_TYPE);
+  SET_STRING("FOLDER", IDS_FILE_BROWSER_FOLDER);
+  SET_STRING("GDOC_DOCUMENT_FILE_TYPE",
+             IDS_FILE_BROWSER_GDOC_DOCUMENT_FILE_TYPE);
+  SET_STRING("GDRAW_DOCUMENT_FILE_TYPE",
+             IDS_FILE_BROWSER_GDRAW_DOCUMENT_FILE_TYPE);
+  SET_STRING("GENERIC_FILE_TYPE", IDS_FILE_BROWSER_GENERIC_FILE_TYPE);
+  SET_STRING("GFORM_DOCUMENT_FILE_TYPE",
+             IDS_FILE_BROWSER_GFORM_DOCUMENT_FILE_TYPE);
+  SET_STRING("GLINK_DOCUMENT_FILE_TYPE",
+             IDS_FILE_BROWSER_GLINK_DOCUMENT_FILE_TYPE);
+  SET_STRING("GMAP_DOCUMENT_FILE_TYPE",
+             IDS_FILE_BROWSER_GMAP_DOCUMENT_FILE_TYPE);
+  SET_STRING("GSHEET_DOCUMENT_FILE_TYPE",
+             IDS_FILE_BROWSER_GSHEET_DOCUMENT_FILE_TYPE);
+  SET_STRING("GSITE_DOCUMENT_FILE_TYPE",
+             IDS_FILE_BROWSER_GSITE_DOCUMENT_FILE_TYPE);
+  SET_STRING("GSLIDES_DOCUMENT_FILE_TYPE",
+             IDS_FILE_BROWSER_GSLIDES_DOCUMENT_FILE_TYPE);
+  SET_STRING("GTABLE_DOCUMENT_FILE_TYPE",
+             IDS_FILE_BROWSER_GTABLE_DOCUMENT_FILE_TYPE);
+  SET_STRING("HTML_DOCUMENT_FILE_TYPE",
+             IDS_FILE_BROWSER_HTML_DOCUMENT_FILE_TYPE);
+  SET_STRING("IMAGE_FILE_TYPE", IDS_FILE_BROWSER_IMAGE_FILE_TYPE);
+  SET_STRING("NO_EXTENSION_FILE_TYPE", IDS_FILE_BROWSER_NO_EXTENSION_FILE_TYPE);
+  SET_STRING("PDF_DOCUMENT_FILE_TYPE", IDS_FILE_BROWSER_PDF_DOCUMENT_FILE_TYPE);
+  SET_STRING("PLAIN_TEXT_FILE_TYPE", IDS_FILE_BROWSER_PLAIN_TEXT_FILE_TYPE);
+  SET_STRING("POWERPOINT_PRESENTATION_FILE_TYPE",
+             IDS_FILE_BROWSER_POWERPOINT_PRESENTATION_FILE_TYPE);
+  SET_STRING("RAR_ARCHIVE_FILE_TYPE", IDS_FILE_BROWSER_RAR_ARCHIVE_FILE_TYPE);
+  SET_STRING("TAR_ARCHIVE_FILE_TYPE", IDS_FILE_BROWSER_TAR_ARCHIVE_FILE_TYPE);
+  SET_STRING("TAR_BZIP2_ARCHIVE_FILE_TYPE",
+             IDS_FILE_BROWSER_TAR_BZIP2_ARCHIVE_FILE_TYPE);
+  SET_STRING("TAR_GZIP_ARCHIVE_FILE_TYPE",
+             IDS_FILE_BROWSER_TAR_GZIP_ARCHIVE_FILE_TYPE);
+  SET_STRING("VIDEO_FILE_TYPE", IDS_FILE_BROWSER_VIDEO_FILE_TYPE);
+  SET_STRING("WORD_DOCUMENT_FILE_TYPE",
+             IDS_FILE_BROWSER_WORD_DOCUMENT_FILE_TYPE);
+  SET_STRING("ZIP_ARCHIVE_FILE_TYPE", IDS_FILE_BROWSER_ZIP_ARCHIVE_FILE_TYPE);
+}
+
+void AddStringsForDrive(base::DictionaryValue* dict) {
+  SET_STRING("DRIVE_BUY_MORE_SPACE", IDS_FILE_BROWSER_DRIVE_BUY_MORE_SPACE);
+  SET_STRING("DRIVE_BUY_MORE_SPACE_LINK",
+             IDS_FILE_BROWSER_DRIVE_BUY_MORE_SPACE_LINK);
+  SET_STRING("DRIVE_CANNOT_REACH", IDS_FILE_BROWSER_DRIVE_CANNOT_REACH);
+  SET_STRING("DRIVE_DIRECTORY_LABEL", IDS_FILE_BROWSER_DRIVE_DIRECTORY_LABEL);
+  SET_STRING("DRIVE_CONFIRM_TD_MEMBERS_LOSE_ACCESS",
+             IDS_FILE_BROWSER_DRIVE_CONFIRM_TD_MEMBERS_LOSE_ACCESS);
+  SET_STRING("DRIVE_CONFIRM_CANNOT_MOVE_BACK_TO_TEAM_DRIVE",
+             IDS_FILE_BROWSER_DRIVE_CONFIRM_CANNOT_MOVE_BACK_TO_TEAM_DRIVE);
+  SET_STRING("DRIVE_CONFIRM_TD_MEMBERS_GAIN_ACCESS_TO_COPY",
+             IDS_FILE_BROWSER_DRIVE_CONFIRM_TD_MEMBERS_GAIN_ACCESS_TO_COPY);
+  SET_STRING("DRIVE_CONFIRM_TD_MEMBERS_GAIN_ACCESS",
+             IDS_FILE_BROWSER_DRIVE_CONFIRM_TD_MEMBERS_GAIN_ACCESS);
+  SET_STRING("DRIVE_CONFIRM_OWNERSHIP_TRANSFER",
+             IDS_FILE_BROWSER_DRIVE_CONFIRM_OWNERSHIP_TRANSFER);
+  SET_STRING("CONFIRM_MOVE_BUTTON_LABEL",
+             IDS_FILE_BROWSER_CONFIRM_MOVE_BUTTON_LABEL);
+  SET_STRING("CONFIRM_COPY_BUTTON_LABEL",
+             IDS_FILE_BROWSER_CONFIRM_COPY_BUTTON_LABEL);
+  SET_STRING("DRIVE_LEARN_MORE", IDS_LEARN_MORE);
+  SET_STRING("DRIVE_MENU_HELP", IDS_FILE_BROWSER_DRIVE_MENU_HELP);
+  SET_STRING("DRIVE_MOBILE_CONNECTION_OPTION",
+             IDS_FILE_BROWSER_DRIVE_MOBILE_CONNECTION_OPTION);
+  SET_STRING("DRIVE_MY_DRIVE_LABEL", IDS_FILE_BROWSER_DRIVE_MY_DRIVE_LABEL);
+  SET_STRING("DRIVE_TEAM_DRIVES_LABEL",
+             IDS_FILE_BROWSER_DRIVE_TEAM_DRIVES_LABEL);
+  SET_STRING("DRIVE_NOT_REACHED", IDS_FILE_BROWSER_DRIVE_NOT_REACHED);
+  SET_STRING("DRIVE_OFFLINE_COLLECTION_LABEL",
+             IDS_FILE_BROWSER_DRIVE_OFFLINE_COLLECTION_LABEL);
+  SET_STRING("DRIVE_OUT_OF_SPACE_HEADER",
+             IDS_FILE_BROWSER_DRIVE_OUT_OF_SPACE_HEADER);
+  SET_STRING("DRIVE_OUT_OF_SPACE_MESSAGE",
+             IDS_FILE_BROWSER_DRIVE_OUT_OF_SPACE_MESSAGE);
+  SET_STRING("DRIVE_RECENT_COLLECTION_LABEL",
+             IDS_FILE_BROWSER_DRIVE_RECENT_COLLECTION_LABEL);
+  SET_STRING("DRIVE_SHARED_WITH_ME_COLLECTION_LABEL",
+             IDS_FILE_BROWSER_DRIVE_SHARED_WITH_ME_COLLECTION_LABEL);
+  SET_STRING("DRIVE_SHARE_TYPE_CAN_COMMENT",
+             IDS_FILE_BROWSER_DRIVE_SHARE_TYPE_CAN_COMMENT);
+  SET_STRING("DRIVE_SHARE_TYPE_CAN_EDIT",
+             IDS_FILE_BROWSER_DRIVE_SHARE_TYPE_CAN_EDIT);
+  SET_STRING("DRIVE_SHARE_TYPE_CAN_VIEW",
+             IDS_FILE_BROWSER_DRIVE_SHARE_TYPE_CAN_VIEW);
+  SET_STRING("DRIVE_SHOW_HOSTED_FILES_OPTION",
+             IDS_FILE_BROWSER_DRIVE_SHOW_HOSTED_FILES_OPTION);
+  SET_STRING("DRIVE_SPACE_AVAILABLE_LONG",
+             IDS_FILE_BROWSER_DRIVE_SPACE_AVAILABLE_LONG);
+  SET_STRING("DRIVE_VISIT_DRIVE_GOOGLE_COM",
+             IDS_FILE_BROWSER_DRIVE_VISIT_DRIVE_GOOGLE_COM);
+  SET_STRING("DRIVE_WELCOME_CHECK_ELIGIBILITY",
+             IDS_FILE_BROWSER_DRIVE_WELCOME_CHECK_ELIGIBILITY);
+  SET_STRING("DRIVE_WELCOME_DISMISS", IDS_FILE_BROWSER_DRIVE_WELCOME_DISMISS);
+  SET_STRING("DRIVE_WELCOME_TEXT_LONG",
+             IDS_FILE_BROWSER_DRIVE_WELCOME_TEXT_LONG);
+  SET_STRING("DRIVE_WELCOME_TEXT_SHORT",
+             IDS_FILE_BROWSER_DRIVE_WELCOME_TEXT_SHORT);
+  SET_STRING("DRIVE_WELCOME_TITLE", IDS_FILE_BROWSER_DRIVE_WELCOME_TITLE);
+  SET_STRING("DRIVE_WELCOME_TITLE_ALTERNATIVE",
+             IDS_FILE_BROWSER_DRIVE_WELCOME_TITLE_ALTERNATIVE);
+  SET_STRING("DRIVE_WELCOME_TITLE_ALTERNATIVE_1TB",
+             IDS_FILE_BROWSER_DRIVE_WELCOME_TITLE_ALTERNATIVE_1TB);
+  SET_STRING("SYNC_DELETE_WITHOUT_PERMISSION_ERROR",
+             IDS_FILE_BROWSER_SYNC_DELETE_WITHOUT_PERMISSION_ERROR);
+  SET_STRING("SYNC_FILE_NAME", IDS_FILE_BROWSER_SYNC_FILE_NAME);
+  SET_STRING("SYNC_FILE_NUMBER", IDS_FILE_BROWSER_SYNC_FILE_NUMBER);
+  SET_STRING("SYNC_MISC_ERROR", IDS_FILE_BROWSER_SYNC_MISC_ERROR);
+  SET_STRING("SYNC_NO_SERVER_SPACE", IDS_FILE_BROWSER_SYNC_NO_SERVER_SPACE);
+  SET_STRING("SYNC_PROGRESS_SUMMARY", IDS_FILE_BROWSER_SYNC_PROGRESS_SUMMARY);
+  SET_STRING("SYNC_SERVICE_UNAVAILABLE_ERROR",
+             IDS_FILE_BROWSER_SYNC_SERVICE_UNAVAILABLE_ERROR);
+}
+
+void AddStringsForMediaView(base::DictionaryValue* dict) {
+  SET_STRING("MEDIA_VIEW_AUDIO_ROOT_LABEL",
+             IDS_FILE_BROWSER_MEDIA_VIEW_AUDIO_ROOT_LABEL);
+  SET_STRING("MEDIA_VIEW_IMAGES_ROOT_LABEL",
+             IDS_FILE_BROWSER_MEDIA_VIEW_IMAGES_ROOT_LABEL);
+  SET_STRING("MEDIA_VIEW_VIDEOS_ROOT_LABEL",
+             IDS_FILE_BROWSER_MEDIA_VIEW_VIDEOS_ROOT_LABEL);
+}
+
+void AddStringsForGallery(base::DictionaryValue* dict) {
+  SET_STRING("GALLERY_ASPECT_RATIO_16_9",
+             IDS_FILE_BROWSER_GALLERY_ASPECT_RATIO_16_9);
+  SET_STRING("GALLERY_ASPECT_RATIO_1_1",
+             IDS_FILE_BROWSER_GALLERY_ASPECT_RATIO_1_1);
+  SET_STRING("GALLERY_ASPECT_RATIO_6_4",
+             IDS_FILE_BROWSER_GALLERY_ASPECT_RATIO_6_4);
+  SET_STRING("GALLERY_ASPECT_RATIO_7_5",
+             IDS_FILE_BROWSER_GALLERY_ASPECT_RATIO_7_5);
+  SET_STRING("GALLERY_AUTOFIX", IDS_FILE_BROWSER_GALLERY_AUTOFIX);
+  SET_STRING("GALLERY_BRIGHTNESS", IDS_FILE_BROWSER_GALLERY_BRIGHTNESS);
+  SET_STRING("GALLERY_CANCEL_LABEL", IDS_FILE_BROWSER_CANCEL_LABEL);
+  SET_STRING("GALLERY_CONFIRM_DELETE_ONE", IDS_FILE_BROWSER_CONFIRM_DELETE_ONE);
+  SET_STRING("GALLERY_CONFIRM_DELETE_SOME",
+             IDS_FILE_BROWSER_CONFIRM_DELETE_SOME);
+  SET_STRING("GALLERY_CONTRAST", IDS_FILE_BROWSER_GALLERY_CONTRAST);
+  SET_STRING("GALLERY_CROP", IDS_FILE_BROWSER_GALLERY_CROP);
+  SET_STRING("GALLERY_DELETE", IDS_FILE_BROWSER_GALLERY_DELETE);
+  SET_STRING("GALLERY_EDIT", IDS_FILE_BROWSER_GALLERY_EDIT);
+  SET_STRING("GALLERY_EXIT", IDS_FILE_BROWSER_GALLERY_EXIT);
+  SET_STRING("GALLERY_ENTER_WHEN_DONE",
+             IDS_FILE_BROWSER_GALLERY_ENTER_WHEN_DONE);
+  SET_STRING("GALLERY_EXPOSURE", IDS_FILE_BROWSER_GALLERY_EXPOSURE);
+  SET_STRING("GALLERY_FILE_EXISTS", IDS_FILE_BROWSER_GALLERY_FILE_EXISTS);
+  SET_STRING("GALLERY_FIXED", IDS_FILE_BROWSER_GALLERY_FIXED);
+  SET_STRING("GALLERY_FIXRATIO", IDS_FILE_BROWSER_GALLERY_FIXRATIO);
+  SET_STRING("GALLERY_HEIGHT", IDS_FILE_BROWSER_GALLERY_HEIGHT);
+  SET_STRING("GALLERY_IMAGE_ERROR", IDS_FILE_BROWSER_GALLERY_IMAGE_ERROR);
+  SET_STRING("GALLERY_IMAGE_OFFLINE", IDS_FILE_BROWSER_GALLERY_IMAGE_OFFLINE);
+  SET_STRING("GALLERY_RESIZE", IDS_FILE_BROWSER_GALLERY_RESIZE);
+  SET_STRING("GALLERY_INVALIDVALUE", IDS_FILE_BROWSER_GALLERY_INVALIDVALUE);
+  SET_STRING("GALLERY_ITEMS_SELECTED", IDS_FILE_BROWSER_GALLERY_ITEMS_SELECTED);
+  SET_STRING("GALLERY_NO_IMAGES", IDS_FILE_BROWSER_GALLERY_NO_IMAGES);
+  SET_STRING("GALLERY_OK_LABEL", IDS_FILE_BROWSER_OK_LABEL);
+  SET_STRING("GALLERY_OVERWRITE_BUBBLE",
+             IDS_FILE_BROWSER_GALLERY_OVERWRITE_BUBBLE);
+  SET_STRING("GALLERY_OVERWRITE_ORIGINAL",
+             IDS_FILE_BROWSER_GALLERY_OVERWRITE_ORIGINAL);
+  SET_STRING("GALLERY_PRINT", IDS_FILE_BROWSER_GALLERY_PRINT);
+  SET_STRING("GALLERY_READONLY_WARNING",
+             IDS_FILE_BROWSER_GALLERY_READONLY_WARNING);
+  SET_STRING("GALLERY_READONLY_AND_NON_WRITABLE_FORMAT_WARNING",
+             IDS_FILE_BROWSER_GALLERY_READONLY_AND_NON_WRITABLE_FORMAT_WARNING);
+  SET_STRING("GALLERY_NON_WRITABLE_FORMAT_WARNING",
+             IDS_FILE_BROWSER_GALLERY_NON_WRITABLE_FORMAT_WARNING);
+  SET_STRING("GALLERY_REDO", IDS_FILE_BROWSER_GALLERY_REDO);
+  SET_STRING("GALLERY_ROTATE_LEFT", IDS_FILE_BROWSER_GALLERY_ROTATE_LEFT);
+  SET_STRING("GALLERY_ROTATE_RIGHT", IDS_FILE_BROWSER_GALLERY_ROTATE_RIGHT);
+  SET_STRING("GALLERY_SAVED", IDS_FILE_BROWSER_GALLERY_SAVED);
+  SET_STRING("GALLERY_SAVE_FAILED", IDS_FILE_BROWSER_GALLERY_SAVE_FAILED);
+  SET_STRING("GALLERY_SHARE", IDS_FILE_BROWSER_GALLERY_SHARE);
+  SET_STRING("GALLERY_SLIDE", IDS_FILE_BROWSER_GALLERY_SLIDE);
+  SET_STRING("GALLERY_SLIDESHOW", IDS_FILE_BROWSER_GALLERY_SLIDESHOW);
+  SET_STRING("GALLERY_THUMBNAIL", IDS_FILE_BROWSER_GALLERY_THUMBNAIL);
+  SET_STRING("GALLERY_UNDO", IDS_FILE_BROWSER_GALLERY_UNDO);
+  SET_STRING("GALLERY_DONE", IDS_FILE_BROWSER_GALLERY_DONE);
+  SET_STRING("GALLERY_WIDTH", IDS_FILE_BROWSER_GALLERY_WIDTH);
+}
+
+void AddStringsForMediaPlayer(base::DictionaryValue* dict) {
+  SET_STRING("MEDIA_PLAYER_PLAY_BUTTON_LABEL",
+             IDS_MEDIA_PLAYER_PLAY_BUTTON_LABEL);
+  SET_STRING("MEDIA_PLAYER_PAUSE_BUTTON_LABEL",
+             IDS_MEDIA_PLAYER_PAUSE_BUTTON_LABEL);
+  SET_STRING("MEDIA_PLAYER_MUTE_BUTTON_LABEL",
+             IDS_MEDIA_PLAYER_MUTE_BUTTON_LABEL);
+  SET_STRING("MEDIA_PLAYER_UNMUTE_BUTTON_LABEL",
+             IDS_MEDIA_PLAYER_UNMUTE_BUTTON_LABEL);
+  SET_STRING("MEDIA_PLAYER_PREVIOUS_BUTTON_LABEL",
+             IDS_MEDIA_PLAYER_PREVIOUS_BUTTON_LABEL);
+  SET_STRING("MEDIA_PLAYER_NEXT_BUTTON_LABEL",
+             IDS_MEDIA_PLAYER_NEXT_BUTTON_LABEL);
+  SET_STRING("MEDIA_PLAYER_SEEK_SLIDER_LABEL",
+             IDS_MEDIA_PLAYER_SEEK_SLIDER_LABEL);
+  SET_STRING("MEDIA_PLAYER_VOLUME_SLIDER_LABEL",
+             IDS_MEDIA_PLAYER_VOLUME_SLIDER_LABEL);
+}
+
+void AddStringsForVideoPlayer(base::DictionaryValue* dict) {
+  SET_STRING("VIDEO_PLAYER_LOOPED_MODE", IDS_VIDEO_PLAYER_LOOPED_MODE);
+  SET_STRING("VIDEO_PLAYER_PLAYBACK_ERROR", IDS_VIDEO_PLAYER_PLAYBACK_ERROR);
+  SET_STRING("VIDEO_PLAYER_PLAYING_ON", IDS_VIDEO_PLAYER_PLAYING_ON);
+  SET_STRING("VIDEO_PLAYER_PLAY_ON", IDS_VIDEO_PLAYER_PLAY_ON);
+  SET_STRING("VIDEO_PLAYER_PLAY_THIS_COMPUTER",
+             IDS_VIDEO_PLAYER_PLAY_THIS_COMPUTER);
+  SET_STRING("VIDEO_PLAYER_VIDEO_FILE_UNSUPPORTED",
+             IDS_VIDEO_PLAYER_VIDEO_FILE_UNSUPPORTED);
+  SET_STRING("VIDEO_PLAYER_VIDEO_FILE_UNSUPPORTED_FOR_CAST",
+             IDS_VIDEO_PLAYER_VIDEO_FILE_UNSUPPORTED_FOR_CAST);
+  SET_STRING("VIDEO_PLAYER_FULL_SCREEN_BUTTON_LABEL",
+             IDS_VIDEO_PLAYER_FULL_SCREEN_BUTTON_LABEL);
+  SET_STRING("VIDEO_PLAYER_EXIT_FULL_SCREEN_BUTTON_LABEL",
+             IDS_VIDEO_PLAYER_EXIT_FULL_SCREEN_BUTTON_LABEL);
+  SET_STRING("VIDEO_PLAYER_ENABLE_SUBTITLES_BUTTON_LABEL",
+             IDS_VIDEO_PLAYER_ENABLE_SUBTITLES_BUTTON_LABEL);
+  SET_STRING("VIDEO_PLAYER_DISABLE_SUBTITLES_BUTTON_LABEL",
+             IDS_VIDEO_PLAYER_DISABLE_SUBTITLES_BUTTON_LABEL);
+}
+
+void AddStringsForAudioPlayer(base::DictionaryValue* dict) {
+  SET_STRING("AUDIO_ERROR", IDS_FILE_BROWSER_AUDIO_ERROR);
+  SET_STRING("AUDIO_OFFLINE", IDS_FILE_BROWSER_AUDIO_OFFLINE);
+  SET_STRING("AUDIO_PLAYER_DEFAULT_ARTIST",
+             IDS_FILE_BROWSER_AUDIO_PLAYER_DEFAULT_ARTIST);
+  SET_STRING("AUDIO_PLAYER_TITLE", IDS_FILE_BROWSER_AUDIO_PLAYER_TITLE);
+  SET_STRING("AUDIO_PLAYER_SHUFFLE_BUTTON_LABEL",
+             IDS_AUDIO_PLAYER_SHUFFLE_BUTTON_LABEL);
+  SET_STRING("AUDIO_PLAYER_REPEAT_BUTTON_LABEL",
+             IDS_AUDIO_PLAYER_REPEAT_BUTTON_LABEL);
+  SET_STRING("AUDIO_PLAYER_OPEN_PLAY_LIST_BUTTON_LABEL",
+             IDS_AUDIO_PLAYER_OPEN_PLAY_LIST_BUTTON_LABEL);
+}
+
+void AddStringsForCloudImport(base::DictionaryValue* dict) {
+  SET_STRING("CLOUD_IMPORT_TITLE", IDS_FILE_BROWSER_CLOUD_IMPORT_TITLE);
+  SET_STRING("CLOUD_IMPORT_DESTINATION_FOLDER",
+             IDS_FILE_BROWSER_CLOUD_DESTINATION_FOLDER);
+  SET_STRING("CLOUD_IMPORT_DESCRIPTION",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_DESCRIPTION);
+  SET_STRING("CLOUD_IMPORT_START", IDS_FILE_BROWSER_CLOUD_IMPORT_START);
+  SET_STRING("CLOUD_IMPORT_SHOW_DETAILS",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_SHOW_DETAILS);
+  SET_STRING("CLOUD_IMPORT_COMMAND", IDS_FILE_BROWSER_CLOUD_IMPORT_COMMAND);
+  SET_STRING("CLOUD_IMPORT_CANCEL_COMMAND",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_CANCEL_COMMAND);
+  SET_STRING("CLOUD_IMPORT_ERROR_ITEM",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_ERROR_ITEM);
+
+  SET_STRING("CLOUD_IMPORT_ONE_FILE", IDS_FILE_BROWSER_CLOUD_IMPORT_ONE_FILE);
+  SET_STRING("CLOUD_IMPORT_MULTIPLE_FILES",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_MULTIPLE_FILES);
+  SET_STRING("CLOUD_IMPORT_STATUS_READY",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_DONE);
+  SET_STRING("CLOUD_IMPORT_STATUS_IMPORTING",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_IMPORTING);
+  SET_STRING("CLOUD_IMPORT_STATUS_INSUFFICIENT_CLOUD_SPACE",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_INSUFFICIENT_CLOUD_SPACE);
+  SET_STRING("CLOUD_IMPORT_STATUS_INSUFFICIENT_LOCAL_SPACE",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_INSUFFICIENT_LOCAL_SPACE);
+  SET_STRING("CLOUD_IMPORT_STATUS_NO_MEDIA",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_NO_MEDIA);
+  SET_STRING("CLOUD_IMPORT_STATUS_READY",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_READY);
+  SET_STRING("CLOUD_IMPORT_STATUS_SCANNING",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_STATUS_SCANNING);
+  SET_STRING("CLOUD_IMPORT_ITEMS_REMAINING",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_ITEMS_REMAINING);
+
+  SET_STRING("CLOUD_IMPORT_TOOLTIP_READY",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_DONE);
+  SET_STRING("CLOUD_IMPORT_TOOLTIP_IMPORTING",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_IMPORTING);
+  SET_STRING("CLOUD_IMPORT_TOOLTIP_INSUFFICIENT_CLOUD_SPACE",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_INSUFFICIENT_CLOUD_SPACE);
+  SET_STRING("CLOUD_IMPORT_TOOLTIP_INSUFFICIENT_LOCAL_SPACE",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_INSUFFICIENT_LOCAL_SPACE);
+  SET_STRING("CLOUD_IMPORT_TOOLTIP_NO_MEDIA",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_NO_MEDIA);
+  SET_STRING("CLOUD_IMPORT_TOOLTIP_READY",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_READY);
+  SET_STRING("CLOUD_IMPORT_TOOLTIP_SCANNING",
+             IDS_FILE_BROWSER_CLOUD_IMPORT_TOOLTIP_SCANNING);
+}
+
+void AddStringsForCrUiMenuItemShortcuts(base::DictionaryValue* dict) {
+  // Shortcut key names: used from cr.ui.MenuItem.updateShortcut_.
+  SET_STRING("SHORTCUT_ALT", IDS_FILE_BROWSER_SHORTCUT_ALT);
+  SET_STRING("SHORTCUT_BACKSPACE", IDS_FILE_BROWSER_SHORTCUT_BACKSPACE);
+  SET_STRING("SHORTCUT_CTRL", IDS_FILE_BROWSER_SHORTCUT_CTRL);
+  SET_STRING("SHORTCUT_ENTER", IDS_FILE_BROWSER_SHORTCUT_ENTER);
+  SET_STRING("SHORTCUT_META", IDS_FILE_BROWSER_SHORTCUT_META);
+  SET_STRING("SHORTCUT_SHIFT", IDS_FILE_BROWSER_SHORTCUT_SHIFT);
+  SET_STRING("SHORTCUT_SPACE", IDS_FILE_BROWSER_SHORTCUT_SPACE);
+}
+
+void AddStringsForFileErrors(base::DictionaryValue* dict) {
+  SET_STRING("FILE_ERROR_GENERIC", IDS_FILE_BROWSER_FILE_ERROR_GENERIC);
+  SET_STRING("FILE_ERROR_INVALID_MODIFICATION",
+             IDS_FILE_BROWSER_FILE_ERROR_INVALID_MODIFICATION);
+  SET_STRING("FILE_ERROR_INVALID_STATE",
+             IDS_FILE_BROWSER_FILE_ERROR_INVALID_STATE);
+  SET_STRING("FILE_ERROR_NOT_FOUND", IDS_FILE_BROWSER_FILE_ERROR_NOT_FOUND);
+  SET_STRING("FILE_ERROR_NOT_READABLE",
+             IDS_FILE_BROWSER_FILE_ERROR_NOT_READABLE);
+  SET_STRING("FILE_ERROR_NO_MODIFICATION_ALLOWED",
+             IDS_FILE_BROWSER_FILE_ERROR_NO_MODIFICATION_ALLOWED);
+  SET_STRING("FILE_ERROR_PATH_EXISTS", IDS_FILE_BROWSER_FILE_ERROR_PATH_EXISTS);
+  SET_STRING("FILE_ERROR_QUOTA_EXCEEDED",
+             IDS_FILE_BROWSER_FILE_ERROR_QUOTA_EXCEEDED);
+  SET_STRING("FILE_ERROR_SECURITY", IDS_FILE_BROWSER_FILE_ERROR_SECURITY);
+}
+
+void AddStringsForZipArchiver(base::DictionaryValue* dict) {
+  SET_STRING("ZIP_ARCHIVER_DESCRIPTION", IDS_ZIP_ARCHIVER_DESCRIPTION);
+  SET_STRING("ZIP_ARCHIVER_MOUNTING_MESSAGE",
+             IDS_ZIP_ARCHIVER_MOUNTING_MESSAGE);
+  SET_STRING("ZIP_ARCHIVER_NAME", IDS_ZIP_ARCHIVER_NAME);
+  SET_STRING("ZIP_ARCHIVER_OTHER_ERROR_MESSAGE",
+             IDS_ZIP_ARCHIVER_OTHER_ERROR_MESSAGE);
+  SET_STRING("ZIP_ARCHIVER_PACKING_CANCEL_BUTTON_LABEL",
+             IDS_ZIP_ARCHIVER_PACKING_CANCEL_BUTTON_LABEL);
+  SET_STRING("ZIP_ARCHIVER_PACKING_DEFERRED_MESSAGE",
+             IDS_ZIP_ARCHIVER_PACKING_DEFERRED_MESSAGE);
+  SET_STRING("ZIP_ARCHIVER_PACKING_ERROR_MESSAGE",
+             IDS_ZIP_ARCHIVER_PACKING_ERROR_MESSAGE);
+  SET_STRING("ZIP_ARCHIVER_PACKING_PROGRESS_MESSAGE",
+             IDS_ZIP_ARCHIVER_PACKING_PROGRESS_MESSAGE);
+  SET_STRING("ZIP_ARCHIVER_PASSPHRASE_ACCEPT",
+             IDS_ZIP_ARCHIVER_PASSPHRASE_ACCEPT);
+  SET_STRING("ZIP_ARCHIVER_PASSPHRASE_CANCEL",
+             IDS_ZIP_ARCHIVER_PASSPHRASE_CANCEL);
+  SET_STRING("ZIP_ARCHIVER_PASSPHRASE_INPUT_LABEL",
+             IDS_ZIP_ARCHIVER_PASSPHRASE_INPUT_LABEL);
+  SET_STRING("ZIP_ARCHIVER_PASSPHRASE_REMEMBER",
+             IDS_ZIP_ARCHIVER_PASSPHRASE_REMEMBER);
+  SET_STRING("ZIP_ARCHIVER_PASSPHRASE_TITLE",
+             IDS_ZIP_ARCHIVER_PASSPHRASE_TITLE);
+}
+
+}  // namespace
+
+namespace extensions {
+
+FileManagerPrivateGetStringsFunction::FileManagerPrivateGetStringsFunction() =
+    default;
+
+FileManagerPrivateGetStringsFunction::~FileManagerPrivateGetStringsFunction() =
+    default;
+
+ExtensionFunction::ResponseAction FileManagerPrivateGetStringsFunction::Run() {
+  std::unique_ptr<base::DictionaryValue> dict(new base::DictionaryValue());
+
+  AddStringsForDrive(dict.get());
+  AddStringsForMediaView(dict.get());
+  AddStringsForFileTypes(dict.get());
+  AddStringsForGallery(dict.get());
+  AddStringsForMediaPlayer(dict.get());
+  AddStringsForVideoPlayer(dict.get());
+  AddStringsForAudioPlayer(dict.get());
+  AddStringsForCloudImport(dict.get());
+  AddStringsForCrUiMenuItemShortcuts(dict.get());
+  AddStringsForFileErrors(dict.get());
+  AddStringsForZipArchiver(dict.get());
+
+  SET_STRING("ADD_NEW_SERVICES_BUTTON_LABEL",
+             IDS_FILE_BROWSER_ADD_NEW_SERVICES_BUTTON_LABEL);
+  SET_STRING("ALL_FILES_FILTER", IDS_FILE_BROWSER_ALL_FILES_FILTER);
+  SET_STRING("ARCHIVE_MOUNT_FAILED", IDS_FILE_BROWSER_ARCHIVE_MOUNT_FAILED);
+  SET_STRING("CALCULATING_SIZE", IDS_FILE_BROWSER_CALCULATING_SIZE);
+  SET_STRING("CANCEL_LABEL", IDS_FILE_BROWSER_CANCEL_LABEL);
+  SET_STRING("CHANGE_DEFAULT_CAPTION", IDS_FILE_BROWSER_CHANGE_DEFAULT_CAPTION);
+  SET_STRING("CHANGE_DEFAULT_MENU_ITEM",
+             IDS_FILE_BROWSER_CHANGE_DEFAULT_MENU_ITEM);
+  SET_STRING("CLOSE_VOLUME_BUTTON_LABEL",
+             IDS_FILE_BROWSER_CLOSE_VOLUME_BUTTON_LABEL);
+  SET_STRING("CONFIGURE_VOLUME_BUTTON_LABEL",
+             IDS_FILE_BROWSER_CONFIGURE_VOLUME_BUTTON_LABEL);
+  SET_STRING("CONFIRM_MOBILE_DATA_USE",
+             IDS_FILE_BROWSER_CONFIRM_MOBILE_DATA_USE);
+  SET_STRING("CONFIRM_MOBILE_DATA_USE_PLURAL",
+             IDS_FILE_BROWSER_CONFIRM_MOBILE_DATA_USE_PLURAL);
+  SET_STRING("CONFIRM_OVERWRITE_FILE", IDS_FILE_BROWSER_CONFIRM_OVERWRITE_FILE);
+  SET_STRING("CONFLICT_DIALOG_APPLY_TO_ALL",
+             IDS_FILE_BROWSER_CONFLICT_DIALOG_APPLY_TO_ALL);
+  SET_STRING("CONFLICT_DIALOG_KEEP_BOTH",
+             IDS_FILE_BROWSER_CONFLICT_DIALOG_KEEP_BOTH);
+  SET_STRING("CONFLICT_DIALOG_MESSAGE",
+             IDS_FILE_BROWSER_CONFLICT_DIALOG_MESSAGE);
+  SET_STRING("CONFLICT_DIALOG_REPLACE",
+             IDS_FILE_BROWSER_CONFLICT_DIALOG_REPLACE);
+  SET_STRING("COPY_BUTTON_LABEL", IDS_FILE_BROWSER_COPY_BUTTON_LABEL);
+  SET_STRING("COPY_FILESYSTEM_ERROR", IDS_FILE_BROWSER_COPY_FILESYSTEM_ERROR);
+  SET_STRING("COPY_FILE_NAME", IDS_FILE_BROWSER_COPY_FILE_NAME);
+  SET_STRING("COPY_ITEMS_REMAINING", IDS_FILE_BROWSER_COPY_ITEMS_REMAINING);
+  SET_STRING("COPY_PROGRESS_SUMMARY", IDS_FILE_BROWSER_COPY_PROGRESS_SUMMARY);
+  SET_STRING("COPY_SOURCE_NOT_FOUND_ERROR",
+             IDS_FILE_BROWSER_COPY_SOURCE_NOT_FOUND_ERROR);
+  SET_STRING("COPY_TARGET_EXISTS_ERROR",
+             IDS_FILE_BROWSER_COPY_TARGET_EXISTS_ERROR);
+  SET_STRING("COPY_UNEXPECTED_ERROR", IDS_FILE_BROWSER_COPY_UNEXPECTED_ERROR);
+  SET_STRING("CREATE_FOLDER_SHORTCUT_BUTTON_LABEL",
+             IDS_FILE_BROWSER_CREATE_FOLDER_SHORTCUT_BUTTON_LABEL);
+  SET_STRING("CUT_BUTTON_LABEL", IDS_FILE_BROWSER_CUT_BUTTON_LABEL);
+  SET_STRING("DATE_COLUMN_LABEL", IDS_FILE_BROWSER_DATE_COLUMN_LABEL);
+  SET_STRING("DEFAULT_NEW_FOLDER_NAME",
+             IDS_FILE_BROWSER_DEFAULT_NEW_FOLDER_NAME);
+  SET_STRING("DEFAULT_TASK_LABEL", IDS_FILE_BROWSER_DEFAULT_TASK_LABEL);
+  SET_STRING("DELETE_BUTTON_LABEL", IDS_FILE_BROWSER_DELETE_BUTTON_LABEL);
+  SET_STRING("DELETE_ERROR", IDS_FILE_BROWSER_DELETE_ERROR);
+  SET_STRING("DELETE_FILE_NAME", IDS_FILE_BROWSER_DELETE_FILE_NAME);
+  SET_STRING("DELETE_ITEMS_REMAINING", IDS_FILE_BROWSER_DELETE_ITEMS_REMAINING);
+  SET_STRING("DELETE_PROGRESS_SUMMARY",
+             IDS_FILE_BROWSER_DELETE_PROGRESS_SUMMARY);
+  SET_STRING("DEVICE_HARD_UNPLUGGED_MESSAGE",
+             IDS_DEVICE_HARD_UNPLUGGED_MESSAGE);
+  SET_STRING("DEVICE_HARD_UNPLUGGED_TITLE", IDS_DEVICE_HARD_UNPLUGGED_TITLE);
+  SET_STRING("DEVICE_UNKNOWN_BUTTON_LABEL", IDS_DEVICE_UNKNOWN_BUTTON_LABEL);
+  SET_STRING("DEVICE_UNKNOWN_DEFAULT_MESSAGE",
+             IDS_DEVICE_UNKNOWN_DEFAULT_MESSAGE);
+  SET_STRING("DEVICE_UNKNOWN_MESSAGE", IDS_DEVICE_UNKNOWN_MESSAGE);
+  SET_STRING("DEVICE_UNSUPPORTED_DEFAULT_MESSAGE",
+             IDS_DEVICE_UNSUPPORTED_DEFAULT_MESSAGE);
+  SET_STRING("DEVICE_UNSUPPORTED_MESSAGE", IDS_DEVICE_UNSUPPORTED_MESSAGE);
+  SET_STRING("DEVICE_WRITE_PROTECTED",
+             IDS_FILE_BROWSER_DROP_TARGET_DEVICE_WRITE_PROTECTED);
+  SET_STRING("DEVICE_ACCESS_RESTRICTED",
+             IDS_FILE_BROWSER_DROP_TARGET_ACCESS_RESTRICTED);
+  SET_STRING("DIRECTORY_ALREADY_EXISTS",
+             IDS_FILE_BROWSER_DIRECTORY_ALREADY_EXISTS);
+  SET_STRING("DISABLED_MOBILE_SYNC_NOTIFICATION_ENABLE_BUTTON",
+             IDS_FILE_BROWSER_DISABLED_MOBILE_SYNC_NOTIFICATION_ENABLE_BUTTON);
+  SET_STRING("DISABLED_MOBILE_SYNC_NOTIFICATION_MESSAGE",
+             IDS_FILE_BROWSER_DISABLED_MOBILE_SYNC_NOTIFICATION_MESSAGE);
+  SET_STRING("DOWNLOADS_DIRECTORY_LABEL",
+             IDS_FILE_BROWSER_DOWNLOADS_DIRECTORY_LABEL);
+  SET_STRING("DOWNLOADS_DIRECTORY_WARNING",
+             IDS_FILE_BROWSER_DOWNLOADS_DIRECTORY_WARNING);
+  SET_STRING("DRAGGING_MULTIPLE_ITEMS",
+             IDS_FILE_BROWSER_DRAGGING_MULTIPLE_ITEMS);
+  SET_STRING("DROP_TARGET_FOLDER_NO_MOVE_PERMISSION",
+             IDS_FILE_BROWSER_DROP_TARGET_FOLDER_NO_MOVE_PERMISSION);
+  SET_STRING("ERROR_CREATING_FOLDER", IDS_FILE_BROWSER_ERROR_CREATING_FOLDER);
+  SET_STRING("ERROR_HIDDEN_NAME", IDS_FILE_BROWSER_ERROR_HIDDEN_NAME);
+  SET_STRING("ERROR_INVALID_CHARACTER",
+             IDS_FILE_BROWSER_ERROR_INVALID_CHARACTER);
+  SET_STRING("ERROR_EXTERNAL_DRIVE_INVALID_CHARACTER",
+             IDS_FILE_BROWSER_ERROR_EXTERNAL_DRIVE_INVALID_CHARACTER);
+  SET_STRING("ERROR_INVALID_WALLPAPER",
+             IDS_WALLPAPER_MANAGER_INVALID_WALLPAPER);
+  SET_STRING("ERROR_LINUX_FILES_CONNECTION",
+             IDS_FILE_BROWSER_ERROR_LINUX_FILES_CONNECTION);
+  SET_STRING("ERROR_LONG_NAME", IDS_FILE_BROWSER_ERROR_LONG_NAME);
+  SET_STRING("ERROR_EXTERNAL_DRIVE_LONG_NAME",
+             IDS_FILE_BROWSER_ERROR_EXTERNAL_DRIVE_LONG_NAME);
+  SET_STRING("ERROR_PROGRESS_SUMMARY", IDS_FILE_BROWSER_ERROR_PROGRESS_SUMMARY);
+  SET_STRING("ERROR_PROGRESS_SUMMARY_PLURAL",
+             IDS_FILE_BROWSER_ERROR_PROGRESS_SUMMARY_PLURAL);
+  SET_STRING("ERROR_RENAMING", IDS_FILE_BROWSER_ERROR_RENAMING);
+  SET_STRING("ERROR_RESERVED_NAME", IDS_FILE_BROWSER_ERROR_RESERVED_NAME);
+  SET_STRING("ERROR_WHITESPACE_NAME", IDS_FILE_BROWSER_ERROR_WHITESPACE_NAME);
+  SET_STRING("EXTERNAL_STORAGE_DISABLED_MESSAGE",
+             IDS_EXTERNAL_STORAGE_DISABLED_MESSAGE);
+  SET_STRING("FAILED_SPACE_INFO", IDS_FILE_BROWSER_FAILED_SPACE_INFO);
+  SET_STRING("FILENAME_LABEL", IDS_FILE_BROWSER_FILENAME_LABEL);
+  SET_STRING("FILE_ALREADY_EXISTS", IDS_FILE_BROWSER_FILE_ALREADY_EXISTS);
+  SET_STRING("FORMATTING_FINISHED_FAILURE_MESSAGE",
+             IDS_FORMATTING_FINISHED_FAILURE_MESSAGE);
+  SET_STRING("FORMATTING_FINISHED_SUCCESS_MESSAGE",
+             IDS_FORMATTING_FINISHED_SUCCESS_MESSAGE);
+  SET_STRING("FORMATTING_OF_DEVICE_FAILED_TITLE",
+             IDS_FORMATTING_OF_DEVICE_FAILED_TITLE);
+  SET_STRING("FORMATTING_OF_DEVICE_FINISHED_TITLE",
+             IDS_FORMATTING_OF_DEVICE_FINISHED_TITLE);
+  SET_STRING("FORMATTING_OF_DEVICE_PENDING_MESSAGE",
+             IDS_FORMATTING_OF_DEVICE_PENDING_MESSAGE);
+  SET_STRING("FORMATTING_OF_DEVICE_PENDING_TITLE",
+             IDS_FORMATTING_OF_DEVICE_PENDING_TITLE);
+  SET_STRING("FORMATTING_WARNING", IDS_FILE_BROWSER_FORMATTING_WARNING);
+  SET_STRING("RENAMING_OF_DEVICE_FINISHED_FAILURE_MESSAGE",
+             IDS_RENAMING_OF_DEVICE_FINISHED_FAILURE_MESSAGE);
+  SET_STRING("RENAMING_OF_DEVICE_FAILED_TITLE",
+             IDS_RENAMING_OF_DEVICE_FAILED_TITLE);
+  SET_STRING("FORMAT_DEVICE_BUTTON_LABEL",
+             IDS_FILE_BROWSER_FORMAT_DEVICE_BUTTON_LABEL);
+  SET_STRING("SHARE_BUTTON_TOOLTIP", IDS_FILE_BROWSER_SHARE_BUTTON_TOOLTIP);
+  SET_STRING("SORT_BUTTON_TOOLTIP", IDS_FILE_BROWSER_SORT_BUTTON_TOOLTIP);
+  SET_STRING("GEAR_BUTTON_TOOLTIP", IDS_FILE_BROWSER_GEAR_BUTTON_TOOLTIP);
+  SET_STRING("SELECTION_MENU_BUTTON_TOOLTIP",
+             IDS_FILE_BROWSER_SELECTION_MENU_BUTTON_TOOLTIP);
+  SET_STRING("GET_INFO_BUTTON_LABEL", IDS_FILE_BROWSER_GET_INFO_BUTTON_LABEL);
+  SET_STRING("HOSTED_OFFLINE_MESSAGE", IDS_FILE_BROWSER_HOSTED_OFFLINE_MESSAGE);
+  SET_STRING("HOSTED_OFFLINE_MESSAGE_PLURAL",
+             IDS_FILE_BROWSER_HOSTED_OFFLINE_MESSAGE_PLURAL);
+  SET_STRING("INSTALL_LINUX_PACKAGE_TITLE",
+             IDS_FILE_BROWSER_INSTALL_LINUX_PACKAGE_TITLE);
+  SET_STRING("INSTALL_LINUX_PACKAGE_DESCRIPTION",
+             IDS_FILE_BROWSER_INSTALL_LINUX_PACKAGE_DESCRIPTION);
+  SET_STRING("INSTALL_LINUX_PACKAGE_INSTALL_BUTTON",
+             IDS_FILE_BROWSER_INSTALL_LINUX_PACKAGE_INSTALL_BUTTON);
+  SET_STRING("INSTALL_LINUX_PACKAGE_INSTALLATION_STARTED",
+             IDS_FILE_BROWSER_INSTALL_LINUX_PACKAGE_INSTALLATION_STARTED);
+  SET_STRING("INSTALL_LINUX_PACKAGE_ERROR_TITLE",
+             IDS_FILE_BROWSER_INSTALL_LINUX_PACKAGE_ERROR_TITLE);
+  SET_STRING("INSTALL_LINUX_PACKAGE_ERROR_DESCRIPTION",
+             IDS_FILE_BROWSER_INSTALL_LINUX_PACKAGE_ERROR_DESCRIPTION);
+  SET_STRING("INSTALL_NEW_EXTENSION_LABEL",
+             IDS_FILE_BROWSER_INSTALL_NEW_EXTENSION_LABEL);
+  SET_STRING("MANY_DIRECTORIES_SELECTED",
+             IDS_FILE_BROWSER_MANY_DIRECTORIES_SELECTED);
+  SET_STRING("MANY_ENTRIES_SELECTED", IDS_FILE_BROWSER_MANY_ENTRIES_SELECTED);
+  SET_STRING("MANY_FILES_SELECTED", IDS_FILE_BROWSER_MANY_FILES_SELECTED);
+  SET_STRING("METADATA_BOX_ALBUM_TITLE",
+             IDS_FILE_BROWSER_METADATA_BOX_ALBUM_TITLE);
+  SET_STRING("METADATA_BOX_AUDIO_INFO",
+             IDS_FILE_BROWSER_METADATA_BOX_AUDIO_INFO);
+  SET_STRING("METADATA_BOX_CODEC", IDS_FILE_BROWSER_METADATA_BOX_CODEC);
+  SET_STRING("METADATA_BOX_CREATED_BY",
+             IDS_FILE_BROWSER_METADATA_BOX_CREATED_BY);
+  SET_STRING("METADATA_BOX_CREATION_TIME",
+             IDS_FILE_BROWSER_METADATA_BOX_CREATION_TIME);
+  SET_STRING("METADATA_BOX_DIMENSION", IDS_FILE_BROWSER_METADATA_BOX_DIMENSION);
+  SET_STRING("METADATA_BOX_DURATION", IDS_FILE_BROWSER_METADATA_BOX_DURATION);
+  SET_STRING("METADATA_BOX_EXIF_DEVICE_MODEL",
+             IDS_FILE_BROWSER_METADATA_BOX_EXIF_DEVICE_MODEL);
+  SET_STRING("METADATA_BOX_EXIF_DEVICE_SETTINGS",
+             IDS_FILE_BROWSER_METADATA_BOX_EXIF_DEVICE_SETTINGS);
+  SET_STRING("METADATA_BOX_EXIF_GEOGRAPHY",
+             IDS_FILE_BROWSER_METADATA_BOX_EXIF_GEOGRAPHY);
+  SET_STRING("METADATA_BOX_FILE_PATH", IDS_FILE_BROWSER_METADATA_BOX_FILE_PATH);
+  SET_STRING("METADATA_BOX_FILE_SIZE", IDS_FILE_BROWSER_METADATA_BOX_FILE_SIZE);
+  SET_STRING("METADATA_BOX_FRAME_RATE",
+             IDS_FILE_BROWSER_METADATA_BOX_FRAME_RATE);
+  SET_STRING("METADATA_BOX_GENERAL_INFO",
+             IDS_FILE_BROWSER_METADATA_BOX_GENERAL_INFO);
+  SET_STRING("METADATA_BOX_GENRE", IDS_FILE_BROWSER_METADATA_BOX_GENRE);
+  SET_STRING("METADATA_BOX_IMAGE_INFO",
+             IDS_FILE_BROWSER_METADATA_BOX_IMAGE_INFO);
+  SET_STRING("METADATA_BOX_MEDIA_ARTIST",
+             IDS_FILE_BROWSER_METADATA_BOX_MEDIA_ARTIST);
+  SET_STRING("METADATA_BOX_MEDIA_MIME_TYPE",
+             IDS_FILE_BROWSER_METADATA_BOX_MEDIA_MIME_TYPE);
+  SET_STRING("METADATA_BOX_MEDIA_TITLE",
+             IDS_FILE_BROWSER_METADATA_BOX_MEDIA_TITLE);
+  SET_STRING("METADATA_BOX_MODIFICATION_TIME",
+             IDS_FILE_BROWSER_METADATA_BOX_MODIFICATION_TIME);
+  SET_STRING("METADATA_BOX_MODIFIED_BY",
+             IDS_FILE_BROWSER_METADATA_BOX_MODIFIED_BY);
+  SET_STRING("METADATA_BOX_PAGE_COUNT",
+             IDS_FILE_BROWSER_METADATA_BOX_PAGE_COUNT);
+  SET_STRING("METADATA_BOX_SOURCE", IDS_FILE_BROWSER_METADATA_BOX_SOURCE);
+  SET_STRING("METADATA_BOX_TRACK", IDS_FILE_BROWSER_METADATA_BOX_TRACK);
+  SET_STRING("METADATA_BOX_VIDEO_INFO",
+             IDS_FILE_BROWSER_METADATA_BOX_VIDEO_INFO);
+  SET_STRING("METADATA_BOX_YEAR_RECORDED",
+             IDS_FILE_BROWSER_METADATA_BOX_YEAR_RECORDED);
+  SET_STRING("MOUNT_ARCHIVE", IDS_FILE_BROWSER_MOUNT_ARCHIVE);
+  SET_STRING("MOVE_FILESYSTEM_ERROR", IDS_FILE_BROWSER_MOVE_FILESYSTEM_ERROR);
+  SET_STRING("MOVE_FILE_NAME", IDS_FILE_BROWSER_MOVE_FILE_NAME);
+  SET_STRING("MOVE_ITEMS_REMAINING", IDS_FILE_BROWSER_MOVE_ITEMS_REMAINING);
+  SET_STRING("MOVE_PROGRESS_SUMMARY", IDS_FILE_BROWSER_MOVE_PROGRESS_SUMMARY);
+  SET_STRING("MOVE_SOURCE_NOT_FOUND_ERROR",
+             IDS_FILE_BROWSER_MOVE_SOURCE_NOT_FOUND_ERROR);
+  SET_STRING("MOVE_TARGET_EXISTS_ERROR",
+             IDS_FILE_BROWSER_MOVE_TARGET_EXISTS_ERROR);
+  SET_STRING("MOVE_UNEXPECTED_ERROR", IDS_FILE_BROWSER_MOVE_UNEXPECTED_ERROR);
+  SET_STRING("MULTIPART_DEVICE_UNSUPPORTED_DEFAULT_MESSAGE",
+             IDS_MULTIPART_DEVICE_UNSUPPORTED_DEFAULT_MESSAGE);
+  SET_STRING("MULTIPART_DEVICE_UNSUPPORTED_MESSAGE",
+             IDS_MULTIPART_DEVICE_UNSUPPORTED_MESSAGE);
+  SET_STRING("MULTI_PROFILE_SHARE_DIALOG_MESSAGE",
+             IDS_FILE_BROWSER_MULTI_PROFILE_SHARE_DIALOG_MESSAGE);
+  SET_STRING("MULTI_PROFILE_SHARE_DIALOG_MESSAGE_PLURAL",
+             IDS_FILE_BROWSER_MULTI_PROFILE_SHARE_DIALOG_MESSAGE_PLURAL);
+  SET_STRING("MULTI_PROFILE_SHARE_DIALOG_TITLE",
+             IDS_FILE_BROWSER_MULTI_PROFILE_SHARE_DIALOG_TITLE);
+  SET_STRING("MULTI_PROFILE_SHARE_DIALOG_TITLE_PLURAL",
+             IDS_FILE_BROWSER_MULTI_PROFILE_SHARE_DIALOG_TITLE_PLURAL);
+  SET_STRING("NAME_COLUMN_LABEL", IDS_FILE_BROWSER_NAME_COLUMN_LABEL);
+  SET_STRING("EMPTY_FOLDER", IDS_FILE_BROWSER_EMPTY_FOLDER);
+  SET_STRING("NEW_FOLDER_BUTTON_LABEL",
+             IDS_FILE_BROWSER_NEW_FOLDER_BUTTON_LABEL);
+  SET_STRING("NEW_WINDOW_BUTTON_LABEL",
+             IDS_FILE_BROWSER_NEW_WINDOW_BUTTON_LABEL);
+  SET_STRING("NO_TASK_FOR_CRX", IDS_FILE_BROWSER_NO_TASK_FOR_CRX);
+  SET_STRING("NO_TASK_FOR_CRX_TITLE", IDS_FILE_BROWSER_NO_TASK_FOR_CRX_TITLE);
+  SET_STRING("NO_TASK_FOR_DMG", IDS_FILE_BROWSER_NO_TASK_FOR_DMG);
+  SET_STRING("NO_TASK_FOR_EXECUTABLE", IDS_FILE_BROWSER_NO_TASK_FOR_EXECUTABLE);
+  SET_STRING("NO_TASK_FOR_FILE", IDS_FILE_BROWSER_NO_TASK_FOR_FILE);
+  SET_STRING("OFFLINE_COLUMN_LABEL", IDS_FILE_BROWSER_OFFLINE_COLUMN_LABEL);
+  SET_STRING("OFFLINE_HEADER", IDS_FILE_BROWSER_OFFLINE_HEADER);
+  SET_STRING("OFFLINE_MESSAGE", IDS_FILE_BROWSER_OFFLINE_MESSAGE);
+  SET_STRING("OFFLINE_MESSAGE_PLURAL", IDS_FILE_BROWSER_OFFLINE_MESSAGE_PLURAL);
+  SET_STRING("OK_LABEL", IDS_FILE_BROWSER_OK_LABEL);
+  SET_STRING("ONE_DIRECTORY_SELECTED", IDS_FILE_BROWSER_ONE_DIRECTORY_SELECTED);
+  SET_STRING("ONE_FILE_SELECTED", IDS_FILE_BROWSER_ONE_FILE_SELECTED);
+  SET_STRING("OPEN_IN_OTHER_DESKTOP_MESSAGE",
+             IDS_FILE_BROWSER_OPEN_IN_OTHER_DESKTOP_MESSAGE);
+  SET_STRING("OPEN_IN_OTHER_DESKTOP_MESSAGE_PLURAL",
+             IDS_FILE_BROWSER_OPEN_IN_OTHER_DESKTOP_MESSAGE_PLURAL);
+  SET_STRING("OPEN_LABEL", IDS_FILE_BROWSER_OPEN_LABEL);
+  SET_STRING("OPEN_WITH_BUTTON_LABEL", IDS_FILE_BROWSER_OPEN_WITH_BUTTON_LABEL);
+  SET_STRING("OPENING_LINUX_FILES",
+             IDS_FILE_BROWSER_DROP_TARGET_OPENING_LINUX_FILES);
+  SET_STRING("MORE_ACTIONS_BUTTON_LABEL",
+             IDS_FILE_BROWSER_MORE_ACTIONS_BUTTON_LABEL);
+  SET_STRING("OPEN_WITH_VERB_BUTTON_LABEL",
+             IDS_FILE_BROWSER_OPEN_WITH_VERB_BUTTON_LABEL);
+  SET_STRING("ADD_TO_VERB_BUTTON_LABEL",
+             IDS_FILE_BROWSER_ADD_TO_VERB_BUTTON_LABEL);
+  SET_STRING("PACK_WITH_VERB_BUTTON_LABEL",
+             IDS_FILE_BROWSER_PACK_WITH_VERB_BUTTON_LABEL);
+  SET_STRING("SHARE_WITH_VERB_BUTTON_LABEL",
+             IDS_FILE_BROWSER_SHARE_WITH_VERB_BUTTON_LABEL);
+  SET_STRING("PASTE_BUTTON_LABEL", IDS_FILE_BROWSER_PASTE_BUTTON_LABEL);
+  SET_STRING("PASTE_INTO_FOLDER_BUTTON_LABEL",
+             IDS_FILE_BROWSER_PASTE_INTO_FOLDER_BUTTON_LABEL);
+  SET_STRING("PREPARING_LABEL", IDS_FILE_BROWSER_PREPARING_LABEL);
+  SET_STRING("QUICK_VIEW_CLOSE_BUTTON_LABEL",
+             IDS_FILE_BROWSER_QUICK_VIEW_CLOSE_BUTTON_LABEL);
+  SET_STRING("QUICK_VIEW_NO_PLAYBACK_AVAILABLE",
+             IDS_FILE_BROWSER_QUICK_VIEW_NO_PLAYBACK_AVAILABLE);
+  SET_STRING("QUICK_VIEW_NO_PREVIEW_AVAILABLE",
+             IDS_FILE_BROWSER_QUICK_VIEW_NO_PREVIEW_AVAILABLE);
+  SET_STRING("QUICK_VIEW_OPEN_IN_NEW_BUTTON_LABEL",
+             IDS_FILE_BROWSER_QUICK_VIEW_OPEN_IN_NEW_BUTTON_LABEL);
+  SET_STRING("QUICK_VIEW_TOGGLE_METADATA_BOX_BUTTON_LABEL",
+             IDS_FILE_BROWSER_QUICK_VIEW_TOGGLE_METADATA_BOX_BUTTON_LABEL);
+  SET_STRING("REFRESH_BUTTON_LABEL", IDS_FILE_BROWSER_REFRESH_BUTTON_LABEL);
+  SET_STRING("REMOVABLE_DEVICE_DETECTION_TITLE",
+             IDS_REMOVABLE_DEVICE_DETECTION_TITLE);
+  SET_STRING("REMOVABLE_DEVICE_IMPORT_BUTTON_LABEL",
+             IDS_REMOVABLE_DEVICE_IMPORT_BUTTON_LABEL);
+  SET_STRING("REMOVABLE_DEVICE_IMPORT_MESSAGE",
+             IDS_REMOVABLE_DEVICE_IMPORT_MESSAGE);
+  SET_STRING("REMOVABLE_DEVICE_NAVIGATION_BUTTON_LABEL",
+             IDS_REMOVABLE_DEVICE_NAVIGATION_BUTTON_LABEL);
+  SET_STRING("REMOVABLE_DEVICE_NAVIGATION_MESSAGE",
+             IDS_REMOVABLE_DEVICE_NAVIGATION_MESSAGE);
+  SET_STRING("REMOVABLE_DEVICE_NAVIGATION_MESSAGE_READONLY_POLICY",
+             IDS_REMOVABLE_DEVICE_NAVIGATION_MESSAGE_READONLY_POLICY);
+  SET_STRING("REMOVE_FOLDER_SHORTCUT_BUTTON_LABEL",
+             IDS_FILE_BROWSER_REMOVE_FOLDER_SHORTCUT_BUTTON_LABEL);
+  SET_STRING("RENAME_BUTTON_LABEL", IDS_FILE_BROWSER_RENAME_BUTTON_LABEL);
+  SET_STRING("SAVE_LABEL", IDS_FILE_BROWSER_SAVE_LABEL);
+  SET_STRING("SEARCH_DRIVE_HTML", IDS_FILE_BROWSER_SEARCH_DRIVE_HTML);
+  SET_STRING("SEARCH_NO_MATCHING_FILES_HTML",
+             IDS_FILE_BROWSER_SEARCH_NO_MATCHING_FILES_HTML);
+  SET_STRING("SEARCH_TEXT_LABEL", IDS_FILE_BROWSER_SEARCH_TEXT_LABEL);
+  SET_STRING("SELECT_ALL_COMMAND_LABEL",
+             IDS_FILE_BROWSER_SELECT_ALL_COMMAND_LABEL);
+  SET_STRING("TASKS_BUTTON_LABEL", IDS_FILE_BROWSER_TASKS_BUTTON_LABEL);
+  SET_STRING("TOGGLE_HIDDEN_FILES_COMMAND_LABEL",
+             IDS_FILE_BROWSER_TOGGLE_HIDDEN_FILES_COMMAND_LABEL);
+  SET_STRING("SHARE_BUTTON_LABEL", IDS_FILE_BROWSER_SHARE_BUTTON_LABEL);
+  SET_STRING("MANAGE_IN_DRIVE_BUTTON_LABEL",
+             IDS_FILE_BROWSER_MANAGE_IN_DRIVE_BUTTON_LABEL);
+  SET_STRING("CHANGE_TO_LISTVIEW_BUTTON_LABEL",
+             IDS_FILE_BROWSER_CHANGE_TO_LISTVIEW_BUTTON_LABEL);
+  SET_STRING("CHANGE_TO_THUMBNAILVIEW_BUTTON_LABEL",
+             IDS_FILE_BROWSER_CHANGE_TO_THUMBNAILVIEW_BUTTON_LABEL);
+  SET_STRING("CANCEL_SELECTION_BUTTON_LABEL",
+             IDS_FILE_BROWSER_CANCEL_SELECTION_BUTTON_LABEL);
+  SET_STRING("SET_WALLPAPER_BUTTON_LABEL",
+             IDS_FILE_BROWSER_SET_WALLPAPER_BUTTON_LABEL);
+  SET_STRING("SHARE_ERROR", IDS_FILE_BROWSER_SHARE_ERROR);
+
+  SET_STRING("SIZE_BYTES", IDS_FILE_BROWSER_SIZE_BYTES);
+  SET_STRING("SIZE_COLUMN_LABEL", IDS_FILE_BROWSER_SIZE_COLUMN_LABEL);
+  SET_STRING("SIZE_GB", IDS_FILE_BROWSER_SIZE_GB);
+  SET_STRING("SIZE_KB", IDS_FILE_BROWSER_SIZE_KB);
+  SET_STRING("SIZE_MB", IDS_FILE_BROWSER_SIZE_MB);
+  SET_STRING("SIZE_PB", IDS_FILE_BROWSER_SIZE_PB);
+  SET_STRING("SIZE_TB", IDS_FILE_BROWSER_SIZE_TB);
+  SET_STRING("SPACE_AVAILABLE", IDS_FILE_BROWSER_SPACE_AVAILABLE);
+  SET_STRING("STATUS_COLUMN_LABEL", IDS_FILE_BROWSER_STATUS_COLUMN_LABEL);
+  SET_STRING("TOTAL_FILE_SIZE", IDS_FILE_BROWSER_TOTAL_FILE_SIZE_LABEL);
+  SET_STRING("TOTAL_FILE_COUNT", IDS_FILE_BROWSER_TOTAL_FILE_COUNT_LABEL);
+  SET_STRING("IMAGE_RESOLUTION_COLUMN_LABEL",
+             IDS_FILE_BROWSER_IMAGE_RESOLUTION_COLUMN_LABEL);
+  SET_STRING("ANDROID_FILES_ROOT_LABEL",
+             IDS_FILE_BROWSER_ANDROID_FILES_ROOT_LABEL);
+  SET_STRING("SHOW_ALL_ANDROID_FOLDERS_OPTION",
+             IDS_FILE_BROWSER_SHOW_ALL_ANDROID_FOLDERS_OPTION);
+  SET_STRING("LINUX_FILES_ROOT_LABEL", IDS_FILE_BROWSER_LINUX_FILES_ROOT_LABEL);
+  SET_STRING("MY_FILES_ROOT_LABEL", IDS_FILE_BROWSER_MY_FILES_ROOT_LABEL);
+  SET_STRING("MEDIA_ARTIST_COLUMN_LABEL",
+             IDS_FILE_BROWSER_MEDIA_ARTIST_COLUMN_LABEL);
+  SET_STRING("MEDIA_TITLE_COLUMN_LABEL",
+             IDS_FILE_BROWSER_MEDIA_TITLE_COLUMN_LABEL);
+  SET_STRING("RECENT_ROOT_LABEL", IDS_FILE_BROWSER_RECENT_ROOT_LABEL);
+  SET_STRING("SUGGEST_DIALOG_INSTALLATION_FAILED",
+             IDS_FILE_BROWSER_SUGGEST_DIALOG_INSTALLATION_FAILED);
+  SET_STRING("SUGGEST_DIALOG_LINK_TO_WEBSTORE",
+             IDS_FILE_BROWSER_SUGGEST_DIALOG_LINK_TO_WEBSTORE);
+  SET_STRING("SUGGEST_DIALOG_TITLE", IDS_FILE_BROWSER_SUGGEST_DIALOG_TITLE);
+  SET_STRING("SUGGEST_DIALOG_FOR_PROVIDERS_TITLE",
+             IDS_FILE_BROWSER_SUGGEST_DIALOG_FOR_PROVIDERS_TITLE);
+  SET_STRING("SUGGEST_DIALOG_LOADING_SPINNER_ALT",
+             IDS_WEBSTORE_WIDGET_LOADING_SPINNER_ALT);
+  SET_STRING("SUGGEST_DIALOG_INSTALLING_SPINNER_ALT",
+             IDS_WEBSTORE_WIDGET_INSTALLING_SPINNER_ALT);
+  SET_STRING("TASK_INSTALL_LINUX_PACKAGE",
+             IDS_FILE_BROWSER_TASK_INSTALL_LINUX_PACKAGE);
+  SET_STRING("TASK_LISTEN", IDS_FILE_BROWSER_TASK_LISTEN);
+  SET_STRING("TASK_OPEN", IDS_FILE_BROWSER_TASK_OPEN);
+  SET_STRING("TASK_OPEN_GDOC", IDS_FILE_BROWSER_TASK_OPEN_GDOC);
+  SET_STRING("TASK_OPEN_GSHEET", IDS_FILE_BROWSER_TASK_OPEN_GSHEET);
+  SET_STRING("TASK_OPEN_GSLIDES", IDS_FILE_BROWSER_TASK_OPEN_GSLIDES);
+  SET_STRING("TASK_VIEW", IDS_FILE_BROWSER_TASK_VIEW);
+  SET_STRING("THUMBNAIL_VIEW_TOOLTIP", IDS_FILE_BROWSER_THUMBNAIL_VIEW_TOOLTIP);
+  SET_STRING("TIME_TODAY", IDS_FILE_BROWSER_TIME_TODAY);
+  SET_STRING("TIME_YESTERDAY", IDS_FILE_BROWSER_TIME_YESTERDAY);
+  SET_STRING("TRANSFER_PROGRESS_SUMMARY",
+             IDS_FILE_BROWSER_TRANSFER_PROGRESS_SUMMARY);
+  SET_STRING("TYPE_COLUMN_LABEL", IDS_FILE_BROWSER_TYPE_COLUMN_LABEL);
+  SET_STRING("UNABLE_TO_OPEN_CROSTINI",
+             IDS_FILE_BROWSER_UNABLE_TO_OPEN_CROSTINI);
+  SET_STRING("UNABLE_TO_OPEN_CROSTINI_TITLE",
+             IDS_FILE_BROWSER_UNABLE_TO_OPEN_CROSTINI_TITLE);
+  SET_STRING("UNKNOWN_FILESYSTEM_WARNING",
+             IDS_FILE_BROWSER_UNKNOWN_FILESYSTEM_WARNING);
+  SET_STRING("UNMOUNT_DEVICE_BUTTON_LABEL",
+             IDS_FILE_BROWSER_UNMOUNT_DEVICE_BUTTON_LABEL);
+  SET_STRING("UNMOUNT_FAILED", IDS_FILE_BROWSER_UNMOUNT_FAILED);
+  SET_STRING("UNMOUNT_PROVIDED_FAILED",
+             IDS_FILE_BROWSER_UNMOUNT_PROVIDED_FAILED);
+  SET_STRING("UNSUPPORTED_FILESYSTEM_WARNING",
+             IDS_FILE_BROWSER_UNSUPPORTED_FILESYSTEM_WARNING);
+  SET_STRING("UPLOAD_LABEL", IDS_FILE_BROWSER_UPLOAD_LABEL);
+  SET_STRING("WAITING_FOR_SPACE_INFO", IDS_FILE_BROWSER_WAITING_FOR_SPACE_INFO);
+  SET_STRING("ZIP_FILESYSTEM_ERROR", IDS_FILE_BROWSER_ZIP_FILESYSTEM_ERROR);
+  SET_STRING("ZIP_FILE_NAME", IDS_FILE_BROWSER_ZIP_FILE_NAME);
+  SET_STRING("ZIP_ITEMS_REMAINING", IDS_FILE_BROWSER_ZIP_ITEMS_REMAINING);
+  SET_STRING("ZIP_PROGRESS_SUMMARY", IDS_FILE_BROWSER_ZIP_PROGRESS_SUMMARY);
+  SET_STRING("ZIP_SELECTION_BUTTON_LABEL",
+             IDS_FILE_BROWSER_ZIP_SELECTION_BUTTON_LABEL);
+  SET_STRING("ZIP_TARGET_EXISTS_ERROR",
+             IDS_FILE_BROWSER_ZIP_TARGET_EXISTS_ERROR);
+  SET_STRING("ZIP_UNEXPECTED_ERROR", IDS_FILE_BROWSER_ZIP_UNEXPECTED_ERROR);
+  SET_STRING("SEE_MENU_FOR_ACTIONS", IDS_FILE_BROWSER_SEE_MENU_FOR_ACTIONS);
+#undef SET_STRING
+
+  dict->SetBoolean("PDF_VIEW_ENABLED",
+                   file_manager::util::ShouldBeOpenedWithPlugin(
+                       Profile::FromBrowserContext(browser_context()),
+                       FILE_PATH_LITERAL(".pdf")));
+  dict->SetBoolean("SWF_VIEW_ENABLED",
+                   file_manager::util::ShouldBeOpenedWithPlugin(
+                       Profile::FromBrowserContext(browser_context()),
+                       FILE_PATH_LITERAL(".swf")));
+  dict->SetString("CHROMEOS_RELEASE_BOARD",
+                  base::SysInfo::GetLsbReleaseBoard());
+  dict->SetString(
+      "DOWNLOADS_LOW_SPACE_WARNING_HELP_URL",
+      base::StringPrintf(kHelpURLFormat, kDownloadsLowSpaceWarningHelpNumber));
+  dict->SetString("FILES_APP_HELP_URL",
+                  base::StringPrintf(kHelpURLFormat, kFilesAppHelpNumber));
+
+  dict->SetString("GOOGLE_DRIVE_BUY_STORAGE_URL", kGoogleDriveBuyStorageUrl);
+  dict->SetString(
+      "GOOGLE_DRIVE_ERROR_HELP_URL",
+      base::StringPrintf(kHelpURLFormat, kGoogleDriveErrorHelpNumber));
+  dict->SetString("GOOGLE_DRIVE_HELP_URL", kGoogleDriveHelpUrl);
+  dict->SetString("GOOGLE_DRIVE_OVERVIEW_URL", kGoogleDriveOverviewUrl);
+  dict->SetString("GOOGLE_DRIVE_REDEEM_URL", kGoogleDriveRedeemUrl);
+  dict->SetString("GOOGLE_DRIVE_ROOT_URL", kGoogleDriveRootUrl);
+  dict->SetString(
+      "NO_TASK_FOR_FILE_URL",
+      base::StringPrintf(kHelpURLFormat, kNoActionForFileHelpNumber));
+  dict->SetString("UI_LOCALE", extension_l10n_util::CurrentLocaleOrDefault());
+
+  const std::string& app_locale = g_browser_process->GetApplicationLocale();
+  webui::SetLoadTimeDataDefaults(app_locale, dict.get());
+
+  return RespondNow(OneArgument(std::move(dict)));
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_manager/private_api_strings.h b/chrome/browser/extensions/api/file_manager/private_api_strings.h
new file mode 100644
index 0000000000000..8e4f948910029
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/private_api_strings.h
@@ -0,0 +1,32 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file only provides getStrings() as the .cc file for it is big.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_STRINGS_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_STRINGS_H_
+
+#include "chrome/browser/extensions/chrome_extension_function.h"
+
+namespace extensions {
+
+// Implements the chrome.fileManagerPrivate.getStrings method.
+// Used to get strings for the file manager from JavaScript.
+class FileManagerPrivateGetStringsFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.getStrings",
+                             FILEMANAGERPRIVATE_GETSTRINGS)
+
+  FileManagerPrivateGetStringsFunction();
+
+ protected:
+  ~FileManagerPrivateGetStringsFunction() override;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_STRINGS_H_
diff --git a/chrome/browser/extensions/api/file_manager/private_api_tasks.cc b/chrome/browser/extensions/api/file_manager/private_api_tasks.cc
new file mode 100644
index 0000000000000..9b00157054b5d
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/private_api_tasks.cc
@@ -0,0 +1,251 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/private_api_tasks.h"
+
+#include <stddef.h>
+
+#include <memory>
+#include <set>
+#include <string>
+#include <vector>
+
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/fileapi/file_system_backend.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "chrome/common/extensions/api/file_manager_private_internal.h"
+#include "content/public/browser/browser_thread.h"
+#include "extensions/browser/api/file_handlers/directory_util.h"
+#include "extensions/browser/api/file_handlers/mime_util.h"
+#include "extensions/browser/entry_info.h"
+#include "net/base/filename_util.h"
+#include "storage/browser/fileapi/file_system_context.h"
+#include "storage/browser/fileapi/file_system_url.h"
+
+using content::BrowserThread;
+using storage::FileSystemURL;
+
+namespace extensions {
+namespace {
+
+// Error messages.
+const char kInvalidTask[] = "Invalid task: ";
+const char kInvalidFileUrl[] = "Invalid file URL";
+
+// Make a set of unique filename suffixes out of the list of file URLs.
+std::set<std::string> GetUniqueSuffixes(
+    const std::vector<std::string>& url_list,
+    const storage::FileSystemContext* context) {
+  std::set<std::string> suffixes;
+  for (size_t i = 0; i < url_list.size(); ++i) {
+    const FileSystemURL url = context->CrackURL(GURL(url_list[i]));
+    if (!url.is_valid() || url.path().empty())
+      return std::set<std::string>();
+    // We'll skip empty suffixes.
+    if (!url.path().Extension().empty())
+      suffixes.insert(url.path().Extension());
+  }
+  return suffixes;
+}
+
+// Make a set of unique MIME types out of the list of MIME types.
+std::set<std::string> GetUniqueMimeTypes(
+    const std::vector<std::string>& mime_type_list) {
+  std::set<std::string> mime_types;
+  for (size_t i = 0; i < mime_type_list.size(); ++i) {
+    const std::string mime_type = mime_type_list[i];
+    // We'll skip empty MIME types and existing MIME types.
+    if (!mime_type.empty())
+      mime_types.insert(mime_type);
+  }
+  return mime_types;
+}
+
+}  // namespace
+
+bool FileManagerPrivateInternalExecuteTaskFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::ExecuteTask::Params;
+  using extensions::api::file_manager_private_internal::ExecuteTask::Results::
+      Create;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  file_manager::file_tasks::TaskDescriptor task;
+  if (!file_manager::file_tasks::ParseTaskID(params->task_id, &task)) {
+    SetError(kInvalidTask + params->task_id);
+    results_ =
+        Create(extensions::api::file_manager_private::TASK_RESULT_FAILED);
+    return false;
+  }
+
+  if (params->urls.empty()) {
+    results_ = Create(extensions::api::file_manager_private::TASK_RESULT_EMPTY);
+    SendResponse(true);
+    return true;
+  }
+
+  const scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  std::vector<FileSystemURL> urls;
+  for (size_t i = 0; i < params->urls.size(); i++) {
+    const FileSystemURL url =
+        file_system_context->CrackURL(GURL(params->urls[i]));
+    if (!chromeos::FileSystemBackend::CanHandleURL(url)) {
+      SetError(kInvalidFileUrl);
+      results_ =
+          Create(extensions::api::file_manager_private::TASK_RESULT_FAILED);
+      return false;
+    }
+    urls.push_back(url);
+  }
+
+  const bool result = file_manager::file_tasks::ExecuteFileTask(
+      GetProfile(), source_url(), task, urls,
+      base::Bind(&FileManagerPrivateInternalExecuteTaskFunction::OnTaskExecuted,
+                 this));
+  if (!result) {
+    results_ =
+        Create(extensions::api::file_manager_private::TASK_RESULT_FAILED);
+  }
+  return result;
+}
+
+void FileManagerPrivateInternalExecuteTaskFunction::OnTaskExecuted(
+    extensions::api::file_manager_private::TaskResult result) {
+  results_ = extensions::api::file_manager_private_internal::ExecuteTask::
+      Results::Create(result);
+  SendResponse(result !=
+               extensions::api::file_manager_private::TASK_RESULT_FAILED);
+}
+
+FileManagerPrivateInternalGetFileTasksFunction::
+    FileManagerPrivateInternalGetFileTasksFunction() = default;
+
+FileManagerPrivateInternalGetFileTasksFunction::
+    ~FileManagerPrivateInternalGetFileTasksFunction() = default;
+
+bool FileManagerPrivateInternalGetFileTasksFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::GetFileTasks::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  if (params->urls.empty())
+    return false;
+
+  const scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  // Collect all the URLs, convert them to GURLs, and crack all the urls into
+  // file paths.
+  for (size_t i = 0; i < params->urls.size(); ++i) {
+    const GURL url(params->urls[i]);
+    storage::FileSystemURL file_system_url(file_system_context->CrackURL(url));
+    if (!chromeos::FileSystemBackend::CanHandleURL(file_system_url))
+      continue;
+    urls_.push_back(url);
+    local_paths_.push_back(file_system_url.path());
+  }
+
+  mime_type_collector_ =
+      std::make_unique<app_file_handler_util::MimeTypeCollector>(GetProfile());
+  mime_type_collector_->CollectForLocalPaths(
+      local_paths_,
+      base::Bind(
+          &FileManagerPrivateInternalGetFileTasksFunction::OnMimeTypesCollected,
+          this));
+
+  return true;
+}
+
+void FileManagerPrivateInternalGetFileTasksFunction::OnMimeTypesCollected(
+    std::unique_ptr<std::vector<std::string>> mime_types) {
+  is_directory_collector_ =
+      std::make_unique<app_file_handler_util::IsDirectoryCollector>(
+          GetProfile());
+  is_directory_collector_->CollectForEntriesPaths(
+      local_paths_, base::Bind(&FileManagerPrivateInternalGetFileTasksFunction::
+                                   OnAreDirectoriesAndMimeTypesCollected,
+                               this, base::Passed(std::move(mime_types))));
+}
+
+void FileManagerPrivateInternalGetFileTasksFunction::
+    OnAreDirectoriesAndMimeTypesCollected(
+        std::unique_ptr<std::vector<std::string>> mime_types,
+        std::unique_ptr<std::set<base::FilePath>> directory_paths) {
+  std::vector<EntryInfo> entries;
+  for (size_t i = 0; i < local_paths_.size(); ++i) {
+    entries.emplace_back(
+        local_paths_[i], (*mime_types)[i],
+        directory_paths->find(local_paths_[i]) != directory_paths->end());
+  }
+
+  file_manager::file_tasks::FindAllTypesOfTasks(
+      GetProfile(), drive::util::GetDriveAppRegistryByProfile(GetProfile()),
+      entries, urls_,
+      base::Bind(
+          &FileManagerPrivateInternalGetFileTasksFunction::OnFileTasksListed,
+          this));
+}
+
+void FileManagerPrivateInternalGetFileTasksFunction::OnFileTasksListed(
+    std::unique_ptr<std::vector<file_manager::file_tasks::FullTaskDescriptor>>
+        tasks) {
+  // Convert the tasks into JSON compatible objects.
+  using api::file_manager_private::FileTask;
+  std::vector<FileTask> results;
+  for (const file_manager::file_tasks::FullTaskDescriptor& task : *tasks) {
+    FileTask converted;
+    converted.task_id =
+        file_manager::file_tasks::TaskDescriptorToId(task.task_descriptor());
+    if (!task.icon_url().is_empty())
+      converted.icon_url = task.icon_url().spec();
+    converted.title = task.task_title();
+    converted.verb = task.task_verb();
+    converted.is_default = task.is_default();
+    converted.is_generic_file_handler = task.is_generic_file_handler();
+    results.push_back(std::move(converted));
+  }
+
+  results_ = extensions::api::file_manager_private_internal::GetFileTasks::
+      Results::Create(results);
+  SendResponse(true);
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateInternalSetDefaultTaskFunction::Run() {
+  using extensions::api::file_manager_private_internal::SetDefaultTask::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  Profile* profile = Profile::FromBrowserContext(browser_context());
+  const scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          profile, render_frame_host());
+
+  const std::set<std::string> suffixes =
+      GetUniqueSuffixes(params->urls, file_system_context.get());
+  const std::set<std::string> mime_types =
+      GetUniqueMimeTypes(params->mime_types);
+
+  // If there weren't any mime_types, and all the suffixes were blank,
+  // then we "succeed", but don't actually associate with anything.
+  // Otherwise, any time we set the default on a file with no extension
+  // on the local drive, we'd fail.
+  // TODO(gspencer): Fix file manager so that it never tries to set default in
+  // cases where extensionless local files are part of the selection.
+  if (suffixes.empty() && mime_types.empty()) {
+    return RespondNow(OneArgument(std::make_unique<base::Value>(true)));
+  }
+
+  file_manager::file_tasks::UpdateDefaultTask(
+      profile->GetPrefs(), params->task_id, suffixes, mime_types);
+  return RespondNow(NoArguments());
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_manager/private_api_tasks.h b/chrome/browser/extensions/api/file_manager/private_api_tasks.h
new file mode 100644
index 0000000000000..74777847c15d8
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/private_api_tasks.h
@@ -0,0 +1,98 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides task related API functions.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_TASKS_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_TASKS_H_
+
+#include <memory>
+#include <set>
+#include <string>
+#include <vector>
+
+#include "chrome/browser/extensions/api/file_manager/private_api_base.h"
+#include "chrome/browser/file_manager/file_tasks.h"
+
+namespace base {
+class FilePath;
+}  // namespace base
+
+namespace extensions {
+
+namespace app_file_handler_util {
+class IsDirectoryCollector;
+class MimeTypeCollector;
+}  // namespace app_file_handler_util
+
+// Implements the chrome.fileManagerPrivateInternal.executeTask method.
+class FileManagerPrivateInternalExecuteTaskFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.executeTask",
+                             FILEMANAGERPRIVATEINTERNAL_EXECUTETASK)
+
+ protected:
+  ~FileManagerPrivateInternalExecuteTaskFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  void OnTaskExecuted(
+      extensions::api::file_manager_private::TaskResult success);
+};
+
+// Implements the chrome.fileManagerPrivateInternal.getFileTasks method.
+class FileManagerPrivateInternalGetFileTasksFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  FileManagerPrivateInternalGetFileTasksFunction();
+
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getFileTasks",
+                             FILEMANAGERPRIVATEINTERNAL_GETFILETASKS)
+
+ protected:
+  ~FileManagerPrivateInternalGetFileTasksFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  void OnMimeTypesCollected(
+      std::unique_ptr<std::vector<std::string>> mime_types);
+
+  void OnAreDirectoriesAndMimeTypesCollected(
+      std::unique_ptr<std::vector<std::string>> mime_types,
+      std::unique_ptr<std::set<base::FilePath>> path_directory_set);
+
+  void OnFileTasksListed(
+      std::unique_ptr<std::vector<file_manager::file_tasks::FullTaskDescriptor>>
+          tasks);
+
+  std::unique_ptr<app_file_handler_util::IsDirectoryCollector>
+      is_directory_collector_;
+  std::unique_ptr<app_file_handler_util::MimeTypeCollector>
+      mime_type_collector_;
+  std::vector<GURL> urls_;
+  std::vector<base::FilePath> local_paths_;
+};
+
+// Implements the chrome.fileManagerPrivateInternal.setDefaultTask method.
+class FileManagerPrivateInternalSetDefaultTaskFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.setDefaultTask",
+                             FILEMANAGERPRIVATEINTERNAL_SETDEFAULTTASK)
+
+ protected:
+  ~FileManagerPrivateInternalSetDefaultTaskFunction() override = default;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_TASKS_H_
diff --git a/chrome/browser/extensions/api/file_manager/private_api_util.cc b/chrome/browser/extensions/api/file_manager/private_api_util.cc
new file mode 100644
index 0000000000000..eb6b72ef74f6c
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/private_api_util.cc
@@ -0,0 +1,411 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+
+#include <stddef.h>
+#include <memory>
+#include <string>
+#include <utility>
+
+#include "base/files/file_path.h"
+#include "base/location.h"
+#include "base/macros.h"
+#include "base/single_thread_task_runner.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/filesystem_api_util.h"
+#include "chrome/browser/file_manager/path_util.h"
+#include "chrome/browser/file_manager/snapshot_manager.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/browser/fileapi/file_system_backend.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "components/drive/chromeos/file_system_interface.h"
+#include "components/drive/drive.pb.h"
+#include "components/drive/file_errors.h"
+#include "content/public/browser/child_process_security_policy.h"
+#include "storage/browser/fileapi/file_system_context.h"
+#include "storage/browser/fileapi/file_system_url.h"
+#include "ui/shell_dialogs/selected_file_info.h"
+
+namespace file_manager_private = extensions::api::file_manager_private;
+
+namespace file_manager {
+namespace util {
+namespace {
+
+// The struct is used for GetSelectedFileInfo().
+struct GetSelectedFileInfoParams {
+  GetSelectedFileInfoLocalPathOption local_path_option;
+  GetSelectedFileInfoCallback callback;
+  std::vector<base::FilePath> file_paths;
+  std::vector<ui::SelectedFileInfo> selected_files;
+};
+
+// The callback type for GetFileNativeLocalPathFor{Opening,Saving}. It receives
+// the resolved local path when successful, and receives empty path for failure.
+typedef base::Callback<void(const base::FilePath&)> LocalPathCallback;
+
+// Converts a callback from Drive file system to LocalPathCallback.
+void OnDriveGetFile(const base::FilePath& path,
+                    const LocalPathCallback& callback,
+                    drive::FileError error,
+                    const base::FilePath& local_file_path,
+                    std::unique_ptr<drive::ResourceEntry> entry) {
+  if (error != drive::FILE_ERROR_OK)
+    DLOG(ERROR) << "Failed to get " << path.value() << " with: " << error;
+  callback.Run(local_file_path);
+}
+
+// Gets a resolved local file path of a non native |path| for file opening.
+void GetFileNativeLocalPathForOpening(Profile* profile,
+                                      const base::FilePath& path,
+                                      const LocalPathCallback& callback) {
+  if (drive::util::IsUnderDriveMountPoint(path)) {
+    drive::FileSystemInterface* file_system =
+        drive::util::GetFileSystemByProfile(profile);
+    if (!file_system) {
+      DLOG(ERROR) << "Drive file selected while disabled: " << path.value();
+      callback.Run(base::FilePath());
+      return;
+    }
+    file_system->GetFile(drive::util::ExtractDrivePath(path),
+                         base::BindOnce(&OnDriveGetFile, path, callback));
+    return;
+  }
+
+  VolumeManager::Get(profile)->snapshot_manager()->CreateManagedSnapshot(
+      path, callback);
+}
+
+// Gets a resolved local file path of a non native |path| for file saving.
+void GetFileNativeLocalPathForSaving(Profile* profile,
+                                     const base::FilePath& path,
+                                     const LocalPathCallback& callback) {
+  if (drive::util::IsUnderDriveMountPoint(path)) {
+    drive::FileSystemInterface* file_system =
+        drive::util::GetFileSystemByProfile(profile);
+    if (!file_system) {
+      DLOG(ERROR) << "Drive file selected while disabled: " << path.value();
+      callback.Run(base::FilePath());
+      return;
+    }
+    file_system->GetFileForSaving(
+        drive::util::ExtractDrivePath(path),
+        base::BindOnce(&OnDriveGetFile, path, callback));
+    return;
+  }
+
+  // TODO(kinaba): For now, the only writable non-local volume is Drive.
+  NOTREACHED();
+  callback.Run(base::FilePath());
+}
+
+// Forward declarations of helper functions for GetSelectedFileInfo().
+void ContinueGetSelectedFileInfo(
+    Profile* profile,
+    std::unique_ptr<GetSelectedFileInfoParams> params,
+    const base::FilePath& local_file_path);
+
+// Part of GetSelectedFileInfo().
+void GetSelectedFileInfoInternal(
+    Profile* profile,
+    std::unique_ptr<GetSelectedFileInfoParams> params) {
+  DCHECK(profile);
+
+  for (size_t i = params->selected_files.size();
+       i < params->file_paths.size(); ++i) {
+    const base::FilePath& file_path = params->file_paths[i];
+
+    if (file_manager::util::IsUnderNonNativeLocalPath(profile, file_path)) {
+      // When the caller of the select file dialog wants local file paths, and
+      // the selected path does not point to a native local path (e.g., Drive,
+      // MTP, or provided file system), we should resolve the path.
+      switch (params->local_path_option) {
+        case NO_LOCAL_PATH_RESOLUTION:
+          // Pass empty local path.
+          params->selected_files.emplace_back(file_path, base::FilePath());
+          break;
+        case NEED_LOCAL_PATH_FOR_OPENING:
+          GetFileNativeLocalPathForOpening(
+              profile,
+              file_path,
+              base::Bind(&ContinueGetSelectedFileInfo,
+                         profile,
+                         base::Passed(&params)));
+          return;  // Remaining work is done in ContinueGetSelectedFileInfo.
+        case NEED_LOCAL_PATH_FOR_SAVING:
+          GetFileNativeLocalPathForSaving(
+              profile,
+              file_path,
+              base::Bind(&ContinueGetSelectedFileInfo,
+                         profile,
+                         base::Passed(&params)));
+          return;  // Remaining work is done in ContinueGetSelectedFileInfo.
+      }
+    } else {
+      params->selected_files.emplace_back(file_path, file_path);
+    }
+  }
+  params->callback.Run(params->selected_files);
+}
+
+// Part of GetSelectedFileInfo().
+void ContinueGetSelectedFileInfo(
+    Profile* profile,
+    std::unique_ptr<GetSelectedFileInfoParams> params,
+    const base::FilePath& local_path) {
+  if (local_path.empty()) {
+    params->callback.Run(std::vector<ui::SelectedFileInfo>());
+    return;
+  }
+  const int index = params->selected_files.size();
+  const base::FilePath& file_path = params->file_paths[index];
+  params->selected_files.emplace_back(file_path, local_path);
+  GetSelectedFileInfoInternal(profile, std::move(params));
+}
+
+}  // namespace
+
+void FillIconSet(file_manager_private::IconSet* output,
+                 const chromeos::file_system_provider::IconSet& input) {
+  DCHECK(output);
+  using chromeos::file_system_provider::IconSet;
+  if (input.HasIcon(IconSet::IconSize::SIZE_16x16)) {
+    output->icon16x16_url = std::make_unique<std::string>(
+        input.GetIcon(IconSet::IconSize::SIZE_16x16).spec());
+  }
+  if (input.HasIcon(IconSet::IconSize::SIZE_32x32)) {
+    output->icon32x32_url = std::make_unique<std::string>(
+        input.GetIcon(IconSet::IconSize::SIZE_32x32).spec());
+  }
+}
+
+void VolumeToVolumeMetadata(
+    Profile* profile,
+    const Volume& volume,
+    file_manager_private::VolumeMetadata* volume_metadata) {
+  DCHECK(volume_metadata);
+
+  volume_metadata->volume_id = volume.volume_id();
+
+  // TODO(kinaba): fill appropriate information once multi-profile support is
+  // implemented.
+  volume_metadata->profile.display_name = profile->GetProfileUserName();
+  volume_metadata->profile.is_current_profile = true;
+
+  if (!volume.source_path().empty()) {
+    volume_metadata->source_path =
+        std::make_unique<std::string>(volume.source_path().AsUTF8Unsafe());
+  }
+
+  switch (volume.source()) {
+    case SOURCE_FILE:
+      volume_metadata->source = file_manager_private::SOURCE_FILE;
+      break;
+    case SOURCE_DEVICE:
+      volume_metadata->source = file_manager_private::SOURCE_DEVICE;
+      volume_metadata->is_read_only_removable_device = volume
+          .is_read_only_removable_device();
+      break;
+    case SOURCE_NETWORK:
+      volume_metadata->source =
+          extensions::api::file_manager_private::SOURCE_NETWORK;
+      break;
+    case SOURCE_SYSTEM:
+      volume_metadata->source =
+          extensions::api::file_manager_private::SOURCE_SYSTEM;
+      break;
+  }
+
+  volume_metadata->configurable = volume.configurable();
+  volume_metadata->watchable = volume.watchable();
+
+  if (volume.type() == VOLUME_TYPE_PROVIDED) {
+    volume_metadata->provider_id =
+        std::make_unique<std::string>(volume.provider_id().ToString());
+    volume_metadata->file_system_id =
+        std::make_unique<std::string>(volume.file_system_id());
+  }
+
+  FillIconSet(&volume_metadata->icon_set, volume.icon_set());
+
+  volume_metadata->volume_label =
+      std::make_unique<std::string>(volume.volume_label());
+  volume_metadata->disk_file_system_type =
+      std::make_unique<std::string>(volume.file_system_type());
+
+  switch (volume.type()) {
+    case VOLUME_TYPE_GOOGLE_DRIVE:
+      volume_metadata->volume_type =
+          file_manager_private::VOLUME_TYPE_DRIVE;
+      break;
+    case VOLUME_TYPE_DOWNLOADS_DIRECTORY:
+      volume_metadata->volume_type =
+          file_manager_private::VOLUME_TYPE_DOWNLOADS;
+      break;
+    case VOLUME_TYPE_REMOVABLE_DISK_PARTITION:
+      volume_metadata->volume_type =
+          file_manager_private::VOLUME_TYPE_REMOVABLE;
+      break;
+    case VOLUME_TYPE_MOUNTED_ARCHIVE_FILE:
+      volume_metadata->volume_type = file_manager_private::VOLUME_TYPE_ARCHIVE;
+      break;
+    case VOLUME_TYPE_PROVIDED:
+      volume_metadata->volume_type = file_manager_private::VOLUME_TYPE_PROVIDED;
+      break;
+    case VOLUME_TYPE_MTP:
+      volume_metadata->volume_type = file_manager_private::VOLUME_TYPE_MTP;
+      break;
+    case VOLUME_TYPE_MEDIA_VIEW:
+      volume_metadata->volume_type =
+          file_manager_private::VOLUME_TYPE_MEDIA_VIEW;
+      break;
+    case VOLUME_TYPE_CROSTINI:
+      volume_metadata->volume_type = file_manager_private::VOLUME_TYPE_CROSTINI;
+      break;
+    case VOLUME_TYPE_ANDROID_FILES:
+      volume_metadata->volume_type =
+          file_manager_private::VOLUME_TYPE_ANDROID_FILES;
+      break;
+    case VOLUME_TYPE_TESTING:
+      volume_metadata->volume_type =
+          file_manager_private::VOLUME_TYPE_TESTING;
+      break;
+    case NUM_VOLUME_TYPE:
+      NOTREACHED();
+      break;
+  }
+
+  // Fill device_type iff the volume is removable partition.
+  if (volume.type() == VOLUME_TYPE_REMOVABLE_DISK_PARTITION) {
+    switch (volume.device_type()) {
+      case chromeos::DEVICE_TYPE_UNKNOWN:
+        volume_metadata->device_type =
+            file_manager_private::DEVICE_TYPE_UNKNOWN;
+        break;
+      case chromeos::DEVICE_TYPE_USB:
+        volume_metadata->device_type = file_manager_private::DEVICE_TYPE_USB;
+        break;
+      case chromeos::DEVICE_TYPE_SD:
+        volume_metadata->device_type = file_manager_private::DEVICE_TYPE_SD;
+        break;
+      case chromeos::DEVICE_TYPE_OPTICAL_DISC:
+      case chromeos::DEVICE_TYPE_DVD:
+        volume_metadata->device_type =
+            file_manager_private::DEVICE_TYPE_OPTICAL;
+        break;
+      case chromeos::DEVICE_TYPE_MOBILE:
+        volume_metadata->device_type = file_manager_private::DEVICE_TYPE_MOBILE;
+        break;
+    }
+    volume_metadata->device_path = std::make_unique<std::string>(
+        volume.system_path_prefix().AsUTF8Unsafe());
+    volume_metadata->is_parent_device =
+        std::make_unique<bool>(volume.is_parent());
+  } else {
+    volume_metadata->device_type =
+        file_manager_private::DEVICE_TYPE_NONE;
+  }
+
+  volume_metadata->is_read_only = volume.is_read_only();
+  volume_metadata->has_media = volume.has_media();
+
+  switch (volume.mount_condition()) {
+    case chromeos::disks::MOUNT_CONDITION_NONE:
+      volume_metadata->mount_condition =
+          file_manager_private::MOUNT_CONDITION_NONE;
+      break;
+    case chromeos::disks::MOUNT_CONDITION_UNKNOWN_FILESYSTEM:
+      volume_metadata->mount_condition =
+          file_manager_private::MOUNT_CONDITION_UNKNOWN;
+      break;
+    case chromeos::disks::MOUNT_CONDITION_UNSUPPORTED_FILESYSTEM:
+      volume_metadata->mount_condition =
+          file_manager_private::MOUNT_CONDITION_UNSUPPORTED;
+      break;
+  }
+
+  // If the context is known, then pass it.
+  switch (volume.mount_context()) {
+    case MOUNT_CONTEXT_USER:
+      volume_metadata->mount_context = file_manager_private::MOUNT_CONTEXT_USER;
+      break;
+    case MOUNT_CONTEXT_AUTO:
+      volume_metadata->mount_context = file_manager_private::MOUNT_CONTEXT_AUTO;
+      break;
+    case MOUNT_CONTEXT_UNKNOWN:
+      break;
+  }
+}
+
+base::FilePath GetLocalPathFromURL(content::RenderFrameHost* render_frame_host,
+                                   Profile* profile,
+                                   const GURL& url) {
+  DCHECK(render_frame_host);
+  DCHECK(profile);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      util::GetFileSystemContextForRenderFrameHost(profile, render_frame_host);
+
+  const storage::FileSystemURL filesystem_url(
+      file_system_context->CrackURL(url));
+  base::FilePath path;
+  if (!chromeos::FileSystemBackend::CanHandleURL(filesystem_url))
+    return base::FilePath();
+  return filesystem_url.path();
+}
+
+void GetSelectedFileInfo(content::RenderFrameHost* render_frame_host,
+                         Profile* profile,
+                         const std::vector<GURL>& file_urls,
+                         GetSelectedFileInfoLocalPathOption local_path_option,
+                         GetSelectedFileInfoCallback callback) {
+  DCHECK(render_frame_host);
+  DCHECK(profile);
+
+  std::unique_ptr<GetSelectedFileInfoParams> params(
+      new GetSelectedFileInfoParams);
+  params->local_path_option = local_path_option;
+  params->callback = callback;
+
+  for (size_t i = 0; i < file_urls.size(); ++i) {
+    const GURL& file_url = file_urls[i];
+    const base::FilePath path = GetLocalPathFromURL(
+        render_frame_host, profile, file_url);
+    if (!path.empty()) {
+      DVLOG(1) << "Selected: file path: " << path.value();
+      params->file_paths.push_back(path);
+    }
+  }
+
+  base::ThreadTaskRunnerHandle::Get()->PostTask(
+      FROM_HERE, base::BindOnce(&GetSelectedFileInfoInternal, profile,
+                                base::Passed(&params)));
+}
+
+void SetupProfileFileAccessPermissions(int render_view_process_id,
+                                       Profile* profile) {
+  const base::FilePath paths[] = {
+    drive::util::GetDriveMountPointPath(profile),
+    util::GetDownloadsFolderForProfile(profile),
+  };
+  for (size_t i = 0; i < arraysize(paths); ++i) {
+    content::ChildProcessSecurityPolicy::GetInstance(
+        )->GrantCreateReadWriteFile(render_view_process_id, paths[i]);
+  }
+}
+
+drive::EventLogger* GetLogger(Profile* profile) {
+  drive::DriveIntegrationService* service =
+      drive::DriveIntegrationServiceFactory::FindForProfile(profile);
+  return service ? service->event_logger() : nullptr;
+}
+
+}  // namespace util
+}  // namespace file_manager
diff --git a/chrome/browser/extensions/api/file_manager/private_api_util.h b/chrome/browser/extensions/api/file_manager/private_api_util.h
new file mode 100644
index 0000000000000..fa5ef1bceab50
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/private_api_util.h
@@ -0,0 +1,108 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides utility functions for fileManagerPrivate API.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_UTIL_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_UTIL_H_
+
+#include <vector>
+
+#include "base/callback_forward.h"
+#include "chrome/browser/chromeos/file_system_provider/icon_set.h"
+
+class GURL;
+class Profile;
+
+namespace base {
+class FilePath;
+}
+
+namespace content {
+class RenderFrameHost;
+}
+
+namespace drive {
+class EventLogger;
+}
+
+namespace extensions {
+namespace api {
+namespace file_manager_private {
+struct IconSet;
+struct VolumeMetadata;
+}
+}
+}
+
+namespace ui {
+struct SelectedFileInfo;
+}
+
+namespace file_manager {
+
+class Volume;
+
+namespace util {
+
+// Fills out IDL IconSet struct with the provided icon set.
+void FillIconSet(extensions::api::file_manager_private::IconSet* output,
+                 const chromeos::file_system_provider::IconSet& input);
+
+// Converts the |volume| to VolumeMetadata to communicate with JavaScript via
+// private API.
+void VolumeToVolumeMetadata(
+    Profile* profile,
+    const Volume& volume,
+    extensions::api::file_manager_private::VolumeMetadata* volume_metadata);
+
+// Returns the local FilePath associated with |url|. If the file isn't of the
+// type FileSystemBackend handles, returns an empty
+// FilePath. |render_frame_host| and |profile| are needed to obtain the
+// FileSystemContext currently in use.
+//
+// Local paths will look like "/home/chronos/user/Downloads/foo/bar.txt" or
+// "/special/drive/foo/bar.txt".
+base::FilePath GetLocalPathFromURL(content::RenderFrameHost* render_frame_host,
+                                   Profile* profile,
+                                   const GURL& url);
+
+// The callback type is used for GetSelectedFileInfo().
+typedef base::Callback<void(const std::vector<ui::SelectedFileInfo>&)>
+    GetSelectedFileInfoCallback;
+
+// Option enum to control how to set the ui::SelectedFileInfo::local_path
+// fields in GetSelectedFileInfo() for Drive files.
+// NO_LOCAL_PATH_RESOLUTION:
+//   Does nothing. Set the Drive path as-is.
+// NEED_LOCAL_PATH_FOR_OPENING:
+//   Sets the path to a local cache file.
+// NEED_LOCAL_PATH_FOR_SAVING:
+//   Sets the path to a local cache file. Modification to the file is monitored
+//   and automatically synced to the Drive server.
+enum GetSelectedFileInfoLocalPathOption {
+  NO_LOCAL_PATH_RESOLUTION,
+  NEED_LOCAL_PATH_FOR_OPENING,
+  NEED_LOCAL_PATH_FOR_SAVING,
+};
+
+// Gets the information for |file_urls|.
+void GetSelectedFileInfo(content::RenderFrameHost* render_frame_host,
+                         Profile* profile,
+                         const std::vector<GURL>& file_urls,
+                         GetSelectedFileInfoLocalPathOption local_path_option,
+                         GetSelectedFileInfoCallback callback);
+
+// Grants permission to access per-profile folder (Downloads, Drive) of
+// |profile| for the process |render_view_process_id|.
+void SetupProfileFileAccessPermissions(int render_view_process_id,
+                                       Profile* profile);
+
+// Get event logger to chrome://drive-internals page for the |profile|.
+drive::EventLogger* GetLogger(Profile* profile);
+
+}  // namespace util
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_PRIVATE_API_UTIL_H_

From f7bedbb064b0c603c02e885d8bbee9a399efe42a Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Wed, 22 Aug 2018 17:30:37 +0900
Subject: [PATCH 20/32] Add file_manager files for managing files to
 chrome/browser/

It adds file_manager for managing files to chrome/browser/
to share them with Linux/Ozone build.
It was used only for ChromeOS and the original code is
from chrome/browser/chromeos/file_manager.
---
 chrome/browser/file_manager/DEPS              |    4 +
 chrome/browser/file_manager/OWNERS            |    1 +
 chrome/browser/file_manager/app_id.h          |   36 +
 chrome/browser/file_manager/arc_file_tasks.cc |  298 ++++
 chrome/browser/file_manager/arc_file_tasks.h  |   45 +
 .../file_manager/audio_player_browsertest.cc  |   82 +
 .../file_manager/crostini_file_tasks.cc       |  146 ++
 .../file_manager/crostini_file_tasks.h        |   47 +
 .../external_filesystem_apitest.cc            |  799 ++++++++++
 .../file_manager/fake_disk_mount_manager.cc   |  167 ++
 .../file_manager/fake_disk_mount_manager.h    |  124 ++
 .../file_manager/file_browser_handlers.cc     |  536 +++++++
 .../file_manager/file_browser_handlers.h      |   55 +
 .../file_manager/file_manager_browsertest.cc  |  711 +++++++++
 .../file_manager_browsertest_base.cc          | 1282 +++++++++++++++
 .../file_manager_browsertest_base.h           |  116 ++
 .../file_manager/file_manager_jstest.cc       |  220 +++
 .../file_manager/file_manager_jstest_base.cc  |   48 +
 .../file_manager/file_manager_jstest_base.h   |   28 +
 .../file_manager/file_manager_test_util.cc    |   38 +
 .../file_manager/file_manager_test_util.h     |   20 +
 .../file_manager/file_manager_uitest.cc       |   76 +
 chrome/browser/file_manager/file_tasks.cc     |  688 +++++++++
 chrome/browser/file_manager/file_tasks.h      |  341 ++++
 .../file_manager/file_tasks_browsertest.cc    |  132 ++
 .../file_manager/file_tasks_unittest.cc       | 1370 +++++++++++++++++
 chrome/browser/file_manager/file_watcher.cc   |  113 ++
 chrome/browser/file_manager/file_watcher.h    |   89 ++
 .../file_manager/file_watcher_unittest.cc     |  158 ++
 chrome/browser/file_manager/fileapi_util.cc   |  618 ++++++++
 chrome/browser/file_manager/fileapi_util.h    |  174 +++
 .../file_manager/fileapi_util_unittest.cc     |  143 ++
 .../file_manager/filesystem_api_util.cc       |  272 ++++
 .../file_manager/filesystem_api_util.h        |   59 +
 .../file_manager/gallery_browsertest.cc       |  333 ++++
 chrome/browser/file_manager/gallery_jstest.cc |   58 +
 .../file_manager/image_loader_jstest.cc       |   28 +
 .../browser/file_manager/mount_test_util.cc   |   73 +
 chrome/browser/file_manager/mount_test_util.h |   21 +
 chrome/browser/file_manager/open_util.cc      |  214 +++
 chrome/browser/file_manager/open_util.h       |   54 +
 .../browser/file_manager/open_with_browser.cc |  226 +++
 .../browser/file_manager/open_with_browser.h  |   42 +
 chrome/browser/file_manager/path_util.cc      |  317 ++++
 chrome/browser/file_manager/path_util.h       |   96 ++
 .../file_manager/path_util_unittest.cc        |  457 ++++++
 .../file_manager/select_file_dialog_util.cc   |   52 +
 .../file_manager/select_file_dialog_util.h    |   21 +
 .../browser/file_manager/snapshot_manager.cc  |  212 +++
 .../browser/file_manager/snapshot_manager.h   |   88 ++
 chrome/browser/file_manager/url_util.cc       |  142 ++
 chrome/browser/file_manager/url_util.h        |   37 +
 .../browser/file_manager/url_util_unittest.cc |  130 ++
 .../file_manager/video_player_browsertest.cc  |   76 +
 chrome/browser/file_manager/volume_manager.cc | 1200 +++++++++++++++
 chrome/browser/file_manager/volume_manager.h  |  400 +++++
 .../file_manager/volume_manager_factory.cc    |   67 +
 .../file_manager/volume_manager_factory.h     |   55 +
 .../file_manager/volume_manager_observer.h    |   67 +
 .../file_manager/volume_manager_unittest.cc   | 1002 ++++++++++++
 60 files changed, 14504 insertions(+)
 create mode 100644 chrome/browser/file_manager/DEPS
 create mode 100644 chrome/browser/file_manager/OWNERS
 create mode 100644 chrome/browser/file_manager/app_id.h
 create mode 100644 chrome/browser/file_manager/arc_file_tasks.cc
 create mode 100644 chrome/browser/file_manager/arc_file_tasks.h
 create mode 100644 chrome/browser/file_manager/audio_player_browsertest.cc
 create mode 100644 chrome/browser/file_manager/crostini_file_tasks.cc
 create mode 100644 chrome/browser/file_manager/crostini_file_tasks.h
 create mode 100644 chrome/browser/file_manager/external_filesystem_apitest.cc
 create mode 100644 chrome/browser/file_manager/fake_disk_mount_manager.cc
 create mode 100644 chrome/browser/file_manager/fake_disk_mount_manager.h
 create mode 100644 chrome/browser/file_manager/file_browser_handlers.cc
 create mode 100644 chrome/browser/file_manager/file_browser_handlers.h
 create mode 100644 chrome/browser/file_manager/file_manager_browsertest.cc
 create mode 100644 chrome/browser/file_manager/file_manager_browsertest_base.cc
 create mode 100644 chrome/browser/file_manager/file_manager_browsertest_base.h
 create mode 100644 chrome/browser/file_manager/file_manager_jstest.cc
 create mode 100644 chrome/browser/file_manager/file_manager_jstest_base.cc
 create mode 100644 chrome/browser/file_manager/file_manager_jstest_base.h
 create mode 100644 chrome/browser/file_manager/file_manager_test_util.cc
 create mode 100644 chrome/browser/file_manager/file_manager_test_util.h
 create mode 100644 chrome/browser/file_manager/file_manager_uitest.cc
 create mode 100644 chrome/browser/file_manager/file_tasks.cc
 create mode 100644 chrome/browser/file_manager/file_tasks.h
 create mode 100644 chrome/browser/file_manager/file_tasks_browsertest.cc
 create mode 100644 chrome/browser/file_manager/file_tasks_unittest.cc
 create mode 100644 chrome/browser/file_manager/file_watcher.cc
 create mode 100644 chrome/browser/file_manager/file_watcher.h
 create mode 100644 chrome/browser/file_manager/file_watcher_unittest.cc
 create mode 100644 chrome/browser/file_manager/fileapi_util.cc
 create mode 100644 chrome/browser/file_manager/fileapi_util.h
 create mode 100644 chrome/browser/file_manager/fileapi_util_unittest.cc
 create mode 100644 chrome/browser/file_manager/filesystem_api_util.cc
 create mode 100644 chrome/browser/file_manager/filesystem_api_util.h
 create mode 100644 chrome/browser/file_manager/gallery_browsertest.cc
 create mode 100644 chrome/browser/file_manager/gallery_jstest.cc
 create mode 100644 chrome/browser/file_manager/image_loader_jstest.cc
 create mode 100644 chrome/browser/file_manager/mount_test_util.cc
 create mode 100644 chrome/browser/file_manager/mount_test_util.h
 create mode 100644 chrome/browser/file_manager/open_util.cc
 create mode 100644 chrome/browser/file_manager/open_util.h
 create mode 100644 chrome/browser/file_manager/open_with_browser.cc
 create mode 100644 chrome/browser/file_manager/open_with_browser.h
 create mode 100644 chrome/browser/file_manager/path_util.cc
 create mode 100644 chrome/browser/file_manager/path_util.h
 create mode 100644 chrome/browser/file_manager/path_util_unittest.cc
 create mode 100644 chrome/browser/file_manager/select_file_dialog_util.cc
 create mode 100644 chrome/browser/file_manager/select_file_dialog_util.h
 create mode 100644 chrome/browser/file_manager/snapshot_manager.cc
 create mode 100644 chrome/browser/file_manager/snapshot_manager.h
 create mode 100644 chrome/browser/file_manager/url_util.cc
 create mode 100644 chrome/browser/file_manager/url_util.h
 create mode 100644 chrome/browser/file_manager/url_util_unittest.cc
 create mode 100644 chrome/browser/file_manager/video_player_browsertest.cc
 create mode 100644 chrome/browser/file_manager/volume_manager.cc
 create mode 100644 chrome/browser/file_manager/volume_manager.h
 create mode 100644 chrome/browser/file_manager/volume_manager_factory.cc
 create mode 100644 chrome/browser/file_manager/volume_manager_factory.h
 create mode 100644 chrome/browser/file_manager/volume_manager_observer.h
 create mode 100644 chrome/browser/file_manager/volume_manager_unittest.cc

diff --git a/chrome/browser/file_manager/DEPS b/chrome/browser/file_manager/DEPS
new file mode 100644
index 0000000000000..f46949c65d139
--- /dev/null
+++ b/chrome/browser/file_manager/DEPS
@@ -0,0 +1,4 @@
+include_rules = [
+  "+components/drive",
+]
+
diff --git a/chrome/browser/file_manager/OWNERS b/chrome/browser/file_manager/OWNERS
new file mode 100644
index 0000000000000..73220a827d8dc
--- /dev/null
+++ b/chrome/browser/file_manager/OWNERS
@@ -0,0 +1 @@
+file://ui/file_manager/OWNERS
diff --git a/chrome/browser/file_manager/app_id.h b/chrome/browser/file_manager/app_id.h
new file mode 100644
index 0000000000000..14c0db25f0095
--- /dev/null
+++ b/chrome/browser/file_manager/app_id.h
@@ -0,0 +1,36 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_APP_ID_H_
+#define CHROME_BROWSER_FILE_MANAGER_APP_ID_H_
+
+namespace file_manager {
+
+// The file manager's app ID.
+//
+// Note that file_manager::kFileManagerAppId is a bit redundant but a shorter
+// name like kAppId would be cryptic inside "file_manager" namespace.
+const char kFileManagerAppId[] = "hhaomjibdihmijegdhdafkllkbggdgoj";
+
+// The video player's app ID.
+const char kVideoPlayerAppId[] = "jcgeabjmjgoblfofpppfkcoakmfobdko";
+
+// The gallery's app ID.
+const char kGalleryAppId[] = "nlkncpkkdoccmpiclbokaimcnedabhhm";
+
+// The audio player's app ID.
+const char kAudioPlayerAppId[] = "cjbfomnbifhcdnihkgipgfcihmgjfhbf";
+
+// The text editor's app ID.
+const char kTextEditorAppId[] = "mmfbcljfglbokpmkimbfghdkjmjhdgbg";
+
+// The image loader extension's ID.
+const char kImageLoaderExtensionId[] = "pmfjbimdmchhbnneeidfognadeopoehp";
+
+// Zip Archiver extension's ID.
+const char kZipArchiverId[] = "dmboannefpncccogfdikhmhpmdnddgoe";
+
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_APP_ID_H_
diff --git a/chrome/browser/file_manager/arc_file_tasks.cc b/chrome/browser/file_manager/arc_file_tasks.cc
new file mode 100644
index 0000000000000..61a878bee89bd
--- /dev/null
+++ b/chrome/browser/file_manager/arc_file_tasks.cc
@@ -0,0 +1,298 @@
+// Copyright (c) 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/arc_file_tasks.h"
+
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/bind.h"
+#include "base/files/file_path.h"
+#include "base/logging.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/threading/thread_restrictions.h"
+#include "chrome/browser/chromeos/profiles/profile_helper.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/path_util.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "components/arc/arc_bridge_service.h"
+#include "components/arc/arc_service_manager.h"
+#include "components/arc/common/intent_helper.mojom.h"
+#include "components/arc/intent_helper/arc_intent_helper_bridge.h"
+#include "components/arc/intent_helper/intent_constants.h"
+#include "content/public/browser/browser_thread.h"
+#include "extensions/browser/entry_info.h"
+#include "storage/browser/fileapi/file_system_url.h"
+#include "url/gurl.h"
+
+namespace file_manager {
+namespace file_tasks {
+
+namespace {
+
+constexpr char kAppIdSeparator = '/';
+
+// Converts an Android intent action (see kIntentAction* in
+// components/arc/intent_helper/intent_constants.h) to a file task action ID
+// (see chrome/browser/file_manager/file_tasks.h).
+std::string ArcActionToFileTaskActionId(const std::string& action) {
+  if (action == arc::kIntentActionView)
+    return "view";
+  else if (action == arc::kIntentActionSend)
+    return "send";
+  else if (action == arc::kIntentActionSendMultiple)
+    return "send_multiple";
+  NOTREACHED() << "Unhandled ARC action \"" << action << "\"";
+  return "";
+}
+
+// TODO(derat): Replace this with a FileTaskActionIdToArcAction method once
+// HandleUrlList has been updated to take a string action rather than an
+// ArcActionType.
+arc::mojom::ActionType FileTaskActionIdToArcActionType(const std::string& id) {
+  if (id == "view")
+    return arc::mojom::ActionType::VIEW;
+  if (id == "send")
+    return arc::mojom::ActionType::SEND;
+  if (id == "send_multiple")
+    return arc::mojom::ActionType::SEND_MULTIPLE;
+  NOTREACHED() << "Unhandled file task action ID \"" << id << "\"";
+  return arc::mojom::ActionType::VIEW;
+}
+
+std::string ActivityNameToAppId(const std::string& package_name,
+                                const std::string& activity_name) {
+  return package_name + kAppIdSeparator + activity_name;
+}
+
+arc::mojom::ActivityNamePtr AppIdToActivityName(const std::string& id) {
+  arc::mojom::ActivityNamePtr name = arc::mojom::ActivityName::New();
+
+  const size_t separator = id.find(kAppIdSeparator);
+  if (separator == std::string::npos) {
+    name->package_name = id;
+    name->activity_name = std::string();
+  } else {
+    name->package_name = id.substr(0, separator);
+    name->activity_name = id.substr(separator + 1);
+  }
+  return name;
+}
+
+// Below is the sequence of thread-hopping for loading ARC file tasks.
+void OnArcHandlerList(
+    Profile* profile,
+    std::unique_ptr<std::vector<FullTaskDescriptor>> result_list,
+    const FindTasksCallback& callback,
+    std::vector<arc::mojom::IntentHandlerInfoPtr> handlers);
+
+void OnArcIconLoaded(
+    std::unique_ptr<std::vector<FullTaskDescriptor>> result_list,
+    const FindTasksCallback& callback,
+    std::vector<arc::mojom::IntentHandlerInfoPtr> handlers,
+    std::unique_ptr<arc::ArcIntentHelperBridge::ActivityToIconsMap> icons);
+
+// Called after the handlers from ARC is obtained. Proceeds to OnArcIconLoaded.
+void OnArcHandlerList(
+    Profile* profile,
+    std::unique_ptr<std::vector<FullTaskDescriptor>> result_list,
+    const FindTasksCallback& callback,
+    std::vector<arc::mojom::IntentHandlerInfoPtr> handlers) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  auto* intent_helper_bridge =
+      arc::ArcIntentHelperBridge::GetForBrowserContext(profile);
+  if (!intent_helper_bridge) {
+    callback.Run(std::move(result_list));
+    return;
+  }
+
+  std::vector<arc::mojom::IntentHandlerInfoPtr> handlers_filtered =
+      arc::ArcIntentHelperBridge::FilterOutIntentHelper(std::move(handlers));
+  std::vector<arc::ArcIntentHelperBridge::ActivityName> activity_names;
+  for (const arc::mojom::IntentHandlerInfoPtr& handler : handlers_filtered)
+    activity_names.emplace_back(handler->package_name, handler->activity_name);
+
+  intent_helper_bridge->GetActivityIcons(
+      activity_names, base::BindOnce(&OnArcIconLoaded, std::move(result_list),
+                                     callback, std::move(handlers_filtered)));
+}
+
+// Called after icon data for ARC apps are loaded. Proceeds to OnArcIconEncoded.
+void OnArcIconLoaded(
+    std::unique_ptr<std::vector<FullTaskDescriptor>> result_list,
+    const FindTasksCallback& callback,
+    std::vector<arc::mojom::IntentHandlerInfoPtr> handlers,
+    std::unique_ptr<arc::ArcIntentHelperBridge::ActivityToIconsMap> icons) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  using extensions::api::file_manager_private::Verb;
+  for (const arc::mojom::IntentHandlerInfoPtr& handler : handlers) {
+    std::string action(arc::kIntentActionView);
+    if (handler->action.has_value())
+      action = *handler->action;
+    std::string name(handler->name);
+    Verb handler_verb = Verb::VERB_NONE;
+    if (action == arc::kIntentActionSend ||
+        action == arc::kIntentActionSendMultiple) {
+      handler_verb = Verb::VERB_SHARE_WITH;
+    }
+    auto it = icons->find(arc::ArcIntentHelperBridge::ActivityName(
+        handler->package_name, handler->activity_name));
+    const GURL& icon_url =
+        (it == icons->end() ? GURL::EmptyGURL()
+                            : it->second.icon16_dataurl->data);
+    result_list->push_back(FullTaskDescriptor(
+        TaskDescriptor(
+            ActivityNameToAppId(handler->package_name, handler->activity_name),
+            TASK_TYPE_ARC_APP, ArcActionToFileTaskActionId(action)),
+        name, handler_verb, icon_url, false /* is_default */,
+        action != arc::kIntentActionView /* is_generic */));
+  }
+  callback.Run(std::move(result_list));
+}
+
+void FindArcTasksAfterContentUrlsResolved(
+    Profile* profile,
+    const std::vector<extensions::EntryInfo>& entries,
+    std::unique_ptr<std::vector<FullTaskDescriptor>> result_list,
+    const FindTasksCallback& callback,
+    const std::vector<GURL>& content_urls) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DCHECK_EQ(entries.size(), content_urls.size());
+
+  arc::mojom::IntentHelperInstance* arc_intent_helper = nullptr;
+  // File manager in secondary profile cannot access ARC.
+  if (chromeos::ProfileHelper::IsPrimaryProfile(profile)) {
+    auto* arc_service_manager = arc::ArcServiceManager::Get();
+    if (arc_service_manager) {
+      arc_intent_helper = ARC_GET_INSTANCE_FOR_METHOD(
+          arc_service_manager->arc_bridge_service()->intent_helper(),
+          RequestUrlListHandlerList);
+    }
+  }
+  if (!arc_intent_helper) {
+    callback.Run(std::move(result_list));
+    return;
+  }
+
+  std::vector<arc::mojom::UrlWithMimeTypePtr> urls;
+  for (size_t i = 0; i < entries.size(); ++i) {
+    const auto& entry = entries[i];
+    const GURL& content_url = content_urls[i];
+
+    if (entry.is_directory) {  // ARC apps don't support directories.
+      callback.Run(std::move(result_list));
+      return;
+    }
+
+    if (!content_url.is_valid()) {
+      callback.Run(std::move(result_list));
+      return;
+    }
+
+    arc::mojom::UrlWithMimeTypePtr url_with_type =
+        arc::mojom::UrlWithMimeType::New();
+    url_with_type->url = content_url.spec();
+    url_with_type->mime_type = entry.mime_type;
+    urls.push_back(std::move(url_with_type));
+  }
+  // The callback will be invoked on UI thread, so |profile| should be alive.
+  arc_intent_helper->RequestUrlListHandlerList(
+      std::move(urls), base::Bind(&OnArcHandlerList, base::Unretained(profile),
+                                  base::Passed(&result_list), callback));
+}
+
+void ExecuteArcTaskAfterContentUrlsResolved(
+    Profile* profile,
+    const TaskDescriptor& task,
+    const std::vector<std::string>& mime_types,
+    const FileTaskFinishedCallback& done,
+    const std::vector<GURL>& content_urls) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DCHECK_EQ(content_urls.size(), mime_types.size());
+
+  arc::mojom::IntentHelperInstance* arc_intent_helper = nullptr;
+  // File manager in secondary profile cannot access ARC.
+  if (chromeos::ProfileHelper::IsPrimaryProfile(profile)) {
+    auto* arc_service_manager = arc::ArcServiceManager::Get();
+    if (arc_service_manager) {
+      // TODO(niwa): Switch to FileSystemInstance.OpenUrlsWithPermission().
+      arc_intent_helper = ARC_GET_INSTANCE_FOR_METHOD(
+          arc_service_manager->arc_bridge_service()->intent_helper(),
+          HandleUrlListDeprecated);
+    }
+  }
+  if (!arc_intent_helper) {
+    done.Run(extensions::api::file_manager_private::TASK_RESULT_FAILED);
+    return;
+  }
+
+  std::vector<arc::mojom::UrlWithMimeTypePtr> urls;
+  for (size_t i = 0; i < content_urls.size(); ++i) {
+    const GURL& content_url = content_urls[i];
+    if (!content_url.is_valid()) {
+      done.Run(extensions::api::file_manager_private::TASK_RESULT_FAILED);
+      return;
+    }
+    arc::mojom::UrlWithMimeTypePtr url_with_type =
+        arc::mojom::UrlWithMimeType::New();
+    url_with_type->url = content_url.spec();
+    url_with_type->mime_type = mime_types[i];
+    urls.push_back(std::move(url_with_type));
+  }
+
+  arc_intent_helper->HandleUrlListDeprecated(
+      std::move(urls), AppIdToActivityName(task.app_id),
+      FileTaskActionIdToArcActionType(task.action_id));
+  done.Run(extensions::api::file_manager_private::TASK_RESULT_MESSAGE_SENT);
+}
+
+}  // namespace
+
+void FindArcTasks(Profile* profile,
+                  const std::vector<extensions::EntryInfo>& entries,
+                  const std::vector<GURL>& file_urls,
+                  std::unique_ptr<std::vector<FullTaskDescriptor>> result_list,
+                  const FindTasksCallback& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DCHECK_EQ(entries.size(), file_urls.size());
+
+  storage::FileSystemContext* file_system_context =
+      util::GetFileSystemContextForExtensionId(profile, kFileManagerAppId);
+
+  std::vector<storage::FileSystemURL> file_system_urls;
+  for (const GURL& file_url : file_urls) {
+    file_system_urls.push_back(file_system_context->CrackURL(file_url));
+  }
+
+  // Using base::Unretained(profile) is safe because callback will be invoked on
+  // UI thread, where |profile| should be alive.
+  file_manager::util::ConvertToContentUrls(
+      file_system_urls, base::BindOnce(&FindArcTasksAfterContentUrlsResolved,
+                                       base::Unretained(profile), entries,
+                                       base::Passed(&result_list), callback));
+}
+
+void ExecuteArcTask(Profile* profile,
+                    const TaskDescriptor& task,
+                    const std::vector<storage::FileSystemURL>& file_system_urls,
+                    const std::vector<std::string>& mime_types,
+                    const FileTaskFinishedCallback& done) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DCHECK_EQ(file_system_urls.size(), mime_types.size());
+
+  // Using base::Unretained(profile) is safe because callback will be invoked on
+  // UI thread, where |profile| should be alive.
+  file_manager::util::ConvertToContentUrls(
+      file_system_urls,
+      base::BindOnce(&ExecuteArcTaskAfterContentUrlsResolved,
+                     base::Unretained(profile), task, mime_types, done));
+}
+
+}  // namespace file_tasks
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/arc_file_tasks.h b/chrome/browser/file_manager/arc_file_tasks.h
new file mode 100644
index 0000000000000..fe1de9ad8f4bd
--- /dev/null
+++ b/chrome/browser/file_manager/arc_file_tasks.h
@@ -0,0 +1,45 @@
+// Copyright (c) 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_ARC_FILE_TASKS_H_
+#define CHROME_BROWSER_FILE_MANAGER_ARC_FILE_TASKS_H_
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "chrome/browser/file_manager/file_tasks.h"
+
+class Profile;
+
+namespace extensions {
+struct EntryInfo;
+}
+
+namespace storage {
+class FileSystemURL;
+}
+
+namespace file_manager {
+namespace file_tasks {
+
+// Finds the ARC tasks that can handle |entries|, appends them to |result_list|,
+// and calls back to |callback|.
+void FindArcTasks(Profile* profile,
+                  const std::vector<extensions::EntryInfo>& entries,
+                  const std::vector<GURL>& file_urls,
+                  std::unique_ptr<std::vector<FullTaskDescriptor>> result_list,
+                  const FindTasksCallback& callback);
+
+// Executes the specified task by ARC.
+void ExecuteArcTask(Profile* profile,
+                    const TaskDescriptor& task,
+                    const std::vector<storage::FileSystemURL>& file_system_urls,
+                    const std::vector<std::string>& mime_types,
+                    const FileTaskFinishedCallback& done);
+
+}  // namespace file_tasks
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_ARC_FILE_TASKS_H_
diff --git a/chrome/browser/file_manager/audio_player_browsertest.cc b/chrome/browser/file_manager/audio_player_browsertest.cc
new file mode 100644
index 0000000000000..f764e3613d459
--- /dev/null
+++ b/chrome/browser/file_manager/audio_player_browsertest.cc
@@ -0,0 +1,82 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/file_manager_browsertest_base.h"
+
+namespace file_manager {
+
+template <GuestMode MODE>
+class AudioPlayerBrowserTestBase : public FileManagerBrowserTestBase {
+ public:
+  AudioPlayerBrowserTestBase() = default;
+
+ protected:
+  GuestMode GetGuestMode() const override { return MODE; }
+
+  const char* GetTestCaseName() const override {
+    return test_case_name_.c_str();
+  }
+
+  std::string GetFullTestCaseName() const override {
+    return test_case_name_;
+  }
+
+  const char* GetTestExtensionManifestName() const override {
+    return "audio_player_test_manifest.json";
+  }
+
+  void set_test_case_name(const std::string& name) { test_case_name_ = name; }
+
+ private:
+  std::string test_case_name_;
+
+  DISALLOW_COPY_AND_ASSIGN(AudioPlayerBrowserTestBase);
+};
+
+typedef AudioPlayerBrowserTestBase<NOT_IN_GUEST_MODE> AudioPlayerBrowserTest;
+typedef AudioPlayerBrowserTestBase<IN_GUEST_MODE>
+    AudioPlayerBrowserTestInGuestMode;
+
+IN_PROC_BROWSER_TEST_F(AudioPlayerBrowserTest, OpenAudioOnDownloads) {
+  set_test_case_name("openAudioOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(AudioPlayerBrowserTestInGuestMode,
+                       OpenAudioOnDownloads) {
+  set_test_case_name("openAudioOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(AudioPlayerBrowserTest, OpenAudioOnDrive) {
+  set_test_case_name("openAudioOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(AudioPlayerBrowserTest, TogglePlayState) {
+  set_test_case_name("togglePlayState");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(AudioPlayerBrowserTest, ChangeVolumeLevel) {
+  set_test_case_name("changeVolumeLevel");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(AudioPlayerBrowserTest, ChangeTracks) {
+  set_test_case_name("changeTracks");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(AudioPlayerBrowserTest, ChangeTracksPlayList) {
+  set_test_case_name("changeTracksPlayList");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(AudioPlayerBrowserTest, ChangeTracksPlayListIcon) {
+  set_test_case_name("changeTracksPlayListIcon");
+  StartTest();
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/crostini_file_tasks.cc b/chrome/browser/file_manager/crostini_file_tasks.cc
new file mode 100644
index 0000000000000..30138c0a08829
--- /dev/null
+++ b/chrome/browser/file_manager/crostini_file_tasks.cc
@@ -0,0 +1,146 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/crostini_file_tasks.h"
+
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/base64.h"
+#include "base/bind.h"
+#include "base/files/file_path.h"
+#include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "chrome/browser/chromeos/crostini/crostini_registry_service.h"
+#include "chrome/browser/chromeos/crostini/crostini_registry_service_factory.h"
+#include "chrome/browser/chromeos/crostini/crostini_util.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/path_util.h"
+#include "extensions/browser/entry_info.h"
+#include "storage/browser/fileapi/file_system_url.h"
+#include "ui/base/layout.h"
+#include "ui/display/types/display_constants.h"
+#include "ui/gfx/codec/png_codec.h"
+#include "ui/gfx/image/image_skia.h"
+#include "ui/gfx/image/image_skia_operations.h"
+#include "url/gurl.h"
+
+namespace file_manager {
+namespace file_tasks {
+
+namespace {
+
+constexpr base::TimeDelta kIconLoadTimeout =
+    base::TimeDelta::FromMilliseconds(100);
+constexpr size_t kIconSizeInDip = 16;
+
+GURL GeneratePNGDataUrl(const SkBitmap& sk_bitmap) {
+  std::vector<unsigned char> output;
+  gfx::PNGCodec::EncodeBGRASkBitmap(sk_bitmap, false /* discard_transparency */,
+                                    &output);
+  std::string encoded;
+  base::Base64Encode(
+      base::StringPiece(reinterpret_cast<const char*>(output.data()),
+                        output.size()),
+      &encoded);
+  return GURL("data:image/png;base64," + encoded);
+}
+
+void OnAppIconsLoaded(Profile* profile,
+                      const std::vector<std::string>& app_ids,
+                      ui::ScaleFactor scale_factor,
+                      std::vector<FullTaskDescriptor>* result_list,
+                      base::OnceClosure completion_closure,
+                      const std::vector<gfx::ImageSkia>& icons) {
+  DCHECK(!app_ids.empty());
+  DCHECK_EQ(app_ids.size(), icons.size());
+
+  float scale = ui::GetScaleForScaleFactor(scale_factor);
+
+  crostini::CrostiniRegistryService* registry_service =
+      crostini::CrostiniRegistryServiceFactory::GetForProfile(profile);
+  for (size_t i = 0; i < app_ids.size(); ++i) {
+    result_list->push_back(FullTaskDescriptor(
+        TaskDescriptor(app_ids[i], TASK_TYPE_CROSTINI_APP,
+                       kCrostiniAppActionID),
+        registry_service->GetRegistration(app_ids[i])->Name(),
+        extensions::api::file_manager_private::Verb::VERB_OPEN_WITH,
+        GeneratePNGDataUrl(icons[i].GetRepresentation(scale).sk_bitmap()),
+        false /* is_default */, false /* is_generic */));
+  }
+
+  std::move(completion_closure).Run();
+}
+
+}  // namespace
+
+void FindCrostiniTasks(Profile* profile,
+                       const std::vector<extensions::EntryInfo>& entries,
+                       std::vector<FullTaskDescriptor>* result_list,
+                       base::OnceClosure completion_closure) {
+  if (!IsCrostiniUIAllowedForProfile(profile)) {
+    std::move(completion_closure).Run();
+    return;
+  }
+
+  std::set<std::string> target_mime_types;
+  for (const extensions::EntryInfo& entry : entries)
+    target_mime_types.insert(entry.mime_type);
+
+  std::vector<std::string> result_app_ids;
+
+  crostini::CrostiniRegistryService* registry_service =
+      crostini::CrostiniRegistryServiceFactory::GetForProfile(profile);
+  for (const std::string& app_id : registry_service->GetRegisteredAppIds()) {
+    crostini::CrostiniRegistryService::Registration registration =
+        *registry_service->GetRegistration(app_id);
+
+    const std::set<std::string>& supported_mime_types =
+        registration.MimeTypes();
+    bool had_unsupported_mime_type = false;
+    for (const std::string& target_mime_type : target_mime_types) {
+      if (supported_mime_types.find(target_mime_type) !=
+          supported_mime_types.end())
+        continue;
+      had_unsupported_mime_type = true;
+      break;
+    }
+    if (had_unsupported_mime_type)
+      continue;
+    result_app_ids.push_back(app_id);
+  }
+
+  if (result_app_ids.empty()) {
+    std::move(completion_closure).Run();
+    return;
+  }
+
+  ui::ScaleFactor scale_factor = ui::GetSupportedScaleFactors().back();
+
+  LoadIcons(
+      profile, result_app_ids, kIconSizeInDip, scale_factor, kIconLoadTimeout,
+      base::BindOnce(OnAppIconsLoaded, profile, result_app_ids, scale_factor,
+                     result_list, std::move(completion_closure)));
+}
+
+void ExecuteCrostiniTask(
+    Profile* profile,
+    const TaskDescriptor& task,
+    const std::vector<storage::FileSystemURL>& file_system_urls,
+    const FileTaskFinishedCallback& done) {
+  DCHECK(IsCrostiniUIAllowedForProfile(profile));
+
+  std::vector<std::string> files;
+  for (const storage::FileSystemURL& file_system_url : file_system_urls) {
+    files.emplace_back(util::ConvertFileSystemURLToPathInsideCrostini(
+        profile, file_system_url));
+  }
+
+  LaunchCrostiniApp(profile, task.app_id, display::kInvalidDisplayId, files);
+}
+
+}  // namespace file_tasks
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/crostini_file_tasks.h b/chrome/browser/file_manager/crostini_file_tasks.h
new file mode 100644
index 0000000000000..eae50a22a557e
--- /dev/null
+++ b/chrome/browser/file_manager/crostini_file_tasks.h
@@ -0,0 +1,47 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_CROSTINI_FILE_TASKS_H_
+#define CHROME_BROWSER_FILE_MANAGER_CROSTINI_FILE_TASKS_H_
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "chrome/browser/file_manager/file_tasks.h"
+
+class Profile;
+
+namespace extensions {
+struct EntryInfo;
+}
+
+namespace storage {
+class FileSystemURL;
+}
+
+namespace file_manager {
+namespace file_tasks {
+
+// Crostini apps all use the same action ID.
+constexpr char kCrostiniAppActionID[] = "open-with";
+
+// Finds the Crostini tasks that can handle |entries|, appends them to
+// |result_list|, and calls back to |callback| once finished.
+void FindCrostiniTasks(Profile* profile,
+                       const std::vector<extensions::EntryInfo>& entries,
+                       std::vector<FullTaskDescriptor>* result_list,
+                       base::OnceClosure completion_closure);
+
+// Executes the specified task by Crostini.
+void ExecuteCrostiniTask(
+    Profile* profile,
+    const TaskDescriptor& task,
+    const std::vector<storage::FileSystemURL>& file_system_urls,
+    const FileTaskFinishedCallback& done);
+
+}  // namespace file_tasks
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_CROSTINI_FILE_TASKS_H_
diff --git a/chrome/browser/file_manager/external_filesystem_apitest.cc b/chrome/browser/file_manager/external_filesystem_apitest.cc
new file mode 100644
index 0000000000000..f15b825bbbc0c
--- /dev/null
+++ b/chrome/browser/file_manager/external_filesystem_apitest.cc
@@ -0,0 +1,799 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <memory>
+
+#include "base/bind.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/files/scoped_temp_dir.h"
+#include "base/path_service.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/file_manager/mount_test_util.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/browser/chromeos/profiles/profile_helper.h"
+#include "chrome/browser/extensions/extension_apitest.h"
+#include "chrome/browser/media/router/test/mock_media_router.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/browser/ui/ash/cast_config_client_media_router.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/common/chrome_constants.h"
+#include "chrome/common/chrome_paths.h"
+#include "chromeos/chromeos_switches.h"
+#include "components/drive/service/fake_drive_service.h"
+#include "components/session_manager/core/session_manager.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/notification_service.h"
+#include "content/public/test/test_utils.h"
+#include "extensions/browser/notification_types.h"
+#include "extensions/test/result_catcher.h"
+#include "google_apis/drive/drive_api_parser.h"
+#include "google_apis/drive/test_util.h"
+#include "google_apis/drive/time_util.h"
+#include "storage/browser/fileapi/external_mount_points.h"
+#include "ui/shell_dialogs/select_file_dialog_factory.h"
+#include "ui/shell_dialogs/select_file_policy.h"
+
+// Tests for access to external file systems (as defined in
+// storage/common/fileapi/file_system_types.h) from extensions with
+// fileManagerPrivate and fileBrowserHandler extension permissions.
+// The tests cover following external file system types:
+// - local (kFileSystemTypeLocalNative): a local file system on which files are
+//   accessed using native local path.
+// - restricted (kFileSystemTypeRestrictedLocalNative): a *read-only* local file
+//   system which can only be accessed by extensions that have full access to
+//   external file systems (i.e. extensions with fileManagerPrivate permission).
+// - drive (kFileSystemTypeDrive): a file system that provides access to Google
+//   Drive.
+//
+// The tests cover following scenarios:
+// - Performing file system operations on external file systems from an
+//   app with fileManagerPrivate permission (i.e. The Files app).
+// - Performing read/write operations from file handler extensions. These
+//   extensions need a file browser extension to give them permissions to access
+//   files. This also includes file handler extensions in filesystem API.
+// - Observing directory changes from a file browser extension (using
+//   fileManagerPrivate API).
+// - Doing searches on drive file system from file browser extension (using
+//   fileManagerPrivate API).
+
+using drive::DriveIntegrationServiceFactory;
+using extensions::Extension;
+
+namespace file_manager {
+namespace {
+
+// Root dirs for file systems expected by the test extensions.
+// NOTE: Root dir for drive file system is set by Chrome's drive implementation,
+// but the test will have to make sure the mount point is added before
+// starting a test extension using WaitUntilDriveMountPointIsAdded().
+constexpr char kLocalMountPointName[] = "local";
+constexpr char kRestrictedMountPointName[] = "restricted";
+
+// Default file content for the test files.
+constexpr char kTestFileContent[] = "This is some test content.";
+
+// User account email and directory hash for secondary account for multi-profile
+// sensitive test cases.
+constexpr char kSecondProfileAccount[] = "profile2@test.com";
+constexpr char kSecondProfileGiaId[] = "9876543210";
+constexpr char kSecondProfileHash[] = "fileBrowserApiTestProfile2";
+
+class FakeSelectFileDialog : public ui::SelectFileDialog {
+ public:
+  FakeSelectFileDialog(ui::SelectFileDialog::Listener* listener,
+                       std::unique_ptr<ui::SelectFilePolicy> policy)
+      : ui::SelectFileDialog(listener, std::move(policy)) {}
+
+  void SelectFileImpl(Type type,
+                      const base::string16& title,
+                      const base::FilePath& default_path,
+                      const FileTypeInfo* file_types,
+                      int file_type_index,
+                      const base::FilePath::StringType& default_extension,
+                      gfx::NativeWindow owning_window,
+                      void* params) override {
+    listener_->FileSelected(base::FilePath("/special/drive-user/root/test_dir"),
+                            0, nullptr);
+  }
+
+  bool IsRunning(gfx::NativeWindow owning_window) const override {
+    return false;
+  }
+
+  void ListenerDestroyed() override {}
+
+  bool HasMultipleFileTypeChoicesImpl() override { return false; }
+
+ private:
+  ~FakeSelectFileDialog() override = default;
+};
+
+class FakeSelectFileDialogFactory : public ui::SelectFileDialogFactory {
+ private:
+  ui::SelectFileDialog* Create(
+      ui::SelectFileDialog::Listener* listener,
+      std::unique_ptr<ui::SelectFilePolicy> policy) override {
+    return new FakeSelectFileDialog(listener, std::move(policy));
+  }
+};
+
+// Sets up the initial file system state for native local and restricted native
+// local file systems. The hierarchy is the same as for the drive file system.
+// The directory is created at unique_temp_dir/|mount_point_name| path.
+bool InitializeLocalFileSystem(std::string mount_point_name,
+                               base::ScopedTempDir* tmp_dir,
+                               base::FilePath* mount_point_dir) {
+  if (!tmp_dir->CreateUniqueTempDir())
+    return false;
+
+  *mount_point_dir = tmp_dir->GetPath().AppendASCII(mount_point_name);
+  // Create the mount point.
+  if (!base::CreateDirectory(*mount_point_dir))
+    return false;
+
+  base::FilePath test_dir = mount_point_dir->AppendASCII("test_dir");
+  if (!base::CreateDirectory(test_dir))
+    return false;
+
+  base::FilePath test_subdir = test_dir.AppendASCII("empty_test_dir");
+  if (!base::CreateDirectory(test_subdir))
+    return false;
+
+  test_subdir = test_dir.AppendASCII("subdir");
+  if (!base::CreateDirectory(test_subdir))
+    return false;
+
+  base::FilePath test_file = test_dir.AppendASCII("test_file.xul");
+  if (!google_apis::test_util::WriteStringToFile(test_file, kTestFileContent))
+    return false;
+
+  test_file = test_dir.AppendASCII("test_file.xul.foo");
+  if (!google_apis::test_util::WriteStringToFile(test_file, kTestFileContent))
+    return false;
+
+  test_file = test_dir.AppendASCII("test_file.tiff");
+  if (!google_apis::test_util::WriteStringToFile(test_file, kTestFileContent))
+    return false;
+
+  test_file = test_dir.AppendASCII("test_file.tiff.foo");
+  if (!google_apis::test_util::WriteStringToFile(test_file, kTestFileContent))
+    return false;
+
+  test_file = test_dir.AppendASCII("empty_test_file.foo");
+  if (!google_apis::test_util::WriteStringToFile(test_file, ""))
+    return false;
+
+  return true;
+}
+
+void IgnoreDriveEntryResult(google_apis::DriveApiErrorCode error,
+                            std::unique_ptr<google_apis::FileResource> entry) {}
+
+void UpdateDriveEntryTime(drive::FakeDriveService* fake_drive_service,
+                          const std::string& resource_id,
+                          const std::string& last_modified,
+                          const std::string& last_viewed_by_me) {
+  base::Time last_modified_time, last_viewed_by_me_time;
+  ASSERT_TRUE(google_apis::util::GetTimeFromString(last_modified,
+                                                   &last_modified_time) &&
+              google_apis::util::GetTimeFromString(last_viewed_by_me,
+                                                   &last_viewed_by_me_time));
+  fake_drive_service->UpdateResource(resource_id,
+                                     std::string(),  // parent_resource_id
+                                     std::string(),  // title
+                                     last_modified_time, last_viewed_by_me_time,
+                                     google_apis::drive::Properties(),
+                                     base::Bind(&IgnoreDriveEntryResult));
+}
+
+void AddFileToDriveService(drive::FakeDriveService* fake_drive_service,
+                           const std::string& mime_type,
+                           const std::string& content,
+                           const std::string& parent_resource_id,
+                           const std::string& title,
+                           const std::string& last_modified,
+                           const std::string& last_viewed_by_me) {
+  fake_drive_service->AddNewFileWithResourceId(
+      title, mime_type, content, parent_resource_id, title,
+      false,  // shared_with_me
+      base::Bind(&IgnoreDriveEntryResult));
+  UpdateDriveEntryTime(fake_drive_service, title, last_modified,
+                       last_viewed_by_me);
+}
+
+void AddDirectoryToDriveService(drive::FakeDriveService* fake_drive_service,
+                                const std::string& parent_resource_id,
+                                const std::string& title,
+                                const std::string& last_modified,
+                                const std::string& last_viewed_by_me) {
+  fake_drive_service->AddNewDirectoryWithResourceId(
+      title, parent_resource_id, title, drive::AddNewDirectoryOptions(),
+      base::Bind(&IgnoreDriveEntryResult));
+  UpdateDriveEntryTime(fake_drive_service, title, last_modified,
+                       last_viewed_by_me);
+}
+
+// Sets up the drive service state.
+// The hierarchy is the same as for the local file system.
+drive::FakeDriveService* CreateDriveService() {
+  drive::FakeDriveService* service = new drive::FakeDriveService;
+  service->LoadAppListForDriveApi("drive/applist.json");
+  AddDirectoryToDriveService(service, service->GetRootResourceId(), "test_dir",
+                             "2012-01-02T00:00:00.000Z",
+                             "2012-01-02T00:00:01.000Z");
+  AddDirectoryToDriveService(service, "test_dir", "empty_test_dir",
+                             "2011-11-02T04:00:00.000Z",
+                             "2011-11-02T04:00:00.000Z");
+  AddDirectoryToDriveService(service, "test_dir", "subdir",
+                             "2011-04-01T18:34:08.234Z",
+                             "2012-01-02T00:00:01.000Z");
+  AddFileToDriveService(service, "application/vnd.mozilla.xul+xml",
+                        kTestFileContent, "test_dir", "test_file.xul",
+                        "2011-12-14T00:40:47.330Z", "2012-01-02T00:00:00.000Z");
+  AddFileToDriveService(service, "test/ro", kTestFileContent, "test_dir",
+                        "test_file.xul.foo", "2012-01-01T10:00:30.000Z",
+                        "2012-01-01T00:00:00.000Z");
+  AddFileToDriveService(service, "image/tiff", kTestFileContent, "test_dir",
+                        "test_file.tiff", "2011-04-03T11:11:10.000Z",
+                        "2012-01-02T00:00:00.000Z");
+  AddFileToDriveService(service, "test/rw", kTestFileContent, "test_dir",
+                        "test_file.tiff.foo", "2011-12-14T00:40:47.330Z",
+                        "2010-01-02T00:00:00.000Z");
+  AddFileToDriveService(service, "test/rw", "", "test_dir",
+                        "empty_test_file.foo", "2011-12-14T00:40:47.330Z",
+                        "2011-12-14T00:40:47.330Z");
+  return service;
+}
+
+// Helper class to wait for a background page to load or close again.
+class BackgroundObserver {
+ public:
+  BackgroundObserver()
+      : page_created_(extensions::NOTIFICATION_EXTENSION_BACKGROUND_PAGE_READY,
+                      content::NotificationService::AllSources()),
+        page_closed_(extensions::NOTIFICATION_EXTENSION_HOST_DESTROYED,
+                     content::NotificationService::AllSources()) {}
+
+  void WaitUntilLoaded() {
+    page_created_.Wait();
+  }
+
+  void WaitUntilClosed() {
+    page_closed_.Wait();
+  }
+
+ private:
+  content::WindowedNotificationObserver page_created_;
+  content::WindowedNotificationObserver page_closed_;
+};
+
+// Base class for FileSystemExtensionApi tests.
+class FileSystemExtensionApiTestBase : public extensions::ExtensionApiTest {
+ public:
+  enum Flags {
+    FLAGS_NONE = 0,
+    FLAGS_USE_FILE_HANDLER = 1 << 1,
+    FLAGS_LAZY_FILE_HANDLER = 1 << 2
+  };
+
+  FileSystemExtensionApiTestBase() = default;
+  ~FileSystemExtensionApiTestBase() override = default;
+
+  void SetUp() override {
+    InitTestFileSystem();
+    extensions::ExtensionApiTest::SetUp();
+  }
+
+  void SetUpOnMainThread() override {
+    AddTestMountPoint();
+
+    // Mock the Media Router in extension api tests. Dispatches to the message
+    // loop now try to handle mojo messages that will call back into Profile
+    // creation through the media router, which then confuse the drive code.
+    ON_CALL(media_router_, RegisterMediaSinksObserver(testing::_))
+        .WillByDefault(testing::Return(true));
+    CastConfigClientMediaRouter::SetMediaRouterForTest(&media_router_);
+
+    extensions::ExtensionApiTest::SetUpOnMainThread();
+  }
+
+  void TearDownOnMainThread() override {
+    CastConfigClientMediaRouter::SetMediaRouterForTest(nullptr);
+    extensions::ExtensionApiTest::TearDownOnMainThread();
+  }
+
+  // Runs a file system extension API test.
+  // It loads test component extension at |filebrowser_path| with manifest
+  // at |filebrowser_manifest|. The |filebrowser_manifest| should be a path
+  // relative to |filebrowser_path|. The method waits until the test extension
+  // sends test succeed or fail message. It returns true if the test succeeds.
+  // If |FLAGS_USE_FILE_HANDLER| flag is set, the file handler extension at path
+  // |filehandler_path| will be loaded before the file browser extension.
+  // If the flag FLAGS_LAZY_FILE_HANDLER is set, the file handler extension must
+  // not have persistent background page. The test will wait until the file
+  // handler's background page is closed after initial load before the file
+  // browser extension is loaded.
+  // If |RunFileSystemExtensionApiTest| fails, |message_| will contain a failure
+  // message.
+  bool RunFileSystemExtensionApiTest(
+      const std::string& filebrowser_path,
+      const base::FilePath::CharType* filebrowser_manifest,
+      const std::string& filehandler_path,
+      int flags) {
+    if (flags & FLAGS_USE_FILE_HANDLER) {
+      if (filehandler_path.empty()) {
+        message_ = "Missing file handler path.";
+        return false;
+      }
+
+      BackgroundObserver page_complete;
+      const Extension* file_handler =
+          LoadExtension(test_data_dir_.AppendASCII(filehandler_path));
+      if (!file_handler) {
+        message_ = "Error loading file handler extension";
+        return false;
+      }
+
+      if (flags & FLAGS_LAZY_FILE_HANDLER) {
+        page_complete.WaitUntilClosed();
+      } else {
+        page_complete.WaitUntilLoaded();
+      }
+    }
+
+    extensions::ResultCatcher catcher;
+
+    const Extension* file_browser = LoadExtensionAsComponentWithManifest(
+        test_data_dir_.AppendASCII(filebrowser_path),
+        filebrowser_manifest);
+    if (!file_browser) {
+      message_ = "Could not create file browser";
+      return false;
+    }
+
+    if (!catcher.GetNextResult()) {
+      message_ = catcher.message();
+      return false;
+    }
+
+    return true;
+  }
+
+ protected:
+  // Sets up initial test file system hierarchy.
+  virtual void InitTestFileSystem() = 0;
+  // Registers mount point used in the test.
+  virtual void AddTestMountPoint() = 0;
+
+ private:
+  media_router::MockMediaRouter media_router_;
+
+  DISALLOW_COPY_AND_ASSIGN(FileSystemExtensionApiTestBase);
+};
+
+// Tests for a native local file system.
+class LocalFileSystemExtensionApiTest : public FileSystemExtensionApiTestBase {
+ public:
+  LocalFileSystemExtensionApiTest() = default;
+  ~LocalFileSystemExtensionApiTest() override = default;
+
+  // FileSystemExtensionApiTestBase override.
+  void InitTestFileSystem() override {
+    ASSERT_TRUE(InitializeLocalFileSystem(
+        kLocalMountPointName, &tmp_dir_, &mount_point_dir_))
+        << "Failed to initialize file system.";
+  }
+
+  // FileSystemExtensionApiTestBase override.
+  void AddTestMountPoint() override {
+    EXPECT_TRUE(
+        content::BrowserContext::GetMountPoints(profile())->RegisterFileSystem(
+            kLocalMountPointName, storage::kFileSystemTypeNativeLocal,
+            storage::FileSystemMountOption(), mount_point_dir_));
+    VolumeManager::Get(profile())->AddVolumeForTesting(
+        mount_point_dir_, VOLUME_TYPE_TESTING, chromeos::DEVICE_TYPE_UNKNOWN,
+        false /* read_only */);
+  }
+
+ private:
+  base::ScopedTempDir tmp_dir_;
+  base::FilePath mount_point_dir_;
+};
+
+// Tests for restricted native local file systems.
+class RestrictedFileSystemExtensionApiTest
+    : public FileSystemExtensionApiTestBase {
+ public:
+  RestrictedFileSystemExtensionApiTest() = default;
+  ~RestrictedFileSystemExtensionApiTest() override = default;
+
+  // FileSystemExtensionApiTestBase override.
+  void InitTestFileSystem() override {
+    ASSERT_TRUE(InitializeLocalFileSystem(
+        kRestrictedMountPointName, &tmp_dir_, &mount_point_dir_))
+        << "Failed to initialize file system.";
+  }
+
+  // FileSystemExtensionApiTestBase override.
+  void AddTestMountPoint() override {
+    EXPECT_TRUE(
+        content::BrowserContext::GetMountPoints(profile())->RegisterFileSystem(
+            kRestrictedMountPointName,
+            storage::kFileSystemTypeRestrictedNativeLocal,
+            storage::FileSystemMountOption(), mount_point_dir_));
+    VolumeManager::Get(profile())->AddVolumeForTesting(
+        mount_point_dir_, VOLUME_TYPE_TESTING, chromeos::DEVICE_TYPE_UNKNOWN,
+        true /* read_only */);
+  }
+
+ private:
+  base::ScopedTempDir tmp_dir_;
+  base::FilePath mount_point_dir_;
+};
+
+// Tests for a drive file system.
+class DriveFileSystemExtensionApiTest : public FileSystemExtensionApiTestBase {
+ public:
+  DriveFileSystemExtensionApiTest() = default;
+  ~DriveFileSystemExtensionApiTest() override = default;
+
+  // FileSystemExtensionApiTestBase override.
+  void InitTestFileSystem() override {
+    // Set up cache root to be used by DriveIntegrationService. This has to be
+    // done before the browser is created because the service instance is
+    // initialized by EventRouter.
+    ASSERT_TRUE(test_cache_root_.CreateUniqueTempDir());
+
+    // This callback will get called during Profile creation.
+    create_drive_integration_service_ = base::Bind(
+        &DriveFileSystemExtensionApiTest::CreateDriveIntegrationService,
+        base::Unretained(this));
+    service_factory_for_test_ =
+        std::make_unique<DriveIntegrationServiceFactory::ScopedFactoryForTest>(
+
+            &create_drive_integration_service_);
+  }
+
+  // FileSystemExtensionApiTestBase override.
+  void AddTestMountPoint() override {
+    test_util::WaitUntilDriveMountPointIsAdded(profile());
+  }
+
+  // FileSystemExtensionApiTestBase override.
+  void TearDown() override {
+    FileSystemExtensionApiTestBase::TearDown();
+    ui::SelectFileDialog::SetFactory(nullptr);
+  }
+
+ protected:
+  // DriveIntegrationService factory function for this test.
+  drive::DriveIntegrationService* CreateDriveIntegrationService(
+      Profile* profile) {
+    // Ignore signin and lock screen apps profile.
+    if (profile->GetPath() == chromeos::ProfileHelper::GetSigninProfileDir() ||
+        profile->GetPath() ==
+            chromeos::ProfileHelper::GetLockScreenAppProfilePath()) {
+      return nullptr;
+    }
+
+    // DriveFileSystemExtensionApiTest doesn't expect that several user profiles
+    // could exist simultaneously.
+    DCHECK(!fake_drive_service_);
+    fake_drive_service_ = CreateDriveService();
+    return new drive::DriveIntegrationService(
+        profile, nullptr, fake_drive_service_, "", test_cache_root_.GetPath(),
+        nullptr);
+  }
+
+  base::ScopedTempDir test_cache_root_;
+  drive::FakeDriveService* fake_drive_service_ = nullptr;
+  DriveIntegrationServiceFactory::FactoryCallback
+      create_drive_integration_service_;
+  std::unique_ptr<DriveIntegrationServiceFactory::ScopedFactoryForTest>
+      service_factory_for_test_;
+};
+
+// Tests for Drive file systems in multi-profile setting.
+class MultiProfileDriveFileSystemExtensionApiTest :
+    public FileSystemExtensionApiTestBase {
+ public:
+  MultiProfileDriveFileSystemExtensionApiTest() = default;
+
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    FileSystemExtensionApiTestBase::SetUpCommandLine(command_line);
+    // Don't require policy for our sessions - this is required because
+    // this test creates a secondary profile synchronously, so we need to
+    // let the policy code know not to expect cached policy.
+    command_line->AppendSwitchASCII(chromeos::switches::kProfileRequiresPolicy,
+                                    "false");
+  }
+
+  void SetUpOnMainThread() override {
+    base::FilePath user_data_directory;
+    base::PathService::Get(chrome::DIR_USER_DATA, &user_data_directory);
+    session_manager::SessionManager::Get()->CreateSession(
+        AccountId::FromUserEmailGaiaId(kSecondProfileAccount,
+                                       kSecondProfileGiaId),
+        kSecondProfileHash, false);
+    // Set up the secondary profile.
+    base::FilePath profile_dir =
+        user_data_directory.Append(
+            chromeos::ProfileHelper::GetUserProfileDir(
+                kSecondProfileHash).BaseName());
+    second_profile_ =
+        g_browser_process->profile_manager()->GetProfile(profile_dir);
+
+    FileSystemExtensionApiTestBase::SetUpOnMainThread();
+  }
+
+  void InitTestFileSystem() override {
+    ASSERT_TRUE(tmp_dir_.CreateUniqueTempDir());
+
+    // This callback will get called during Profile creation.
+    create_drive_integration_service_ = base::Bind(
+        &MultiProfileDriveFileSystemExtensionApiTest::
+            CreateDriveIntegrationService,
+        base::Unretained(this));
+    service_factory_for_test_ =
+        std::make_unique<DriveIntegrationServiceFactory::ScopedFactoryForTest>(
+
+            &create_drive_integration_service_);
+  }
+
+  void AddTestMountPoint() override {
+    test_util::WaitUntilDriveMountPointIsAdded(profile());
+    test_util::WaitUntilDriveMountPointIsAdded(second_profile_);
+  }
+
+ protected:
+  // DriveIntegrationService factory function for this test.
+  drive::DriveIntegrationService* CreateDriveIntegrationService(
+      Profile* profile) {
+    base::FilePath cache_dir;
+    base::CreateTemporaryDirInDir(tmp_dir_.GetPath(),
+                                  base::FilePath::StringType(), &cache_dir);
+
+    drive::FakeDriveService* const service = CreateDriveService();
+    return new drive::DriveIntegrationService(
+        profile, nullptr, service, std::string(), cache_dir, nullptr);
+  }
+
+  void AddTestHostedDocuments() {
+    const char kResourceId[] = "unique-id-for-multiprofile-copy-test";
+    drive::FakeDriveService* const main_service =
+        static_cast<drive::FakeDriveService*>(
+            drive::util::GetDriveServiceByProfile(profile()));
+    drive::FakeDriveService* const sub_service =
+        static_cast<drive::FakeDriveService*>(
+            drive::util::GetDriveServiceByProfile(second_profile_));
+
+    // Place a hosted document under root/test_dir of the sub profile.
+    sub_service->AddNewFileWithResourceId(
+        kResourceId, "application/vnd.google-apps.document", "", "test_dir",
+        "hosted_doc", true, base::Bind(&IgnoreDriveEntryResult));
+
+    // Place the hosted document with no parent in the main profile, for
+    // simulating the situation that the document is shared to the main profile.
+    main_service->AddNewFileWithResourceId(
+        kResourceId, "application/vnd.google-apps.document", "", "",
+        "hosted_doc", true, base::Bind(&IgnoreDriveEntryResult));
+  }
+
+  base::ScopedTempDir tmp_dir_;
+  DriveIntegrationServiceFactory::FactoryCallback
+      create_drive_integration_service_;
+  std::unique_ptr<DriveIntegrationServiceFactory::ScopedFactoryForTest>
+      service_factory_for_test_;
+  Profile* second_profile_ = nullptr;
+};
+
+class LocalAndDriveFileSystemExtensionApiTest
+    : public FileSystemExtensionApiTestBase {
+ public:
+  LocalAndDriveFileSystemExtensionApiTest() = default;
+  ~LocalAndDriveFileSystemExtensionApiTest() override = default;
+
+  // FileSystemExtensionApiTestBase override.
+  void InitTestFileSystem() override {
+    ASSERT_TRUE(InitializeLocalFileSystem(
+        kLocalMountPointName, &local_tmp_dir_, &local_mount_point_dir_))
+        << "Failed to initialize file system.";
+
+    // Set up cache root to be used by DriveIntegrationService. This has to be
+    // done before the browser is created because the service instance is
+    // initialized by EventRouter.
+    ASSERT_TRUE(test_cache_root_.CreateUniqueTempDir());
+
+    // This callback will get called during Profile creation.
+    create_drive_integration_service_ = base::Bind(
+        &LocalAndDriveFileSystemExtensionApiTest::CreateDriveIntegrationService,
+        base::Unretained(this));
+    service_factory_for_test_ =
+        std::make_unique<DriveIntegrationServiceFactory::ScopedFactoryForTest>(
+
+            &create_drive_integration_service_);
+  }
+
+  // FileSystemExtensionApiTestBase override.
+  void AddTestMountPoint() override {
+    EXPECT_TRUE(
+        content::BrowserContext::GetMountPoints(profile())->RegisterFileSystem(
+            kLocalMountPointName, storage::kFileSystemTypeNativeLocal,
+            storage::FileSystemMountOption(), local_mount_point_dir_));
+    VolumeManager::Get(profile())->AddVolumeForTesting(
+        local_mount_point_dir_, VOLUME_TYPE_TESTING,
+        chromeos::DEVICE_TYPE_UNKNOWN, false /* read_only */);
+    test_util::WaitUntilDriveMountPointIsAdded(profile());
+  }
+
+ protected:
+  // DriveIntegrationService factory function for this test.
+  drive::DriveIntegrationService* CreateDriveIntegrationService(
+      Profile* profile) {
+    fake_drive_service_ = CreateDriveService();
+    return new drive::DriveIntegrationService(
+        profile, nullptr, fake_drive_service_, "drive",
+        test_cache_root_.GetPath(), nullptr);
+  }
+
+ private:
+  // For local volume.
+  base::ScopedTempDir local_tmp_dir_;
+  base::FilePath local_mount_point_dir_;
+
+  // For drive volume.
+  base::ScopedTempDir test_cache_root_;
+  drive::FakeDriveService* fake_drive_service_ = nullptr;
+  DriveIntegrationServiceFactory::FactoryCallback
+      create_drive_integration_service_;
+  std::unique_ptr<DriveIntegrationServiceFactory::ScopedFactoryForTest>
+      service_factory_for_test_;
+};
+
+//
+// LocalFileSystemExtensionApiTests.
+//
+
+IN_PROC_BROWSER_TEST_F(LocalFileSystemExtensionApiTest, FileSystemOperations) {
+  EXPECT_TRUE(RunFileSystemExtensionApiTest(
+      "file_browser/filesystem_operations_test",
+      FILE_PATH_LITERAL("manifest.json"),
+      "",
+      FLAGS_NONE)) << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(LocalFileSystemExtensionApiTest, FileWatch) {
+  EXPECT_TRUE(RunFileSystemExtensionApiTest(
+      "file_browser/file_watcher_test",
+      FILE_PATH_LITERAL("manifest.json"),
+      "",
+      FLAGS_NONE)) << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(LocalFileSystemExtensionApiTest, FileBrowserHandlers) {
+  EXPECT_TRUE(RunFileSystemExtensionApiTest(
+      "file_browser/handler_test_runner",
+      FILE_PATH_LITERAL("manifest.json"),
+      "file_browser/file_browser_handler",
+      FLAGS_USE_FILE_HANDLER)) << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(LocalFileSystemExtensionApiTest,
+                       FileBrowserHandlersLazy) {
+  EXPECT_TRUE(RunFileSystemExtensionApiTest(
+      "file_browser/handler_test_runner",
+      FILE_PATH_LITERAL("manifest.json"),
+      "file_browser/file_browser_handler_lazy",
+      FLAGS_USE_FILE_HANDLER | FLAGS_LAZY_FILE_HANDLER)) << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(LocalFileSystemExtensionApiTest, AppFileHandler) {
+  EXPECT_TRUE(RunFileSystemExtensionApiTest(
+      "file_browser/handler_test_runner",
+      FILE_PATH_LITERAL("manifest.json"),
+      "file_browser/app_file_handler",
+      FLAGS_USE_FILE_HANDLER)) << message_;
+}
+
+//
+// RestrictedFileSystemExtensionApiTests.
+//
+IN_PROC_BROWSER_TEST_F(RestrictedFileSystemExtensionApiTest,
+                       FileSystemOperations) {
+  EXPECT_TRUE(RunFileSystemExtensionApiTest(
+      "file_browser/filesystem_operations_test",
+      FILE_PATH_LITERAL("manifest.json"),
+      "",
+      FLAGS_NONE)) << message_;
+}
+
+//
+// DriveFileSystemExtensionApiTests.
+//
+#if defined(LEAK_SANITIZER)
+#define MAYBE_FileSystemOperations DISABLED_FileSystemOperations
+#else
+#define MAYBE_FileSystemOperations FileSystemOperations
+#endif
+IN_PROC_BROWSER_TEST_F(DriveFileSystemExtensionApiTest,
+                       MAYBE_FileSystemOperations) {
+  EXPECT_TRUE(RunFileSystemExtensionApiTest(
+      "file_browser/filesystem_operations_test",
+      FILE_PATH_LITERAL("manifest.json"),
+      "",
+      FLAGS_NONE)) << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(DriveFileSystemExtensionApiTest, FileWatch) {
+  EXPECT_TRUE(RunFileSystemExtensionApiTest(
+      "file_browser/file_watcher_test",
+      FILE_PATH_LITERAL("manifest.json"),
+      "",
+      FLAGS_NONE)) << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(DriveFileSystemExtensionApiTest, FileBrowserHandlers) {
+  EXPECT_TRUE(RunFileSystemExtensionApiTest(
+      "file_browser/handler_test_runner",
+      FILE_PATH_LITERAL("manifest.json"),
+      "file_browser/file_browser_handler",
+      FLAGS_USE_FILE_HANDLER)) << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(DriveFileSystemExtensionApiTest, Search) {
+  // Configure the drive service to return only one search result at a time
+  // to simulate paginated searches.
+  fake_drive_service_->set_default_max_results(1);
+  EXPECT_TRUE(RunFileSystemExtensionApiTest(
+      "file_browser/drive_search_test",
+      FILE_PATH_LITERAL("manifest.json"),
+      "",
+      FLAGS_NONE)) << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(DriveFileSystemExtensionApiTest, AppFileHandler) {
+  EXPECT_TRUE(RunFileSystemExtensionApiTest(
+      "file_browser/handler_test_runner",
+      FILE_PATH_LITERAL("manifest.json"),
+      "file_browser/app_file_handler",
+      FLAGS_USE_FILE_HANDLER)) << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(DriveFileSystemExtensionApiTest, RetainEntry) {
+  ui::SelectFileDialog::SetFactory(new FakeSelectFileDialogFactory());
+  EXPECT_TRUE(RunFileSystemExtensionApiTest("file_browser/retain_entry",
+                                            FILE_PATH_LITERAL("manifest.json"),
+                                            "",
+                                            FLAGS_NONE))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(MultiProfileDriveFileSystemExtensionApiTest,
+                       CrossProfileCopy) {
+  AddTestHostedDocuments();
+  EXPECT_TRUE(RunFileSystemExtensionApiTest(
+      "file_browser/multi_profile_copy",
+      FILE_PATH_LITERAL("manifest.json"),
+      "",
+      FLAGS_NONE)) << message_;
+}
+
+//
+// LocalAndDriveFileSystemExtensionApiTests.
+//
+IN_PROC_BROWSER_TEST_F(LocalAndDriveFileSystemExtensionApiTest,
+                       AppFileHandlerMulti) {
+  EXPECT_TRUE(
+      RunFileSystemExtensionApiTest("file_browser/app_file_handler_multi",
+                                    FILE_PATH_LITERAL("manifest.json"),
+                                    "",
+                                    FLAGS_NONE))
+      << message_;
+}
+}  // namespace
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/fake_disk_mount_manager.cc b/chrome/browser/file_manager/fake_disk_mount_manager.cc
new file mode 100644
index 0000000000000..cb66d3e24040c
--- /dev/null
+++ b/chrome/browser/file_manager/fake_disk_mount_manager.cc
@@ -0,0 +1,167 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/fake_disk_mount_manager.h"
+
+#include "chromeos/disks/disk.h"
+
+namespace file_manager {
+
+FakeDiskMountManager::MountRequest::MountRequest(
+    const std::string& source_path,
+    const std::string& source_format,
+    const std::string& mount_label,
+    const std::vector<std::string>& mount_options,
+    chromeos::MountType type,
+    chromeos::MountAccessMode access_mode)
+    : source_path(source_path),
+      source_format(source_format),
+      mount_label(mount_label),
+      mount_options(mount_options),
+      type(type),
+      access_mode(access_mode) {}
+
+FakeDiskMountManager::MountRequest::MountRequest(const MountRequest& other) =
+    default;
+
+FakeDiskMountManager::MountRequest::~MountRequest() = default;
+
+FakeDiskMountManager::UnmountRequest::UnmountRequest(
+    const std::string& mount_path,
+    chromeos::UnmountOptions options)
+    : mount_path(mount_path),
+      options(options) {
+}
+
+FakeDiskMountManager::RemountAllRequest::RemountAllRequest(
+    chromeos::MountAccessMode access_mode)
+    : access_mode(access_mode) {}
+
+FakeDiskMountManager::FakeDiskMountManager() = default;
+
+FakeDiskMountManager::~FakeDiskMountManager() = default;
+
+void FakeDiskMountManager::AddObserver(Observer* observer) {
+  DCHECK(observer);
+  observers_.AddObserver(observer);
+}
+
+void FakeDiskMountManager::RemoveObserver(Observer* observer) {
+  DCHECK(observer);
+  observers_.RemoveObserver(observer);
+}
+
+const chromeos::disks::DiskMountManager::DiskMap&
+FakeDiskMountManager::disks() const {
+  return disks_;
+}
+
+const chromeos::disks::Disk* FakeDiskMountManager::FindDiskBySourcePath(
+    const std::string& source_path) const {
+  DiskMap::const_iterator iter = disks_.find(source_path);
+  return iter != disks_.end() ? iter->second.get() : nullptr;
+}
+
+const chromeos::disks::DiskMountManager::MountPointMap&
+FakeDiskMountManager::mount_points() const {
+  return mount_points_;
+}
+
+void FakeDiskMountManager::EnsureMountInfoRefreshed(
+    const EnsureMountInfoRefreshedCallback& callback,
+    bool force) {
+  callback.Run(true);
+}
+
+void FakeDiskMountManager::MountPath(
+    const std::string& source_path,
+    const std::string& source_format,
+    const std::string& mount_label,
+    const std::vector<std::string>& mount_options,
+    chromeos::MountType type,
+    chromeos::MountAccessMode access_mode) {
+  mount_requests_.emplace_back(source_path, source_format, mount_label,
+                               mount_options, type, access_mode);
+
+  const MountPointInfo mount_point(
+      source_path,
+      source_path,
+      type,
+      chromeos::disks::MOUNT_CONDITION_NONE);
+  mount_points_.insert(make_pair(source_path, mount_point));
+  for (auto& observer : observers_) {
+    observer.OnMountEvent(DiskMountManager::MOUNTING,
+                          chromeos::MOUNT_ERROR_NONE, mount_point);
+  }
+}
+
+void FakeDiskMountManager::UnmountPath(const std::string& mount_path,
+                                       chromeos::UnmountOptions options,
+                                       const UnmountPathCallback& callback) {
+  unmount_requests_.emplace_back(mount_path, options);
+
+  MountPointMap::iterator iter = mount_points_.find(mount_path);
+  if (iter == mount_points_.end())
+    return;
+
+  const MountPointInfo mount_point = iter->second;
+  mount_points_.erase(iter);
+  for (auto& observer : observers_) {
+    observer.OnMountEvent(DiskMountManager::UNMOUNTING,
+                          chromeos::MOUNT_ERROR_NONE, mount_point);
+  }
+
+  // Enqueue callback so that |FakeDiskMountManager::FinishAllUnmountRequest()|
+  // can call them.
+  pending_unmount_callbacks_.push(callback);
+}
+
+void FakeDiskMountManager::RemountAllRemovableDrives(
+    chromeos::MountAccessMode access_mode) {
+  remount_all_requests_.emplace_back(access_mode);
+}
+
+bool FakeDiskMountManager::FinishAllUnmountPathRequests() {
+  if (pending_unmount_callbacks_.empty())
+    return false;
+
+  while (!pending_unmount_callbacks_.empty()) {
+    pending_unmount_callbacks_.front().Run(chromeos::MOUNT_ERROR_NONE);
+    pending_unmount_callbacks_.pop();
+  }
+  return true;
+}
+
+void FakeDiskMountManager::FormatMountedDevice(const std::string& mount_path) {
+}
+
+void FakeDiskMountManager::RenameMountedDevice(const std::string& mount_path,
+                                               const std::string& volume_name) {
+}
+
+void FakeDiskMountManager::UnmountDeviceRecursively(
+    const std::string& device_path,
+    UnmountDeviceRecursivelyCallbackType callback) {}
+
+bool FakeDiskMountManager::AddDiskForTest(
+    std::unique_ptr<chromeos::disks::Disk> disk) {
+  DCHECK(disk);
+  return disks_.insert(make_pair(disk->device_path(), std::move(disk))).second;
+}
+
+bool FakeDiskMountManager::AddMountPointForTest(
+    const MountPointInfo& mount_point) {
+  return false;
+}
+
+void FakeDiskMountManager::InvokeDiskEventForTest(
+    chromeos::disks::DiskMountManager::DiskEvent event,
+    const chromeos::disks::Disk* disk) {
+  for (auto& observer : observers_) {
+    disk->is_auto_mountable() ? observer.OnAutoMountableDiskEvent(event, *disk)
+                              : observer.OnBootDeviceDiskEvent(event, *disk);
+  }
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/fake_disk_mount_manager.h b/chrome/browser/file_manager/fake_disk_mount_manager.h
new file mode 100644
index 0000000000000..67e968053dc68
--- /dev/null
+++ b/chrome/browser/file_manager/fake_disk_mount_manager.h
@@ -0,0 +1,124 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_FAKE_DISK_MOUNT_MANAGER_H_
+#define CHROME_BROWSER_FILE_MANAGER_FAKE_DISK_MOUNT_MANAGER_H_
+
+#include <string>
+#include <vector>
+
+#include "base/callback.h"
+#include "base/compiler_specific.h"
+#include "base/containers/queue.h"
+#include "base/macros.h"
+#include "base/observer_list.h"
+#include "chromeos/dbus/cros_disks_client.h"
+#include "chromeos/disks/disk_mount_manager.h"
+
+namespace file_manager {
+
+class FakeDiskMountManager : public chromeos::disks::DiskMountManager {
+ public:
+  struct MountRequest {
+    MountRequest(const std::string& source_path,
+                 const std::string& source_format,
+                 const std::string& mount_label,
+                 const std::vector<std::string>& mount_options,
+                 chromeos::MountType type,
+                 chromeos::MountAccessMode access_mode);
+    MountRequest(const MountRequest& other);
+    ~MountRequest();
+
+    std::string source_path;
+    std::string source_format;
+    std::string mount_label;
+    std::vector<std::string> mount_options;
+    chromeos::MountType type;
+    chromeos::MountAccessMode access_mode;
+  };
+
+  struct UnmountRequest {
+    UnmountRequest(const std::string& mount_path,
+                   chromeos::UnmountOptions options);
+
+    std::string mount_path;
+    chromeos::UnmountOptions options;
+  };
+
+  struct RemountAllRequest {
+    explicit RemountAllRequest(chromeos::MountAccessMode access_mode);
+    chromeos::MountAccessMode access_mode;
+  };
+
+  FakeDiskMountManager();
+  ~FakeDiskMountManager() override;
+
+  const std::vector<MountRequest>& mount_requests() const {
+    return mount_requests_;
+  }
+  const std::vector<UnmountRequest>& unmount_requests() const {
+    return unmount_requests_;
+  }
+  const std::vector<RemountAllRequest>& remount_all_requests() const {
+    return remount_all_requests_;
+  }
+
+  // Emulates that all mount request finished.
+  // Return true if there was one or more mount request enqueued, or false
+  // otherwise.
+  bool FinishAllUnmountPathRequests();
+
+  // DiskMountManager overrides.
+  void AddObserver(Observer* observer) override;
+  void RemoveObserver(Observer* observer) override;
+  const DiskMap& disks() const override;
+  const chromeos::disks::Disk* FindDiskBySourcePath(
+      const std::string& source_path) const override;
+  const MountPointMap& mount_points() const override;
+  void EnsureMountInfoRefreshed(
+      const EnsureMountInfoRefreshedCallback& callback,
+      bool force) override;
+  void MountPath(const std::string& source_path,
+                 const std::string& source_format,
+                 const std::string& mount_label,
+                 const std::vector<std::string>& mount_options,
+                 chromeos::MountType type,
+                 chromeos::MountAccessMode access_mode) override;
+  // In order to simulate asynchronous invocation of callbacks after unmount
+  // is finished, |callback| will be invoked only when
+  // |FinishAllUnmountRequest()| is called.
+  void UnmountPath(const std::string& mount_path,
+                   chromeos::UnmountOptions options,
+                   const UnmountPathCallback& callback) override;
+  void RemountAllRemovableDrives(
+      chromeos::MountAccessMode access_mode) override;
+  void FormatMountedDevice(const std::string& mount_path) override;
+  void RenameMountedDevice(const std::string& mount_path,
+                           const std::string& volume_name) override;
+  void UnmountDeviceRecursively(
+      const std::string& device_path,
+      UnmountDeviceRecursivelyCallbackType callback) override;
+
+  bool AddDiskForTest(std::unique_ptr<chromeos::disks::Disk> disk) override;
+  bool AddMountPointForTest(const MountPointInfo& mount_point) override;
+  void InvokeDiskEventForTest(DiskEvent event,
+                              const chromeos::disks::Disk* disk);
+
+ private:
+  base::ObserverList<Observer>::Unchecked observers_;
+  base::queue<UnmountPathCallback> pending_unmount_callbacks_;
+
+  DiskMap disks_;
+  MountPointMap mount_points_;
+
+  std::vector<MountRequest> mount_requests_;
+  std::vector<UnmountRequest> unmount_requests_;
+  std::vector<RemountAllRequest> remount_all_requests_;
+
+  DISALLOW_COPY_AND_ASSIGN(FakeDiskMountManager);
+};
+
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_FAKE_DISK_MOUNT_MANAGER_H_
diff --git a/chrome/browser/file_manager/file_browser_handlers.cc b/chrome/browser/file_manager/file_browser_handlers.cc
new file mode 100644
index 0000000000000..f34d3d267e480
--- /dev/null
+++ b/chrome/browser/file_manager/file_browser_handlers.cc
@@ -0,0 +1,536 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/file_browser_handlers.h"
+
+#include <stddef.h>
+#include <algorithm>
+#include <memory>
+#include <set>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/command_line.h"
+#include "base/files/file_util.h"
+#include "base/i18n/case_conversion.h"
+#include "base/macros.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/task/post_task.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/open_with_browser.h"
+#include "chrome/browser/fileapi/file_system_backend.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser_finder.h"
+#include "chrome/common/extensions/api/file_browser_handlers/file_browser_handler.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "chromeos/chromeos_switches.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/child_process_security_policy.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/site_instance.h"
+#include "content/public/browser/web_contents.h"
+#include "extensions/browser/event_router.h"
+#include "extensions/browser/extension_host.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/browser/extension_util.h"
+#include "extensions/browser/lazy_background_task_queue.h"
+#include "extensions/common/extension_set.h"
+#include "extensions/common/manifest_handlers/background_info.h"
+#include "extensions/common/url_pattern.h"
+#include "net/base/escape.h"
+#include "storage/browser/fileapi/file_system_context.h"
+#include "storage/browser/fileapi/file_system_url.h"
+#include "storage/common/fileapi/file_system_info.h"
+#include "storage/common/fileapi/file_system_util.h"
+
+using content::BrowserThread;
+using content::ChildProcessSecurityPolicy;
+using content::SiteInstance;
+using content::WebContents;
+using extensions::Extension;
+using storage::FileSystemURL;
+using file_manager::util::EntryDefinition;
+using file_manager::util::EntryDefinitionList;
+using file_manager::util::FileDefinition;
+using file_manager::util::FileDefinitionList;
+
+namespace file_manager {
+namespace file_browser_handlers {
+namespace {
+
+// Returns process id of the process the extension is running in.
+int ExtractProcessFromExtensionId(Profile* profile,
+                                  const std::string& extension_id) {
+  GURL extension_url =
+      Extension::GetBaseURLFromExtensionId(extension_id);
+  extensions::ProcessManager* manager =
+      extensions::ProcessManager::Get(profile);
+
+  scoped_refptr<SiteInstance> site_instance =
+      manager->GetSiteInstanceForURL(extension_url);
+  if (!site_instance || !site_instance->HasProcess())
+    return -1;
+  content::RenderProcessHost* process = site_instance->GetProcess();
+
+  return process->GetID();
+}
+
+// Finds a file browser handler that matches |action_id|. Returns NULL if not
+// found.
+const FileBrowserHandler* FindFileBrowserHandlerForActionId(
+    const Extension* extension,
+    const std::string& action_id) {
+  FileBrowserHandler::List* handler_list =
+      FileBrowserHandler::GetHandlers(extension);
+  for (FileBrowserHandler::List::const_iterator handler_iter =
+           handler_list->begin();
+       handler_iter != handler_list->end();
+       ++handler_iter) {
+    if (handler_iter->get()->id() == action_id)
+      return handler_iter->get();
+  }
+  return nullptr;
+}
+
+std::string EscapedUtf8ToLower(const std::string& str) {
+  base::string16 utf16 = base::UTF8ToUTF16(
+      net::UnescapeURLComponent(str, net::UnescapeRule::NORMAL));
+  return net::EscapeUrlEncodedData(
+      base::UTF16ToUTF8(base::i18n::ToLower(utf16)),
+      false /* do not replace space with plus */);
+}
+
+// Finds file browser handlers that can handle the |selected_file_url|.
+FileBrowserHandlerList FindFileBrowserHandlersForURL(
+    Profile* profile,
+    const GURL& selected_file_url) {
+  extensions::ExtensionRegistry* registry =
+      extensions::ExtensionRegistry::Get(profile);
+  // In unit-tests, we may not have an ExtensionRegistry.
+  if (!registry)
+    return FileBrowserHandlerList();
+
+  // We need case-insensitive matching, and pattern in the handler is already
+  // in lower case.
+  const GURL lowercase_url(EscapedUtf8ToLower(selected_file_url.spec()));
+
+  FileBrowserHandlerList results;
+  for (const scoped_refptr<const Extension>& extension :
+       registry->enabled_extensions()) {
+    if (profile->IsOffTheRecord() &&
+        !extensions::util::IsIncognitoEnabled(extension->id(), profile))
+      continue;
+    FileBrowserHandler::List* handler_list =
+        FileBrowserHandler::GetHandlers(extension.get());
+    if (!handler_list)
+      continue;
+    for (FileBrowserHandler::List::const_iterator handler_iter =
+             handler_list->begin();
+         handler_iter != handler_list->end();
+         ++handler_iter) {
+      const FileBrowserHandler* handler = handler_iter->get();
+      if (!handler->MatchesURL(lowercase_url))
+        continue;
+
+      // Filter out Files app from handling ZIP files via a handler, as it's
+      // now handled by:
+      // - ZIP unpacker extension based on File System Provider API
+      // - Zip Archiver native extension component
+      const URLPattern zip_pattern(URLPattern::SCHEME_EXTENSION,
+                                   "chrome-extension://*/*.zip");
+      if (handler->extension_id() == kFileManagerAppId &&
+          zip_pattern.MatchesURL(selected_file_url) &&
+          (!base::CommandLine::ForCurrentProcess()->HasSwitch(
+               chromeos::switches::kDisableNewZIPUnpacker) ||
+           chromeos::switches::IsZipArchiverUnpackerEnabled())) {
+        continue;
+      }
+      results.push_back(handler);
+    }
+  }
+  return results;
+}
+
+// This class is used to execute a file browser handler task. Here's how this
+// works:
+//
+// 1) Open the "external" file system
+// 2) Set up permissions for the target files on the external file system.
+// 3) Raise onExecute event with the action ID and entries of the target
+//    files. The event will launch the file browser handler if not active.
+// 4) In the file browser handler, onExecute event is handled and executes the
+//    task in JavaScript.
+//
+// That said, the class itself does not execute a task. The task will be
+// executed in JavaScript.
+class FileBrowserHandlerExecutor {
+ public:
+  FileBrowserHandlerExecutor(Profile* profile,
+                             const Extension* extension,
+                             const std::string& action_id);
+
+  // Executes the task for each file. |done| will be run with the result.
+  void Execute(const std::vector<FileSystemURL>& file_urls,
+               const file_tasks::FileTaskFinishedCallback& done);
+
+ private:
+  // This object is responsible to delete itself.
+  virtual ~FileBrowserHandlerExecutor();
+
+  // Checks legitimacy of file url and grants file RO access permissions from
+  // handler (target) extension and its renderer process.
+  static std::unique_ptr<FileDefinitionList> SetupFileAccessPermissions(
+      scoped_refptr<storage::FileSystemContext> file_system_context_handler,
+      const scoped_refptr<const Extension>& handler_extension,
+      const std::vector<FileSystemURL>& file_urls);
+
+  void ExecuteDoneOnUIThread(bool success);
+  void ExecuteAfterSetupFileAccess(
+      std::unique_ptr<FileDefinitionList> file_list);
+  void ExecuteFileActionsOnUIThread(
+      std::unique_ptr<FileDefinitionList> file_definition_list,
+      std::unique_ptr<EntryDefinitionList> entry_definition_list);
+  void SetupPermissionsAndDispatchEvent(
+      std::unique_ptr<FileDefinitionList> file_definition_list,
+      std::unique_ptr<EntryDefinitionList> entry_definition_list,
+      int handler_pid_in,
+      extensions::ExtensionHost* host);
+
+  // Registers file permissions from |handler_host_permissions_| with
+  // ChildProcessSecurityPolicy for process with id |handler_pid|.
+  void SetupHandlerHostFileAccessPermissions(
+      FileDefinitionList* file_definition_list,
+      const Extension* extension,
+      int handler_pid);
+
+  Profile* profile_;
+  scoped_refptr<const Extension> extension_;
+  const std::string action_id_;
+  file_tasks::FileTaskFinishedCallback done_;
+  base::WeakPtrFactory<FileBrowserHandlerExecutor> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(FileBrowserHandlerExecutor);
+};
+
+// static
+std::unique_ptr<FileDefinitionList>
+FileBrowserHandlerExecutor::SetupFileAccessPermissions(
+    scoped_refptr<storage::FileSystemContext> file_system_context_handler,
+    const scoped_refptr<const Extension>& handler_extension,
+    const std::vector<FileSystemURL>& file_urls) {
+  DCHECK(handler_extension.get());
+
+  storage::ExternalFileSystemBackend* backend =
+      file_system_context_handler->external_backend();
+
+  std::unique_ptr<FileDefinitionList> file_definition_list(
+      new FileDefinitionList);
+  for (size_t i = 0; i < file_urls.size(); ++i) {
+    const FileSystemURL& url = file_urls[i];
+
+    // Check if this file system entry exists first.
+    base::File::Info file_info;
+
+    base::FilePath local_path = url.path();
+    base::FilePath virtual_path = url.virtual_path();
+
+    const bool is_drive_file = url.type() == storage::kFileSystemTypeDrive;
+    DCHECK(!is_drive_file || drive::util::IsUnderDriveMountPoint(local_path));
+
+    const bool is_native_file =
+        url.type() == storage::kFileSystemTypeNativeLocal ||
+        url.type() == storage::kFileSystemTypeRestrictedNativeLocal;
+
+    // If the file is from a physical volume, actual file must be found.
+    if (is_native_file) {
+      if (!base::PathExists(local_path) ||
+          base::IsLink(local_path) ||
+          !base::GetFileInfo(local_path, &file_info)) {
+        continue;
+      }
+    }
+
+    // Grant access to this particular file to target extension. This will
+    // ensure that the target extension can access only this FS entry and
+    // prevent from traversing FS hierarchy upward.
+    backend->GrantFileAccessToExtension(handler_extension->id(), virtual_path);
+
+    // Output values.
+    FileDefinition file_definition;
+    file_definition.virtual_path = virtual_path;
+    file_definition.is_directory = file_info.is_directory;
+    file_definition.absolute_path = local_path;
+    file_definition_list->push_back(file_definition);
+  }
+
+  return file_definition_list;
+}
+
+FileBrowserHandlerExecutor::FileBrowserHandlerExecutor(
+    Profile* profile,
+    const Extension* extension,
+    const std::string& action_id)
+    : profile_(profile),
+      extension_(extension),
+      action_id_(action_id),
+      weak_ptr_factory_(this) {
+}
+
+FileBrowserHandlerExecutor::~FileBrowserHandlerExecutor() = default;
+
+void FileBrowserHandlerExecutor::Execute(
+    const std::vector<FileSystemURL>& file_urls,
+    const file_tasks::FileTaskFinishedCallback& done) {
+  done_ = done;
+
+  // Get file system context for the extension to which onExecute event will be
+  // sent. The file access permissions will be granted to the extension in the
+  // file system context for the files in |file_urls|.
+  scoped_refptr<storage::FileSystemContext> file_system_context(
+      util::GetFileSystemContextForExtensionId(profile_, extension_->id()));
+
+  base::PostTaskWithTraitsAndReplyWithResult(
+      FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_BLOCKING},
+      base::Bind(&SetupFileAccessPermissions, file_system_context, extension_,
+                 file_urls),
+      base::Bind(&FileBrowserHandlerExecutor::ExecuteAfterSetupFileAccess,
+                 weak_ptr_factory_.GetWeakPtr()));
+}
+
+void FileBrowserHandlerExecutor::ExecuteAfterSetupFileAccess(
+    std::unique_ptr<FileDefinitionList> file_definition_list) {
+  // Outlives the conversion process, since bound to the callback.
+  const FileDefinitionList& file_definition_list_ref =
+      *file_definition_list.get();
+  file_manager::util::ConvertFileDefinitionListToEntryDefinitionList(
+      profile_,
+      extension_->id(),
+      file_definition_list_ref,
+      base::Bind(&FileBrowserHandlerExecutor::ExecuteFileActionsOnUIThread,
+                 weak_ptr_factory_.GetWeakPtr(),
+                 base::Passed(&file_definition_list)));
+}
+
+void FileBrowserHandlerExecutor::ExecuteDoneOnUIThread(bool success) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  if (!done_.is_null())
+    done_.Run(
+        success
+            ? extensions::api::file_manager_private::TASK_RESULT_MESSAGE_SENT
+            : extensions::api::file_manager_private::TASK_RESULT_FAILED);
+  delete this;
+}
+
+void FileBrowserHandlerExecutor::ExecuteFileActionsOnUIThread(
+    std::unique_ptr<FileDefinitionList> file_definition_list,
+    std::unique_ptr<EntryDefinitionList> entry_definition_list) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (file_definition_list->empty() || entry_definition_list->empty()) {
+    ExecuteDoneOnUIThread(false);
+    return;
+  }
+
+  int handler_pid = ExtractProcessFromExtensionId(profile_, extension_->id());
+  if (handler_pid <= 0 &&
+      !extensions::BackgroundInfo::HasLazyBackgroundPage(extension_.get())) {
+    ExecuteDoneOnUIThread(false);
+    return;
+  }
+
+  if (handler_pid > 0) {
+    SetupPermissionsAndDispatchEvent(std::move(file_definition_list),
+                                     std::move(entry_definition_list),
+                                     handler_pid, nullptr);
+  } else {
+    // We have to wake the handler background page before we proceed.
+    extensions::LazyBackgroundTaskQueue* queue =
+        extensions::LazyBackgroundTaskQueue::Get(profile_);
+    if (!queue->ShouldEnqueueTask(profile_, extension_.get())) {
+      ExecuteDoneOnUIThread(false);
+      return;
+    }
+    queue->AddPendingTask(
+        profile_, extension_->id(),
+        base::BindOnce(
+            &FileBrowserHandlerExecutor::SetupPermissionsAndDispatchEvent,
+            weak_ptr_factory_.GetWeakPtr(),
+            base::Passed(std::move(file_definition_list)),
+            base::Passed(std::move(entry_definition_list)), handler_pid));
+  }
+}
+
+void FileBrowserHandlerExecutor::SetupPermissionsAndDispatchEvent(
+    std::unique_ptr<FileDefinitionList> file_definition_list,
+    std::unique_ptr<EntryDefinitionList> entry_definition_list,
+    int handler_pid_in,
+    extensions::ExtensionHost* host) {
+  int handler_pid = host ? host->render_process_host()->GetID() :
+      handler_pid_in;
+
+  if (handler_pid <= 0) {
+    ExecuteDoneOnUIThread(false);
+    return;
+  }
+
+  extensions::EventRouter* router = extensions::EventRouter::Get(profile_);
+  if (!router) {
+    ExecuteDoneOnUIThread(false);
+    return;
+  }
+
+  SetupHandlerHostFileAccessPermissions(
+      file_definition_list.get(), extension_.get(), handler_pid);
+
+  std::unique_ptr<base::ListValue> event_args(new base::ListValue());
+  event_args->AppendString(action_id_);
+  auto details = std::make_unique<base::DictionaryValue>();
+  // Get file definitions. These will be replaced with Entry instances by
+  // dispatchEvent() method from event_binding.js.
+  auto file_entries = std::make_unique<base::ListValue>();
+
+  for (EntryDefinitionList::const_iterator iter =
+           entry_definition_list->begin();
+       iter != entry_definition_list->end();
+       ++iter) {
+    auto file_def = std::make_unique<base::DictionaryValue>();
+    file_def->SetString("fileSystemName", iter->file_system_name);
+    file_def->SetString("fileSystemRoot", iter->file_system_root_url);
+    file_def->SetString("fileFullPath",
+                        "/" + iter->full_path.AsUTF8Unsafe());
+    file_def->SetBoolean("fileIsDirectory", iter->is_directory);
+    file_entries->Append(std::move(file_def));
+  }
+
+  details->Set("entries", std::move(file_entries));
+  event_args->Append(std::move(details));
+  auto event = std::make_unique<extensions::Event>(
+      extensions::events::FILE_BROWSER_HANDLER_ON_EXECUTE,
+      "fileBrowserHandler.onExecute", std::move(event_args), profile_);
+  router->DispatchEventToExtension(extension_->id(), std::move(event));
+
+  ExecuteDoneOnUIThread(true);
+}
+
+void FileBrowserHandlerExecutor::SetupHandlerHostFileAccessPermissions(
+    FileDefinitionList* file_definition_list,
+    const Extension* extension,
+    int handler_pid) {
+  const FileBrowserHandler* action =
+      FindFileBrowserHandlerForActionId(extension_.get(), action_id_);
+  for (FileDefinitionList::const_iterator iter = file_definition_list->begin();
+       iter != file_definition_list->end();
+       ++iter) {
+    if (!action)
+      continue;
+    if (action->CanRead()) {
+      content::ChildProcessSecurityPolicy::GetInstance()->GrantReadFile(
+          handler_pid, iter->absolute_path);
+    }
+    if (action->CanWrite()) {
+      content::ChildProcessSecurityPolicy::GetInstance()->
+          GrantCreateReadWriteFile(handler_pid, iter->absolute_path);
+    }
+  }
+}
+
+// Returns true if |extension_id| and |action_id| indicate that the file
+// currently being handled should be opened with the browser. This function
+// is used to handle certain action IDs of the file manager.
+bool ShouldBeOpenedWithBrowser(const std::string& extension_id,
+                               const std::string& action_id) {
+  return (extension_id == kFileManagerAppId &&
+          (action_id == "view-pdf" ||
+           action_id == "view-swf" ||
+           action_id == "view-in-browser" ||
+           action_id == "open-hosted-generic" ||
+           action_id == "open-hosted-gdoc" ||
+           action_id == "open-hosted-gsheet" ||
+           action_id == "open-hosted-gslides"));
+}
+
+// Opens the files specified by |file_urls| with the browser for |profile|.
+// Returns true on success. It's a failure if no files are opened.
+bool OpenFilesWithBrowser(Profile* profile,
+                          const std::vector<FileSystemURL>& file_urls) {
+  int num_opened = 0;
+  for (size_t i = 0; i < file_urls.size(); ++i) {
+    const FileSystemURL& file_url = file_urls[i];
+    if (chromeos::FileSystemBackend::CanHandleURL(file_url)) {
+      num_opened += util::OpenFileWithBrowser(profile, file_url) ? 1 : 0;
+    }
+  }
+  return num_opened > 0;
+}
+
+}  // namespace
+
+bool ExecuteFileBrowserHandler(
+    Profile* profile,
+    const Extension* extension,
+    const std::string& action_id,
+    const std::vector<FileSystemURL>& file_urls,
+    const file_tasks::FileTaskFinishedCallback& done) {
+  // Forbid calling undeclared handlers.
+  if (!FindFileBrowserHandlerForActionId(extension, action_id))
+    return false;
+
+  // Some action IDs of the file manager's file browser handlers require the
+  // files to be directly opened with the browser.
+  if (ShouldBeOpenedWithBrowser(extension->id(), action_id)) {
+    const bool result = OpenFilesWithBrowser(profile, file_urls);
+    if (result && !done.is_null())
+      done.Run(extensions::api::file_manager_private::TASK_RESULT_OPENED);
+    return result;
+  }
+
+  // The executor object will be self deleted on completion.
+  (new FileBrowserHandlerExecutor(
+      profile, extension, action_id))->Execute(file_urls, done);
+  return true;
+}
+
+FileBrowserHandlerList FindFileBrowserHandlers(
+    Profile* profile,
+    const std::vector<GURL>& file_list) {
+  FileBrowserHandlerList common_handlers;
+  for (std::vector<GURL>::const_iterator it = file_list.begin();
+       it != file_list.end(); ++it) {
+    FileBrowserHandlerList handlers =
+        FindFileBrowserHandlersForURL(profile, *it);
+    // If there is nothing to do for one file, the intersection of handlers
+    // for all files will be empty at the end, so no need to check further.
+    if (handlers.empty())
+      return FileBrowserHandlerList();
+
+    // For the very first file, just copy all the elements.
+    if (it == file_list.begin()) {
+      common_handlers = handlers;
+    } else {
+      // For all additional files, find intersection between the accumulated and
+      // file specific set.
+      FileBrowserHandlerList intersection;
+      std::set<const FileBrowserHandler*> common_handler_set(
+          common_handlers.begin(), common_handlers.end());
+
+      for (FileBrowserHandlerList::const_iterator itr = handlers.begin();
+           itr != handlers.end(); ++itr) {
+        if (base::ContainsKey(common_handler_set, *itr))
+          intersection.push_back(*itr);
+      }
+
+      std::swap(common_handlers, intersection);
+      if (common_handlers.empty())
+        return FileBrowserHandlerList();
+    }
+  }
+
+  return common_handlers;
+}
+
+}  // namespace file_browser_handlers
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/file_browser_handlers.h b/chrome/browser/file_manager/file_browser_handlers.h
new file mode 100644
index 0000000000000..b6b7f1a014000
--- /dev/null
+++ b/chrome/browser/file_manager/file_browser_handlers.h
@@ -0,0 +1,55 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides utility functions for file browser handlers.
+// https://developer.chrome.com/extensions/fileBrowserHandler.html
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_FILE_BROWSER_HANDLERS_H_
+#define CHROME_BROWSER_FILE_MANAGER_FILE_BROWSER_HANDLERS_H_
+
+#include <string>
+#include <vector>
+
+#include "base/callback_forward.h"
+#include "chrome/browser/file_manager/file_tasks.h"
+
+class FileBrowserHandler;
+class GURL;
+class Profile;
+
+namespace extensions {
+class Extension;
+}
+
+namespace storage {
+class FileSystemURL;
+}
+
+namespace file_manager {
+namespace file_browser_handlers {
+
+// Tasks are stored as a vector in order of priorities.
+typedef std::vector<const FileBrowserHandler*> FileBrowserHandlerList;
+
+// Returns the list of file browser handlers that can open all files in
+// |file_list|.
+FileBrowserHandlerList FindFileBrowserHandlers(
+    Profile* profile,
+    const std::vector<GURL>& file_list);
+
+// Executes a file browser handler specified by |extension| of the given
+// action ID for |file_urls|. Returns false if undeclared handlers are
+// found. |done| is on completion. See also the comment at ExecuteFileTask()
+// for other parameters.
+bool ExecuteFileBrowserHandler(
+    Profile* profile,
+    const extensions::Extension* extension,
+    const std::string& action_id,
+    const std::vector<storage::FileSystemURL>& file_urls,
+    const file_tasks::FileTaskFinishedCallback& done);
+
+}  // namespace file_browser_handlers
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_FILE_BROWSER_HANDLERS_H_
diff --git a/chrome/browser/file_manager/file_manager_browsertest.cc b/chrome/browser/file_manager/file_manager_browsertest.cc
new file mode 100644
index 0000000000000..f2783e558c163
--- /dev/null
+++ b/chrome/browser/file_manager/file_manager_browsertest.cc
@@ -0,0 +1,711 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stddef.h>
+
+#include "base/macros.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/file_manager/file_manager_browsertest_base.h"
+#include "chrome/browser/chromeos/profiles/profile_helper.h"
+#include "chrome/browser/signin/identity_manager_factory.h"
+#include "chromeos/chromeos_switches.h"
+#include "components/session_manager/core/session_manager.h"
+#include "components/user_manager/user_manager.h"
+#include "services/identity/public/cpp/identity_manager.h"
+
+namespace file_manager {
+
+// TestCase: FilesAppBrowserTest parameters.
+struct TestCase {
+  explicit TestCase(const char* name) : test_case_name(name) {
+    CHECK(name) << "FATAL: no test case name";
+  }
+
+  TestCase& InGuestMode() {
+    guest_mode = IN_GUEST_MODE;
+    return *this;
+  }
+
+  TestCase& InIncognito() {
+    guest_mode = IN_INCOGNITO;
+    return *this;
+  }
+
+  TestCase& TabletMode() {
+    tablet_mode = true;
+    return *this;
+  }
+
+  TestCase& EnableDriveFs() {
+    enable_drivefs = true;
+    return *this;
+  }
+
+  // Show the startup browser. Some tests invoke the file picker dialog during
+  // the test. Requesting a file picker from a background page is forbidden by
+  // the apps platform, and it's a bug that these tests do so.
+  // FindRuntimeContext() in select_file_dialog_extension.cc will use the last
+  // active browser in this case, which requires a Browser to be present. See
+  // https://crbug.com/736930.
+  TestCase& WithBrowser() {
+    with_browser = true;
+    return *this;
+  }
+
+  static std::string GetFullTestCaseName(const TestCase& test) {
+    std::string name(test.test_case_name);
+
+    CHECK(!name.empty()) << "FATAL: no test case name.";
+
+    if (test.guest_mode == IN_GUEST_MODE)
+      name.append("_GuestMode");
+    else if (test.guest_mode == IN_INCOGNITO)
+      name.append("_Incognito");
+
+    if (test.tablet_mode)
+      name.append("_TabletMode");
+
+    if (test.enable_drivefs)
+      name.append("_DriveFs");
+
+    return name;
+  }
+
+  const char* test_case_name = nullptr;
+  GuestMode guest_mode = NOT_IN_GUEST_MODE;
+  bool trusted_events = false;
+  bool tablet_mode = false;
+  bool enable_drivefs = false;
+  bool with_browser = false;
+  bool needs_zip = false;
+};
+
+// EventCase: FilesAppBrowserTest with trusted JS Events.
+struct EventCase : public TestCase {
+  explicit EventCase(const char* name) : TestCase(name) {
+    trusted_events = true;
+  }
+};
+
+// ZipCase: FilesAppBrowserTest with zip/unzip support.
+struct ZipCase : public TestCase {
+  explicit ZipCase(const char* name) : TestCase(name) {
+    needs_zip = true;
+  }
+};
+
+// FilesApp browser test.
+class FilesAppBrowserTest : public FileManagerBrowserTestBase,
+                            public ::testing::WithParamInterface<TestCase> {
+ public:
+  FilesAppBrowserTest() = default;
+
+ protected:
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    FileManagerBrowserTestBase::SetUpCommandLine(command_line);
+
+    // Prevent Blink swallowing Tab key with its default handlers: forward
+    // the Tab key event to the Files.App JS page under test instead.
+    if (GetParam().trusted_events) {
+      command_line->AppendSwitchASCII("disable-blink-features",
+                                      "TrustedEventsDefaultAction");
+    }
+
+    // Default mode is clamshell: force Ash into tablet mode if requested.
+    if (GetParam().tablet_mode) {
+      command_line->AppendSwitchASCII("force-tablet-mode", "touch_view");
+    }
+  }
+
+  GuestMode GetGuestMode() const override { return GetParam().guest_mode; }
+
+  const char* GetTestCaseName() const override {
+    return GetParam().test_case_name;
+  }
+
+  std::string GetFullTestCaseName() const override {
+    return TestCase::GetFullTestCaseName(GetParam());
+  }
+
+  const char* GetTestExtensionManifestName() const override {
+    return "file_manager_test_manifest.json";
+  }
+
+  bool GetEnableDriveFs() const override { return GetParam().enable_drivefs; }
+
+  bool GetRequiresStartupBrowser() const override {
+    return GetParam().with_browser;
+  }
+
+  bool GetNeedsZipSupport() const override {
+    return GetParam().needs_zip;
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(FilesAppBrowserTest);
+};
+
+IN_PROC_BROWSER_TEST_P(FilesAppBrowserTest, Test) {
+  StartTest();
+}
+
+// INSTANTIATE_TEST_CASE_P expands to code that stringizes the arguments. Thus
+// macro parameters such as |prefix| and |test_class| won't be expanded by the
+// macro pre-processor. To work around this, indirect INSTANTIATE_TEST_CASE_P,
+// as WRAPPED_INSTANTIATE_TEST_CASE_P here, so the pre-processor expands macro
+// defines used to disable tests, MAYBE_prefix for example.
+#define WRAPPED_INSTANTIATE_TEST_CASE_P(prefix, test_class, generator) \
+  INSTANTIATE_TEST_CASE_P(prefix, test_class, generator, &PostTestCaseName)
+
+std::string PostTestCaseName(const ::testing::TestParamInfo<TestCase>& test) {
+  return TestCase::GetFullTestCaseName(test.param);
+}
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    FileDisplay, /* file_display.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("fileDisplayDownloads"),
+                      TestCase("fileDisplayDownloads").InGuestMode(),
+                      TestCase("fileDisplayDownloads").TabletMode(),
+                      TestCase("fileDisplayDrive"),
+                      TestCase("fileDisplayDrive").TabletMode(),
+                      TestCase("fileDisplayDrive").EnableDriveFs(),
+                      TestCase("fileDisplayMtp"),
+                      TestCase("fileDisplayUsb"),
+                      TestCase("fileSearch"),
+                      TestCase("fileSearchCaseInsensitive"),
+                      TestCase("fileSearchNotFound")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    OpenVideoFiles, /* open_video_files.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("videoOpenDownloads").InGuestMode(),
+                      TestCase("videoOpenDownloads"),
+                      TestCase("videoOpenDrive"),
+                      TestCase("videoOpenDrive").EnableDriveFs()));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    OpenAudioFiles, /* open_audio_files.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("audioOpenCloseDownloads"),
+                      TestCase("audioOpenCloseDownloads").InGuestMode(),
+                      TestCase("audioOpenCloseDrive"),
+                      TestCase("audioOpenDownloads").InGuestMode(),
+                      TestCase("audioOpenDownloads"),
+                      TestCase("audioOpenDrive"),
+                      TestCase("audioOpenDrive").EnableDriveFs(),
+                      TestCase("audioAutoAdvanceDrive"),
+                      TestCase("audioRepeatAllModeSingleFileDrive"),
+                      TestCase("audioNoRepeatModeSingleFileDrive"),
+                      TestCase("audioRepeatOneModeSingleFileDrive"),
+                      TestCase("audioRepeatAllModeMultipleFileDrive"),
+                      TestCase("audioNoRepeatModeMultipleFileDrive"),
+                      TestCase("audioRepeatOneModeMultipleFileDrive")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    OpenImageFiles, /* open_image_files.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("imageOpenDownloads").InGuestMode(),
+                      TestCase("imageOpenDownloads"),
+                      TestCase("imageOpenDrive"),
+                      TestCase("imageOpenDrive").EnableDriveFs(),
+                      TestCase("imageOpenGalleryOpenDownloads"),
+                      TestCase("imageOpenGalleryOpenDrive"),
+                      TestCase("imageOpenGalleryOpenDrive").EnableDriveFs()));
+
+// NaCl fails to compile zip plugin.pexe too often on ASAN, crbug.com/867738
+#if defined(ADDRESS_SANITIZER)
+#define MAYBE_ZipFiles DISABLED_ZipFiles
+#else
+#define MAYBE_ZipFiles ZipFiles
+#endif
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    MAYBE_ZipFiles, /* zip_files.js */
+    FilesAppBrowserTest,
+    ::testing::Values(ZipCase("zipFileOpenDownloads").InGuestMode(),
+                      ZipCase("zipFileOpenDownloads"),
+                      ZipCase("zipFileOpenDrive").EnableDriveFs(),
+                      ZipCase("zipFileOpenDrive"),
+                      ZipCase("zipFileOpenUsb"),
+                      ZipCase("zipCreateFileDownloads").InGuestMode(),
+                      ZipCase("zipCreateFileDownloads"),
+                      ZipCase("zipCreateFileDrive").EnableDriveFs(),
+                      ZipCase("zipCreateFileDrive"),
+                      ZipCase("zipCreateFileUsb")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    CreateNewFolder, /* create_new_folder.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("selectCreateFolderDownloads").InGuestMode(),
+                      TestCase("selectCreateFolderDownloads"),
+                      TestCase("createFolderDownloads").InGuestMode(),
+                      TestCase("createFolderDownloads"),
+                      TestCase("createFolderNestedDownloads"),
+                      TestCase("createFolderDrive"),
+                      TestCase("createFolderDrive").EnableDriveFs()));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    KeyboardOperations, /* keyboard_operations.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("keyboardDeleteDownloads").InGuestMode(),
+                      TestCase("keyboardDeleteDownloads"),
+                      TestCase("keyboardDeleteDrive"),
+                      TestCase("keyboardDeleteDrive").EnableDriveFs(),
+                      TestCase("keyboardDeleteFolderDownloads").InGuestMode(),
+                      TestCase("keyboardDeleteFolderDownloads"),
+                      TestCase("keyboardDeleteFolderDrive"),
+                      TestCase("keyboardDeleteFolderDrive").EnableDriveFs(),
+                      TestCase("keyboardCopyDownloads").InGuestMode(),
+                      TestCase("keyboardCopyDownloads"),
+                      TestCase("keyboardCopyDrive"),
+                      TestCase("keyboardCopyDrive").EnableDriveFs(),
+                      TestCase("renameFileDownloads").InGuestMode(),
+                      TestCase("renameFileDownloads"),
+                      TestCase("renameFileDrive"),
+                      TestCase("renameFileDrive").EnableDriveFs(),
+                      TestCase("renameNewFolderDownloads").InGuestMode(),
+                      TestCase("renameNewFolderDownloads"),
+                      TestCase("renameNewFolderDrive"),
+                      TestCase("renameNewFolderDrive").EnableDriveFs()));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    ContextMenu, /* context_menu.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("checkDeleteEnabledForReadWriteFile"),
+                      TestCase("checkDeleteDisabledForReadOnlyDocument"),
+                      TestCase("checkDeleteDisabledForReadOnlyFile"),
+                      TestCase("checkDeleteDisabledForReadOnlyFolder"),
+                      TestCase("checkRenameEnabledForReadWriteFile"),
+                      TestCase("checkRenameDisabledForReadOnlyDocument"),
+                      TestCase("checkRenameDisabledForReadOnlyFile"),
+                      TestCase("checkRenameDisabledForReadOnlyFolder"),
+                      TestCase("checkShareEnabledForReadWriteFile"),
+                      TestCase("checkShareEnabledForReadOnlyDocument"),
+                      TestCase("checkShareDisabledForStrictReadOnlyDocument"),
+                      TestCase("checkShareEnabledForReadOnlyFile"),
+                      TestCase("checkShareEnabledForReadOnlyFolder"),
+                      TestCase("checkCopyEnabledForReadWriteFile"),
+                      TestCase("checkCopyEnabledForReadOnlyDocument"),
+                      TestCase("checkCopyDisabledForStrictReadOnlyDocument"),
+                      TestCase("checkCopyEnabledForReadOnlyFile"),
+                      TestCase("checkCopyEnabledForReadOnlyFolder"),
+                      TestCase("checkCutEnabledForReadWriteFile"),
+                      TestCase("checkCutDisabledForReadOnlyDocument"),
+                      TestCase("checkCutDisabledForReadOnlyFile"),
+                      TestCase("checkCutDisabledForReadOnlyFolder"),
+                      TestCase("checkPasteIntoFolderEnabledForReadWriteFolder"),
+                      TestCase("checkPasteIntoFolderDisabledForReadOnlyFolder"),
+                      TestCase("checkContextMenusForInputElements"),
+                      TestCase("checkNewFolderEnabledInsideReadWriteFolder"),
+                      TestCase("checkNewFolderDisabledInsideReadOnlyFolder"),
+                      TestCase("checkPasteEnabledInsideReadWriteFolder"),
+                      TestCase("checkPasteDisabledInsideReadOnlyFolder"),
+                      TestCase("checkCopyEnabledForReadWriteFolderInTree"),
+                      TestCase("checkCopyEnabledForReadOnlyFolderInTree"),
+                      TestCase("checkCutEnabledForReadWriteFolderInTree"),
+                      TestCase("checkCutDisabledForReadOnlyFolderInTree"),
+                      TestCase("checkPasteEnabledForReadWriteFolderInTree"),
+                      TestCase("checkPasteDisabledForReadOnlyFolderInTree"),
+                      TestCase("checkContextMenuForTeamDriveRoot")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    Delete, /* delete.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("deleteMenuItemNoEntrySelected"),
+                      TestCase("deleteEntryWithToolbar").InGuestMode(),
+                      TestCase("deleteEntryWithToolbar")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    QuickView, /* quick_view.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("openQuickView"),
+                      TestCase("openQuickView").InGuestMode(),
+                      TestCase("openQuickView").TabletMode(),
+                      TestCase("openQuickViewDrive"),
+                      TestCase("openQuickViewDrive").EnableDriveFs(),
+                      TestCase("openQuickViewUsb"),
+                      TestCase("openQuickViewMtp"),
+                      TestCase("closeQuickView")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    DirectoryTreeContextMenu, /* directory_tree_context_menu.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("dirCopyWithContextMenu"),
+                      TestCase("dirCopyWithContextMenu").InGuestMode(),
+                      TestCase("dirCopyWithKeyboard"),
+                      TestCase("dirCopyWithKeyboard").InGuestMode(),
+                      TestCase("dirCopyWithoutChangingCurrent"),
+                      TestCase("dirCutWithContextMenu"),
+                      TestCase("dirCutWithContextMenu").InGuestMode(),
+                      TestCase("dirCutWithKeyboard"),
+                      TestCase("dirCutWithKeyboard").InGuestMode(),
+                      TestCase("dirPasteWithContextMenu"),
+                      TestCase("dirPasteWithContextMenu").InGuestMode(),
+                      TestCase("dirPasteWithoutChangingCurrent"),
+                      TestCase("dirRenameWithContextMenu"),
+                      TestCase("dirRenameWithContextMenu").InGuestMode(),
+                      TestCase("dirRenameWithKeyboard"),
+                      TestCase("dirRenameWithKeyboard").InGuestMode(),
+                      TestCase("dirRenameWithoutChangingCurrent"),
+                      TestCase("dirRenameToEmptyString"),
+                      TestCase("dirRenameToEmptyString").InGuestMode(),
+                      TestCase("dirRenameToExisting"),
+                      TestCase("dirRenameToExisting").InGuestMode(),
+                      TestCase("dirCreateWithContextMenu"),
+                      TestCase("dirCreateWithKeyboard"),
+                      TestCase("dirCreateWithoutChangingCurrent")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    DriveSpecific, /* drive_specific.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("driveOpenSidebarOffline"),
+                      TestCase("driveOpenSidebarSharedWithMe"),
+                      TestCase("driveAutoCompleteQuery"),
+                      TestCase("drivePinFileMobileNetwork"),
+                      TestCase("drivePinFileMobileNetwork").EnableDriveFs(),
+                      TestCase("driveClickFirstSearchResult"),
+                      TestCase("drivePressEnterToSearch"),
+                      TestCase("drivePressCtrlAFromSearch")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    Transfer, /* transfer.js */
+    FilesAppBrowserTest,
+    ::testing::Values(
+        TestCase("transferFromDriveToDownloads"),
+        TestCase("transferFromDriveToDownloads").EnableDriveFs(),
+        TestCase("transferFromDownloadsToDrive"),
+        TestCase("transferFromDownloadsToDrive").EnableDriveFs(),
+        TestCase("transferFromSharedToDownloads"),
+        TestCase("transferFromSharedToDrive"),
+        TestCase("transferFromOfflineToDownloads"),
+        TestCase("transferFromOfflineToDrive"),
+        TestCase("transferFromTeamDriveToDrive"),
+        TestCase("transferFromTeamDriveToDrive").EnableDriveFs(),
+        TestCase("transferFromDriveToTeamDrive"),
+        TestCase("transferFromDriveToTeamDrive").EnableDriveFs(),
+        TestCase("transferFromTeamDriveToDownloads"),
+        TestCase("transferFromTeamDriveToDownloads").EnableDriveFs(),
+        TestCase("transferHostedFileFromTeamDriveToDownloads"),
+        TestCase("transferHostedFileFromTeamDriveToDownloads").EnableDriveFs(),
+        TestCase("transferFromDownloadsToTeamDrive"),
+        TestCase("transferFromDownloadsToTeamDrive").EnableDriveFs(),
+        TestCase("transferBetweenTeamDrives"),
+        TestCase("transferBetweenTeamDrives").EnableDriveFs()));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    RestorePrefs, /* restore_prefs.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("restoreSortColumn").InGuestMode(),
+                      TestCase("restoreSortColumn"),
+                      TestCase("restoreCurrentView").InGuestMode(),
+                      TestCase("restoreCurrentView")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    RestoreGeometry, /* restore_geometry.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("restoreGeometry"),
+                      TestCase("restoreGeometry").InGuestMode(),
+                      TestCase("restoreGeometryMaximized")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    ShareAndManageDialog, /* share_and_manage_dialog.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("shareFileDrive"),
+                      TestCase("shareDirectoryDrive"),
+                      TestCase("manageHostedFileDrive"),
+                      TestCase("manageHostedFileDrive").EnableDriveFs(),
+                      TestCase("manageFileDrive"),
+                      TestCase("manageFileDrive").EnableDriveFs(),
+                      TestCase("manageDirectoryDrive"),
+                      TestCase("manageDirectoryDrive").EnableDriveFs()));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    SuggestAppDialog, /* suggest_app_dialog.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("suggestAppDialog")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    Traverse, /* traverse.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("traverseDownloads").InGuestMode(),
+                      TestCase("traverseDownloads"),
+                      TestCase("traverseDrive"),
+                      TestCase("traverseDrive").EnableDriveFs()));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    Tasks, /* tasks.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("executeDefaultTaskDownloads"),
+                      TestCase("executeDefaultTaskDownloads").InGuestMode(),
+                      TestCase("executeDefaultTaskDrive"),
+                      TestCase("executeDefaultTaskDrive").EnableDriveFs(),
+                      TestCase("defaultTaskDialogDownloads"),
+                      TestCase("defaultTaskDialogDownloads").InGuestMode(),
+                      TestCase("defaultTaskDialogDrive"),
+                      TestCase("defaultTaskDialogDrive").EnableDriveFs(),
+                      TestCase("genericTaskIsNotExecuted"),
+                      TestCase("genericTaskAndNonGenericTask")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    FolderShortcuts, /* folder_shortcuts.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("traverseFolderShortcuts"),
+                      TestCase("addRemoveFolderShortcuts")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    SortColumns, /* sort_columns.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("sortColumns"),
+                      TestCase("sortColumns").InGuestMode()));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    TabIndex, /* tab_index.js: tabindex tests require trusted JS Events. */
+    FilesAppBrowserTest,
+    ::testing::Values(
+        EventCase("tabindexSearchBoxFocus"),
+        EventCase("tabindexFocus"),
+        EventCase("tabindexFocusDownloads"),
+        EventCase("tabindexFocusDownloads").InGuestMode(),
+        EventCase("tabindexFocusDirectorySelected"),
+        EventCase("tabindexOpenDialogDrive").WithBrowser(),
+        EventCase("tabindexOpenDialogDrive").WithBrowser().EnableDriveFs(),
+        EventCase("tabindexOpenDialogDownloads").WithBrowser(),
+        EventCase("tabindexOpenDialogDownloads").WithBrowser().InGuestMode(),
+        EventCase("tabindexSaveFileDialogDrive").WithBrowser(),
+        EventCase("tabindexSaveFileDialogDrive").WithBrowser().EnableDriveFs(),
+        EventCase("tabindexSaveFileDialogDownloads").WithBrowser(),
+        EventCase("tabindexSaveFileDialogDownloads")
+            .WithBrowser()
+            .InGuestMode()));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    FileDialog, /* file_dialog.js */
+    FilesAppBrowserTest,
+    ::testing::Values(
+        TestCase("openFileDialogUnload").WithBrowser(),
+        TestCase("openFileDialogDownloads").WithBrowser(),
+        TestCase("openFileDialogDownloads").WithBrowser().InGuestMode(),
+        TestCase("openFileDialogDownloads").WithBrowser().InIncognito(),
+        TestCase("openFileDialogCancelDownloads").WithBrowser(),
+        TestCase("openFileDialogEscapeDownloads").WithBrowser(),
+        TestCase("openFileDialogDrive").WithBrowser(),
+        TestCase("openFileDialogDrive").WithBrowser().InIncognito(),
+        TestCase("openFileDialogDrive").WithBrowser().EnableDriveFs(),
+        TestCase("openFileDialogDrive")
+            .WithBrowser()
+            .InIncognito()
+            .EnableDriveFs(),
+        TestCase("openFileDialogCancelDrive").WithBrowser(),
+        TestCase("openFileDialogCancelDrive").WithBrowser().EnableDriveFs(),
+        TestCase("openFileDialogEscapeDrive").WithBrowser(),
+        TestCase("openFileDialogEscapeDrive").WithBrowser().EnableDriveFs()));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    CopyBetweenWindows, /* copy_between_windows.js */
+    FilesAppBrowserTest,
+    ::testing::Values(
+        TestCase("copyBetweenWindowsLocalToDrive"),
+        TestCase("copyBetweenWindowsLocalToDrive").EnableDriveFs(),
+        TestCase("copyBetweenWindowsLocalToUsb"),
+        TestCase("copyBetweenWindowsUsbToDrive"),
+        TestCase("copyBetweenWindowsUsbToDrive").EnableDriveFs(),
+        TestCase("copyBetweenWindowsDriveToLocal"),
+        TestCase("copyBetweenWindowsDriveToLocal").EnableDriveFs(),
+        TestCase("copyBetweenWindowsDriveToUsb"),
+        TestCase("copyBetweenWindowsDriveToUsb").EnableDriveFs(),
+        TestCase("copyBetweenWindowsUsbToLocal")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    GridView, /* grid_view.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("showGridViewDownloads"),
+                      TestCase("showGridViewDownloads").InGuestMode(),
+                      TestCase("showGridViewDrive"),
+                      TestCase("showGridViewDrive").EnableDriveFs()));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    Providers, /* providers.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("requestMount"),
+                      TestCase("requestMountMultipleMounts"),
+                      TestCase("requestMountSourceDevice"),
+                      TestCase("requestMountSourceFile")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    GearMenu, /* gear_menu.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("showHiddenFilesDownloads"),
+                      TestCase("showHiddenFilesDownloads").InGuestMode(),
+                      TestCase("showHiddenFilesDrive"),
+                      TestCase("showHiddenFilesDrive").EnableDriveFs(),
+                      TestCase("toogleGoogleDocsDrive"),
+                      TestCase("toogleGoogleDocsDrive").EnableDriveFs(),
+                      TestCase("showPasteIntoCurrentFolder"),
+                      TestCase("showSelectAllInCurrentFolder")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    Crostini, /* crostini.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("mountCrostiniContainer")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    MyFiles, /* my_files.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("showMyFiles"),
+                      TestCase("hideSearchButton"),
+                      TestCase("myFilesDisplaysAndOpensEntries"),
+                      TestCase("directoryTreeRefresh"),
+                      TestCase("myFilesUpdatesChildren")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    InstallLinuxPackageDialog, /* install_linux_package_dialog.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("installLinuxPackageDialog")));
+
+WRAPPED_INSTANTIATE_TEST_CASE_P(
+    LauncherSearch, /* launcher_search.js */
+    FilesAppBrowserTest,
+    ::testing::Values(TestCase("launcherOpenSearchResult")));
+
+// Structure to describe an account info.
+struct TestAccountInfo {
+  const char* const gaia_id;
+  const char* const email;
+  const char* const hash;
+  const char* const display_name;
+};
+
+enum {
+  DUMMY_ACCOUNT_INDEX = 0,
+  PRIMARY_ACCOUNT_INDEX = 1,
+  SECONDARY_ACCOUNT_INDEX_START = 2,
+};
+
+static const TestAccountInfo kTestAccounts[] = {
+    {"gaia-id-d", "__dummy__@invalid.domain", "hashdummy", "Dummy Account"},
+    {"gaia-id-a", "alice@invalid.domain", "hashalice", "Alice"},
+    {"gaia-id-b", "bob@invalid.domain", "hashbob", "Bob"},
+    {"gaia-id-c", "charlie@invalid.domain", "hashcharlie", "Charlie"},
+};
+
+// Test fixture class for testing multi-profile features.
+class MultiProfileFilesAppBrowserTest : public FileManagerBrowserTestBase {
+ public:
+  MultiProfileFilesAppBrowserTest() = default;
+
+ protected:
+  // Enables multi-profiles.
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    FileManagerBrowserTestBase::SetUpCommandLine(command_line);
+    // Logs in to a dummy profile (For making MultiProfileWindowManager happy;
+    // browser test creates a default window and the manager tries to assign a
+    // user for it, and we need a profile connected to a user.)
+    command_line->AppendSwitchASCII(chromeos::switches::kLoginUser,
+                                    kTestAccounts[DUMMY_ACCOUNT_INDEX].email);
+    command_line->AppendSwitchASCII(chromeos::switches::kLoginProfile,
+                                    kTestAccounts[DUMMY_ACCOUNT_INDEX].hash);
+    // Don't require policy for our sessions - this is required because
+    // this test creates a secondary profile synchronously, so we need to
+    // let the policy code know not to expect cached policy.
+    command_line->AppendSwitchASCII(chromeos::switches::kProfileRequiresPolicy,
+                                    "false");
+  }
+
+  // Logs in to the primary profile of this test.
+  void SetUpOnMainThread() override {
+    const TestAccountInfo& info = kTestAccounts[PRIMARY_ACCOUNT_INDEX];
+
+    AddUser(info, true);
+    FileManagerBrowserTestBase::SetUpOnMainThread();
+  }
+
+  // Loads all users to the current session and sets up necessary fields.
+  // This is used for preparing all accounts in PRE_ test setup, and for testing
+  // actual login behavior.
+  void AddAllUsers() {
+    for (size_t i = 0; i < arraysize(kTestAccounts); ++i) {
+      // The primary account was already set up in SetUpOnMainThread, so skip it
+      // here.
+      if (i == PRIMARY_ACCOUNT_INDEX)
+        continue;
+      AddUser(kTestAccounts[i], i >= SECONDARY_ACCOUNT_INDEX_START);
+    }
+  }
+
+  // Returns primary profile (if it is already created.)
+  Profile* profile() override {
+    Profile* const profile =
+        chromeos::ProfileHelper::GetProfileByUserIdHashForTest(
+            kTestAccounts[PRIMARY_ACCOUNT_INDEX].hash);
+    return profile ? profile : FileManagerBrowserTestBase::profile();
+  }
+
+  // Adds a new user for testing to the current session.
+  void AddUser(const TestAccountInfo& info, bool log_in) {
+    base::ScopedAllowBlockingForTesting allow_blocking;
+    const AccountId account_id(
+        AccountId::FromUserEmailGaiaId(info.email, info.gaia_id));
+    if (log_in) {
+      session_manager::SessionManager::Get()->CreateSession(account_id,
+                                                            info.hash, false);
+    }
+    user_manager::UserManager::Get()->SaveUserDisplayName(
+        account_id, base::UTF8ToUTF16(info.display_name));
+    Profile* profile =
+        chromeos::ProfileHelper::GetProfileByUserIdHashForTest(info.hash);
+    // TODO(https://crbug.com/814307): We can't use
+    // identity::MakePrimaryAccountAvailable from identity_test_utils.h here
+    // because that DCHECKs that the SigninManager isn't authenticated yet.
+    // Here, it *can* be already authenticated if a PRE_ test previously set up
+    // the user.
+    IdentityManagerFactory::GetForProfile(profile)
+        ->SetPrimaryAccountSynchronouslyForTests(info.gaia_id, info.email,
+                                                 "refresh_token");
+  }
+
+  GuestMode GetGuestMode() const override { return NOT_IN_GUEST_MODE; }
+
+  const char* GetTestCaseName() const override {
+    return test_case_name_.c_str();
+  }
+
+  std::string GetFullTestCaseName() const override {
+    return test_case_name_;
+  }
+
+  const char* GetTestExtensionManifestName() const override {
+    return "file_manager_test_manifest.json";
+  }
+
+  void set_test_case_name(const std::string& name) { test_case_name_ = name; }
+
+ private:
+  std::string test_case_name_;
+
+  DISALLOW_COPY_AND_ASSIGN(MultiProfileFilesAppBrowserTest);
+};
+
+IN_PROC_BROWSER_TEST_F(MultiProfileFilesAppBrowserTest, PRE_BasicDownloads) {
+  AddAllUsers();
+}
+
+IN_PROC_BROWSER_TEST_F(MultiProfileFilesAppBrowserTest, BasicDownloads) {
+  AddAllUsers();
+  // Sanity check that normal operations work in multi-profile.
+  set_test_case_name("keyboardCopyDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(MultiProfileFilesAppBrowserTest, PRE_BasicDrive) {
+  AddAllUsers();
+}
+
+IN_PROC_BROWSER_TEST_F(MultiProfileFilesAppBrowserTest, BasicDrive) {
+  AddAllUsers();
+  // Sanity check that normal operations work in multi-profile.
+  set_test_case_name("keyboardCopyDrive");
+  StartTest();
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/file_manager_browsertest_base.cc b/chrome/browser/file_manager/file_manager_browsertest_base.cc
new file mode 100644
index 0000000000000..3c9432fcb8923
--- /dev/null
+++ b/chrome/browser/file_manager/file_manager_browsertest_base.cc
@@ -0,0 +1,1282 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/file_manager_browsertest_base.h"
+
+#include <stddef.h>
+
+#include <memory>
+#include <utility>
+
+#include "base/containers/circular_deque.h"
+#include "base/json/json_reader.h"
+#include "base/json/json_value_converter.h"
+#include "base/json/json_writer.h"
+#include "base/path_service.h"
+#include "base/run_loop.h"
+#include "base/strings/strcat.h"
+#include "base/strings/string_piece.h"
+#include "base/threading/thread_restrictions.h"
+#include "base/time/time.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/chromeos/crostini/crostini_manager.h"
+#include "chrome/browser/chromeos/crostini/crostini_pref_names.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/file_manager/file_manager_test_util.h"
+#include "chrome/browser/file_manager/mount_test_util.h"
+#include "chrome/browser/file_manager/path_util.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/browser/chromeos/profiles/profile_helper.h"
+#include "chrome/browser/notifications/notification_display_service_tester.h"
+#include "chrome/common/chrome_constants.h"
+#include "chrome/common/chrome_features.h"
+#include "chrome/common/chrome_paths.h"
+#include "chrome/common/chrome_switches.h"
+#include "chromeos/chromeos_features.h"
+#include "chromeos/chromeos_switches.h"
+#include "chromeos/components/drivefs/drivefs_host.h"
+#include "chromeos/components/drivefs/fake_drivefs.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
+#include "chromeos/dbus/fake_cros_disks_client.h"
+#include "components/drive/chromeos/file_system_interface.h"
+#include "components/drive/drive_pref_names.h"
+#include "components/drive/service/fake_drive_service.h"
+#include "components/prefs/pref_service.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/notification_service.h"
+#include "content/public/test/test_utils.h"
+#include "extensions/browser/api/test/test_api.h"
+#include "extensions/browser/notification_types.h"
+#include "google_apis/drive/drive_api_parser.h"
+#include "google_apis/drive/test_util.h"
+#include "media/base/media_switches.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+#include "storage/browser/fileapi/external_mount_points.h"
+#include "ui/message_center/public/cpp/notification.h"
+
+namespace file_manager {
+namespace {
+
+// During test, the test extensions can send a list of entries (directories
+// or files) to add to a target volume using an AddEntriesMessage command.
+//
+// During a files app browser test, the "addEntries" message (see onCommand()
+// below when name is "addEntries"). This adds them to the fake file system that
+// is being used for testing.
+//
+// Here, we define some useful types to help parse the JSON from the addEntries
+// format. The RegisterJSONConverter() method defines the expected types of each
+// field from the message and which member variables to save them in.
+//
+// The "addEntries" message contains a vector of TestEntryInfo, which contains
+// various nested subtypes:
+//
+//   * EntryType, which represents the type of entry (defined as an enum and
+//     converted from the JSON string representation in MapStringToEntryType)
+//
+//   * SharedOption, representing whether the file is shared and appears in the
+//     Shared with Me section of the app (similarly converted from the JSON
+//     string representation to an enum for storing in MapStringToSharedOption)
+//
+//   * EntryCapabilities, which represents the capabilities (permissions) for
+//     the new entry
+//
+//   * TestEntryInfo, which stores all of the above information, plus more
+//     metadata about the entry.
+//
+// AddEntriesMessage contains an array of TestEntryInfo (one for each entry to
+// add), plus the volume to add the entries to. It is constructed from JSON-
+// parseable format as described in RegisterJSONConverter.
+struct AddEntriesMessage {
+  // Utility types.
+  struct EntryCapabilities;
+  struct TestEntryInfo;
+
+  // Represents the various volumes available for adding entries.
+  enum TargetVolume { LOCAL_VOLUME, DRIVE_VOLUME, CROSTINI_VOLUME, USB_VOLUME };
+
+  // Represents the different types of entries (e.g. file, folder).
+  enum EntryType { FILE, DIRECTORY, TEAM_DRIVE };
+
+  // Represents whether an entry appears in 'Share with Me' or not.
+  enum SharedOption { NONE, SHARED };
+
+  // The actual AddEntriesMessage contents.
+
+  // The volume to add |entries| to.
+  TargetVolume volume;
+
+  // The |entries| to be added.
+  std::vector<std::unique_ptr<struct TestEntryInfo>> entries;
+
+  // Converts |value| to an AddEntriesMessage: true on success.
+  static bool ConvertJSONValue(const base::DictionaryValue& value,
+                               AddEntriesMessage* message) {
+    base::JSONValueConverter<AddEntriesMessage> converter;
+    return converter.Convert(value, message);
+  }
+
+  // Registers AddEntriesMessage member info to the |converter|.
+  static void RegisterJSONConverter(
+      base::JSONValueConverter<AddEntriesMessage>* converter) {
+    converter->RegisterCustomField("volume", &AddEntriesMessage::volume,
+                                   &MapStringToTargetVolume);
+    converter->RegisterRepeatedMessage<struct TestEntryInfo>(
+        "entries", &AddEntriesMessage::entries);
+  }
+
+  // Maps |value| to TargetVolume. Returns true on success.
+  static bool MapStringToTargetVolume(base::StringPiece value,
+                                      TargetVolume* volume) {
+    if (value == "local")
+      *volume = LOCAL_VOLUME;
+    else if (value == "drive")
+      *volume = DRIVE_VOLUME;
+    else if (value == "crostini")
+      *volume = CROSTINI_VOLUME;
+    else if (value == "usb")
+      *volume = USB_VOLUME;
+    else
+      return false;
+    return true;
+  }
+
+  // A message that specifies the capabilities (permissions) for the entry, in
+  // a dictionary in JSON-parseable format.
+  struct EntryCapabilities {
+    EntryCapabilities()
+        : can_copy(true),
+          can_delete(true),
+          can_rename(true),
+          can_add_children(true),
+          can_share(true) {}
+
+    EntryCapabilities(bool can_copy,
+                      bool can_delete,
+                      bool can_rename,
+                      bool can_add_children,
+                      bool can_share)
+        : can_copy(can_copy),
+          can_delete(can_delete),
+          can_rename(can_rename),
+          can_add_children(can_add_children),
+          can_share(can_share) {}
+
+    bool can_copy;    // Whether the user can copy this file or directory.
+    bool can_delete;  // Whether the user can delete this file or directory.
+    bool can_rename;  // Whether the user can rename this file or directory.
+    bool can_add_children;  // For directories, whether the user can add
+                            // children to this directory.
+    bool can_share;  // Whether the user can share this file or directory.
+
+    static void RegisterJSONConverter(
+        base::JSONValueConverter<EntryCapabilities>* converter) {
+      converter->RegisterBoolField("canCopy", &EntryCapabilities::can_copy);
+      converter->RegisterBoolField("canDelete", &EntryCapabilities::can_delete);
+      converter->RegisterBoolField("canRename", &EntryCapabilities::can_rename);
+      converter->RegisterBoolField("canAddChildren",
+                                   &EntryCapabilities::can_add_children);
+      converter->RegisterBoolField("canShare", &EntryCapabilities::can_share);
+    }
+  };
+
+  // A message that specifies the metadata (name, shared options, capabilities
+  // etc) for an entry, in a dictionary in JSON-parseable format.
+  // This object must match TestEntryInfo in
+  // ui/file_manager/integration_tests/test_util.js, which generates the message
+  // that contains this object.
+  struct TestEntryInfo {
+    TestEntryInfo() : type(FILE), shared_option(NONE) {}
+
+    TestEntryInfo(EntryType type,
+                  const std::string& source_file_name,
+                  const std::string& target_path,
+                  const std::string& mime_type,
+                  const std::string& team_drive_name,
+                  SharedOption shared_option,
+                  const base::Time& last_modified_time,
+                  const EntryCapabilities& capabilities)
+        : type(type),
+          shared_option(shared_option),
+          source_file_name(source_file_name),
+          target_path(target_path),
+          team_drive_name(team_drive_name),
+          mime_type(mime_type),
+          last_modified_time(last_modified_time),
+          capabilities(capabilities) {}
+
+    EntryType type;                  // Entry type: file or directory.
+    SharedOption shared_option;      // File entry sharing option.
+    std::string source_file_name;    // Source file name prototype.
+    std::string target_path;         // Target file or directory path.
+    std::string name_text;           // Display file name.
+    std::string team_drive_name;     // Name of team drive this entry is in.
+    std::string mime_type;           // File entry content mime type.
+    base::Time last_modified_time;   // Entry last modified time.
+    EntryCapabilities capabilities;  // Entry permissions.
+
+    // Registers the member information to the given converter.
+    static void RegisterJSONConverter(
+        base::JSONValueConverter<TestEntryInfo>* converter) {
+      converter->RegisterCustomField("type", &TestEntryInfo::type,
+                                     &MapStringToEntryType);
+      converter->RegisterStringField("sourceFileName",
+                                     &TestEntryInfo::source_file_name);
+      converter->RegisterStringField("targetPath", &TestEntryInfo::target_path);
+      converter->RegisterStringField("nameText", &TestEntryInfo::name_text);
+      converter->RegisterStringField("teamDriveName",
+                                     &TestEntryInfo::team_drive_name);
+      converter->RegisterStringField("mimeType", &TestEntryInfo::mime_type);
+      converter->RegisterCustomField("sharedOption",
+                                     &TestEntryInfo::shared_option,
+                                     &MapStringToSharedOption);
+      converter->RegisterCustomField("lastModifiedTime",
+                                     &TestEntryInfo::last_modified_time,
+                                     &MapStringToTime);
+      converter->RegisterNestedField("capabilities",
+                                     &TestEntryInfo::capabilities);
+    }
+
+    // Maps |value| to an EntryType. Returns true on success.
+    static bool MapStringToEntryType(base::StringPiece value, EntryType* type) {
+      if (value == "file")
+        *type = FILE;
+      else if (value == "directory")
+        *type = DIRECTORY;
+      else if (value == "team_drive")
+        *type = TEAM_DRIVE;
+      else
+        return false;
+      return true;
+    }
+
+    // Maps |value| to SharedOption. Returns true on success.
+    static bool MapStringToSharedOption(base::StringPiece value,
+                                        SharedOption* option) {
+      if (value == "shared")
+        *option = SHARED;
+      else if (value == "none")
+        *option = NONE;
+      else
+        return false;
+      return true;
+    }
+
+    // Maps |value| to base::Time. Returns true on success.
+    static bool MapStringToTime(base::StringPiece value, base::Time* time) {
+      return base::Time::FromString(value.as_string().c_str(), time);
+    }
+  };
+};
+
+// Listens for chrome.test messages: PASS, FAIL, and SendMessage.
+class FileManagerTestMessageListener : public content::NotificationObserver {
+ public:
+  struct Message {
+    int type;
+    std::string message;
+    scoped_refptr<extensions::TestSendMessageFunction> function;
+  };
+
+  FileManagerTestMessageListener() {
+    registrar_.Add(this, extensions::NOTIFICATION_EXTENSION_TEST_PASSED,
+                   content::NotificationService::AllSources());
+    registrar_.Add(this, extensions::NOTIFICATION_EXTENSION_TEST_FAILED,
+                   content::NotificationService::AllSources());
+    registrar_.Add(this, extensions::NOTIFICATION_EXTENSION_TEST_MESSAGE,
+                   content::NotificationService::AllSources());
+  }
+
+  Message GetNextMessage() {
+    DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+    if (messages_.empty()) {
+      base::RunLoop run_loop;
+      quit_closure_ = run_loop.QuitClosure();
+      run_loop.Run();
+    }
+
+    DCHECK(!messages_.empty());
+    const Message next = messages_.front();
+    messages_.pop_front();
+    return next;
+  }
+
+  void Observe(int type,
+               const content::NotificationSource& source,
+               const content::NotificationDetails& details) override {
+    DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+    Message message{type, std::string(), nullptr};
+    if (type == extensions::NOTIFICATION_EXTENSION_TEST_PASSED) {
+      test_complete_ = true;
+    } else if (type == extensions::NOTIFICATION_EXTENSION_TEST_FAILED) {
+      message.message = *content::Details<std::string>(details).ptr();
+      test_complete_ = true;
+    } else if (type == extensions::NOTIFICATION_EXTENSION_TEST_MESSAGE) {
+      message.message = *content::Details<std::string>(details).ptr();
+      using SendMessage = content::Source<extensions::TestSendMessageFunction>;
+      message.function = SendMessage(source).ptr();
+      using WillReply = content::Details<std::pair<std::string, bool*>>;
+      *WillReply(details).ptr()->second = true;  // crbug.com/668680
+      CHECK(!test_complete_) << "LATE MESSAGE: " << message.message;
+    }
+
+    messages_.push_back(message);
+    if (quit_closure_) {
+      std::move(quit_closure_).Run();
+    }
+  }
+
+ private:
+  bool test_complete_ = false;
+  base::OnceClosure quit_closure_;
+  base::circular_deque<Message> messages_;
+  content::NotificationRegistrar registrar_;
+
+  DISALLOW_COPY_AND_ASSIGN(FileManagerTestMessageListener);
+};
+
+// Test volume.
+class TestVolume {
+ protected:
+  explicit TestVolume(const std::string& name) : name_(name) {}
+  virtual ~TestVolume() = default;
+
+  bool CreateRootDirectory(const Profile* profile) {
+    if (root_initialized_)
+      return true;
+    root_initialized_ = root_.Set(profile->GetPath().Append(name_));
+    return root_initialized_;
+  }
+
+  const std::string& name() const { return name_; }
+  const base::FilePath& root_path() const { return root_.GetPath(); }
+
+  static base::FilePath GetTestDataFilePath(const std::string& file_name) {
+    // Get the path to file manager's test data directory.
+    base::FilePath source_dir;
+    CHECK(base::PathService::Get(base::DIR_SOURCE_ROOT, &source_dir));
+    auto test_data_dir = source_dir.AppendASCII("chrome")
+                             .AppendASCII("test")
+                             .AppendASCII("data")
+                             .AppendASCII("chromeos")
+                             .AppendASCII("file_manager");
+    // Return full test data path to the given |file_name|.
+    return test_data_dir.Append(base::FilePath::FromUTF8Unsafe(file_name));
+  }
+
+ private:
+  base::ScopedTempDir root_;
+  bool root_initialized_ = false;
+  std::string name_;
+
+  DISALLOW_COPY_AND_ASSIGN(TestVolume);
+};
+
+constexpr char kPredefinedProfileSalt[] = "salt";
+
+}  // anonymous namespace
+
+// LocalTestVolume: test volume for a local drive.
+class LocalTestVolume : public TestVolume {
+ public:
+  explicit LocalTestVolume(const std::string& name) : TestVolume(name) {}
+  ~LocalTestVolume() override = default;
+
+  // Adds this local volume. Returns true on success.
+  virtual bool Mount(Profile* profile) = 0;
+
+  void CreateEntry(const AddEntriesMessage::TestEntryInfo& entry) {
+    const base::FilePath target_path =
+        root_path().AppendASCII(entry.target_path);
+
+    entries_.insert(std::make_pair(target_path, entry));
+    switch (entry.type) {
+      case AddEntriesMessage::FILE: {
+        const base::FilePath source_path =
+            TestVolume::GetTestDataFilePath(entry.source_file_name);
+        ASSERT_TRUE(base::CopyFile(source_path, target_path))
+            << "Copy from " << source_path.value() << " to "
+            << target_path.value() << " failed.";
+        break;
+      }
+      case AddEntriesMessage::DIRECTORY:
+        ASSERT_TRUE(base::CreateDirectory(target_path))
+            << "Failed to create a directory: " << target_path.value();
+        break;
+      case AddEntriesMessage::TEAM_DRIVE:
+        NOTREACHED() << "Can't create a team drive in a local volume: "
+                     << target_path.value();
+        break;
+    }
+
+    ASSERT_TRUE(UpdateModifiedTime(entry));
+  }
+
+ private:
+  // Updates the ModifiedTime of the entry, and its parent directories if
+  // needed. Returns true on success.
+  bool UpdateModifiedTime(const AddEntriesMessage::TestEntryInfo& entry) {
+    const base::FilePath path = root_path().AppendASCII(entry.target_path);
+    if (!base::TouchFile(path, entry.last_modified_time,
+                         entry.last_modified_time)) {
+      return false;
+    }
+
+    // Update the modified time of parent directories because they may be
+    // also affected by the update of child items.
+    if (path.DirName() != root_path()) {
+      const auto& it = entries_.find(path.DirName());
+      if (it == entries_.end())
+        return false;
+      return UpdateModifiedTime(it->second);
+    }
+
+    return true;
+  }
+
+  std::map<base::FilePath, const AddEntriesMessage::TestEntryInfo> entries_;
+
+  DISALLOW_COPY_AND_ASSIGN(LocalTestVolume);
+};
+
+// DownloadsTestVolume: local test volume for the "Downloads" directory.
+class DownloadsTestVolume : public LocalTestVolume {
+ public:
+  DownloadsTestVolume() : LocalTestVolume("Downloads") {}
+  ~DownloadsTestVolume() override = default;
+
+  bool Mount(Profile* profile) override {
+    if (!CreateRootDirectory(profile))
+      return false;
+    auto* volume = VolumeManager::Get(profile);
+    return volume->RegisterDownloadsDirectoryForTesting(root_path());
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(DownloadsTestVolume);
+};
+
+// CrostiniTestVolume: local test volume for the "Linux files" directory.
+class CrostiniTestVolume : public LocalTestVolume {
+ public:
+  CrostiniTestVolume() : LocalTestVolume("Crostini") {}
+  ~CrostiniTestVolume() override = default;
+
+  // Create root dir so entries can be created, but volume is not mounted.
+  bool Initialize(Profile* profile) { return CreateRootDirectory(profile); }
+
+  bool Mount(Profile* profile) override {
+    return CreateRootDirectory(profile) &&
+           VolumeManager::Get(profile)->RegisterCrostiniDirectoryForTesting(
+               root_path());
+  }
+
+  const base::FilePath& mount_path() const { return root_path(); }
+
+  void Unmount(Profile* profile) {
+    VolumeManager::Get(profile)->RemoveSshfsCrostiniVolume(root_path());
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(CrostiniTestVolume);
+};
+
+// FakeTestVolume: local test volume with a given volume and device type.
+class FakeTestVolume : public LocalTestVolume {
+ public:
+  FakeTestVolume(const std::string& name,
+                 VolumeType volume_type,
+                 chromeos::DeviceType device_type)
+      : LocalTestVolume(name),
+        volume_type_(volume_type),
+        device_type_(device_type) {}
+  ~FakeTestVolume() override = default;
+
+  // Add the fake test volume entries.
+  bool PrepareTestEntries(Profile* profile) {
+    if (!CreateRootDirectory(profile))
+      return false;
+
+    // Note: must be kept in sync with BASIC_FAKE_ENTRY_SET defined in the
+    // integration_tests/file_manager JS code.
+    CreateEntry(AddEntriesMessage::TestEntryInfo(
+        AddEntriesMessage::FILE, "text.txt", "hello.txt", std::string(),
+        "text/plain", AddEntriesMessage::SharedOption::NONE, base::Time::Now(),
+        AddEntriesMessage::EntryCapabilities()));
+    CreateEntry(AddEntriesMessage::TestEntryInfo(
+        AddEntriesMessage::DIRECTORY, std::string(), "A", std::string(),
+        std::string(), AddEntriesMessage::SharedOption::NONE, base::Time::Now(),
+        AddEntriesMessage::EntryCapabilities()));
+    base::RunLoop().RunUntilIdle();
+    return true;
+  }
+
+  bool Mount(Profile* profile) override {
+    if (!CreateRootDirectory(profile))
+      return false;
+
+    // Revoke name() mount point first, then re-add its mount point.
+    GetMountPoints()->RevokeFileSystem(name());
+    const bool added = GetMountPoints()->RegisterFileSystem(
+        name(), storage::kFileSystemTypeNativeLocal,
+        storage::FileSystemMountOption(), root_path());
+    if (!added)
+      return false;
+
+    // Expose the mount point with the given volume and device type.
+    VolumeManager::Get(profile)->AddVolumeForTesting(root_path(), volume_type_,
+                                                     device_type_, read_only_);
+    base::RunLoop().RunUntilIdle();
+    return true;
+  }
+
+ private:
+  storage::ExternalMountPoints* GetMountPoints() {
+    return storage::ExternalMountPoints::GetSystemInstance();
+  }
+
+  const VolumeType volume_type_;
+  const chromeos::DeviceType device_type_;
+  const bool read_only_ = false;
+
+  DISALLOW_COPY_AND_ASSIGN(FakeTestVolume);
+};
+
+// DriveTestVolume: test volume for Google Drive.
+class DriveTestVolume : public TestVolume {
+ public:
+  DriveTestVolume() : TestVolume("drive") {}
+  ~DriveTestVolume() override = default;
+
+  virtual void CreateEntry(const AddEntriesMessage::TestEntryInfo& entry) {
+    const base::FilePath path =
+        base::FilePath::FromUTF8Unsafe(entry.target_path);
+    const std::string target_name = path.BaseName().AsUTF8Unsafe();
+
+    // Obtain the parent entry.
+    drive::FileError error = drive::FILE_ERROR_OK;
+    std::unique_ptr<drive::ResourceEntry> parent_entry(
+        new drive::ResourceEntry);
+
+    if (!entry.team_drive_name.empty()) {
+      integration_service_->file_system()->GetResourceEntry(
+          drive::util::GetDriveTeamDrivesRootPath()
+              .Append(entry.team_drive_name)
+              .Append(path)
+              .DirName(),
+          google_apis::test_util::CreateCopyResultCallback(&error,
+                                                           &parent_entry));
+    } else {
+      integration_service_->file_system()->GetResourceEntry(
+          drive::util::GetDriveMyDriveRootPath().Append(path).DirName(),
+          google_apis::test_util::CreateCopyResultCallback(&error,
+                                                           &parent_entry));
+    }
+    content::RunAllTasksUntilIdle();
+    ASSERT_EQ(drive::FILE_ERROR_OK, error);
+    ASSERT_TRUE(parent_entry);
+
+    // Create the capabilities object.
+    google_apis::FileResourceCapabilities file_capabilities;
+    file_capabilities.set_can_copy(entry.capabilities.can_copy);
+    file_capabilities.set_can_delete(entry.capabilities.can_delete);
+    file_capabilities.set_can_rename(entry.capabilities.can_rename);
+    file_capabilities.set_can_add_children(entry.capabilities.can_add_children);
+    file_capabilities.set_can_share(entry.capabilities.can_share);
+
+    google_apis::TeamDriveCapabilities team_drive_capabilities;
+    team_drive_capabilities.set_can_copy(entry.capabilities.can_copy);
+    team_drive_capabilities.set_can_delete_team_drive(
+        entry.capabilities.can_delete);
+    team_drive_capabilities.set_can_rename_team_drive(
+        entry.capabilities.can_rename);
+    team_drive_capabilities.set_can_add_children(
+        entry.capabilities.can_add_children);
+    team_drive_capabilities.set_can_share(entry.capabilities.can_share);
+
+    // Add the file or directory entry.
+    switch (entry.type) {
+      case AddEntriesMessage::FILE:
+        CreateFile(entry.source_file_name, parent_entry->resource_id(),
+                   target_name, entry.mime_type,
+                   entry.shared_option == AddEntriesMessage::SHARED,
+                   entry.last_modified_time, file_capabilities);
+        break;
+      case AddEntriesMessage::DIRECTORY:
+        CreateDirectory(parent_entry->resource_id(), target_name,
+                        entry.last_modified_time, file_capabilities);
+        break;
+      case AddEntriesMessage::TEAM_DRIVE:
+        CreateTeamDrive(entry.team_drive_name, team_drive_capabilities);
+        break;
+    }
+
+    // Any file or directory created above, will only appear in Drive after
+    // CheckForUpdates() has completed.
+    CheckForUpdates();
+    content::RunAllTasksUntilIdle();
+  }
+
+  // Creates a new Team Drive with ID |name| and name |name|, and sets the
+  // capabilities to |capabilities|.
+  void CreateTeamDrive(const std::string& name,
+                       google_apis::TeamDriveCapabilities capabilities) {
+    fake_drive_service_->AddTeamDrive(name, name);
+    fake_drive_service_->SetTeamDriveCapabilities(name, capabilities);
+  }
+
+  // Creates an empty directory with the given |name| and |modification_time|.
+  void CreateDirectory(
+      const std::string& parent_id,
+      const std::string& target_name,
+      const base::Time& modification_time,
+      const google_apis::FileResourceCapabilities& capabilities) {
+    google_apis::DriveApiErrorCode error = google_apis::DRIVE_OTHER_ERROR;
+
+    std::unique_ptr<google_apis::FileResource> entry;
+    fake_drive_service_->AddNewDirectory(
+        parent_id, target_name, drive::AddNewDirectoryOptions(),
+        google_apis::test_util::CreateCopyResultCallback(&error, &entry));
+    base::RunLoop().RunUntilIdle();
+    ASSERT_EQ(google_apis::HTTP_CREATED, error);
+    ASSERT_TRUE(entry);
+
+    fake_drive_service_->SetLastModifiedTime(
+        entry->file_id(), modification_time,
+        google_apis::test_util::CreateCopyResultCallback(&error, &entry));
+    base::RunLoop().RunUntilIdle();
+    ASSERT_TRUE(error == google_apis::HTTP_SUCCESS);
+    ASSERT_TRUE(entry);
+
+    fake_drive_service_->SetFileCapabilities(
+        entry->file_id(), capabilities,
+        google_apis::test_util::CreateCopyResultCallback(&error, &entry));
+    base::RunLoop().RunUntilIdle();
+    ASSERT_TRUE(error == google_apis::HTTP_SUCCESS);
+    ASSERT_TRUE(entry);
+  }
+
+  // Creates a test file with the given spec.
+  // Serves |test_file_name| file. Pass an empty string for an empty file.
+  void CreateFile(const std::string& source_file_name,
+                  const std::string& parent_id,
+                  const std::string& target_name,
+                  const std::string& mime_type,
+                  bool shared_with_me,
+                  const base::Time& modification_time,
+                  const google_apis::FileResourceCapabilities& capabilities) {
+    google_apis::DriveApiErrorCode error = google_apis::DRIVE_OTHER_ERROR;
+
+    std::string content_data;
+    if (!source_file_name.empty()) {
+      base::FilePath source_path =
+          TestVolume::GetTestDataFilePath(source_file_name);
+      ASSERT_TRUE(base::ReadFileToString(source_path, &content_data));
+    }
+
+    std::unique_ptr<google_apis::FileResource> entry;
+    fake_drive_service_->AddNewFile(
+        mime_type, content_data, parent_id, target_name, shared_with_me,
+        google_apis::test_util::CreateCopyResultCallback(&error, &entry));
+    base::RunLoop().RunUntilIdle();
+    ASSERT_EQ(google_apis::HTTP_CREATED, error);
+    ASSERT_TRUE(entry);
+
+    fake_drive_service_->SetLastModifiedTime(
+        entry->file_id(), modification_time,
+        google_apis::test_util::CreateCopyResultCallback(&error, &entry));
+    base::RunLoop().RunUntilIdle();
+    ASSERT_EQ(google_apis::HTTP_SUCCESS, error);
+    ASSERT_TRUE(entry);
+
+    fake_drive_service_->SetFileCapabilities(
+        entry->file_id(), capabilities,
+        google_apis::test_util::CreateCopyResultCallback(&error, &entry));
+    base::RunLoop().RunUntilIdle();
+    ASSERT_TRUE(error == google_apis::HTTP_SUCCESS);
+    ASSERT_TRUE(entry);
+  }
+
+  // Notifies FileSystem that the contents in FakeDriveService have changed,
+  // hence the new contents should be fetched.
+  void CheckForUpdates() {
+    if (integration_service_ && integration_service_->file_system()) {
+      integration_service_->file_system()->CheckForUpdates();
+    }
+  }
+
+  // Sets the url base for the test server to be used to generate share urls
+  // on the files and directories.
+  virtual void ConfigureShareUrlBase(const GURL& share_url_base) {
+    fake_drive_service_->set_share_url_base(share_url_base);
+  }
+
+  drive::DriveIntegrationService* CreateDriveIntegrationService(
+      Profile* profile) {
+    if (!CreateRootDirectory(profile))
+      return nullptr;
+
+    EXPECT_FALSE(profile_);
+    profile_ = profile;
+
+    EXPECT_FALSE(fake_drive_service_);
+    fake_drive_service_ = new drive::FakeDriveService;
+    fake_drive_service_->LoadAppListForDriveApi("drive/applist.json");
+
+    EXPECT_FALSE(integration_service_);
+    integration_service_ = new drive::DriveIntegrationService(
+        profile, nullptr, fake_drive_service_, std::string(), root_path(),
+        nullptr, CreateDriveFsConnectionDelegate());
+
+    return integration_service_;
+  }
+
+ private:
+  virtual base::RepeatingCallback<
+      std::unique_ptr<drivefs::DriveFsHost::MojoConnectionDelegate>()>
+  CreateDriveFsConnectionDelegate() {
+    return {};
+  }
+
+  // Profile associated with this volume: not owned.
+  Profile* profile_ = nullptr;
+  // Fake drive service used for testing: not owned.
+  drive::FakeDriveService* fake_drive_service_ = nullptr;
+  // Integration service used for testing: not owned.
+  drive::DriveIntegrationService* integration_service_ = nullptr;
+
+  DISALLOW_COPY_AND_ASSIGN(DriveTestVolume);
+};
+
+// DriveFsTestVolume: test volume for Google Drive using DriveFS.
+class DriveFsTestVolume : public DriveTestVolume {
+ public:
+  explicit DriveFsTestVolume(Profile* profile) : profile_(profile) {}
+  ~DriveFsTestVolume() override = default;
+
+  void CreateEntry(const AddEntriesMessage::TestEntryInfo& entry) override {
+    const base::FilePath target_path = GetTargetPathForTestEntry(entry);
+
+    entries_.insert(std::make_pair(target_path, entry));
+    switch (entry.type) {
+      case AddEntriesMessage::FILE: {
+        fake_drivefs_->SetMetadata(
+            GetRelativeDrivePathForTestEntry(entry), entry.mime_type,
+            base::FilePath(entry.target_path).BaseName().value());
+
+        if (entry.source_file_name.empty()) {
+          ASSERT_EQ(0, base::WriteFile(target_path, "", 0));
+          break;
+        }
+        const base::FilePath source_path =
+            TestVolume::GetTestDataFilePath(entry.source_file_name);
+        ASSERT_TRUE(base::CopyFile(source_path, target_path))
+            << "Copy from " << source_path.value() << " to "
+            << target_path.value() << " failed.";
+        break;
+      }
+      case AddEntriesMessage::DIRECTORY:
+        ASSERT_TRUE(base::CreateDirectory(target_path))
+            << "Failed to create a directory: " << target_path.value();
+        break;
+      case AddEntriesMessage::TEAM_DRIVE:
+        ASSERT_TRUE(base::CreateDirectory(target_path))
+            << "Failed to create a team drive: " << target_path.value();
+        break;
+    }
+
+    ASSERT_TRUE(UpdateModifiedTime(entry));
+  }
+
+  void ConfigureShareUrlBase(const GURL& share_url_base) override {}
+
+ private:
+  base::RepeatingCallback<
+      std::unique_ptr<drivefs::DriveFsHost::MojoConnectionDelegate>()>
+  CreateDriveFsConnectionDelegate() override {
+    CHECK(base::CreateDirectory(GetMyDrivePath()));
+    CHECK(base::CreateDirectory(GetTeamDriveGrandRoot()));
+
+    InitializeFakeDriveFs();
+    return base::BindRepeating(&drivefs::FakeDriveFs::CreateConnectionDelegate,
+                               base::Unretained(fake_drivefs_.get()));
+  }
+
+  void InitializeFakeDriveFs() {
+    fake_drivefs_ = std::make_unique<drivefs::FakeDriveFs>(root_path());
+    fake_drivefs_->RegisterMountingForAccountId(base::BindRepeating(
+        [](Profile* profile) {
+          auto* user =
+              chromeos::ProfileHelper::Get()->GetUserByProfile(profile);
+          if (!user)
+            return std::string();
+
+          return base::MD5String(
+              kPredefinedProfileSalt +
+              ("-" + user->GetAccountId().GetAccountIdKey()));
+        },
+        profile_));
+  }
+
+  // Updates the ModifiedTime of the entry, and its parent directories if
+  // needed. Returns true on success.
+  bool UpdateModifiedTime(const AddEntriesMessage::TestEntryInfo& entry) {
+    const auto path = GetTargetPathForTestEntry(entry);
+    if (!base::TouchFile(path, entry.last_modified_time,
+                         entry.last_modified_time)) {
+      return false;
+    }
+
+    // Update the modified time of parent directories because they may be
+    // also affected by the update of child items.
+    if (path.DirName() != GetTeamDriveGrandRoot() &&
+        path.DirName() != GetMyDrivePath()) {
+      const auto it = entries_.find(path.DirName());
+      if (it == entries_.end())
+        return false;
+      return UpdateModifiedTime(it->second);
+    }
+
+    return true;
+  }
+
+  base::FilePath GetTargetPathForTestEntry(
+      const AddEntriesMessage::TestEntryInfo& entry) {
+    const base::FilePath target_path =
+        entry.team_drive_name.empty()
+            ? GetMyDrivePath().Append(entry.target_path)
+            : GetTeamDrivePath(entry.team_drive_name).Append(entry.target_path);
+    if (entry.name_text != entry.target_path)
+      return target_path.DirName().Append(entry.name_text);
+    return target_path;
+  }
+
+  base::FilePath GetRelativeDrivePathForTestEntry(
+      const AddEntriesMessage::TestEntryInfo& entry) {
+    const base::FilePath target_path = GetTargetPathForTestEntry(entry);
+    base::FilePath drive_path("/");
+    CHECK(root_path().AppendRelativePath(target_path, &drive_path));
+    return drive_path;
+  }
+
+  base::FilePath GetMyDrivePath() { return root_path().Append("root"); }
+
+  base::FilePath GetTeamDriveGrandRoot() {
+    return root_path().Append("team_drives");
+  }
+
+  base::FilePath GetTeamDrivePath(const std::string& team_drive_name) {
+    return GetTeamDriveGrandRoot().Append(team_drive_name);
+  }
+
+  Profile* const profile_;
+  std::map<base::FilePath, const AddEntriesMessage::TestEntryInfo> entries_;
+  std::unique_ptr<drivefs::FakeDriveFs> fake_drivefs_;
+
+  DISALLOW_COPY_AND_ASSIGN(DriveFsTestVolume);
+};
+
+FileManagerBrowserTestBase::FileManagerBrowserTestBase() = default;
+
+FileManagerBrowserTestBase::~FileManagerBrowserTestBase() = default;
+
+void FileManagerBrowserTestBase::SetUp() {
+  net::NetworkChangeNotifier::SetTestNotificationsOnly(true);
+  extensions::ExtensionApiTest::SetUp();
+}
+
+void FileManagerBrowserTestBase::SetUpCommandLine(
+    base::CommandLine* command_line) {
+  // Use a fake audio stream crbug.com/835626
+  command_line->AppendSwitch(switches::kDisableAudioOutput);
+
+  if (!GetRequiresStartupBrowser()) {
+    // Don't sink time into showing an unused browser window.
+    // InProcessBrowserTest::browser() will be null.
+    command_line->AppendSwitch(switches::kNoStartupWindow);
+
+    // Without a browser window, opening an app window, then closing it will
+    // trigger browser shutdown. Usually this is fine, except it also prevents
+    // any _new_ app window being created, should a test want to do that.
+    // (At the time of writing, exactly one does).
+    // Although in this path no browser is created (and so one can never
+    // close..), setting this to false prevents InProcessBrowserTest from adding
+    // the kDisableZeroBrowsersOpenForTests flag, which would prevent
+    // chrome_browser_main_chromeos from adding the keepalive that normally
+    // stops chromeos from shutting down unexpectedly.
+    set_exit_when_last_browser_closes(false);
+  }
+
+  if (IsGuestModeTest()) {
+    command_line->AppendSwitch(chromeos::switches::kGuestSession);
+    command_line->AppendSwitchNative(chromeos::switches::kLoginUser, "$guest");
+    command_line->AppendSwitchASCII(chromeos::switches::kLoginProfile, "user");
+    command_line->AppendSwitch(switches::kIncognito);
+    set_chromeos_user_ = false;
+  }
+
+  if (IsIncognitoModeTest()) {
+    command_line->AppendSwitch(switches::kIncognito);
+  }
+
+  if (!IsZipTest()) {  // Block NaCl use unless needed crbug.com/788671
+    command_line->AppendSwitch(chromeos::switches::kDisableZipArchiverUnpacker);
+    command_line->AppendSwitch(chromeos::switches::kDisableZipArchiverPacker);
+  }
+
+  std::vector<base::Feature> enabled_features;
+  if (!IsGuestModeTest()) {
+    enabled_features.emplace_back(features::kCrostini);
+    enabled_features.emplace_back(features::kExperimentalCrostiniUI);
+  }
+  if (IsDriveFsTest()) {
+    enabled_features.emplace_back(chromeos::features::kDriveFs);
+  }
+  feature_list_.InitWithFeatures(enabled_features, {});
+
+  extensions::ExtensionApiTest::SetUpCommandLine(command_line);
+}
+
+bool FileManagerBrowserTestBase::SetUpUserDataDirectory() {
+  if (IsGuestModeTest())
+    return true;
+
+  auto known_users_list = std::make_unique<base::ListValue>();
+  auto user_dict = std::make_unique<base::DictionaryValue>();
+  user_dict->SetString("account_type", "google");
+  user_dict->SetString("email", "testuser@gmail.com");
+  user_dict->SetString("gaia_id", "123456");
+  known_users_list->Append(std::move(user_dict));
+
+  base::DictionaryValue local_state;
+  local_state.SetList("KnownUsers", std::move(known_users_list));
+
+  std::string local_state_json;
+  if (!base::JSONWriter::Write(local_state, &local_state_json))
+    return false;
+
+  base::FilePath local_state_file;
+  if (!base::PathService::Get(chrome::DIR_USER_DATA, &local_state_file))
+    return false;
+  local_state_file = local_state_file.Append(chrome::kLocalStateFilename);
+  return base::WriteFile(local_state_file, local_state_json.data(),
+                         local_state_json.size()) != -1;
+}
+
+void FileManagerBrowserTestBase::SetUpInProcessBrowserTestFixture() {
+  extensions::ExtensionApiTest::SetUpInProcessBrowserTestFixture();
+
+  local_volume_ = std::make_unique<DownloadsTestVolume>();
+
+  if (!IsGuestModeTest()) {
+    create_drive_integration_service_ =
+        base::Bind(&FileManagerBrowserTestBase::CreateDriveIntegrationService,
+                   base::Unretained(this));
+    service_factory_for_test_ = std::make_unique<
+        drive::DriveIntegrationServiceFactory::ScopedFactoryForTest>(
+        &create_drive_integration_service_);
+  }
+}
+
+void FileManagerBrowserTestBase::SetUpOnMainThread() {
+  extensions::ExtensionApiTest::SetUpOnMainThread();
+  CHECK(profile());
+  CHECK_EQ(!!browser(), GetRequiresStartupBrowser());
+
+  CHECK(local_volume_->Mount(profile()));
+
+  if (!IsGuestModeTest()) {
+    // Start the embedded test server to serve the mocked share dialog.
+    CHECK(embedded_test_server()->Start());
+    const GURL share_url_base(embedded_test_server()->GetURL(
+        "/chromeos/file_manager/share_dialog_mock/index.html"));
+    drive_volume_ = drive_volumes_[profile()->GetOriginalProfile()].get();
+    drive_volume_->ConfigureShareUrlBase(share_url_base);
+    test_util::WaitUntilDriveMountPointIsAdded(profile());
+
+    // Init crostini.  Set prefs to enable crostini and register
+    // CustomMountPointCallback. TODO(joelhockey): It would be better if the
+    // crostini interface allowed for testing without such tight coupling.
+    crostini_volume_ = std::make_unique<CrostiniTestVolume>();
+    profile()->GetPrefs()->SetBoolean(crostini::prefs::kCrostiniEnabled, true);
+    crostini::CrostiniManager::GetInstance()->set_skip_restart_for_testing();
+    chromeos::DBusThreadManager* dbus_thread_manager =
+        chromeos::DBusThreadManager::Get();
+    static_cast<chromeos::FakeCrosDisksClient*>(
+        dbus_thread_manager->GetCrosDisksClient())
+        ->AddCustomMountPointCallback(
+            base::BindRepeating(&FileManagerBrowserTestBase::MaybeMountCrostini,
+                                base::Unretained(this)));
+  }
+
+  display_service_ =
+      std::make_unique<NotificationDisplayServiceTester>(profile());
+
+  // The test resources are setup: enable and add default ChromeOS component
+  // extensions now and not before: crbug.com/831074, crbug.com/804413
+  test::AddDefaultComponentExtensionsOnMainThread(profile());
+}
+
+bool FileManagerBrowserTestBase::GetEnableDriveFs() const {
+  return false;
+}
+
+bool FileManagerBrowserTestBase::GetRequiresStartupBrowser() const {
+  return false;
+}
+
+bool FileManagerBrowserTestBase::GetNeedsZipSupport() const {
+  return false;
+}
+
+void FileManagerBrowserTestBase::StartTest() {
+  LOG(INFO) << "FileManagerBrowserTest::StartTest " << GetFullTestCaseName();
+  static const base::FilePath test_extension_dir =
+      base::FilePath(FILE_PATH_LITERAL("ui/file_manager/integration_tests"));
+  LaunchExtension(test_extension_dir, GetTestExtensionManifestName());
+  RunTestMessageLoop();
+}
+
+void FileManagerBrowserTestBase::LaunchExtension(const base::FilePath& path,
+                                                 const char* manifest_name) {
+  base::FilePath source_dir;
+  CHECK(base::PathService::Get(base::DIR_SOURCE_ROOT, &source_dir));
+
+  const base::FilePath source_path = source_dir.Append(path);
+  const extensions::Extension* const extension_launched =
+      LoadExtensionAsComponentWithManifest(source_path, manifest_name);
+  CHECK(extension_launched) << "Launching: " << manifest_name;
+}
+
+void FileManagerBrowserTestBase::RunTestMessageLoop() {
+  FileManagerTestMessageListener listener;
+
+  while (true) {
+    auto message = listener.GetNextMessage();
+
+    if (message.type == extensions::NOTIFICATION_EXTENSION_TEST_PASSED)
+      return;  // Test PASSED.
+    if (message.type == extensions::NOTIFICATION_EXTENSION_TEST_FAILED) {
+      ADD_FAILURE() << message.message;
+      return;  // Test FAILED.
+    }
+
+    // If the message in JSON format has no command, ignore it
+    // but note a reply is required: use std::string().
+    const auto json = base::JSONReader::Read(message.message);
+    const base::DictionaryValue* dictionary = nullptr;
+    std::string command;
+    if (!json || !json->GetAsDictionary(&dictionary) ||
+        !dictionary->GetString("name", &command)) {
+      message.function->Reply(std::string());
+      continue;
+    }
+
+    // Process the command, reply with the result.
+    std::string result;
+    OnCommand(command, *dictionary, &result);
+    if (!HasFatalFailure()) {
+      message.function->Reply(result);
+      continue;
+    }
+
+    // Test FAILED: while processing the command.
+    LOG(INFO) << "[FAILED] " << GetTestCaseName();
+    return;
+  }
+}
+
+void FileManagerBrowserTestBase::OnCommand(const std::string& name,
+                                           const base::DictionaryValue& value,
+                                           std::string* output) {
+  base::ScopedAllowBlockingForTesting allow_blocking;
+
+  if (name == "isInGuestMode") {
+    // Obtain if the test runs in guest or incognito mode, or not.
+    if (IsGuestModeTest() || IsIncognitoModeTest()) {
+      LOG(INFO) << GetTestCaseName() << " isInGuestMode: true";
+      *output = "true";
+    } else {
+      ASSERT_EQ(NOT_IN_GUEST_MODE, GetGuestMode());
+      *output = "false";
+    }
+
+    return;
+  }
+
+  if (name == "getRootPaths") {
+    // Obtain the root paths.
+    const auto downloads_root = util::GetDownloadsMountPointName(profile());
+
+    base::DictionaryValue dictionary;
+    dictionary.SetString("downloads", "/" + downloads_root);
+
+    if (!profile()->IsGuestSession()) {
+      auto* drive_integration_service =
+          drive::DriveIntegrationServiceFactory::GetForProfile(profile());
+      if (drive_integration_service->IsMounted()) {
+        const auto drive_mount_name =
+            base::FilePath(drive_integration_service->GetMountPointPath())
+                .BaseName();
+        dictionary.SetString(
+            "drive", base::StrCat({"/", drive_mount_name.value(), "/root"}));
+      }
+    }
+    base::JSONWriter::Write(dictionary, output);
+    return;
+  }
+
+  if (name == "getTestName") {
+    // Obtain the test case name.
+    *output = GetTestCaseName();
+    return;
+  }
+
+  if (name == "getCwsWidgetContainerMockUrl") {
+    // Obtain the mock CWS widget container URL and URL.origin.
+    const GURL url = embedded_test_server()->GetURL(
+        "/chromeos/file_manager/cws_container_mock/index.html");
+    std::string origin = url.GetOrigin().spec();
+    if (*origin.rbegin() == '/')  // Strip origin trailing '/'.
+      origin.resize(origin.length() - 1);
+
+    base::DictionaryValue dictionary;
+    dictionary.SetString("url", url.spec());
+    dictionary.SetString("origin", origin);
+
+    base::JSONWriter::Write(dictionary, output);
+    return;
+  }
+
+  if (name == "addEntries") {
+    // Add the message.entries to the message.volume.
+    AddEntriesMessage message;
+    ASSERT_TRUE(AddEntriesMessage::ConvertJSONValue(value, &message));
+
+    for (size_t i = 0; i < message.entries.size(); ++i) {
+      switch (message.volume) {
+        case AddEntriesMessage::LOCAL_VOLUME:
+          local_volume_->CreateEntry(*message.entries[i]);
+          break;
+        case AddEntriesMessage::CROSTINI_VOLUME:
+          CHECK(crostini_volume_);
+          ASSERT_TRUE(crostini_volume_->Initialize(profile()));
+          crostini_volume_->CreateEntry(*message.entries[i]);
+          break;
+        case AddEntriesMessage::DRIVE_VOLUME:
+          if (drive_volume_) {
+            drive_volume_->CreateEntry(*message.entries[i]);
+          } else if (!IsGuestModeTest()) {
+            LOG(FATAL) << "Add entry: but no Drive volume.";
+          }
+          break;
+        case AddEntriesMessage::USB_VOLUME:
+          if (usb_volume_) {
+            usb_volume_->CreateEntry(*message.entries[i]);
+          } else {
+            LOG(FATAL) << "Add entry: but no USB volume.";
+          }
+          break;
+      }
+    }
+
+    return;
+  }
+
+  if (name == "mountFakeUsb" || name == "mountFakeUsbEmpty") {
+    usb_volume_ = std::make_unique<FakeTestVolume>(
+        "fake-usb", VOLUME_TYPE_REMOVABLE_DISK_PARTITION,
+        chromeos::DEVICE_TYPE_USB);
+
+    if (name == "mountFakeUsb")
+      ASSERT_TRUE(usb_volume_->PrepareTestEntries(profile()));
+
+    ASSERT_TRUE(usb_volume_->Mount(profile()));
+    return;
+  }
+
+  if (name == "mountFakeMtp" || name == "mountFakeMtpEmpty") {
+    mtp_volume_ = std::make_unique<FakeTestVolume>(
+        "fake-mtp", VOLUME_TYPE_MTP, chromeos::DEVICE_TYPE_UNKNOWN);
+
+    if (name == "mountFakeMtp")
+      ASSERT_TRUE(mtp_volume_->PrepareTestEntries(profile()));
+
+    ASSERT_TRUE(mtp_volume_->Mount(profile()));
+    return;
+  }
+
+  if (name == "unmountCrostini") {
+    crostini_volume_->Unmount(profile());
+    return;
+  }
+
+  if (name == "useCellularNetwork") {
+    net::NetworkChangeNotifier::NotifyObserversOfMaxBandwidthChangeForTests(
+        net::NetworkChangeNotifier::GetMaxBandwidthMbpsForConnectionSubtype(
+            net::NetworkChangeNotifier::SUBTYPE_HSPA),
+        net::NetworkChangeNotifier::CONNECTION_3G);
+    return;
+  }
+
+  if (name == "clickNotificationButton") {
+    std::string extension_id;
+    std::string notification_id;
+    ASSERT_TRUE(value.GetString("extensionId", &extension_id));
+    ASSERT_TRUE(value.GetString("notificationId", &notification_id));
+
+    const std::string delegate_id = extension_id + "-" + notification_id;
+    base::Optional<message_center::Notification> notification =
+        display_service_->GetNotification(delegate_id);
+    EXPECT_TRUE(notification);
+
+    int index;
+    ASSERT_TRUE(value.GetInteger("index", &index));
+    display_service_->SimulateClick(NotificationHandler::Type::EXTENSION,
+                                    delegate_id, index, base::nullopt);
+    return;
+  }
+
+  if (name == "launchProviderExtension") {
+    std::string manifest;
+    ASSERT_TRUE(value.GetString("manifest", &manifest));
+    LaunchExtension(base::FilePath(FILE_PATH_LITERAL(
+                        "ui/file_manager/integration_tests/testing_provider")),
+                    manifest.c_str());
+    return;
+  }
+
+  FAIL() << "Unknown test message: " << name;
+}
+
+drive::DriveIntegrationService*
+FileManagerBrowserTestBase::CreateDriveIntegrationService(Profile* profile) {
+  if (base::FeatureList::IsEnabled(chromeos::features::kDriveFs)) {
+    profile->GetPrefs()->SetString(drive::prefs::kDriveFsProfileSalt,
+                                   kPredefinedProfileSalt);
+    drive_volumes_[profile->GetOriginalProfile()] =
+        std::make_unique<DriveFsTestVolume>(profile->GetOriginalProfile());
+  } else {
+    drive_volumes_[profile->GetOriginalProfile()] =
+        std::make_unique<DriveTestVolume>();
+  }
+  return drive_volumes_[profile->GetOriginalProfile()]
+      ->CreateDriveIntegrationService(profile);
+}
+
+base::FilePath FileManagerBrowserTestBase::MaybeMountCrostini(
+    const std::string& source_path,
+    const std::vector<std::string>& mount_options) {
+  GURL source_url(source_path);
+  DCHECK(source_url.is_valid());
+  if (source_url.scheme() != "sshfs") {
+    return {};
+  }
+  CHECK(crostini_volume_->Mount(profile()));
+  return crostini_volume_->mount_path();
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/file_manager_browsertest_base.h b/chrome/browser/file_manager/file_manager_browsertest_base.h
new file mode 100644
index 0000000000000..080bca57d9005
--- /dev/null
+++ b/chrome/browser/file_manager/file_manager_browsertest_base.h
@@ -0,0 +1,116 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_FILE_MANAGER_BROWSERTEST_BASE_H_
+#define CHROME_BROWSER_FILE_MANAGER_FILE_MANAGER_BROWSERTEST_BASE_H_
+
+#include <map>
+#include <memory>
+#include <string>
+
+#include "base/test/scoped_feature_list.h"
+#include "base/values.h"
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/extensions/extension_apitest.h"
+#include "chrome/browser/profiles/profile.h"
+
+class NotificationDisplayServiceTester;
+
+namespace file_manager {
+
+enum GuestMode { NOT_IN_GUEST_MODE, IN_GUEST_MODE, IN_INCOGNITO };
+
+class DriveTestVolume;
+class FakeTestVolume;
+class LocalTestVolume;
+class CrostiniTestVolume;
+
+class FileManagerBrowserTestBase : public extensions::ExtensionApiTest {
+ protected:
+  FileManagerBrowserTestBase();
+  ~FileManagerBrowserTestBase() override;
+
+  // extensions::ExtensionApiTest:
+  void SetUp() override;
+  void SetUpCommandLine(base::CommandLine* command_line) override;
+  bool SetUpUserDataDirectory() override;
+  void SetUpInProcessBrowserTestFixture() override;
+  void SetUpOnMainThread() override;
+
+  // Overrides for each FileManagerBrowserTest test extension type.
+  virtual GuestMode GetGuestMode() const = 0;
+  virtual const char* GetTestCaseName() const = 0;
+  virtual std::string GetFullTestCaseName() const = 0;
+  virtual const char* GetTestExtensionManifestName() const = 0;
+  virtual bool GetEnableDriveFs() const;
+  virtual bool GetRequiresStartupBrowser() const;
+  virtual bool GetNeedsZipSupport() const;
+
+  // Launches the test extension from GetTestExtensionManifestName() and uses
+  // it to drive the testing the actual FileManager component extension under
+  // test by calling RunTestMessageLoop().
+  void StartTest();
+
+ private:
+  // Returns true if the test requires incognito mode.
+  bool IsIncognitoModeTest() const { return GetGuestMode() == IN_INCOGNITO; }
+
+  // Returns true if the test requires in guest mode.
+  bool IsGuestModeTest() const { return GetGuestMode() == IN_GUEST_MODE; }
+
+  // Returns true if the test requires DriveFS.
+  bool IsDriveFsTest() const { return GetEnableDriveFs(); }
+
+  // Returns true if the test requires zip/unzip support.
+  bool IsZipTest() const { return GetNeedsZipSupport(); }
+
+  // Launches the test extension with manifest |manifest_name|. The extension
+  // manifest_name file should reside in the specified |path| relative to the
+  // Chromium src directory.
+  void LaunchExtension(const base::FilePath& path, const char* manifest_name);
+
+  // Runs the test: awaits chrome.test messsage commands and chrome.test PASS
+  // or FAIL messsages to process. |OnCommand| is used to handle the commands
+  // sent from the test extension. Returns on test PASS or FAIL.
+  void RunTestMessageLoop();
+
+  // Process test extension command |name|, with arguments |value|. Write the
+  // results to |output|.
+  void OnCommand(const std::string& name,
+                 const base::DictionaryValue& value,
+                 std::string* output);
+
+  // Called during setup if needed, to create a drive integration service for
+  // the given |profile|. Caller owns the return result.
+  drive::DriveIntegrationService* CreateDriveIntegrationService(
+      Profile* profile);
+
+  // Called during tests if needed to mount a crostini volume, and return the
+  // mount path of the volume.
+  base::FilePath MaybeMountCrostini(
+      const std::string& source_path,
+      const std::vector<std::string>& mount_options);
+
+  base::test::ScopedFeatureList feature_list_;
+
+  std::unique_ptr<LocalTestVolume> local_volume_;
+  std::unique_ptr<CrostiniTestVolume> crostini_volume_;
+  std::map<Profile*, std::unique_ptr<DriveTestVolume>> drive_volumes_;
+  DriveTestVolume* drive_volume_ = nullptr;
+  std::unique_ptr<FakeTestVolume> usb_volume_;
+  std::unique_ptr<FakeTestVolume> mtp_volume_;
+
+  drive::DriveIntegrationServiceFactory::FactoryCallback
+      create_drive_integration_service_;
+  std::unique_ptr<drive::DriveIntegrationServiceFactory::ScopedFactoryForTest>
+      service_factory_for_test_;
+
+  std::unique_ptr<NotificationDisplayServiceTester> display_service_;
+
+  DISALLOW_COPY_AND_ASSIGN(FileManagerBrowserTestBase);
+};
+
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_FILE_MANAGER_BROWSERTEST_BASE_H_
diff --git a/chrome/browser/file_manager/file_manager_jstest.cc b/chrome/browser/file_manager/file_manager_jstest.cc
new file mode 100644
index 0000000000000..01ed81a3ee64a
--- /dev/null
+++ b/chrome/browser/file_manager/file_manager_jstest.cc
@@ -0,0 +1,220 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/file_manager_jstest_base.h"
+
+class FileManagerJsTest : public FileManagerJsTestBase {
+ protected:
+  FileManagerJsTest() : FileManagerJsTestBase(
+      base::FilePath(FILE_PATH_LITERAL("ui/file_manager/file_manager"))) {}
+};
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, ActionsSubmenuTest) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("foreground/js/ui/actions_submenu_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, ActionsModelTest) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("foreground/js/actions_model_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, NavigationListModelTest) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("foreground/js/navigation_list_model_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, FileOperationHandlerTest) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("background/js/file_operation_handler_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, ProgressCenterItemGroupTest) {
+  RunTest(base::FilePath(FILE_PATH_LITERAL(
+      "foreground/js/progress_center_item_group_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, DeviceHandlerTest) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("background/js/device_handler_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, FileOperationManagerTest) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("background/js/file_operation_manager_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, ImporterCommonTest) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("common/js/importer_common_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, ImportHistoryTest) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("background/js/import_history_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, VolumeManagerTest) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("background/js/volume_manager_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, DirectoryTreeTest) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("foreground/js/ui/directory_tree_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, FileTableTest) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("foreground/js/ui/file_table_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, MediaScannerTest) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("background/js/media_scanner_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, LRUCacheTest) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("common/js/lru_cache_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, MediaImportHandlerTest) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("background/js/media_import_handler_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, TaskQueueTest) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("background/js/task_queue_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, DuplicateFinderTest) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("background/js/duplicate_finder_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, ImportControllerTest) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("foreground/js/import_controller_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, AsyncUtilTest) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("common/js/async_util_unittest.html")));
+}
+
+// TODO(sashab): Re-enable when https://crbug.com/842880 is fixed.
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, DISABLED_MetricsTest) {
+  RunTest(base::FilePath(FILE_PATH_LITERAL("common/js/metrics_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, TaskController) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("foreground/js/task_controller_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, FileTasks) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("foreground/js/file_tasks_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, ThumbnailLoader) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("foreground/js/thumbnail_loader_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, MetadataCacheItem) {
+  RunTest(base::FilePath(FILE_PATH_LITERAL(
+      "foreground/js/metadata/metadata_cache_item_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, MetadataCacheSet) {
+  RunTest(base::FilePath(FILE_PATH_LITERAL(
+      "foreground/js/metadata/metadata_cache_set_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, MultiMetadataProvider) {
+  RunTest(base::FilePath(FILE_PATH_LITERAL(
+      "foreground/js/metadata/multi_metadata_provider_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, ListThumbnailLoader) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("foreground/js/list_thumbnail_loader_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, FileSystemMetadataProvider) {
+  RunTest(base::FilePath(FILE_PATH_LITERAL(
+      "foreground/js/metadata/file_system_metadata_provider_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, ExternalMetadataProvider) {
+  RunTest(base::FilePath(FILE_PATH_LITERAL(
+      "foreground/js/metadata/external_metadata_provider_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, ContentMetadataProvider) {
+  RunTest(base::FilePath(FILE_PATH_LITERAL(
+      "foreground/js/metadata/content_metadata_provider_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, MetadataModel) {
+  RunTest(base::FilePath(FILE_PATH_LITERAL(
+      "foreground/js/metadata/metadata_model_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, ThumbnailModel) {
+  RunTest(base::FilePath(FILE_PATH_LITERAL(
+      "foreground/js/metadata/thumbnail_model_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, ExifParser) {
+  RunTest(base::FilePath(FILE_PATH_LITERAL(
+      "foreground/js/metadata/exif_parser_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, ImageOrientation) {
+  RunTest(base::FilePath(FILE_PATH_LITERAL(
+      "foreground/js/metadata/image_orientation_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, ProvidersModel) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("foreground/js/providers_model_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, FilesTooltip) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("foreground/elements/files_tooltip_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, SpinnerController) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("foreground/js/spinner_controller_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, FileListModel) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("foreground/js/file_list_model_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, FileTapHandler) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("foreground/js/ui/file_tap_handler_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, FileListSelectionModelTest) {
+  RunTest(base::FilePath(FILE_PATH_LITERAL(
+      "foreground/js/ui/file_list_selection_model_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, FilesAppEntryTypes) {
+  RunTest(base::FilePath(
+      FILE_PATH_LITERAL("common/js/files_app_entry_types_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerJsTest, UtilTest) {
+  RunTest(base::FilePath(FILE_PATH_LITERAL("common/js/util_unittest.html")));
+}
diff --git a/chrome/browser/file_manager/file_manager_jstest_base.cc b/chrome/browser/file_manager/file_manager_jstest_base.cc
new file mode 100644
index 0000000000000..39b0ee177f3eb
--- /dev/null
+++ b/chrome/browser/file_manager/file_manager_jstest_base.cc
@@ -0,0 +1,48 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/file_manager_jstest_base.h"
+
+#include "base/path_service.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/tabs/tab_strip_model.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/test/browser_test_utils.h"
+#include "net/base/filename_util.h"
+
+FileManagerJsTestBase::FileManagerJsTestBase(const base::FilePath& base_path)
+    : base_path_(base_path) {}
+
+void FileManagerJsTestBase::RunTest(const base::FilePath& file) {
+  base::FilePath root_path;
+  ASSERT_TRUE(base::PathService::Get(base::DIR_SOURCE_ROOT, &root_path));
+  base::FilePath full_path = root_path.Append(base_path_).Append(file);
+  ASSERT_TRUE(base::PathExists(full_path)) << full_path.value();
+  RunTestImpl(net::FilePathToFileURL(full_path));
+}
+
+void FileManagerJsTestBase::RunGeneratedTest(const std::string& file) {
+  base::FilePath path;
+  ASSERT_TRUE(base::PathService::Get(base::DIR_EXE, &path));
+  path = path.AppendASCII("gen");
+
+  // Serve the generated html file from out/gen. It references files from
+  // DIR_SOURCE_ROOT, so serve from there as well. An alternative would be to
+  // copy the js files as a build step and serve file:// URLs, but the embedded
+  // test server gives better output for troubleshooting errors.
+  embedded_test_server()->ServeFilesFromDirectory(path.Append(base_path_));
+  embedded_test_server()->ServeFilesFromSourceDirectory(base::FilePath());
+
+  ASSERT_TRUE(embedded_test_server()->Start());
+  RunTestImpl(embedded_test_server()->GetURL(file));
+}
+
+void FileManagerJsTestBase::RunTestImpl(const GURL& url) {
+  ui_test_utils::NavigateToURL(browser(), url);
+  content::WebContents* const web_contents =
+      browser()->tab_strip_model()->GetActiveWebContents();
+  ASSERT_TRUE(web_contents);
+  EXPECT_TRUE(ExecuteWebUIResourceTest(web_contents, {}));
+}
diff --git a/chrome/browser/file_manager/file_manager_jstest_base.h b/chrome/browser/file_manager/file_manager_jstest_base.h
new file mode 100644
index 0000000000000..a8aa38a94662d
--- /dev/null
+++ b/chrome/browser/file_manager/file_manager_jstest_base.h
@@ -0,0 +1,28 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_FILE_MANAGER_JSTEST_BASE_H_
+#define CHROME_BROWSER_FILE_MANAGER_FILE_MANAGER_JSTEST_BASE_H_
+
+#include "base/files/file_path.h"
+#include "chrome/test/base/in_process_browser_test.h"
+
+class FileManagerJsTestBase : public InProcessBrowserTest {
+ protected:
+  explicit FileManagerJsTestBase(const base::FilePath& base_path);
+
+  // Runs all test functions in |file|, waiting for them to complete.
+  void RunTest(const base::FilePath& file);
+
+  // Same as RunTest, but starts the EmbeddedTestServer to serve a generated
+  // |file|, relative to DIR_EXE/gen/base_path.
+  void RunGeneratedTest(const std::string& file);
+
+ private:
+  void RunTestImpl(const GURL& url);
+
+  base::FilePath base_path_;
+};
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_FILE_MANAGER_JSTEST_BASE_H_
diff --git a/chrome/browser/file_manager/file_manager_test_util.cc b/chrome/browser/file_manager/file_manager_test_util.cc
new file mode 100644
index 0000000000000..3fd025af1f54d
--- /dev/null
+++ b/chrome/browser/file_manager/file_manager_test_util.cc
@@ -0,0 +1,38 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/file_manager_test_util.h"
+
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/chromeos/profiles/profile_helper.h"
+#include "chrome/browser/extensions/component_loader.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "extensions/browser/extension_system.h"
+
+namespace file_manager {
+namespace test {
+
+void AddDefaultComponentExtensionsOnMainThread(Profile* profile) {
+  CHECK(profile);
+
+  extensions::ComponentLoader::EnableBackgroundExtensionsForTesting();
+  extensions::ExtensionService* service =
+      extensions::ExtensionSystem::Get(profile)->extension_service();
+  service->component_loader()->AddDefaultComponentExtensions(false);
+
+  // The File Manager component extension should have been added for loading
+  // into the user profile, but not into the sign-in profile.
+  CHECK(extensions::ExtensionSystem::Get(profile)
+            ->extension_service()
+            ->component_loader()
+            ->Exists(kFileManagerAppId));
+  CHECK(!extensions::ExtensionSystem::Get(
+             chromeos::ProfileHelper::GetSigninProfile())
+             ->extension_service()
+             ->component_loader()
+             ->Exists(kFileManagerAppId));
+}
+
+}  // namespace test
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/file_manager_test_util.h b/chrome/browser/file_manager/file_manager_test_util.h
new file mode 100644
index 0000000000000..c2795d750f40c
--- /dev/null
+++ b/chrome/browser/file_manager/file_manager_test_util.h
@@ -0,0 +1,20 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_FILE_MANAGER_TEST_UTIL_H_
+#define CHROME_BROWSER_FILE_MANAGER_FILE_MANAGER_TEST_UTIL_H_
+
+class Profile;
+
+namespace file_manager {
+namespace test {
+
+// Load the default set of component extensions used on ChromeOS. This should be
+// done in an override of InProcessBrowserTest::SetUpOnMainThread().
+void AddDefaultComponentExtensionsOnMainThread(Profile* profile);
+
+}  // namespace test
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_FILE_MANAGER_TEST_UTIL_H_
diff --git a/chrome/browser/file_manager/file_manager_uitest.cc b/chrome/browser/file_manager/file_manager_uitest.cc
new file mode 100644
index 0000000000000..683f67ba1b74c
--- /dev/null
+++ b/chrome/browser/file_manager/file_manager_uitest.cc
@@ -0,0 +1,76 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/path_service.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/common/content_switches.h"
+#include "content/public/common/web_preferences.h"
+#include "content/public/test/browser_test_utils.h"
+#include "net/base/filename_util.h"
+
+namespace file_manager {
+
+// Test fixture class for FileManager UI.
+class FileManagerUITest : public InProcessBrowserTest {
+ public:
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    // --disable-web-security required to load resources from
+    // files and from chrome://resources/... urls.
+    command_line->AppendSwitch(switches::kDisableWebSecurity);
+  }
+
+  void RunTest(std::string test_scope) {
+    base::FilePath root_path;
+    ASSERT_TRUE(base::PathService::Get(base::DIR_MODULE, &root_path));
+
+    // Load test.html.
+    const GURL url = net::FilePathToFileURL(root_path.Append(
+        FILE_PATH_LITERAL("gen/ui/file_manager/file_manager/test.html")));
+    content::WebContents* const web_contents =
+        browser()->tab_strip_model()->GetActiveWebContents();
+
+    // Set prefs required for cut/paste.
+    auto web_prefs = web_contents->GetRenderViewHost()->GetWebkitPreferences();
+    web_prefs.dom_paste_enabled = true;
+    web_prefs.javascript_can_access_clipboard = true;
+    web_contents->GetRenderViewHost()->UpdateWebkitPreferences(web_prefs);
+
+    ASSERT_TRUE(web_contents);
+    ui_test_utils::NavigateToURL(browser(), url);
+
+    // Load and run specified test file.
+    content::DOMMessageQueue message_queue;
+    ExecuteScriptAsync(web_contents,
+                       base::StringPrintf("runTests(%s)", test_scope.c_str()));
+
+    // Wait for JS to call domAutomationController.send("SUCCESS").
+    std::string message;
+    do {
+      EXPECT_TRUE(message_queue.WaitForMessage(&message));
+    } while (message == "\"PENDING\"");
+
+    EXPECT_TRUE(message == "\"SUCCESS\"");
+  }
+};
+
+IN_PROC_BROWSER_TEST_F(FileManagerUITest, CheckSelect) {
+  RunTest("checkselect");
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerUITest, Crostini) {
+  RunTest("crostini");
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerUITest, QuickView) {
+  RunTest("quickview");
+}
+
+IN_PROC_BROWSER_TEST_F(FileManagerUITest, UMA) {
+  RunTest("uma");
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/file_tasks.cc b/chrome/browser/file_manager/file_tasks.cc
new file mode 100644
index 0000000000000..d022109551cf8
--- /dev/null
+++ b/chrome/browser/file_manager/file_tasks.cc
@@ -0,0 +1,688 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/file_tasks.h"
+
+#include <stddef.h>
+
+#include <map>
+
+#include "apps/launcher.h"
+#include "base/bind.h"
+#include "base/macros.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/strings/string_split.h"
+#include "base/strings/stringprintf.h"
+#include "chrome/browser/chromeos/crostini/crostini_util.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/chromeos/drive/file_task_executor.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/arc_file_tasks.h"
+#include "chrome/browser/file_manager/crostini_file_tasks.h"
+#include "chrome/browser/file_manager/file_browser_handlers.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/open_util.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/extensions/application_launch.h"
+#include "chrome/browser/ui/webui/extensions/extension_icon_source.h"
+#include "chrome/common/extensions/api/file_browser_handlers/file_browser_handler.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "chrome/common/extensions/extension_constants.h"
+#include "chrome/common/pref_names.h"
+#include "chromeos/chromeos_switches.h"
+#include "components/drive/drive_api_util.h"
+#include "components/drive/drive_app_registry.h"
+#include "components/prefs/pref_service.h"
+#include "components/prefs/scoped_user_pref_update.h"
+#include "extensions/browser/api/file_handlers/mime_util.h"
+#include "extensions/browser/entry_info.h"
+#include "extensions/browser/extension_host.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/extension_util.h"
+#include "extensions/common/constants.h"
+#include "extensions/common/extension_set.h"
+#include "storage/browser/fileapi/file_system_url.h"
+#include "third_party/blink/public/common/mime_util/mime_util.h"
+
+using extensions::Extension;
+using extensions::api::file_manager_private::Verb;
+using extensions::app_file_handler_util::FindFileHandlersForEntries;
+using storage::FileSystemURL;
+
+namespace file_manager {
+namespace file_tasks {
+
+namespace {
+
+// The values "file" and "app" are confusing, but cannot be changed easily as
+// these are used in default task IDs stored in preferences.
+const char kFileBrowserHandlerTaskType[] = "file";
+const char kFileHandlerTaskType[] = "app";
+const char kDriveAppTaskType[] = "drive";
+const char kArcAppTaskType[] = "arc";
+const char kCrostiniAppTaskType[] = "crostini";
+
+// Drive apps always use the action ID.
+const char kDriveAppActionID[] = "open-with";
+
+// Converts a TaskType to a string.
+std::string TaskTypeToString(TaskType task_type) {
+  switch (task_type) {
+    case TASK_TYPE_FILE_BROWSER_HANDLER:
+      return kFileBrowserHandlerTaskType;
+    case TASK_TYPE_FILE_HANDLER:
+      return kFileHandlerTaskType;
+    case TASK_TYPE_DRIVE_APP:
+      return kDriveAppTaskType;
+    case TASK_TYPE_ARC_APP:
+      return kArcAppTaskType;
+    case TASK_TYPE_CROSTINI_APP:
+      return kCrostiniAppTaskType;
+    case TASK_TYPE_UNKNOWN:
+    case NUM_TASK_TYPE:
+      break;
+  }
+  NOTREACHED();
+  return "";
+}
+
+// Converts a string to a TaskType. Returns TASK_TYPE_UNKNOWN on error.
+TaskType StringToTaskType(const std::string& str) {
+  if (str == kFileBrowserHandlerTaskType)
+    return TASK_TYPE_FILE_BROWSER_HANDLER;
+  if (str == kFileHandlerTaskType)
+    return TASK_TYPE_FILE_HANDLER;
+  if (str == kDriveAppTaskType)
+    return TASK_TYPE_DRIVE_APP;
+  if (str == kArcAppTaskType)
+    return TASK_TYPE_ARC_APP;
+  if (str == kCrostiniAppTaskType)
+    return TASK_TYPE_CROSTINI_APP;
+  return TASK_TYPE_UNKNOWN;
+}
+
+// Legacy Drive task extension prefix, used by CrackTaskID.
+const char kDriveTaskExtensionPrefix[] = "drive-app:";
+const size_t kDriveTaskExtensionPrefixLength =
+    arraysize(kDriveTaskExtensionPrefix) - 1;
+
+// Returns true if path_mime_set contains a Google document.
+bool ContainsGoogleDocument(const std::vector<extensions::EntryInfo>& entries) {
+  for (const auto& it : entries) {
+    if (drive::util::HasHostedDocumentExtension(it.path))
+      return true;
+  }
+  return false;
+}
+
+// Leaves tasks handled by the file manger itself as is and removes all others.
+void KeepOnlyFileManagerInternalTasks(std::vector<FullTaskDescriptor>* tasks) {
+  std::vector<FullTaskDescriptor> filtered;
+  for (size_t i = 0; i < tasks->size(); ++i) {
+    if ((*tasks)[i].task_descriptor().app_id == kFileManagerAppId)
+      filtered.push_back((*tasks)[i]);
+  }
+  tasks->swap(filtered);
+}
+
+// Returns true if the given task is a handler by built-in apps like the Files
+// app itself or QuickOffice etc. They are used as the initial default app.
+bool IsFallbackFileHandler(const file_tasks::TaskDescriptor& task) {
+  if (task.task_type != file_tasks::TASK_TYPE_FILE_BROWSER_HANDLER &&
+      task.task_type != file_tasks::TASK_TYPE_FILE_HANDLER)
+    return false;
+
+  const char* const kBuiltInApps[] = {
+      kFileManagerAppId,
+      kVideoPlayerAppId,
+      kGalleryAppId,
+      kTextEditorAppId,
+      kAudioPlayerAppId,
+      extension_misc::kQuickOfficeComponentExtensionId,
+      extension_misc::kQuickOfficeInternalExtensionId,
+      extension_misc::kQuickOfficeExtensionId};
+
+  for (size_t i = 0; i < arraysize(kBuiltInApps); ++i) {
+    if (task.app_id == kBuiltInApps[i])
+      return true;
+  }
+  return false;
+}
+
+// Gets the profile in which a file task owned by |extension| should be
+// launched - for example, it makes sure that a file task is not handled in OTR
+// profile for platform apps (outside a guest session).
+Profile* GetProfileForExtensionTask(Profile* profile,
+                                    const extensions::Extension& extension) {
+  // In guest profile, all available task handlers are in OTR profile.
+  if (profile->IsGuestSession()) {
+    DCHECK(profile->IsOffTheRecord());
+    return profile;
+  }
+
+  // Outside guest sessions, if the task is handled by a platform app, launch
+  // the handler in the original profile.
+  if (extension.is_platform_app())
+    return profile->GetOriginalProfile();
+  return profile;
+}
+
+void ExecuteByArcAfterMimeTypesCollected(
+    Profile* profile,
+    const TaskDescriptor& task,
+    const std::vector<FileSystemURL>& file_urls,
+    const FileTaskFinishedCallback& done,
+    extensions::app_file_handler_util::MimeTypeCollector* mime_collector,
+    std::unique_ptr<std::vector<std::string>> mime_types) {
+  ExecuteArcTask(profile, task, file_urls, *mime_types, done);
+}
+
+void PostProcessFoundTasks(
+    Profile* profile,
+    const std::vector<extensions::EntryInfo>& entries,
+    const FindTasksCallback& callback,
+    std::unique_ptr<std::vector<FullTaskDescriptor>> result_list) {
+  // Google documents can only be handled by internal handlers.
+  if (ContainsGoogleDocument(entries))
+    KeepOnlyFileManagerInternalTasks(result_list.get());
+  ChooseAndSetDefaultTask(*profile->GetPrefs(), entries, result_list.get());
+  callback.Run(std::move(result_list));
+}
+
+}  // namespace
+
+FullTaskDescriptor::FullTaskDescriptor(const TaskDescriptor& task_descriptor,
+                                       const std::string& task_title,
+                                       const Verb task_verb,
+                                       const GURL& icon_url,
+                                       bool is_default,
+                                       bool is_generic_file_handler)
+    : task_descriptor_(task_descriptor),
+      task_title_(task_title),
+      task_verb_(task_verb),
+      icon_url_(icon_url),
+      is_default_(is_default),
+      is_generic_file_handler_(is_generic_file_handler) {}
+
+FullTaskDescriptor::~FullTaskDescriptor() = default;
+
+FullTaskDescriptor::FullTaskDescriptor(const FullTaskDescriptor& other) =
+    default;
+
+void UpdateDefaultTask(PrefService* pref_service,
+                       const std::string& task_id,
+                       const std::set<std::string>& suffixes,
+                       const std::set<std::string>& mime_types) {
+  if (!pref_service)
+    return;
+
+  if (!mime_types.empty()) {
+    DictionaryPrefUpdate mime_type_pref(pref_service,
+                                        prefs::kDefaultTasksByMimeType);
+    for (std::set<std::string>::const_iterator iter = mime_types.begin();
+        iter != mime_types.end(); ++iter) {
+      mime_type_pref->SetWithoutPathExpansion(
+          *iter, std::make_unique<base::Value>(task_id));
+    }
+  }
+
+  if (!suffixes.empty()) {
+    DictionaryPrefUpdate mime_type_pref(pref_service,
+                                        prefs::kDefaultTasksBySuffix);
+    for (std::set<std::string>::const_iterator iter = suffixes.begin();
+        iter != suffixes.end(); ++iter) {
+      // Suffixes are case insensitive.
+      std::string lower_suffix = base::ToLowerASCII(*iter);
+      mime_type_pref->SetWithoutPathExpansion(
+          lower_suffix, std::make_unique<base::Value>(task_id));
+    }
+  }
+}
+
+std::string GetDefaultTaskIdFromPrefs(const PrefService& pref_service,
+                                      const std::string& mime_type,
+                                      const std::string& suffix) {
+  VLOG(1) << "Looking for default for MIME type: " << mime_type
+      << " and suffix: " << suffix;
+  std::string task_id;
+  if (!mime_type.empty()) {
+    const base::DictionaryValue* mime_task_prefs =
+        pref_service.GetDictionary(prefs::kDefaultTasksByMimeType);
+    DCHECK(mime_task_prefs);
+    LOG_IF(ERROR, !mime_task_prefs) << "Unable to open MIME type prefs";
+    if (mime_task_prefs &&
+        mime_task_prefs->GetStringWithoutPathExpansion(mime_type, &task_id)) {
+      VLOG(1) << "Found MIME default handler: " << task_id;
+      return task_id;
+    }
+  }
+
+  const base::DictionaryValue* suffix_task_prefs =
+      pref_service.GetDictionary(prefs::kDefaultTasksBySuffix);
+  DCHECK(suffix_task_prefs);
+  LOG_IF(ERROR, !suffix_task_prefs) << "Unable to open suffix prefs";
+  std::string lower_suffix = base::ToLowerASCII(suffix);
+  if (suffix_task_prefs)
+    suffix_task_prefs->GetStringWithoutPathExpansion(lower_suffix, &task_id);
+  VLOG_IF(1, !task_id.empty()) << "Found suffix default handler: " << task_id;
+  return task_id;
+}
+
+std::string MakeTaskID(const std::string& app_id,
+                       TaskType task_type,
+                       const std::string& action_id) {
+  return base::StringPrintf("%s|%s|%s",
+                            app_id.c_str(),
+                            TaskTypeToString(task_type).c_str(),
+                            action_id.c_str());
+}
+
+std::string TaskDescriptorToId(const TaskDescriptor& task_descriptor) {
+  return MakeTaskID(task_descriptor.app_id,
+                    task_descriptor.task_type,
+                    task_descriptor.action_id);
+}
+
+bool ParseTaskID(const std::string& task_id, TaskDescriptor* task) {
+  DCHECK(task);
+
+  std::vector<std::string> result = base::SplitString(
+      task_id, "|", base::KEEP_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
+
+  // Parse a legacy task ID that only contain two parts. Drive tasks are
+  // identified by a prefix "drive-app:" on the extension ID. The legacy task
+  // IDs can be stored in preferences.
+  if (result.size() == 2) {
+    if (base::StartsWith(result[0], kDriveTaskExtensionPrefix,
+                         base::CompareCase::SENSITIVE)) {
+      task->task_type = TASK_TYPE_DRIVE_APP;
+      task->app_id = result[0].substr(kDriveTaskExtensionPrefixLength);
+    } else {
+      task->task_type = TASK_TYPE_FILE_BROWSER_HANDLER;
+      task->app_id = result[0];
+    }
+
+    task->action_id = result[1];
+
+    return true;
+  }
+
+  if (result.size() != 3)
+    return false;
+
+  TaskType task_type = StringToTaskType(result[1]);
+  if (task_type == TASK_TYPE_UNKNOWN)
+    return false;
+
+  task->app_id = result[0];
+  task->task_type = task_type;
+  task->action_id = result[2];
+
+  return true;
+}
+
+bool ExecuteFileTask(Profile* profile,
+                     const GURL& source_url,
+                     const TaskDescriptor& task,
+                     const std::vector<FileSystemURL>& file_urls,
+                     const FileTaskFinishedCallback& done) {
+  UMA_HISTOGRAM_ENUMERATION("FileBrowser.ViewingTaskType", task.task_type,
+                            NUM_TASK_TYPE);
+
+  // ARC apps needs mime types for launching. Retrieve them first.
+  if (task.task_type == TASK_TYPE_ARC_APP) {
+    extensions::app_file_handler_util::MimeTypeCollector* mime_collector =
+        new extensions::app_file_handler_util::MimeTypeCollector(profile);
+    mime_collector->CollectForURLs(
+        file_urls,
+        base::Bind(&ExecuteByArcAfterMimeTypesCollected, profile, task,
+                   file_urls, done, base::Owned(mime_collector)));
+    return true;
+  }
+
+  if (task.task_type == TASK_TYPE_CROSTINI_APP) {
+    DCHECK_EQ(kCrostiniAppActionID, task.action_id);
+    ExecuteCrostiniTask(profile, task, file_urls, done);
+    return true;
+  }
+
+  // drive::FileTaskExecutor is responsible to handle drive tasks.
+  if (task.task_type == TASK_TYPE_DRIVE_APP) {
+    DCHECK_EQ(kDriveAppActionID, task.action_id);
+    drive::FileTaskExecutor* executor =
+        new drive::FileTaskExecutor(profile, task.app_id);
+    executor->Execute(file_urls, done);
+    return true;
+  }
+
+  // Get the extension.
+  const Extension* extension = extensions::ExtensionRegistry::Get(
+      profile)->enabled_extensions().GetByID(task.app_id);
+  if (!extension)
+    return false;
+
+  Profile* extension_task_profile =
+      GetProfileForExtensionTask(profile, *extension);
+
+  // Execute the task.
+  if (task.task_type == TASK_TYPE_FILE_BROWSER_HANDLER) {
+    return file_browser_handlers::ExecuteFileBrowserHandler(
+        extension_task_profile, extension, task.action_id, file_urls, done);
+  } else if (task.task_type == TASK_TYPE_FILE_HANDLER) {
+    std::vector<base::FilePath> paths;
+    for (size_t i = 0; i != file_urls.size(); ++i)
+      paths.push_back(file_urls[i].path());
+    apps::LaunchPlatformAppWithFileHandler(extension_task_profile, extension,
+                                           task.action_id, paths);
+    if (!done.is_null())
+      done.Run(extensions::api::file_manager_private::TASK_RESULT_MESSAGE_SENT);
+    return true;
+  }
+  NOTREACHED();
+  return false;
+}
+
+void FindDriveAppTasks(const drive::DriveAppRegistry& drive_app_registry,
+                       const std::vector<extensions::EntryInfo>& entries,
+                       std::vector<FullTaskDescriptor>* result_list) {
+  DCHECK(result_list);
+
+  bool is_first = true;
+  typedef std::map<std::string, drive::DriveAppInfo> DriveAppInfoMap;
+  DriveAppInfoMap drive_app_map;
+
+  for (std::vector<extensions::EntryInfo>::const_iterator it = entries.begin();
+       it != entries.end(); ++it) {
+    const base::FilePath& file_path = it->path;
+    const std::string& mime_type = it->mime_type;
+    // Return immediately if a file not on Drive is found, as Drive app tasks
+    // work only if all files are on Drive.
+    if (!drive::util::IsUnderDriveMountPoint(file_path))
+      return;
+
+    std::vector<drive::DriveAppInfo> app_info_list;
+    drive_app_registry.GetAppsForFile(file_path.Extension(),
+                                      mime_type,
+                                      &app_info_list);
+
+    if (is_first) {
+      // For the first file, we store all the info.
+      for (size_t j = 0; j < app_info_list.size(); ++j)
+        drive_app_map[app_info_list[j].app_id] = app_info_list[j];
+    } else {
+      // For remaining files, take the intersection with the current
+      // result, based on the app id.
+      std::set<std::string> app_id_set;
+      for (size_t j = 0; j < app_info_list.size(); ++j)
+        app_id_set.insert(app_info_list[j].app_id);
+      for (DriveAppInfoMap::iterator iter = drive_app_map.begin();
+           iter != drive_app_map.end();) {
+        if (app_id_set.count(iter->first) == 0) {
+          drive_app_map.erase(iter++);
+        } else {
+          ++iter;
+        }
+      }
+    }
+
+    is_first = false;
+  }
+
+  for (DriveAppInfoMap::const_iterator iter = drive_app_map.begin();
+       iter != drive_app_map.end(); ++iter) {
+    const drive::DriveAppInfo& app_info = iter->second;
+    TaskDescriptor descriptor(app_info.app_id,
+                              TASK_TYPE_DRIVE_APP,
+                              kDriveAppActionID);
+    GURL icon_url = drive::util::FindPreferredIcon(
+        app_info.app_icons,
+        drive::util::kPreferredIconSize);
+
+    result_list->push_back(FullTaskDescriptor(
+        descriptor, app_info.app_name, Verb::VERB_OPEN_WITH, icon_url,
+        false /* is_default */, false /* is_generic_file_handler */));
+  }
+}
+
+bool IsGoodMatchFileHandler(
+    const extensions::FileHandlerInfo& file_handler_info,
+    const std::vector<extensions::EntryInfo>& entries) {
+  if (file_handler_info.extensions.count("*") > 0 ||
+      file_handler_info.types.count("*") > 0 ||
+      file_handler_info.types.count("*/*") > 0)
+    return false;
+
+  // If text/* file handler matches with unsupported text mime type, we don't
+  // regard it as good match.
+  if (file_handler_info.types.count("text/*")) {
+    for (const auto& entry : entries) {
+      if (blink::IsUnsupportedTextMimeType(entry.mime_type))
+        return false;
+    }
+  }
+
+  // We consider it a good match if no directories are selected.
+  for (const auto& entry : entries) {
+    if (entry.is_directory)
+      return false;
+  }
+  return true;
+}
+
+void FindFileHandlerTasks(Profile* profile,
+                          const std::vector<extensions::EntryInfo>& entries,
+                          std::vector<FullTaskDescriptor>* result_list) {
+  DCHECK(!entries.empty());
+  DCHECK(result_list);
+
+  const extensions::ExtensionSet& enabled_extensions =
+      extensions::ExtensionRegistry::Get(profile)->enabled_extensions();
+
+  for (extensions::ExtensionSet::const_iterator iter =
+           enabled_extensions.begin();
+       iter != enabled_extensions.end();
+       ++iter) {
+    const Extension* extension = iter->get();
+
+    // Check that the extension can be launched via an event. This includes all
+    // platform apps plus whitelisted extensions.
+    if (!CanLaunchViaEvent(extension))
+      continue;
+
+    if (profile->IsOffTheRecord() &&
+        !extensions::util::IsIncognitoEnabled(extension->id(), profile))
+      continue;
+
+    typedef std::vector<const extensions::FileHandlerInfo*> FileHandlerList;
+    FileHandlerList file_handlers =
+        FindFileHandlersForEntries(*extension, entries);
+    if (file_handlers.empty())
+      continue;
+
+    // If the new ZIP unpacker is disabled, then hide its handlers, so we don't
+    // show both the legacy one and the new one in Files app for ZIP files.
+    if (extension->id() == extension_misc::kZIPUnpackerExtensionId &&
+        base::CommandLine::ForCurrentProcess()->HasSwitch(
+            chromeos::switches::kDisableNewZIPUnpacker)) {
+      continue;
+    }
+
+    // A map which has as key a handler verb, and as value a pair of the
+    // handler with which to open the given entries and a boolean marking
+    // if the handler is a good match.
+    std::map<std::string, std::pair<const extensions::FileHandlerInfo*, bool>>
+        handlers_for_entries;
+    // Show the first good matching handler of each verb supporting the given
+    // entries that corresponds to the app. If there doesn't exist such handler,
+    // show the first matching handler of the verb.
+    for (const extensions::FileHandlerInfo* handler : file_handlers) {
+      bool good_match = IsGoodMatchFileHandler(*handler, entries);
+      auto it = handlers_for_entries.find(handler->verb);
+      if (it == handlers_for_entries.end() ||
+          (!it->second.second /* existing handler not a good match */ &&
+           good_match)) {
+        handlers_for_entries[handler->verb] =
+            std::make_pair(handler, good_match);
+      }
+    }
+
+    for (const auto& entry : handlers_for_entries) {
+      const extensions::FileHandlerInfo* handler = entry.second.first;
+      std::string task_id = file_tasks::MakeTaskID(
+          extension->id(), file_tasks::TASK_TYPE_FILE_HANDLER, handler->id);
+
+      GURL best_icon = extensions::ExtensionIconSource::GetIconURL(
+          extension, drive::util::kPreferredIconSize,
+          ExtensionIconSet::MATCH_BIGGER,
+          false);  // grayscale
+
+      // If file handler doesn't match as good match, regards it as generic file
+      // handler.
+      const bool is_generic_file_handler =
+          !IsGoodMatchFileHandler(*handler, entries);
+      Verb verb;
+      if (handler->verb == extensions::file_handler_verbs::kAddTo) {
+        verb = Verb::VERB_ADD_TO;
+      } else if (handler->verb == extensions::file_handler_verbs::kPackWith) {
+        verb = Verb::VERB_PACK_WITH;
+      } else if (handler->verb == extensions::file_handler_verbs::kShareWith) {
+        verb = Verb::VERB_SHARE_WITH;
+      } else {
+        // Only kOpenWith is a valid remaining verb. Invalid verbs should fall
+        // back to it.
+        DCHECK(handler->verb == extensions::file_handler_verbs::kOpenWith);
+        verb = Verb::VERB_OPEN_WITH;
+      }
+
+      result_list->push_back(FullTaskDescriptor(
+          TaskDescriptor(extension->id(), file_tasks::TASK_TYPE_FILE_HANDLER,
+                         handler->id),
+          extension->name(), verb, best_icon, false /* is_default */,
+          is_generic_file_handler));
+    }
+  }
+}
+
+void FindFileBrowserHandlerTasks(
+    Profile* profile,
+    const std::vector<GURL>& file_urls,
+    std::vector<FullTaskDescriptor>* result_list) {
+  DCHECK(!file_urls.empty());
+  DCHECK(result_list);
+
+  file_browser_handlers::FileBrowserHandlerList common_tasks =
+      file_browser_handlers::FindFileBrowserHandlers(profile, file_urls);
+  if (common_tasks.empty())
+    return;
+
+  const extensions::ExtensionSet& enabled_extensions =
+      extensions::ExtensionRegistry::Get(profile)->enabled_extensions();
+  for (file_browser_handlers::FileBrowserHandlerList::const_iterator iter =
+           common_tasks.begin();
+       iter != common_tasks.end();
+       ++iter) {
+    const FileBrowserHandler* handler = *iter;
+    const std::string extension_id = handler->extension_id();
+    const Extension* extension = enabled_extensions.GetByID(extension_id);
+    DCHECK(extension);
+
+    // TODO(zelidrag): Figure out how to expose icon URL that task defined in
+    // manifest instead of the default extension icon.
+    const GURL icon_url = extensions::ExtensionIconSource::GetIconURL(
+        extension, extension_misc::EXTENSION_ICON_SMALL,
+        ExtensionIconSet::MATCH_BIGGER,
+        false);  // grayscale
+
+    result_list->push_back(FullTaskDescriptor(
+        TaskDescriptor(extension_id, file_tasks::TASK_TYPE_FILE_BROWSER_HANDLER,
+                       handler->id()),
+        handler->title(), Verb::VERB_NONE /* no verb for FileBrowserHandler */,
+        icon_url, false /* is_default */, false /* is_generic_file_handler */));
+  }
+}
+
+void FindExtensionAndAppTasks(
+    Profile* profile,
+    const std::vector<extensions::EntryInfo>& entries,
+    const std::vector<GURL>& file_urls,
+    const FindTasksCallback& callback,
+    std::unique_ptr<std::vector<FullTaskDescriptor>> result_list) {
+  std::vector<FullTaskDescriptor>* result_list_ptr = result_list.get();
+
+  // 3. Continues from FindAllTypesOfTasks. Find and append file handler tasks.
+  FindFileHandlerTasks(profile, entries, result_list_ptr);
+
+  // 4. Find and append file browser handler tasks. We know there aren't
+  // duplicates because "file_browser_handlers" and "file_handlers" shouldn't
+  // be used in the same manifest.json.
+  FindFileBrowserHandlerTasks(profile, file_urls, result_list_ptr);
+
+  // 5. Find and append Crostini tasks.
+  FindCrostiniTasks(profile, entries, result_list_ptr,
+                    // Done. Apply post-filtering and callback.
+                    base::BindOnce(PostProcessFoundTasks, profile, entries,
+                                   callback, std::move(result_list)));
+}
+
+void FindAllTypesOfTasks(Profile* profile,
+                         const drive::DriveAppRegistry* drive_app_registry,
+                         const std::vector<extensions::EntryInfo>& entries,
+                         const std::vector<GURL>& file_urls,
+                         const FindTasksCallback& callback) {
+  DCHECK(profile);
+  std::unique_ptr<std::vector<FullTaskDescriptor>> result_list(
+      new std::vector<FullTaskDescriptor>);
+
+  // 1. Find Drive app tasks, if the drive app registry is present.
+  if (drive_app_registry)
+    FindDriveAppTasks(*drive_app_registry, entries, result_list.get());
+
+  // 2. Find and append ARC handler tasks.
+  FindArcTasks(profile, entries, file_urls, std::move(result_list),
+               base::Bind(&FindExtensionAndAppTasks, profile, entries,
+                          file_urls, callback));
+}
+
+void ChooseAndSetDefaultTask(const PrefService& pref_service,
+                             const std::vector<extensions::EntryInfo>& entries,
+                             std::vector<FullTaskDescriptor>* tasks) {
+  // Collect the task IDs of default tasks from the preferences into a set.
+  std::set<std::string> default_task_ids;
+  for (std::vector<extensions::EntryInfo>::const_iterator it = entries.begin();
+       it != entries.end(); ++it) {
+    const base::FilePath& file_path = it->path;
+    const std::string& mime_type = it->mime_type;
+    std::string task_id = file_tasks::GetDefaultTaskIdFromPrefs(
+        pref_service, mime_type, file_path.Extension());
+    default_task_ids.insert(task_id);
+  }
+
+  // Go through all the tasks from the beginning and see if there is any
+  // default task. If found, pick and set it as default and return.
+  for (size_t i = 0; i < tasks->size(); ++i) {
+    FullTaskDescriptor* task = &tasks->at(i);
+    DCHECK(!task->is_default());
+    const std::string task_id = TaskDescriptorToId(task->task_descriptor());
+    if (base::ContainsKey(default_task_ids, task_id)) {
+      task->set_is_default(true);
+      return;
+    }
+  }
+
+  // No default tasks found. If there is any fallback file browser handler,
+  // make it as default task, so it's selected by default.
+  for (size_t i = 0; i < tasks->size(); ++i) {
+    FullTaskDescriptor* task = &tasks->at(i);
+    DCHECK(!task->is_default());
+    if (IsFallbackFileHandler(task->task_descriptor())) {
+      task->set_is_default(true);
+      return;
+    }
+  }
+}
+
+}  // namespace file_tasks
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/file_tasks.h b/chrome/browser/file_manager/file_tasks.h
new file mode 100644
index 0000000000000..4fb4531cd0b94
--- /dev/null
+++ b/chrome/browser/file_manager/file_tasks.h
@@ -0,0 +1,341 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides utility functions for "file tasks".
+//
+// WHAT ARE FILE TASKS?
+//
+// File tasks are representation of actions that can be performed over the
+// currently selected files from the Files app. A task can be either of:
+//
+// 1) Chrome extension or app, registered via "file_handlers" or
+// "file_browser_handlers" in manifest.json (ex. Text.app). This information
+// comes from FileBrowserHandler::GetHandlers()
+//
+// See also:
+// https://developer.chrome.com/extensions/manifest.html#file_handlers
+// https://developer.chrome.com/extensions/fileBrowserHandler.html
+//
+// 2) Built-in handlers provided from the Files app. The Files app provides
+// lots of file_browser_handlers, such as "play", "mount-archive".  These
+// built-in handlers are often handled in special manners inside the Files
+// app. This information also comes from FileBrowserHandler::GetHandlers().
+//
+// See also:
+// ui/file_manager/file_manager/manifest.json
+//
+// 3) Drive app, which is a hosted app (i.e. just web site), that can work
+// with Drive (ex. Pixlr Editor). This information comes from
+// drive::DriveAppRegistry.
+//
+// See also:
+// https://chrome.google.com/webstore/category/collection/drive_apps
+//
+// For example, if the user is now selecting a JPEG file, the Files app will
+// receive file tasks represented as a JSON object via
+// chrome.fileManagerPrivate.getFileTasks() API, which look like:
+//
+// [
+//   {
+//     "driveApp": true,
+//     "iconUrl": "<app_icon_url>",
+//     "isDefault": false,
+//     "taskId": "<drive_app_id>|drive|open-with",
+//     "title": "Drive App Name (ex. Pixlr Editor)"
+//   },
+//   {
+//     "driveApp": false,
+//     "iconUrl":
+//       "chrome://extension-icon/hhaomjibdihmijegdhdafkllkbggdgoj/16/1",
+//     "isDefault": true,
+//     "taskId": "hhaomjibdihmijegdhdafkllkbggdgoj|file|gallery",
+//     "title": "__MSG_OPEN_ACTION__"
+//   }
+// ]
+//
+// The first file task is a Drive app. The second file task is a built-in
+// handler from the Files app.
+//
+// WHAT ARE TASK IDS?
+//
+// You may have noticed that "taskId" fields in the above example look
+// awkward. Apparently "taskId" encodes three types of information delimited
+// by "|". This is a weird format for something called as an ID.
+//
+// 1) Why are the three types information encoded in this way?
+//
+// It's just a historical reason. The reason is that a simple string can be
+// easily stored in user's preferences. We should stop doing this, by storing
+// this information in chrome.storage instead. crbug.com/267359.
+//
+// 2) OK, then what are the three types of information encoded here?
+//
+// The task ID encodes the following structure:
+//
+//     <app-id>|<task-type>|<task-action-id>
+//
+// <app-id> is either of Chrome Extension/App ID or Drive App ID. For some
+// reason, Chrome Extension/App IDs and Drive App IDs look differently. As of
+// writing, the former looks like "hhaomjibdihmijegdhdafkllkbggdgoj"
+// (the Files app) and the latter looks like "419782477519" (Pixlr Editor).
+//
+// <task-type> is either of
+// - "file" - File browser handler - app/extension declaring
+//            "file_browser_handlers" in manifest.
+// - "app" - File handler - app declaring "file_handlers" in manifest.json.
+// - "drive" - Drive App
+// - "arc" - ARC App
+// - "crostini" - Crostini App
+//
+// <task-action-id> is an ID string used for identifying actions provided
+// from a single Chrome Extension/App. In other words, a single
+// Chrome/Extension can provide multiple file handlers hence each of them
+// needs to have a unique action ID. For Drive and Crostini apps,
+// <task-action-id> is always "open-with".
+//
+// HOW TASKS ARE EXECUTED?
+//
+// chrome.fileManagerPrivate.viewFiles() is used to open a file in a browser,
+// without any handler. Browser will take care of handling the file (ex. PDF).
+//
+// chrome.fileManagerPrivate.executeTasks() is used to open a file with a
+// handler (Chrome Extension/App or Drive App).
+//
+// Some built-in handlers such as "play" are handled internally in the Files
+// app. "mount-archive" is handled very differently. The task execution
+// business should be simplified: crbug.com/267313
+//
+// See also:
+// ui/file_manager/file_manager/foreground/js/file_tasks.js
+//
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_FILE_TASKS_H_
+#define CHROME_BROWSER_FILE_MANAGER_FILE_TASKS_H_
+
+#include <memory>
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/callback_forward.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "extensions/browser/api/file_handlers/app_file_handler_util.h"
+#include "url/gurl.h"
+
+class PrefService;
+class Profile;
+
+namespace drive {
+class DriveAppRegistry;
+}
+
+namespace extensions {
+struct EntryInfo;
+}
+
+namespace storage {
+class FileSystemURL;
+}
+
+namespace file_manager {
+namespace file_tasks {
+
+// Task types as explained in the comment above. Search for <task-type>.
+enum TaskType {
+  TASK_TYPE_UNKNOWN = 0,  // Used only for handling errors.
+  TASK_TYPE_FILE_BROWSER_HANDLER,
+  TASK_TYPE_FILE_HANDLER,
+  TASK_TYPE_DRIVE_APP,
+  TASK_TYPE_ARC_APP,
+  TASK_TYPE_CROSTINI_APP,
+  // The enum values must be kept in sync with FileManagerTaskType in
+  // tools/metrics/histograms/enums.xml. Since enums for histograms are
+  // append-only (for keeping the number consistent across versions), new values
+  // for this enum also has to be always appended at the end (i.e., here).
+  NUM_TASK_TYPE,
+};
+
+// Describes a task.
+// See the comment above for <app-id>, <task-type>, and <action-id>.
+struct TaskDescriptor {
+  TaskDescriptor(const std::string& in_app_id,
+                 TaskType in_task_type,
+                 const std::string& in_action_id)
+      : app_id(in_app_id),
+        task_type(in_task_type),
+        action_id(in_action_id) {
+  }
+  TaskDescriptor() = default;
+
+  std::string app_id;
+  TaskType task_type;
+  std::string action_id;
+};
+
+// Describes a task with extra information such as icon URL.
+class FullTaskDescriptor {
+ public:
+  FullTaskDescriptor(
+      const TaskDescriptor& task_descriptor,
+      const std::string& task_title,
+      const extensions::api::file_manager_private::Verb task_verb,
+      const GURL& icon_url,
+      bool is_default,
+      bool is_generic_file_handler);
+
+  ~FullTaskDescriptor();
+
+  FullTaskDescriptor(const FullTaskDescriptor& other);
+  const TaskDescriptor& task_descriptor() const { return task_descriptor_; }
+
+  // The title of the task.
+  const std::string& task_title() const { return task_title_; }
+  // The verb of the task.
+  extensions::api::file_manager_private::Verb task_verb() const {
+    return task_verb_;
+  }
+  // The icon URL for the task (ex. app icon)
+  const GURL& icon_url() const { return icon_url_; }
+
+  // True if this task is set as default.
+  bool is_default() const { return is_default_; }
+  void set_is_default(bool is_default) { is_default_ = is_default; }
+
+  // True if this task is from generic file handler. Generic file handler is a
+  // file handler which handles any type of files (e.g. extensions: ["*"],
+  // types: ["*/*"]). Partial wild card (e.g. types: ["image/*"]) is not
+  // generic file handler.
+  bool is_generic_file_handler() const { return is_generic_file_handler_; }
+  void set_is_generic_file_handler(bool is_generic_file_handler) {
+    is_generic_file_handler_ = is_generic_file_handler;
+  }
+
+ private:
+  TaskDescriptor task_descriptor_;
+  std::string task_title_;
+  extensions::api::file_manager_private::Verb task_verb_;
+  GURL icon_url_;
+  bool is_default_;
+  bool is_generic_file_handler_;
+};
+
+// Update the default file handler for the given sets of suffixes and MIME
+// types.
+void UpdateDefaultTask(PrefService* pref_service,
+                       const std::string& task_id,
+                       const std::set<std::string>& suffixes,
+                       const std::set<std::string>& mime_types);
+
+// Returns the task ID of the default task for the given |mime_type|/|suffix|
+// combination. If it finds a MIME type match, then it prefers that over a
+// suffix match. If it a default can't be found, then it returns the empty
+// string.
+std::string GetDefaultTaskIdFromPrefs(const PrefService& pref_service,
+                                      const std::string& mime_type,
+                                      const std::string& suffix);
+
+// Generates task id for the task specified by |app_id|, |task_type| and
+// |action_id|.
+//
+// |app_id| is either of Chrome Extension/App ID or Drive App ID.
+// |action_id| is a free-form string ID for the action.
+std::string MakeTaskID(const std::string& app_id,
+                       TaskType task_type,
+                       const std::string& action_id);
+
+// Converts |task_descriptor| to a task ID.
+std::string TaskDescriptorToId(const TaskDescriptor& task_descriptor);
+
+// Parses the task ID and extracts app ID, task type, and action ID into
+// |task|. On failure, returns false, and the contents of |task| are
+// undefined.
+//
+// See also the comment at the beginning of the file for details for how
+// "task_id" looks like.
+bool ParseTaskID(const std::string& task_id, TaskDescriptor* task);
+
+// The callback is used for ExecuteFileTask(). Will be called with true if
+// the file task execution is successful, or false if unsuccessful.
+typedef base::Callback<void(extensions::api::file_manager_private::TaskResult
+                                result)> FileTaskFinishedCallback;
+
+// Executes file handler task for each element of |file_urls|.
+// Returns |false| if the execution cannot be initiated. Otherwise returns
+// |true| and then eventually calls |done| when all the files have been handled.
+// |done| can be a null callback.
+//
+// Parameters:
+// profile    - The profile used for making this function call.
+// source_url - The source URL which originates this function call.
+// task       - See the comment at TaskDescriptor struct.
+// file_urls  - URLs of the target files.
+// done       - The callback which will be called on completion.
+//              The callback won't be called if the function returns
+//              false.
+bool ExecuteFileTask(Profile* profile,
+                     const GURL& source_url,
+                     const TaskDescriptor& task,
+                     const std::vector<storage::FileSystemURL>& file_urls,
+                     const FileTaskFinishedCallback& done);
+
+// Finds the Drive app tasks that can be used with the given |entries|
+// from |drive_app_registry|, and append them to the |result_list|.
+// Drive app tasks will be found only if all of the files are on Drive.
+void FindDriveAppTasks(const drive::DriveAppRegistry& drive_app_registry,
+                       const std::vector<extensions::EntryInfo>& entries,
+                       std::vector<FullTaskDescriptor>* result_list);
+
+// Returns true if a file handler matches with entries as good match.
+bool IsGoodMatchFileHandler(
+    const extensions::FileHandlerInfo& file_handler_info,
+    const std::vector<extensions::EntryInfo>& entries);
+
+// Finds the file handler tasks (apps declaring "file_handlers" in
+// manifest.json) that can be used with the given entries, appending them to
+// the |result_list|.
+void FindFileHandlerTasks(Profile* profile,
+                          const std::vector<extensions::EntryInfo>& entries,
+                          std::vector<FullTaskDescriptor>* result_list);
+
+// Finds the file browser handler tasks (app/extensions declaring
+// "file_browser_handlers" in manifest.json) that can be used with the
+// given files, appending them to the |result_list|.
+void FindFileBrowserHandlerTasks(
+    Profile* profile,
+    const std::vector<GURL>& file_urls,
+    std::vector<FullTaskDescriptor>* result_list);
+
+// Callback function type for FindAllTypesOfTasks.
+typedef base::Callback<void(
+    std::unique_ptr<std::vector<FullTaskDescriptor>> result)>
+    FindTasksCallback;
+
+// Finds all types (drive, file handlers, file browser handlers) of
+// tasks. See the comment at FindDriveAppTasks() about |result_list|.
+// Drive app tasks will be found only if all of the files are on Drive.
+// |drive_app_registry| can be NULL if the drive app registry is not
+// present.
+//
+// If |entries| contains a Google document, only the internal tasks of the
+// Files app (i.e., tasks having the app ID of the Files app) are listed.
+// This is to avoid dups between Drive app tasks and an internal handler that
+// the Files app provides, and to avoid listing normal file handler and file
+// browser handler tasks, which can handle only normal files.
+void FindAllTypesOfTasks(Profile* profile,
+                         const drive::DriveAppRegistry* drive_app_registry,
+                         const std::vector<extensions::EntryInfo>& entries,
+                         const std::vector<GURL>& file_urls,
+                         const FindTasksCallback& callback);
+
+// Chooses the default task in |tasks| and sets it as default, if the default
+// task is found (i.e. the default task may not exist in |tasks|). No tasks
+// should be set as default before calling this function.
+void ChooseAndSetDefaultTask(const PrefService& pref_service,
+                             const std::vector<extensions::EntryInfo>& entries,
+                             std::vector<FullTaskDescriptor>* tasks);
+
+}  // namespace file_tasks
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_FILE_TASKS_H_
diff --git a/chrome/browser/file_manager/file_tasks_browsertest.cc b/chrome/browser/file_manager/file_tasks_browsertest.cc
new file mode 100644
index 0000000000000..d8394aa4a9172
--- /dev/null
+++ b/chrome/browser/file_manager/file_tasks_browsertest.cc
@@ -0,0 +1,132 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/file_tasks.h"
+
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/file_manager_test_util.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "extensions/browser/entry_info.h"
+#include "net/base/mime_util.h"
+
+namespace file_manager {
+namespace file_tasks {
+
+class FileTasksBrowserTest : public InProcessBrowserTest {
+ public:
+  void SetUpOnMainThread() override {
+    test::AddDefaultComponentExtensionsOnMainThread(browser()->profile());
+  }
+};
+
+// Tests the default handlers for various file types in ChromeOS. This test
+// exists to ensure the default app that launches when you open a file in the
+// ChromeOS file manager does not change unexpectedly. Multiple default apps are
+// allowed to register a handler for the same file type. Without that, it is not
+// possible for an app to open that type even when given explicit direction via
+// the chrome.fileManagerPrivate.executeTask API. The current conflict
+// resolution mechanism is "sort by extension ID", which has the desired result.
+// If desires change, we'll need to update ChooseAndSetDefaultTask() with some
+// additional logic.
+IN_PROC_BROWSER_TEST_F(FileTasksBrowserTest, DefaultHandlerChangeDetector) {
+  constexpr struct {
+    const char* file_extension;
+    const char* app_id;
+    bool has_mime = true;
+  } kExpectations[] = {
+      // Images.
+      {"bmp", kGalleryAppId},
+      {"gif", kGalleryAppId},
+      {"ico", kGalleryAppId},
+      {"jpg", kGalleryAppId},
+      {"jpeg", kGalleryAppId},
+      {"png", kGalleryAppId},
+      {"webp", kGalleryAppId},
+
+      // Raw.
+      {"arw", kGalleryAppId, false},
+      {"cr2", kGalleryAppId, false},
+      {"dng", kGalleryAppId, false},
+      {"nef", kGalleryAppId, false},
+      {"nrw", kGalleryAppId, false},
+      {"orf", kGalleryAppId, false},
+      {"raf", kGalleryAppId, false},
+      {"rw2", kGalleryAppId, false},
+
+      // Video.
+      {"3gp", kVideoPlayerAppId, false},
+      {"avi", kVideoPlayerAppId, false},
+      {"m4v", kVideoPlayerAppId},
+      {"mkv", kVideoPlayerAppId, false},
+      {"mov", kVideoPlayerAppId, false},
+      {"mp4", kVideoPlayerAppId},
+      {"mpeg", kVideoPlayerAppId},
+      {"mpeg4", kVideoPlayerAppId, false},
+      {"mpg", kVideoPlayerAppId},
+      {"mpg4", kVideoPlayerAppId, false},
+      {"ogm", kVideoPlayerAppId},
+      {"ogv", kVideoPlayerAppId},
+      {"ogx", kVideoPlayerAppId, false},
+      {"webm", kVideoPlayerAppId},
+
+      // Audio.
+      {"amr", kAudioPlayerAppId, false},
+      {"flac", kAudioPlayerAppId},
+      {"m4a", kAudioPlayerAppId},
+      {"mp3", kAudioPlayerAppId},
+      {"oga", kAudioPlayerAppId},
+      {"ogg", kAudioPlayerAppId},
+      {"wav", kAudioPlayerAppId},
+  };
+
+  base::RunLoop run_loop;
+  int remaining = base::size(kExpectations);
+  auto callback = base::BindRepeating(
+      [](base::RepeatingClosure quit, int* remaining,
+         const char* file_extension, const char* expected_app_id,
+         std::unique_ptr<std::vector<FullTaskDescriptor>> result) {
+        ASSERT_TRUE(result) << file_extension;
+
+        // There can be multiple handlers. The one at index 0 will be picked by
+        // ChooseAndSetDefaultTask() since prefs should be empty in the test.
+        ASSERT_LE(1u, result->size()) << file_extension;
+
+        EXPECT_EQ(expected_app_id, result->at(0).task_descriptor().app_id)
+            << " for extension: " << file_extension;
+
+        // Verify expected behavior of ChooseAndSetDefaultTask().
+        EXPECT_TRUE(result->at(0).is_default()) << file_extension;
+        for (size_t i = 1; i < result->size(); ++i)
+          EXPECT_FALSE(result->at(i).is_default()) << file_extension;
+
+        if (--*remaining == 0)
+          quit.Run();
+      },
+      run_loop.QuitClosure(), &remaining);
+
+  const drive::DriveAppRegistry* const kDriveAppRegistry = nullptr;
+  const base::FilePath prefix = base::FilePath().AppendASCII("file");
+
+  for (const auto& test : kExpectations) {
+    base::FilePath path = prefix.AddExtension(test.file_extension);
+
+    // Fetching a mime type is part of the default app determination, but it
+    // doesn't need to succeed.
+    std::string mime_type;
+    EXPECT_EQ(test.has_mime, net::GetMimeTypeFromFile(path, &mime_type))
+        << test.file_extension;
+
+    std::vector<extensions::EntryInfo> entries = {{path, mime_type, false}};
+    std::vector<GURL> file_urls{GURL()};
+    FindAllTypesOfTasks(
+        browser()->profile(), kDriveAppRegistry, entries, file_urls,
+        base::BindRepeating(callback, test.file_extension, test.app_id));
+  }
+  run_loop.Run();
+  EXPECT_EQ(0, remaining);
+}
+
+}  // namespace file_tasks
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/file_tasks_unittest.cc b/chrome/browser/file_manager/file_tasks_unittest.cc
new file mode 100644
index 0000000000000..ab7ea04773f32
--- /dev/null
+++ b/chrome/browser/file_manager/file_tasks_unittest.cc
@@ -0,0 +1,1370 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/file_tasks.h"
+
+#include <algorithm>
+#include <set>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/command_line.h"
+#include "base/run_loop.h"
+#include "base/values.h"
+#include "chrome/browser/chromeos/crostini/crostini_test_helper.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/path_util.h"
+#include "chrome/browser/chromeos/login/users/scoped_test_user_manager.h"
+#include "chrome/browser/chromeos/settings/scoped_cros_settings_test_helper.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/extensions/test_extension_system.h"
+#include "chrome/common/pref_names.h"
+#include "chrome/test/base/testing_profile.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
+#include "chromeos/dbus/fake_concierge_client.h"
+#include "components/drive/drive_app_registry.h"
+#include "components/prefs/pref_registry_simple.h"
+#include "components/prefs/testing_pref_service.h"
+#include "content/public/test/test_browser_thread_bundle.h"
+#include "extensions/browser/entry_info.h"
+#include "extensions/browser/extension_prefs.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/common/constants.h"
+#include "extensions/common/extension_builder.h"
+#include "google_apis/drive/drive_api_parser.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "url/gurl.h"
+
+using extensions::api::file_manager_private::Verb;
+
+namespace file_manager {
+namespace file_tasks {
+namespace {
+
+// Registers the default task preferences. Used for testing
+// ChooseAndSetDefaultTask().
+void RegisterDefaultTaskPreferences(TestingPrefServiceSimple* pref_service) {
+  DCHECK(pref_service);
+
+  pref_service->registry()->RegisterDictionaryPref(
+      prefs::kDefaultTasksByMimeType);
+  pref_service->registry()->RegisterDictionaryPref(
+      prefs::kDefaultTasksBySuffix);
+}
+
+// Updates the default task preferences per the given dictionary values. Used
+// for testing ChooseAndSetDefaultTask.
+void UpdateDefaultTaskPreferences(TestingPrefServiceSimple* pref_service,
+                                  const base::DictionaryValue& mime_types,
+                                  const base::DictionaryValue& suffixes) {
+  DCHECK(pref_service);
+
+  pref_service->Set(prefs::kDefaultTasksByMimeType, mime_types);
+  pref_service->Set(prefs::kDefaultTasksBySuffix, suffixes);
+}
+
+}  // namespace
+
+TEST(FileManagerFileTasksTest,
+     FullTaskDescriptor_NonDriveAppWithIconAndDefault) {
+  FullTaskDescriptor full_descriptor(
+      TaskDescriptor("app-id", TASK_TYPE_FILE_BROWSER_HANDLER, "action-id"),
+      "task title", Verb::VERB_OPEN_WITH, GURL("http://example.com/icon.png"),
+      true /* is_default */, false /* is_generic_file_handler */);
+
+  const std::string task_id =
+      TaskDescriptorToId(full_descriptor.task_descriptor());
+  EXPECT_EQ("app-id|file|action-id", task_id);
+  EXPECT_EQ("http://example.com/icon.png", full_descriptor.icon_url().spec());
+  EXPECT_EQ("task title", full_descriptor.task_title());
+  EXPECT_EQ(Verb::VERB_OPEN_WITH, full_descriptor.task_verb());
+  EXPECT_TRUE(full_descriptor.is_default());
+}
+
+TEST(FileManagerFileTasksTest,
+     FullTaskDescriptor_DriveAppWithoutIconAndNotDefault) {
+  FullTaskDescriptor full_descriptor(
+      TaskDescriptor("app-id", TASK_TYPE_DRIVE_APP, "action-id"), "task title",
+      Verb::VERB_OPEN_WITH,
+      GURL(),  // No icon URL.
+      false /* is_default */, false /* is_generic_file_handler */);
+
+  const std::string task_id =
+      TaskDescriptorToId(full_descriptor.task_descriptor());
+  EXPECT_EQ("app-id|drive|action-id", task_id);
+  EXPECT_TRUE(full_descriptor.icon_url().is_empty());
+  EXPECT_EQ("task title", full_descriptor.task_title());
+  EXPECT_EQ(Verb::VERB_OPEN_WITH, full_descriptor.task_verb());
+  EXPECT_FALSE(full_descriptor.is_default());
+}
+
+TEST(FileManagerFileTasksTest, MakeTaskID) {
+  EXPECT_EQ("app-id|file|action-id",
+            MakeTaskID("app-id", TASK_TYPE_FILE_BROWSER_HANDLER, "action-id"));
+  EXPECT_EQ("app-id|app|action-id",
+            MakeTaskID("app-id", TASK_TYPE_FILE_HANDLER, "action-id"));
+  EXPECT_EQ("app-id|drive|action-id",
+            MakeTaskID("app-id", TASK_TYPE_DRIVE_APP, "action-id"));
+}
+
+TEST(FileManagerFileTasksTest, TaskDescriptorToId) {
+  EXPECT_EQ("app-id|file|action-id",
+            TaskDescriptorToId(TaskDescriptor("app-id",
+                                              TASK_TYPE_FILE_BROWSER_HANDLER,
+                                              "action-id")));
+}
+
+TEST(FileManagerFileTasksTest, ParseTaskID_FileBrowserHandler) {
+  TaskDescriptor task;
+  EXPECT_TRUE(ParseTaskID("app-id|file|action-id", &task));
+  EXPECT_EQ("app-id", task.app_id);
+  EXPECT_EQ(TASK_TYPE_FILE_BROWSER_HANDLER, task.task_type);
+  EXPECT_EQ("action-id", task.action_id);
+}
+
+TEST(FileManagerFileTasksTest, ParseTaskID_FileHandler) {
+  TaskDescriptor task;
+  EXPECT_TRUE(ParseTaskID("app-id|app|action-id", &task));
+  EXPECT_EQ("app-id", task.app_id);
+  EXPECT_EQ(TASK_TYPE_FILE_HANDLER, task.task_type);
+  EXPECT_EQ("action-id", task.action_id);
+}
+
+TEST(FileManagerFileTasksTest, ParseTaskID_DriveApp) {
+  TaskDescriptor task;
+  EXPECT_TRUE(ParseTaskID("app-id|drive|action-id", &task));
+  EXPECT_EQ("app-id", task.app_id);
+  EXPECT_EQ(TASK_TYPE_DRIVE_APP, task.task_type);
+  EXPECT_EQ("action-id", task.action_id);
+}
+
+TEST(FileManagerFileTasksTest, ParseTaskID_Legacy) {
+  TaskDescriptor task;
+  // A legacy task ID only has two parts. The task type should be
+  // TASK_TYPE_FILE_BROWSER_HANDLER.
+  EXPECT_TRUE(ParseTaskID("app-id|action-id", &task));
+  EXPECT_EQ("app-id", task.app_id);
+  EXPECT_EQ(TASK_TYPE_FILE_BROWSER_HANDLER, task.task_type);
+  EXPECT_EQ("action-id", task.action_id);
+}
+
+TEST(FileManagerFileTasksTest, ParseTaskID_LegacyDrive) {
+  TaskDescriptor task;
+  // A legacy task ID only has two parts. For Drive app, the app ID is
+  // prefixed with "drive-app:".
+  EXPECT_TRUE(ParseTaskID("drive-app:app-id|action-id", &task));
+  EXPECT_EQ("app-id", task.app_id);
+  EXPECT_EQ(TASK_TYPE_DRIVE_APP, task.task_type);
+  EXPECT_EQ("action-id", task.action_id);
+}
+
+TEST(FileManagerFileTasksTest, ParseTaskID_Invalid) {
+  TaskDescriptor task;
+  EXPECT_FALSE(ParseTaskID("invalid", &task));
+}
+
+TEST(FileManagerFileTasksTest, ParseTaskID_UnknownTaskType) {
+  TaskDescriptor task;
+  EXPECT_FALSE(ParseTaskID("app-id|unknown|action-id", &task));
+}
+
+TEST(FileManagerFileTasksTest, FindDriveAppTasks) {
+  // For DriveAppRegistry and TestingProfile, which check
+  // CurrentlyOn(BrowserThread::UI).
+  content::TestBrowserThreadBundle thread_bundle;
+
+  TestingProfile profile;
+
+  // Foo.app can handle "text/plain" and "text/html"
+  std::unique_ptr<google_apis::AppResource> foo_app(
+      new google_apis::AppResource);
+  foo_app->set_product_id("foo_app_id");
+  foo_app->set_application_id("foo_app_id");
+  foo_app->set_name("Foo");
+  foo_app->set_object_type("foo_object_type");
+  std::vector<std::unique_ptr<std::string>> foo_mime_types;
+  foo_mime_types.push_back(std::make_unique<std::string>("text/plain"));
+  foo_mime_types.push_back(std::make_unique<std::string>("text/html"));
+  foo_app->set_primary_mimetypes(std::move(foo_mime_types));
+
+  // Bar.app can only handle "text/plain".
+  std::unique_ptr<google_apis::AppResource> bar_app(
+      new google_apis::AppResource);
+  bar_app->set_product_id("bar_app_id");
+  bar_app->set_application_id("bar_app_id");
+  bar_app->set_name("Bar");
+  bar_app->set_object_type("bar_object_type");
+  std::vector<std::unique_ptr<std::string>> bar_mime_types;
+  bar_mime_types.push_back(std::make_unique<std::string>("text/plain"));
+  bar_app->set_primary_mimetypes(std::move(bar_mime_types));
+
+  // Prepare DriveAppRegistry from Foo.app and Bar.app.
+  std::vector<std::unique_ptr<google_apis::AppResource>> app_resources;
+  app_resources.push_back(std::move(foo_app));
+  app_resources.push_back(std::move(bar_app));
+  google_apis::AppList app_list;
+  app_list.set_items(std::move(app_resources));
+  drive::DriveAppRegistry drive_app_registry(nullptr);
+  drive_app_registry.UpdateFromAppList(app_list);
+
+  // Find apps for a "text/plain" file. Foo.app and Bar.app should be found.
+  std::vector<extensions::EntryInfo> entries;
+  entries.emplace_back(
+      drive::util::GetDriveMountPointPath(&profile).AppendASCII("foo.txt"),
+      "text/plain", false);
+  std::vector<FullTaskDescriptor> tasks;
+  FindDriveAppTasks(drive_app_registry, entries, &tasks);
+  ASSERT_EQ(2U, tasks.size());
+  // Sort the app IDs, as the order is not guaranteed.
+  std::vector<std::string> app_ids;
+  app_ids.push_back(tasks[0].task_descriptor().app_id);
+  app_ids.push_back(tasks[1].task_descriptor().app_id);
+  std::sort(app_ids.begin(), app_ids.end());
+  // Confirm that both Foo.app and Bar.app are found.
+  EXPECT_EQ("bar_app_id", app_ids[0]);
+  EXPECT_EQ("foo_app_id", app_ids[1]);
+
+  // Find apps for "text/plain" and "text/html" files. Only Foo.app should be
+  // found.
+  entries.clear();
+  entries.emplace_back(
+      drive::util::GetDriveMountPointPath(&profile).AppendASCII("foo.txt"),
+      "text/plain", false);
+  entries.emplace_back(
+      drive::util::GetDriveMountPointPath(&profile).AppendASCII("foo.html"),
+      "text/html", false);
+  tasks.clear();
+  FindDriveAppTasks(drive_app_registry, entries, &tasks);
+  ASSERT_EQ(1U, tasks.size());
+  // Confirm that only Foo.app is found.
+  EXPECT_EQ("foo_app_id", tasks[0].task_descriptor().app_id);
+
+  // Add a "text/plain" file not on Drive. No tasks should be found.
+  entries.emplace_back(base::FilePath::FromUTF8Unsafe("not_on_drive.txt"),
+                       "text/plain", false);
+  tasks.clear();
+  FindDriveAppTasks(drive_app_registry, entries, &tasks);
+  // Confirm no tasks are found.
+  ASSERT_TRUE(tasks.empty());
+}
+
+// Test that the right task is chosen from multiple choices per mime types
+// and file extensions.
+TEST(FileManagerFileTasksTest, ChooseAndSetDefaultTask_MultipleTasks) {
+  TestingPrefServiceSimple pref_service;
+  RegisterDefaultTaskPreferences(&pref_service);
+
+  // Text.app and Nice.app were found for "foo.txt".
+  TaskDescriptor text_app_task("text-app-id",
+                               TASK_TYPE_FILE_HANDLER,
+                               "action-id");
+  TaskDescriptor nice_app_task("nice-app-id",
+                               TASK_TYPE_FILE_HANDLER,
+                               "action-id");
+  std::vector<FullTaskDescriptor> tasks;
+  tasks.emplace_back(text_app_task, "Text.app", Verb::VERB_OPEN_WITH,
+                     GURL("http://example.com/text_app.png"),
+                     false /* is_default */,
+                     false /* is_generic_file_handler */);
+  tasks.emplace_back(nice_app_task, "Nice.app", Verb::VERB_ADD_TO,
+                     GURL("http://example.com/nice_app.png"),
+                     false /* is_default */,
+                     false /* is_generic_file_handler */);
+  std::vector<extensions::EntryInfo> entries;
+  entries.emplace_back(base::FilePath::FromUTF8Unsafe("foo.txt"), "text/plain",
+                       false);
+
+  // None of them should be chosen as default, as nothing is set in the
+  // preferences.
+  ChooseAndSetDefaultTask(pref_service, entries, &tasks);
+  EXPECT_FALSE(tasks[0].is_default());
+  EXPECT_FALSE(tasks[1].is_default());
+
+  // Set Text.app as default for "text/plain" in the preferences.
+  base::DictionaryValue empty;
+  base::DictionaryValue mime_types;
+  mime_types.SetKey("text/plain",
+                    base::Value(TaskDescriptorToId(text_app_task)));
+  UpdateDefaultTaskPreferences(&pref_service, mime_types, empty);
+
+  // Text.app should be chosen as default.
+  ChooseAndSetDefaultTask(pref_service, entries, &tasks);
+  EXPECT_TRUE(tasks[0].is_default());
+  EXPECT_FALSE(tasks[1].is_default());
+
+  // Change it back to non-default for testing further.
+  tasks[0].set_is_default(false);
+
+  // Clear the preferences and make sure none of them are default.
+  UpdateDefaultTaskPreferences(&pref_service, empty, empty);
+  ChooseAndSetDefaultTask(pref_service, entries, &tasks);
+  EXPECT_FALSE(tasks[0].is_default());
+  EXPECT_FALSE(tasks[1].is_default());
+
+  // Set Nice.app as default for ".txt" in the preferences.
+  base::DictionaryValue suffixes;
+  suffixes.SetKey(".txt", base::Value(TaskDescriptorToId(nice_app_task)));
+  UpdateDefaultTaskPreferences(&pref_service, empty, suffixes);
+
+  // Now Nice.app should be chosen as default.
+  ChooseAndSetDefaultTask(pref_service, entries, &tasks);
+  EXPECT_FALSE(tasks[0].is_default());
+  EXPECT_TRUE(tasks[1].is_default());
+}
+
+// Test that internal file browser handler of the Files app is chosen as
+// default even if nothing is set in the preferences.
+TEST(FileManagerFileTasksTest, ChooseAndSetDefaultTask_FallbackFileBrowser) {
+  TestingPrefServiceSimple pref_service;
+  RegisterDefaultTaskPreferences(&pref_service);
+
+  // The internal file browser handler of the Files app was found for "foo.txt".
+  TaskDescriptor files_app_task(kFileManagerAppId,
+                                TASK_TYPE_FILE_BROWSER_HANDLER,
+                                "view-in-browser");
+  std::vector<FullTaskDescriptor> tasks;
+  tasks.emplace_back(files_app_task, "View in browser", Verb::VERB_OPEN_WITH,
+                     GURL("http://example.com/some_icon.png"),
+                     false /* is_default */,
+                     false /* is_generic_file_handler */);
+  std::vector<extensions::EntryInfo> entries;
+  entries.emplace_back(base::FilePath::FromUTF8Unsafe("foo.txt"), "text/plain",
+                       false);
+
+  // The internal file browser handler should be chosen as default, as it's a
+  // fallback file browser handler.
+  ChooseAndSetDefaultTask(pref_service, entries, &tasks);
+  EXPECT_TRUE(tasks[0].is_default());
+}
+
+// Test that Text.app is chosen as default even if nothing is set in the
+// preferences.
+TEST(FileManagerFileTasksTest, ChooseAndSetDefaultTask_FallbackTextApp) {
+  TestingPrefServiceSimple pref_service;
+  RegisterDefaultTaskPreferences(&pref_service);
+
+  // The text editor app was found for "foo.txt".
+  TaskDescriptor files_app_task(kTextEditorAppId, TASK_TYPE_FILE_HANDLER,
+                                "Text");
+  std::vector<FullTaskDescriptor> tasks;
+  tasks.emplace_back(
+      files_app_task, "Text", Verb::VERB_OPEN_WITH,
+      GURL("chrome://extension-icon/mmfbcljfglbokpmkimbfghdkjmjhdgbg/16/1"),
+      false /* is_default */, false /* is_generic_file_handler */);
+  std::vector<extensions::EntryInfo> entries;
+  entries.emplace_back(base::FilePath::FromUTF8Unsafe("foo.txt"), "text/plain",
+                       false);
+
+  // The text editor app should be chosen as default, as it's a fallback file
+  // browser handler.
+  ChooseAndSetDefaultTask(pref_service, entries, &tasks);
+  EXPECT_TRUE(tasks[0].is_default());
+}
+
+// Test that Audio Player is chosen as default even if nothing is set in the
+// preferences.
+TEST(FileManagerFileTasksTest, ChooseAndSetDefaultTask_FallbackAudioPlayer) {
+  TestingPrefServiceSimple pref_service;
+  RegisterDefaultTaskPreferences(&pref_service);
+
+  // The Audio Player app was found for "sound.wav".
+  TaskDescriptor files_app_task(kAudioPlayerAppId, TASK_TYPE_FILE_HANDLER,
+                                "Audio Player");
+  std::vector<FullTaskDescriptor> tasks;
+  tasks.emplace_back(
+      files_app_task, "Audio Player", Verb::VERB_OPEN_WITH,
+      GURL("chrome://extension-icon/cjbfomnbifhcdnihkgipgfcihmgjfhbf/32/1"),
+      false /* is_default */, false /* is_generic_file_handler */);
+  std::vector<extensions::EntryInfo> entries;
+  entries.emplace_back(base::FilePath::FromUTF8Unsafe("sound.wav"), "audio/wav",
+                       false);
+
+  // The Audio Player app should be chosen as default, as it's a fallback file
+  // browser handler.
+  ChooseAndSetDefaultTask(pref_service, entries, &tasks);
+  EXPECT_TRUE(tasks[0].is_default());
+}
+
+// Test that Office Editing is chosen as default even if nothing is set in the
+// preferences.
+TEST(FileManagerFileTasksTest, ChooseAndSetDefaultTask_FallbackOfficeEditing) {
+  TestingPrefServiceSimple pref_service;
+  RegisterDefaultTaskPreferences(&pref_service);
+
+  // The Office Editing app was found for "slides.pptx".
+  TaskDescriptor files_app_task(
+      extension_misc::kQuickOfficeComponentExtensionId, TASK_TYPE_FILE_HANDLER,
+      "Office Editing for Docs, Sheets & Slides");
+  std::vector<FullTaskDescriptor> tasks;
+  tasks.emplace_back(
+      files_app_task, "Office Editing for Docs, Sheets & Slides",
+      Verb::VERB_OPEN_WITH,
+      GURL("chrome://extension-icon/bpmcpldpdmajfigpchkicefoigmkfalc/32/1"),
+      false /* is_default */, false /* is_generic_file_handler */);
+  std::vector<extensions::EntryInfo> entries;
+  entries.emplace_back(base::FilePath::FromUTF8Unsafe("slides.pptx"), "",
+                       false);
+
+  // The Office Editing app should be chosen as default, as it's a fallback
+  // file browser handler.
+  ChooseAndSetDefaultTask(pref_service, entries, &tasks);
+  EXPECT_TRUE(tasks[0].is_default());
+}
+
+// Test IsGoodMatchFileHandler which returns whether a file handle info matches
+// with files as good match or not.
+TEST(FileManagerFileTasksTest, IsGoodMatchFileHandler) {
+  using FileHandlerInfo = extensions::FileHandlerInfo;
+
+  std::vector<extensions::EntryInfo> entries_1;
+  entries_1.emplace_back(base::FilePath(FILE_PATH_LITERAL("foo.jpg")),
+                         "image/jpeg", false);
+  entries_1.emplace_back(base::FilePath(FILE_PATH_LITERAL("bar.txt")),
+                         "text/plain", false);
+
+  std::vector<extensions::EntryInfo> entries_2;
+  entries_2.emplace_back(base::FilePath(FILE_PATH_LITERAL("foo.ics")),
+                         "text/calendar", false);
+
+  // extensions: ["*"]
+  FileHandlerInfo file_handler_info_1;
+  file_handler_info_1.extensions.insert("*");
+  EXPECT_FALSE(IsGoodMatchFileHandler(file_handler_info_1, entries_1));
+
+  // extensions: ["*", "jpg"]
+  FileHandlerInfo file_handler_info_2;
+  file_handler_info_2.extensions.insert("*");
+  file_handler_info_2.extensions.insert("jpg");
+  EXPECT_FALSE(IsGoodMatchFileHandler(file_handler_info_2, entries_1));
+
+  // extensions: ["jpg"]
+  FileHandlerInfo file_handler_info_3;
+  file_handler_info_3.extensions.insert("jpg");
+  EXPECT_TRUE(IsGoodMatchFileHandler(file_handler_info_3, entries_1));
+
+  // types: ["*"]
+  FileHandlerInfo file_handler_info_4;
+  file_handler_info_4.types.insert("*");
+  EXPECT_FALSE(IsGoodMatchFileHandler(file_handler_info_4, entries_1));
+
+  // types: ["*/*"]
+  FileHandlerInfo file_handler_info_5;
+  file_handler_info_5.types.insert("*/*");
+  EXPECT_FALSE(IsGoodMatchFileHandler(file_handler_info_5, entries_1));
+
+  // types: ["image/*"]
+  FileHandlerInfo file_handler_info_6;
+  file_handler_info_6.types.insert("image/*");
+  // Partial wild card is not generic.
+  EXPECT_TRUE(IsGoodMatchFileHandler(file_handler_info_6, entries_1));
+
+  // types: ["*", "image/*"]
+  FileHandlerInfo file_handler_info_7;
+  file_handler_info_7.types.insert("*");
+  file_handler_info_7.types.insert("image/*");
+  EXPECT_FALSE(IsGoodMatchFileHandler(file_handler_info_7, entries_1));
+
+  // extensions: ["*"], types: ["image/*"]
+  FileHandlerInfo file_handler_info_8;
+  file_handler_info_8.extensions.insert("*");
+  file_handler_info_8.types.insert("image/*");
+  EXPECT_FALSE(IsGoodMatchFileHandler(file_handler_info_8, entries_1));
+
+  // types: ["text/*"] and target files contain unsupported text mime type, e.g.
+  // text/calendar.
+  FileHandlerInfo file_handler_info_9;
+  file_handler_info_9.types.insert("text/*");
+  EXPECT_FALSE(IsGoodMatchFileHandler(file_handler_info_9, entries_2));
+
+  // types: ["text/*"] and target files don't contain unsupported text mime
+  // type.
+  FileHandlerInfo file_handler_info_10;
+  file_handler_info_10.types.insert("text/*");
+  EXPECT_TRUE(IsGoodMatchFileHandler(file_handler_info_10, entries_1));
+
+  // path_directory_set not empty.
+  FileHandlerInfo file_handler_info_11;
+  std::vector<extensions::EntryInfo> entries_3;
+  entries_3.emplace_back(base::FilePath(FILE_PATH_LITERAL("dir1")), "", true);
+  EXPECT_FALSE(IsGoodMatchFileHandler(file_handler_info_11, entries_3));
+}
+
+// Test using the test extension system, which needs lots of setup.
+class FileManagerFileTasksComplexTest : public testing::Test {
+ protected:
+  FileManagerFileTasksComplexTest()
+      : command_line_(base::CommandLine::NO_PROGRAM),
+        extension_service_(nullptr) {
+    extensions::TestExtensionSystem* test_extension_system =
+        static_cast<extensions::TestExtensionSystem*>(
+            extensions::ExtensionSystem::Get(&test_profile_));
+    extension_service_ = test_extension_system->CreateExtensionService(
+        &command_line_,
+        base::FilePath()  /* install_directory */,
+        false  /* autoupdate_enabled*/);
+  }
+
+  // Helper class for calling FindAllTypesOfTask synchronously.
+  class FindAllTypesOfTasksSynchronousWrapper {
+   public:
+    void Call(Profile* profile,
+              const drive::DriveAppRegistry* drive_app_registry,
+              const std::vector<extensions::EntryInfo>& entries,
+              const std::vector<GURL>& file_urls,
+              std::vector<FullTaskDescriptor>* result) {
+      FindAllTypesOfTasks(
+          profile, drive_app_registry, entries, file_urls,
+          base::Bind(&FindAllTypesOfTasksSynchronousWrapper::OnReply,
+                     base::Unretained(this), result));
+      run_loop_.Run();
+    }
+
+   private:
+    void OnReply(std::vector<FullTaskDescriptor>* out,
+                 std::unique_ptr<std::vector<FullTaskDescriptor>> result) {
+      *out = *result;
+      run_loop_.Quit();
+    }
+
+    base::RunLoop run_loop_;
+  };
+
+  content::TestBrowserThreadBundle thread_bundle_;
+  chromeos::ScopedCrosSettingsTestHelper cros_settings_test_helper_;
+  chromeos::ScopedTestUserManager test_user_manager_;
+  TestingProfile test_profile_;
+  base::CommandLine command_line_;
+  extensions::ExtensionService* extension_service_;  // Owned by test_profile_;
+};
+
+// The basic logic is similar to a test case for FindDriveAppTasks above.
+TEST_F(FileManagerFileTasksComplexTest, FindFileHandlerTasks) {
+  // Random IDs generated by
+  // % ruby -le 'print (0...32).to_a.map{(?a + rand(16)).chr}.join'
+  const char kFooId[] = "hhgbjpmdppecanaaogonaigmmifgpaph";
+  const char kBarId[] = "odlhccgofgkadkkhcmhgnhgahonahoca";
+
+  // Foo.app can handle "text/plain" and "text/html".
+  extensions::ExtensionBuilder foo_app;
+  foo_app.SetManifest(
+      extensions::DictionaryBuilder()
+          .Set("name", "Foo")
+          .Set("version", "1.0.0")
+          .Set("manifest_version", 2)
+          .Set("app", extensions::DictionaryBuilder()
+                          .Set("background",
+                               extensions::DictionaryBuilder()
+                                   .Set("scripts", extensions::ListBuilder()
+                                                       .Append("background.js")
+                                                       .Build())
+                                   .Build())
+                          .Build())
+          .Set("file_handlers",
+               extensions::DictionaryBuilder()
+                   .Set("text", extensions::DictionaryBuilder()
+                                    .Set("title", "Text")
+                                    .Set("types", extensions::ListBuilder()
+                                                      .Append("text/plain")
+                                                      .Append("text/html")
+                                                      .Build())
+                                    .Build())
+                   .Build())
+          .Build());
+  foo_app.SetID(kFooId);
+  extension_service_->AddExtension(foo_app.Build().get());
+
+  // Bar.app can only handle "text/plain".
+  extensions::ExtensionBuilder bar_app;
+  bar_app.SetManifest(
+      extensions::DictionaryBuilder()
+          .Set("name", "Bar")
+          .Set("version", "1.0.0")
+          .Set("manifest_version", 2)
+          .Set("app", extensions::DictionaryBuilder()
+                          .Set("background",
+                               extensions::DictionaryBuilder()
+                                   .Set("scripts", extensions::ListBuilder()
+                                                       .Append("background.js")
+                                                       .Build())
+                                   .Build())
+                          .Build())
+          .Set("file_handlers",
+               extensions::DictionaryBuilder()
+                   .Set("text", extensions::DictionaryBuilder()
+                                    .Set("title", "Text")
+                                    .Set("types", extensions::ListBuilder()
+                                                      .Append("text/plain")
+                                                      .Build())
+                                    .Build())
+                   .Build())
+          .Build());
+  bar_app.SetID(kBarId);
+  extension_service_->AddExtension(bar_app.Build().get());
+
+  // Find apps for a "text/plain" file. Foo.app and Bar.app should be found.
+  std::vector<extensions::EntryInfo> entries;
+  entries.emplace_back(drive::util::GetDriveMountPointPath(&test_profile_)
+                           .AppendASCII("foo.txt"),
+                       "text/plain", false);
+
+  std::vector<FullTaskDescriptor> tasks;
+  FindFileHandlerTasks(&test_profile_, entries, &tasks);
+  ASSERT_EQ(2U, tasks.size());
+  // Sort the app IDs, as the order is not guaranteed.
+  std::vector<std::string> app_ids;
+  app_ids.push_back(tasks[0].task_descriptor().app_id);
+  app_ids.push_back(tasks[1].task_descriptor().app_id);
+  std::sort(app_ids.begin(), app_ids.end());
+  // Confirm that both Foo.app and Bar.app are found.
+  EXPECT_EQ(kFooId, app_ids[0]);
+  EXPECT_EQ(kBarId, app_ids[1]);
+
+  // Find apps for "text/plain" and "text/html" files. Only Foo.app should be
+  // found.
+  entries.clear();
+  entries.emplace_back(drive::util::GetDriveMountPointPath(&test_profile_)
+                           .AppendASCII("foo.txt"),
+                       "text/plain", false);
+  entries.emplace_back(drive::util::GetDriveMountPointPath(&test_profile_)
+                           .AppendASCII("foo.html"),
+                       "text/html", false);
+  tasks.clear();
+  FindFileHandlerTasks(&test_profile_, entries, &tasks);
+  ASSERT_EQ(1U, tasks.size());
+  // Confirm that only Foo.app is found.
+  EXPECT_EQ(kFooId, tasks[0].task_descriptor().app_id);
+
+  // Add an "image/png" file. No tasks should be found.
+  entries.emplace_back(base::FilePath::FromUTF8Unsafe("foo.png"), "image/png",
+                       false);
+  tasks.clear();
+  FindFileHandlerTasks(&test_profile_, entries, &tasks);
+  // Confirm no tasks are found.
+  ASSERT_TRUE(tasks.empty());
+}
+
+// The basic logic is similar to a test case for FindDriveAppTasks above.
+TEST_F(FileManagerFileTasksComplexTest, FindFileBrowserHandlerTasks) {
+  // Copied from FindFileHandlerTasks test above.
+  const char kFooId[] = "hhgbjpmdppecanaaogonaigmmifgpaph";
+  const char kBarId[] = "odlhccgofgkadkkhcmhgnhgahonahoca";
+
+  // Foo.app can handle ".txt" and ".html".
+  // This one is an extension, and has "file_browser_handlers"
+  extensions::ExtensionBuilder foo_app;
+  foo_app.SetManifest(
+      extensions::DictionaryBuilder()
+          .Set("name", "Foo")
+          .Set("version", "1.0.0")
+          .Set("manifest_version", 2)
+          .Set("permissions",
+               extensions::ListBuilder().Append("fileBrowserHandler").Build())
+          .Set("file_browser_handlers",
+               extensions::ListBuilder()
+                   .Append(
+                       extensions::DictionaryBuilder()
+                           .Set("id", "open")
+                           .Set("default_title", "open")
+                           .Set("file_filters", extensions::ListBuilder()
+                                                    .Append("filesystem:*.txt")
+                                                    .Append("filesystem:*.html")
+                                                    .Build())
+                           .Build())
+                   .Build())
+          .Build());
+  foo_app.SetID(kFooId);
+  extension_service_->AddExtension(foo_app.Build().get());
+
+  // Bar.app can only handle ".txt".
+  extensions::ExtensionBuilder bar_app;
+  bar_app.SetManifest(
+      extensions::DictionaryBuilder()
+          .Set("name", "Bar")
+          .Set("version", "1.0.0")
+          .Set("manifest_version", 2)
+          .Set("permissions",
+               extensions::ListBuilder().Append("fileBrowserHandler").Build())
+          .Set("file_browser_handlers",
+               extensions::ListBuilder()
+                   .Append(
+                       extensions::DictionaryBuilder()
+                           .Set("id", "open")
+                           .Set("default_title", "open")
+                           .Set("file_filters", extensions::ListBuilder()
+                                                    .Append("filesystem:*.txt")
+                                                    .Build())
+                           .Build())
+                   .Build())
+          .Build());
+  bar_app.SetID(kBarId);
+  extension_service_->AddExtension(bar_app.Build().get());
+
+  // Find apps for a ".txt" file. Foo.app and Bar.app should be found.
+  std::vector<GURL> file_urls;
+  file_urls.emplace_back("filesystem:chrome-extension://id/dir/foo.txt");
+
+  std::vector<FullTaskDescriptor> tasks;
+  FindFileBrowserHandlerTasks(&test_profile_, file_urls, &tasks);
+  ASSERT_EQ(2U, tasks.size());
+  // Sort the app IDs, as the order is not guaranteed.
+  std::vector<std::string> app_ids;
+  app_ids.push_back(tasks[0].task_descriptor().app_id);
+  app_ids.push_back(tasks[1].task_descriptor().app_id);
+  std::sort(app_ids.begin(), app_ids.end());
+  // Confirm that both Foo.app and Bar.app are found.
+  EXPECT_EQ(kFooId, app_ids[0]);
+  EXPECT_EQ(kBarId, app_ids[1]);
+
+  // Find apps for ".txt" and ".html" files. Only Foo.app should be found.
+  file_urls.clear();
+  file_urls.emplace_back("filesystem:chrome-extension://id/dir/foo.txt");
+  file_urls.emplace_back("filesystem:chrome-extension://id/dir/foo.html");
+  tasks.clear();
+  FindFileBrowserHandlerTasks(&test_profile_, file_urls, &tasks);
+  ASSERT_EQ(1U, tasks.size());
+  // Confirm that only Foo.app is found.
+  EXPECT_EQ(kFooId, tasks[0].task_descriptor().app_id);
+
+  // Add an ".png" file. No tasks should be found.
+  file_urls.emplace_back("filesystem:chrome-extension://id/dir/foo.png");
+  tasks.clear();
+  FindFileBrowserHandlerTasks(&test_profile_, file_urls, &tasks);
+  // Confirm no tasks are found.
+  ASSERT_TRUE(tasks.empty());
+}
+
+// Test that all kinds of apps (file handler, file browser handler, and Drive
+// app) are returned.
+TEST_F(FileManagerFileTasksComplexTest, FindAllTypesOfTasks) {
+  // kFooId and kBarId copied from FindFileHandlerTasks test above.
+  const char kFooId[] = "hhgbjpmdppecanaaogonaigmmifgpaph";
+  const char kBarId[] = "odlhccgofgkadkkhcmhgnhgahonahoca";
+  const char kBazId[] = "plifkpkakemokpflgbnnigcoldgcbdmc";
+
+  // Foo.app can handle "text/plain".
+  // This is a packaged app (file handler).
+  extensions::ExtensionBuilder foo_app;
+  foo_app.SetManifest(
+      extensions::DictionaryBuilder()
+          .Set("name", "Foo")
+          .Set("version", "1.0.0")
+          .Set("manifest_version", 2)
+          .Set("app", extensions::DictionaryBuilder()
+                          .Set("background",
+                               extensions::DictionaryBuilder()
+                                   .Set("scripts", extensions::ListBuilder()
+                                                       .Append("background.js")
+                                                       .Build())
+                                   .Build())
+                          .Build())
+          .Set("file_handlers",
+               extensions::DictionaryBuilder()
+                   .Set("text", extensions::DictionaryBuilder()
+                                    .Set("title", "Text")
+                                    .Set("types", extensions::ListBuilder()
+                                                      .Append("text/plain")
+                                                      .Build())
+                                    .Build())
+                   .Build())
+          .Build());
+  foo_app.SetID(kFooId);
+  extension_service_->AddExtension(foo_app.Build().get());
+
+  // Bar.app can only handle ".txt".
+  // This is an extension (file browser handler).
+  extensions::ExtensionBuilder bar_app;
+  bar_app.SetManifest(
+      extensions::DictionaryBuilder()
+          .Set("name", "Bar")
+          .Set("version", "1.0.0")
+          .Set("manifest_version", 2)
+          .Set("permissions",
+               extensions::ListBuilder().Append("fileBrowserHandler").Build())
+          .Set("file_browser_handlers",
+               extensions::ListBuilder()
+                   .Append(
+                       extensions::DictionaryBuilder()
+                           .Set("id", "open")
+                           .Set("default_title", "open")
+                           .Set("file_filters", extensions::ListBuilder()
+                                                    .Append("filesystem:*.txt")
+                                                    .Build())
+                           .Build())
+                   .Build())
+          .Build());
+  bar_app.SetID(kBarId);
+  extension_service_->AddExtension(bar_app.Build().get());
+
+  // Baz.app can handle "text/plain".
+  // This is a Drive app.
+  std::unique_ptr<google_apis::AppResource> baz_app(
+      new google_apis::AppResource);
+  baz_app->set_product_id("baz_app_id");
+  baz_app->set_application_id(kBazId);
+  baz_app->set_name("Baz");
+  baz_app->set_object_type("baz_object_type");
+  std::vector<std::unique_ptr<std::string>> baz_mime_types;
+  baz_mime_types.push_back(std::make_unique<std::string>("text/plain"));
+  baz_app->set_primary_mimetypes(std::move(baz_mime_types));
+  // Set up DriveAppRegistry.
+  std::vector<std::unique_ptr<google_apis::AppResource>> app_resources;
+  app_resources.push_back(std::move(baz_app));
+  google_apis::AppList app_list;
+  app_list.set_items(std::move(app_resources));
+  drive::DriveAppRegistry drive_app_registry(nullptr);
+  drive_app_registry.UpdateFromAppList(app_list);
+
+  // Find apps for "foo.txt". All apps should be found.
+  std::vector<extensions::EntryInfo> entries;
+  std::vector<GURL> file_urls;
+  entries.emplace_back(drive::util::GetDriveMountPointPath(&test_profile_)
+                           .AppendASCII("foo.txt"),
+                       "text/plain", false);
+  file_urls.emplace_back("filesystem:chrome-extension://id/dir/foo.txt");
+
+  std::vector<FullTaskDescriptor> tasks;
+  FindAllTypesOfTasksSynchronousWrapper().Call(
+      &test_profile_, &drive_app_registry, entries, file_urls, &tasks);
+  ASSERT_EQ(3U, tasks.size());
+
+  // Sort the app IDs, as the order is not guaranteed.
+  std::vector<std::string> app_ids;
+  app_ids.push_back(tasks[0].task_descriptor().app_id);
+  app_ids.push_back(tasks[1].task_descriptor().app_id);
+  app_ids.push_back(tasks[2].task_descriptor().app_id);
+  std::sort(app_ids.begin(), app_ids.end());
+  // Confirm that all apps are found.
+  EXPECT_EQ(kFooId, app_ids[0]);
+  EXPECT_EQ(kBarId, app_ids[1]);
+  EXPECT_EQ(kBazId, app_ids[2]);
+}
+
+TEST_F(FileManagerFileTasksComplexTest, FindAllTypesOfTasks_GoogleDocument) {
+  // kFooId and kBarId copied from FindFileHandlerTasks test above.
+  const char kFooId[] = "hhgbjpmdppecanaaogonaigmmifgpaph";
+  const char kBarId[] = "odlhccgofgkadkkhcmhgnhgahonahoca";
+
+  // Foo.app can handle ".gdoc" files.
+  std::unique_ptr<google_apis::AppResource> foo_app(
+      new google_apis::AppResource);
+  foo_app->set_product_id("foo_app");
+  foo_app->set_application_id(kFooId);
+  foo_app->set_name("Foo");
+  foo_app->set_object_type("foo_object_type");
+  std::vector<std::unique_ptr<std::string>> foo_extensions;
+  foo_extensions.push_back(
+      std::make_unique<std::string>("gdoc"));  // Not ".gdoc"
+  foo_app->set_primary_file_extensions(std::move(foo_extensions));
+
+  // Prepare DriveAppRegistry from Foo.app.
+  std::vector<std::unique_ptr<google_apis::AppResource>> app_resources;
+  app_resources.push_back(std::move(foo_app));
+  google_apis::AppList app_list;
+  app_list.set_items(std::move(app_resources));
+  drive::DriveAppRegistry drive_app_registry(nullptr);
+  drive_app_registry.UpdateFromAppList(app_list);
+
+  // Bar.app can handle ".gdoc" files.
+  // This is an extension (file browser handler).
+  extensions::ExtensionBuilder bar_app;
+  bar_app.SetManifest(
+      extensions::DictionaryBuilder()
+          .Set("name", "Bar")
+          .Set("version", "1.0.0")
+          .Set("manifest_version", 2)
+          .Set("permissions",
+               extensions::ListBuilder().Append("fileBrowserHandler").Build())
+          .Set("file_browser_handlers",
+               extensions::ListBuilder()
+                   .Append(
+                       extensions::DictionaryBuilder()
+                           .Set("id", "open")
+                           .Set("default_title", "open")
+                           .Set("file_filters", extensions::ListBuilder()
+                                                    .Append("filesystem:*.gdoc")
+                                                    .Build())
+                           .Build())
+                   .Build())
+          .Build());
+  bar_app.SetID(kBarId);
+  extension_service_->AddExtension(bar_app.Build().get());
+
+  // The Files app can handle ".gdoc" files.
+  // The ID "kFileManagerAppId" used here is precisely the one that identifies
+  // the Chrome OS Files app application.
+  extensions::ExtensionBuilder files_app;
+  files_app.SetManifest(
+      extensions::DictionaryBuilder()
+          .Set("name", "Files")
+          .Set("version", "1.0.0")
+          .Set("manifest_version", 2)
+          .Set("permissions",
+               extensions::ListBuilder().Append("fileBrowserHandler").Build())
+          .Set("file_browser_handlers",
+               extensions::ListBuilder()
+                   .Append(
+                       extensions::DictionaryBuilder()
+                           .Set("id", "open")
+                           .Set("default_title", "open")
+                           .Set("file_filters", extensions::ListBuilder()
+                                                    .Append("filesystem:*.gdoc")
+                                                    .Build())
+                           .Build())
+                   .Build())
+          .Build());
+  files_app.SetID(kFileManagerAppId);
+  extension_service_->AddExtension(files_app.Build().get());
+
+  // Find apps for a ".gdoc file". Only the built-in handler of the Files apps
+  // should be found.
+  std::vector<extensions::EntryInfo> entries;
+  std::vector<GURL> file_urls;
+  entries.emplace_back(drive::util::GetDriveMountPointPath(&test_profile_)
+                           .AppendASCII("foo.gdoc"),
+                       "application/vnd.google-apps.document", false);
+  file_urls.emplace_back("filesystem:chrome-extension://id/dir/foo.gdoc");
+
+  std::vector<FullTaskDescriptor> tasks;
+  FindAllTypesOfTasksSynchronousWrapper().Call(
+      &test_profile_, &drive_app_registry, entries, file_urls, &tasks);
+  ASSERT_EQ(1U, tasks.size());
+  EXPECT_EQ(kFileManagerAppId, tasks[0].task_descriptor().app_id);
+}
+
+TEST_F(FileManagerFileTasksComplexTest, FindFileHandlerTask_Generic) {
+  // Since we want to keep the order of the result as foo,bar,baz,qux,
+  // keep the ids in alphabetical order.
+  const char kFooId[] = "hhgbjpmdppecanaaogonaigmmifgpaph";
+  const char kBarId[] = "odlhccgofgkadkkhcmhgnhgahonahoca";
+  const char kBazId[] = "plifkpkakemokpflgbnnigcoldgcbdmc";
+  const char kQuxId[] = "pmifkpkakgkadkkhcmhgnigmmifgpaph";
+
+  // Foo app provides file handler for text/plain and all file types.
+  extensions::ExtensionBuilder foo_app;
+  foo_app.SetManifest(
+      extensions::DictionaryBuilder()
+          .Set("name", "Foo")
+          .Set("version", "1.0.0")
+          .Set("manifest_version", 2)
+          .Set("app", extensions::DictionaryBuilder()
+                          .Set("background",
+                               extensions::DictionaryBuilder()
+                                   .Set("scripts", extensions::ListBuilder()
+                                                       .Append("background.js")
+                                                       .Build())
+                                   .Build())
+                          .Build())
+          .Set(
+              "file_handlers",
+              extensions::DictionaryBuilder()
+                  .Set("any",
+                       extensions::DictionaryBuilder()
+                           .Set("types",
+                                extensions::ListBuilder().Append("*/*").Build())
+                           .Build())
+                  .Set("text", extensions::DictionaryBuilder()
+                                   .Set("types", extensions::ListBuilder()
+                                                     .Append("text/plain")
+                                                     .Build())
+                                   .Build())
+                  .Build())
+          .Build());
+  foo_app.SetID(kFooId);
+  extension_service_->AddExtension(foo_app.Build().get());
+
+  // Bar app provides file handler for .txt and not provide generic file
+  // handler, but handles directories.
+  extensions::ExtensionBuilder bar_app;
+  bar_app.SetManifest(
+      extensions::DictionaryBuilder()
+          .Set("name", "Bar")
+          .Set("version", "1.0.0")
+          .Set("manifest_version", 2)
+          .Set("app", extensions::DictionaryBuilder()
+                          .Set("background",
+                               extensions::DictionaryBuilder()
+                                   .Set("scripts", extensions::ListBuilder()
+                                                       .Append("background.js")
+                                                       .Build())
+                                   .Build())
+                          .Build())
+          .Set(
+              "file_handlers",
+              extensions::DictionaryBuilder()
+                  .Set("text",
+                       extensions::DictionaryBuilder()
+                           .Set("include_directories", true)
+                           .Set("extensions",
+                                extensions::ListBuilder().Append("txt").Build())
+                           .Build())
+                  .Build())
+          .Build());
+  bar_app.SetID(kBarId);
+  extension_service_->AddExtension(bar_app.Build().get());
+
+  // Baz app provides file handler for all extensions and images.
+  extensions::ExtensionBuilder baz_app;
+  baz_app.SetManifest(
+      extensions::DictionaryBuilder()
+          .Set("name", "Baz")
+          .Set("version", "1.0.0")
+          .Set("manifest_version", 2)
+          .Set("app", extensions::DictionaryBuilder()
+                          .Set("background",
+                               extensions::DictionaryBuilder()
+                                   .Set("scripts", extensions::ListBuilder()
+                                                       .Append("background.js")
+                                                       .Build())
+                                   .Build())
+                          .Build())
+          .Set("file_handlers",
+               extensions::DictionaryBuilder()
+                   .Set("any", extensions::DictionaryBuilder()
+                                   .Set("extensions", extensions::ListBuilder()
+                                                          .Append("*")
+                                                          .Append("bar")
+                                                          .Build())
+                                   .Build())
+                   .Set("image", extensions::DictionaryBuilder()
+                                     .Set("types", extensions::ListBuilder()
+                                                       .Append("image/*")
+                                                       .Build())
+                                     .Build())
+                   .Build())
+          .Build());
+  baz_app.SetID(kBazId);
+  extension_service_->AddExtension(baz_app.Build().get());
+
+  // Qux app provides file handler for all types.
+  extensions::ExtensionBuilder qux_app;
+  qux_app.SetManifest(
+      extensions::DictionaryBuilder()
+          .Set("name", "Qux")
+          .Set("version", "1.0.0")
+          .Set("manifest_version", 2)
+          .Set("app", extensions::DictionaryBuilder()
+                          .Set("background",
+                               extensions::DictionaryBuilder()
+                                   .Set("scripts", extensions::ListBuilder()
+                                                       .Append("background.js")
+                                                       .Build())
+                                   .Build())
+                          .Build())
+          .Set("file_handlers",
+               extensions::DictionaryBuilder()
+                   .Set("any",
+                        extensions::DictionaryBuilder()
+                            .Set("types",
+                                 extensions::ListBuilder().Append("*").Build())
+                            .Build())
+                   .Build())
+          .Build());
+  qux_app.SetID(kQuxId);
+  extension_service_->AddExtension(qux_app.Build().get());
+
+  // Test case with .txt file
+  std::vector<extensions::EntryInfo> txt_entries;
+  txt_entries.emplace_back(drive::util::GetDriveMountPointPath(&test_profile_)
+                               .AppendASCII("foo.txt"),
+                           "text/plain", false);
+  std::vector<FullTaskDescriptor> txt_result;
+  FindFileHandlerTasks(&test_profile_, txt_entries, &txt_result);
+  EXPECT_EQ(4U, txt_result.size());
+  // Foo app provides a handler for text/plain.
+  EXPECT_EQ("Foo", txt_result[0].task_title());
+  EXPECT_FALSE(txt_result[0].is_generic_file_handler());
+  // Bar app provides a handler for .txt.
+  EXPECT_EQ("Bar", txt_result[1].task_title());
+  EXPECT_FALSE(txt_result[1].is_generic_file_handler());
+  // Baz app provides a handler for all extensions.
+  EXPECT_EQ("Baz", txt_result[2].task_title());
+  EXPECT_TRUE(txt_result[2].is_generic_file_handler());
+  // Qux app provides a handler for all types.
+  EXPECT_EQ("Qux", txt_result[3].task_title());
+  EXPECT_TRUE(txt_result[3].is_generic_file_handler());
+
+  // Test case with .jpg file
+  std::vector<extensions::EntryInfo> jpg_entries;
+  jpg_entries.emplace_back(drive::util::GetDriveMountPointPath(&test_profile_)
+                               .AppendASCII("foo.jpg"),
+                           "image/jpeg", false);
+  std::vector<FullTaskDescriptor> jpg_result;
+  FindFileHandlerTasks(&test_profile_, jpg_entries, &jpg_result);
+  EXPECT_EQ(3U, jpg_result.size());
+  // Foo app provides a handler for all types.
+  EXPECT_EQ("Foo", jpg_result[0].task_title());
+  EXPECT_TRUE(jpg_result[0].is_generic_file_handler());
+  // Baz app provides a handler for image/*. A partial wildcarded handler is
+  // treated as non-generic handler.
+  EXPECT_EQ("Baz", jpg_result[1].task_title());
+  EXPECT_FALSE(jpg_result[1].is_generic_file_handler());
+  // Qux app provides a handler for all types.
+  EXPECT_EQ("Qux", jpg_result[2].task_title());
+  EXPECT_TRUE(jpg_result[2].is_generic_file_handler());
+
+  // Test case with directories.
+  std::vector<extensions::EntryInfo> dir_entries;
+  dir_entries.emplace_back(
+      drive::util::GetDriveMountPointPath(&test_profile_).AppendASCII("dir"),
+      "", true);
+  std::vector<FullTaskDescriptor> dir_result;
+  FindFileHandlerTasks(&test_profile_, dir_entries, &dir_result);
+  ASSERT_EQ(1U, dir_result.size());
+  // Confirm that only Bar.app is found and that it is a generic file handler.
+  EXPECT_EQ(kBarId, dir_result[0].task_descriptor().app_id);
+  EXPECT_TRUE(dir_result[0].is_generic_file_handler());
+}
+
+// The basic logic is similar to a test case for FindDriveAppTasks above.
+TEST_F(FileManagerFileTasksComplexTest, FindFileHandlerTask_Verbs) {
+  // kFooId copied from FindFileHandlerTasks test above.
+  const char kFooId[] = "hhgbjpmdppecanaaogonaigmmifgpaph";
+
+  // Foo.app can handle "text/plain" and "text/html".
+  extensions::ExtensionBuilder foo_app;
+  foo_app.SetManifest(
+      extensions::DictionaryBuilder()
+          .Set("name", "Foo")
+          .Set("version", "1.0.0")
+          .Set("manifest_version", 2)
+          .Set("app", extensions::DictionaryBuilder()
+                          .Set("background",
+                               extensions::DictionaryBuilder()
+                                   .Set("scripts", extensions::ListBuilder()
+                                                       .Append("background.js")
+                                                       .Build())
+                                   .Build())
+                          .Build())
+          .Set(
+              "file_handlers",
+              extensions::DictionaryBuilder()
+                  .Set("any",
+                       extensions::DictionaryBuilder()
+                           .Set("types",
+                                extensions::ListBuilder().Append("*").Build())
+                           .Set("verb", "add_to")
+                           .Build())
+                  .Set("any_with_directories",
+                       extensions::DictionaryBuilder()
+                           .Set("include_directories", true)
+                           .Set("types",
+                                extensions::ListBuilder().Append("*").Build())
+                           .Set("verb", "pack_with")
+                           .Build())
+                  .Set("all_text", extensions::DictionaryBuilder()
+                                       .Set("title", "Text")
+                                       .Set("types", extensions::ListBuilder()
+                                                         .Append("text/plain")
+                                                         .Append("text/html")
+                                                         .Build())
+                                       .Set("verb", "add_to")
+                                       .Build())
+                  .Set("plain_text", extensions::DictionaryBuilder()
+                                         .Set("title", "Plain")
+                                         .Set("types", extensions::ListBuilder()
+                                                           .Append("text/plain")
+                                                           .Build())
+                                         .Set("verb", "open_with")
+                                         .Build())
+                  .Set("html_text_duplicate_verb",
+                       extensions::DictionaryBuilder()
+                           .Set("title", "Html")
+                           .Set("types", extensions::ListBuilder()
+                                             .Append("text/html")
+                                             .Build())
+                           .Set("verb", "add_to")
+                           .Build())
+                  .Set("share_plain_text",
+                       extensions::DictionaryBuilder()
+                           .Set("title", "Share Plain")
+                           .Set("types", extensions::ListBuilder()
+                                             .Append("text/plain")
+                                             .Build())
+                           .Set("verb", "share_with")
+                           .Build())
+                  .Build())
+          .Build());
+  foo_app.SetID(kFooId);
+  extension_service_->AddExtension(foo_app.Build().get());
+
+  // Find app with corresponding verbs for a "text/plain" file.
+  // Foo.app with ADD_TO, OPEN_WITH, PACK_WITH and SHARE_WITH should be found,
+  // but only one ADD_TO that is not a generic handler will be taken into
+  // account, even though there are 2 ADD_TO matches for "text/plain".
+  std::vector<extensions::EntryInfo> entries;
+  entries.emplace_back(drive::util::GetDriveMountPointPath(&test_profile_)
+                           .AppendASCII("foo.txt"),
+                       "text/plain", false);
+
+  std::vector<FullTaskDescriptor> tasks;
+  FindFileHandlerTasks(&test_profile_, entries, &tasks);
+
+  ASSERT_EQ(4U, tasks.size());
+  EXPECT_EQ(kFooId, tasks[0].task_descriptor().app_id);
+  EXPECT_EQ("Foo", tasks[0].task_title());
+  EXPECT_EQ(Verb::VERB_ADD_TO, tasks[0].task_verb());
+  EXPECT_EQ(kFooId, tasks[1].task_descriptor().app_id);
+  EXPECT_EQ("Foo", tasks[1].task_title());
+  EXPECT_EQ(Verb::VERB_OPEN_WITH, tasks[1].task_verb());
+  EXPECT_EQ(kFooId, tasks[2].task_descriptor().app_id);
+  EXPECT_EQ("Foo", tasks[2].task_title());
+  EXPECT_EQ(Verb::VERB_PACK_WITH, tasks[2].task_verb());
+  EXPECT_EQ(kFooId, tasks[3].task_descriptor().app_id);
+  EXPECT_EQ("Foo", tasks[3].task_title());
+  EXPECT_EQ(Verb::VERB_SHARE_WITH, tasks[3].task_verb());
+
+  // Find app with corresponding verbs for a "text/html" file.
+  // Foo.app with ADD_TO and PACK_WITH should be found, but only the first
+  // ADD_TO that is a good match will be taken into account, even though there
+  // are 3 ADD_TO matches for "text/html".
+  entries.clear();
+  entries.emplace_back(drive::util::GetDriveMountPointPath(&test_profile_)
+                           .AppendASCII("foo.html"),
+                       "text/html", false);
+  tasks.clear();
+  FindFileHandlerTasks(&test_profile_, entries, &tasks);
+
+  ASSERT_EQ(2U, tasks.size());
+  EXPECT_EQ(kFooId, tasks[0].task_descriptor().app_id);
+  EXPECT_EQ("Foo", tasks[0].task_title());
+  EXPECT_EQ(Verb::VERB_ADD_TO, tasks[0].task_verb());
+  EXPECT_EQ(kFooId, tasks[1].task_descriptor().app_id);
+  EXPECT_EQ("Foo", tasks[1].task_title());
+  EXPECT_EQ(Verb::VERB_PACK_WITH, tasks[1].task_verb());
+
+  // Find app with corresponding verbs for directories.
+  // Foo.app with only PACK_WITH should be found.
+  entries.clear();
+  entries.emplace_back(
+      drive::util::GetDriveMountPointPath(&test_profile_).AppendASCII("dir"),
+      "", true);
+  tasks.clear();
+  FindFileHandlerTasks(&test_profile_, entries, &tasks);
+
+  ASSERT_EQ(1U, tasks.size());
+  EXPECT_EQ(kFooId, tasks[0].task_descriptor().app_id);
+  EXPECT_EQ("Foo", tasks[0].task_title());
+  EXPECT_EQ(Verb::VERB_PACK_WITH, tasks[0].task_verb());
+}
+
+// Test using the test extension system, which needs lots of setup.
+class FileManagerFileTasksCrostiniTest
+    : public FileManagerFileTasksComplexTest {
+ protected:
+  FileManagerFileTasksCrostiniTest()
+      : crostini_test_helper_(&test_profile_),
+        crostini_folder_(util::GetCrostiniMountDirectory(&test_profile_)) {
+    chromeos::DBusThreadManager::GetSetterForTesting()->SetConciergeClient(
+        std::make_unique<chromeos::FakeConciergeClient>());
+
+    vm_tools::apps::App text_app =
+        crostini::CrostiniTestHelper::BasicApp("text_app");
+    *text_app.add_mime_types() = "text/plain";
+    crostini_test_helper_.AddApp(text_app);
+
+    vm_tools::apps::App image_app =
+        crostini::CrostiniTestHelper::BasicApp("image_app");
+    *image_app.add_mime_types() = "image/gif";
+    *image_app.add_mime_types() = "image/jpeg";
+    *image_app.add_mime_types() = "image/jpg";
+    *image_app.add_mime_types() = "image/png";
+    crostini_test_helper_.AddApp(image_app);
+
+    vm_tools::apps::App gif_app =
+        crostini::CrostiniTestHelper::BasicApp("gif_app");
+    *gif_app.add_mime_types() = "image/gif";
+    crostini_test_helper_.AddApp(gif_app);
+
+    text_app_id_ = crostini::CrostiniTestHelper::GenerateAppId("text_app");
+    image_app_id_ = crostini::CrostiniTestHelper::GenerateAppId("image_app");
+    gif_app_id_ = crostini::CrostiniTestHelper::GenerateAppId("gif_app");
+  }
+
+  crostini::CrostiniTestHelper crostini_test_helper_;
+  base::FilePath crostini_folder_;
+  std::string text_app_id_;
+  std::string image_app_id_;
+  std::string gif_app_id_;
+};
+
+TEST_F(FileManagerFileTasksCrostiniTest, BasicFiles) {
+  std::vector<extensions::EntryInfo> entries{
+      {crostini_folder_.Append("foo.txt"), "text/plain", false}};
+  std::vector<GURL> file_urls{
+      GURL("filesystem:chrome-extension://id/dir/foo.txt")};
+
+  std::vector<FullTaskDescriptor> tasks;
+  FindAllTypesOfTasksSynchronousWrapper().Call(&test_profile_, nullptr, entries,
+                                               file_urls, &tasks);
+  ASSERT_EQ(1U, tasks.size());
+  EXPECT_EQ(text_app_id_, tasks[0].task_descriptor().app_id);
+
+  // Multiple text files
+  entries.emplace_back(crostini_folder_.Append("bar.txt"), "text/plain", false);
+  file_urls.emplace_back("filesystem:chrome-extension://id/dir/bar.txt");
+  FindAllTypesOfTasksSynchronousWrapper().Call(&test_profile_, nullptr, entries,
+                                               file_urls, &tasks);
+  ASSERT_EQ(1U, tasks.size());
+  EXPECT_EQ(text_app_id_, tasks[0].task_descriptor().app_id);
+}
+
+TEST_F(FileManagerFileTasksCrostiniTest, Directories) {
+  std::vector<extensions::EntryInfo> entries{
+      {crostini_folder_.Append("dir"), "", true}};
+  std::vector<GURL> file_urls{GURL("filesystem:chrome-extension://id/dir/dir")};
+  std::vector<FullTaskDescriptor> tasks;
+  FindAllTypesOfTasksSynchronousWrapper().Call(&test_profile_, nullptr, entries,
+                                               file_urls, &tasks);
+  EXPECT_EQ(0U, tasks.size());
+
+  entries.emplace_back(crostini_folder_.Append("foo.txt"), "text/plain", false);
+  file_urls.emplace_back("filesystem:chrome-extension://id/dir/foo.txt");
+  FindAllTypesOfTasksSynchronousWrapper().Call(&test_profile_, nullptr, entries,
+                                               file_urls, &tasks);
+  EXPECT_EQ(0U, tasks.size());
+}
+
+TEST_F(FileManagerFileTasksCrostiniTest, MultipleMatches) {
+  std::vector<extensions::EntryInfo> entries{
+      {crostini_folder_.Append("foo.gif"), "image/gif", false},
+      {crostini_folder_.Append("bar.gif"), "image/gif", false}};
+  std::vector<GURL> file_urls{
+      GURL("filesystem:chrome-extension://id/dir/foo.gif"),
+      GURL("filesystem:chrome-extension://id/dir/bar.gif")};
+
+  std::vector<FullTaskDescriptor> tasks;
+  FindAllTypesOfTasksSynchronousWrapper().Call(&test_profile_, nullptr, entries,
+                                               file_urls, &tasks);
+  // The returned values happen to be ordered alphabetically by app_id, so we
+  // rely on this to keep the test simple.
+  EXPECT_LT(gif_app_id_, image_app_id_);
+  ASSERT_EQ(2U, tasks.size());
+  EXPECT_EQ(gif_app_id_, tasks[0].task_descriptor().app_id);
+  EXPECT_EQ(image_app_id_, tasks[1].task_descriptor().app_id);
+}
+
+TEST_F(FileManagerFileTasksCrostiniTest, MultipleTypes) {
+  std::vector<extensions::EntryInfo> entries{
+      {crostini_folder_.Append("foo.gif"), "image/gif", false},
+      {crostini_folder_.Append("bar.png"), "image/png", false}};
+  std::vector<GURL> file_urls{
+      GURL("filesystem:chrome-extension://id/dir/foo.gif"),
+      GURL("filesystem:chrome-extension://id/dir/bar.png")};
+
+  std::vector<FullTaskDescriptor> tasks;
+  FindAllTypesOfTasksSynchronousWrapper().Call(&test_profile_, nullptr, entries,
+                                               file_urls, &tasks);
+  ASSERT_EQ(1U, tasks.size());
+  EXPECT_EQ(image_app_id_, tasks[0].task_descriptor().app_id);
+
+  entries.emplace_back(crostini_folder_.Append("qux.mp4"), "video/mp4", false);
+  file_urls.emplace_back("filesystem:chrome-extension://id/dir/qux.mp4");
+  FindAllTypesOfTasksSynchronousWrapper().Call(&test_profile_, nullptr, entries,
+                                               file_urls, &tasks);
+  EXPECT_EQ(0U, tasks.size());
+}
+
+}  // namespace file_tasks
+}  // namespace file_manager.
diff --git a/chrome/browser/file_manager/file_watcher.cc b/chrome/browser/file_manager/file_watcher.cc
new file mode 100644
index 0000000000000..8e1aa65b65f3e
--- /dev/null
+++ b/chrome/browser/file_manager/file_watcher.cc
@@ -0,0 +1,113 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/file_watcher.h"
+
+#include "base/bind.h"
+#include "base/task/post_task.h"
+#include "base/task_runner_util.h"
+#include "content/public/browser/browser_thread.h"
+#include "google_apis/drive/task_util.h"
+
+using content::BrowserThread;
+
+namespace file_manager {
+namespace {
+
+// Creates a base::FilePathWatcher and starts watching at |watch_path| with
+// |callback|. Returns NULL on failure.
+base::FilePathWatcher* CreateAndStartFilePathWatcher(
+    const base::FilePath& watch_path,
+    const base::FilePathWatcher::Callback& callback) {
+  DCHECK(!callback.is_null());
+
+  std::unique_ptr<base::FilePathWatcher> watcher(new base::FilePathWatcher);
+  if (!watcher->Watch(watch_path, false /* recursive */, callback))
+    return nullptr;
+
+  return watcher.release();
+}
+
+}  // namespace
+
+FileWatcher::FileWatcher(const base::FilePath& virtual_path)
+    : sequenced_task_runner_(base::CreateSequencedTaskRunnerWithTraits(
+          {base::MayBlock(), base::TaskPriority::USER_VISIBLE})),
+      local_file_watcher_(nullptr),
+      virtual_path_(virtual_path),
+      weak_ptr_factory_(this) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+}
+
+FileWatcher::~FileWatcher() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  sequenced_task_runner_->DeleteSoon(FROM_HERE, local_file_watcher_);
+}
+
+void FileWatcher::AddExtension(const std::string& extension_id) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  extensions_[extension_id]++;
+}
+
+void FileWatcher::RemoveExtension(const std::string& extension_id) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  ExtensionCountMap::iterator it = extensions_.find(extension_id);
+  if (it == extensions_.end()) {
+    LOG(ERROR) << " Extension [" << extension_id
+               << "] tries to unsubscribe from folder ["
+               << virtual_path_.value()
+               << "] it isn't subscribed";
+    return;
+  }
+
+  // If entry found - decrease it's count and remove if necessary
+  --it->second;
+  if (it->second == 0)
+    extensions_.erase(it);
+}
+
+std::vector<std::string> FileWatcher::GetExtensionIds() const {
+  std::vector<std::string> extension_ids;
+  for (ExtensionCountMap::const_iterator iter = extensions_.begin();
+       iter != extensions_.end(); ++iter) {
+    extension_ids.push_back(iter->first);
+  }
+  return extension_ids;
+}
+
+void FileWatcher::WatchLocalFile(
+    const base::FilePath& local_path,
+    const base::FilePathWatcher::Callback& file_watcher_callback,
+    const BoolCallback& callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(!callback.is_null());
+  DCHECK(!local_file_watcher_);
+
+  base::PostTaskAndReplyWithResult(
+      sequenced_task_runner_.get(), FROM_HERE,
+      base::Bind(&CreateAndStartFilePathWatcher, local_path,
+                 google_apis::CreateRelayCallback(file_watcher_callback)),
+      base::Bind(&FileWatcher::OnWatcherStarted, weak_ptr_factory_.GetWeakPtr(),
+                 callback));
+}
+
+void FileWatcher::OnWatcherStarted(
+    const BoolCallback& callback,
+    base::FilePathWatcher* file_watcher) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(!callback.is_null());
+  DCHECK(!local_file_watcher_);
+
+  if (file_watcher) {
+    local_file_watcher_ = file_watcher;
+    callback.Run(true);
+  } else {
+    callback.Run(false);
+  }
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/file_watcher.h b/chrome/browser/file_manager/file_watcher.h
new file mode 100644
index 0000000000000..e4dcbcac908ee
--- /dev/null
+++ b/chrome/browser/file_manager/file_watcher.h
@@ -0,0 +1,89 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_FILE_WATCHER_H_
+#define CHROME_BROWSER_FILE_MANAGER_FILE_WATCHER_H_
+
+#include <map>
+#include <string>
+
+#include "base/callback_forward.h"
+#include "base/files/file_path.h"
+#include "base/files/file_path_watcher.h"
+#include "base/memory/weak_ptr.h"
+#include "base/sequenced_task_runner.h"
+
+namespace file_manager {
+
+// This class is used to watch changes in the given virtual path, remember
+// what extensions are watching the path.
+//
+// For local files, the class maintains a FilePathWatcher instance and
+// remembers what extensions are watching the path.
+//
+// For remote files (ex. files on Drive), the class just remembers what
+// extensions are watching the path. The actual file watching for remote
+// files is handled differently in EventRouter.
+class FileWatcher {
+ public:
+  typedef base::Callback<void(bool success)> BoolCallback;
+
+  // Creates a FileWatcher associated with the virtual path.
+  explicit FileWatcher(const base::FilePath& virtual_path);
+
+  ~FileWatcher();
+
+  // Remembers that the extension of |extension_id| is watching the virtual
+  // path.
+  //
+  // If this function is called more than once with the same extension ID,
+  // the class increments the counter internally, and RemoveExtension()
+  // decrements the counter, and forgets the extension when the counter
+  // becomes zero.
+  void AddExtension(const std::string& extension_id);
+
+  // Forgets that the extension of |extension_id| is watching the virtual path,
+  // or just decrements the internal counter for the extension ID. See the
+  // comment at AddExtension() for details.
+  void RemoveExtension(const std::string& extension_id);
+
+  // Returns IDs of the extensions watching virtual_path. The returned list
+  // is sorted in the alphabetical order and contains no duplicates.
+  std::vector<std::string> GetExtensionIds() const;
+
+  // Returns the virtual path associated with the FileWatcher.
+  const base::FilePath& virtual_path() const { return virtual_path_; }
+
+  // Starts watching a local file at |local_path|. |file_watcher_callback|
+  // will be called when changes are notified.
+  //
+  // |callback| will be called with true, if the file watch is started
+  // successfully, or false if failed. |callback| must not be null.
+  void WatchLocalFile(
+      const base::FilePath& local_path,
+      const base::FilePathWatcher::Callback& file_watcher_callback,
+      const BoolCallback& callback);
+
+ private:
+  // Called when a FilePathWatcher is created and started.
+  // |file_path_watcher| is NULL, if the watcher wasn't started successfully.
+  void OnWatcherStarted(const BoolCallback& callback,
+                        base::FilePathWatcher* file_path_watcher);
+
+  scoped_refptr<base::SequencedTaskRunner> sequenced_task_runner_;
+  base::FilePathWatcher* local_file_watcher_;
+  base::FilePath virtual_path_;
+  // Map of extension-id to counter. See the comment at AddExtension() for
+  // why we need to count.
+  typedef std::map<std::string, int> ExtensionCountMap;
+  ExtensionCountMap extensions_;
+
+  // Note: This should remain the last member so it'll be destroyed and
+  // invalidate the weak pointers before any other members are destroyed.
+  base::WeakPtrFactory<FileWatcher> weak_ptr_factory_;
+};
+
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_FILE_WATCHER_H_
diff --git a/chrome/browser/file_manager/file_watcher_unittest.cc b/chrome/browser/file_manager/file_watcher_unittest.cc
new file mode 100644
index 0000000000000..fc2d4190f7b25
--- /dev/null
+++ b/chrome/browser/file_manager/file_watcher_unittest.cc
@@ -0,0 +1,158 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/file_watcher.h"
+
+#include "base/files/file_util.h"
+#include "base/files/scoped_temp_dir.h"
+#include "base/run_loop.h"
+#include "base/task/task_scheduler/task_scheduler.h"
+#include "content/public/test/test_browser_thread_bundle.h"
+#include "google_apis/drive/test_util.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace file_manager {
+namespace {
+
+using google_apis::test_util::CreateQuitCallback;
+using google_apis::test_util::CreateCopyResultCallback;
+
+class FileManagerFileWatcherTest : public testing::Test {
+ public:
+  // Use IO_MAINLOOP so FilePathWatcher works in the fake FILE thread, which
+  // is actually shared with the main thread.
+  FileManagerFileWatcherTest()
+      : thread_bundle_(content::TestBrowserThreadBundle::IO_MAINLOOP) {
+  }
+
+  void FlushMessageLoopTasks() { thread_bundle_.RunUntilIdle(); };
+
+ private:
+  content::TestBrowserThreadBundle thread_bundle_;
+};
+
+TEST_F(FileManagerFileWatcherTest, AddAndRemoveOneExtensionId) {
+  const base::FilePath kVirtualPath =
+      base::FilePath::FromUTF8Unsafe("foo/bar.txt");
+  const char kExtensionId[] = "extension-id";
+
+  FileWatcher file_watcher(kVirtualPath);
+  file_watcher.AddExtension(kExtensionId);
+  std::vector<std::string> extension_ids = file_watcher.GetExtensionIds();
+
+  ASSERT_EQ(1U, extension_ids.size());
+  ASSERT_EQ(kExtensionId, extension_ids[0]);
+
+  file_watcher.RemoveExtension(kExtensionId);
+  extension_ids = file_watcher.GetExtensionIds();
+  ASSERT_EQ(0U, extension_ids.size());
+}
+
+TEST_F(FileManagerFileWatcherTest, AddAndRemoveMultipleExtensionIds) {
+  const base::FilePath kVirtualPath =
+      base::FilePath::FromUTF8Unsafe("foo/bar.txt");
+  const char kExtensionFooId[] = "extension-foo-id";
+  const char kExtensionBarId[] = "extension-bar-id";
+
+  FileWatcher file_watcher(kVirtualPath);
+  file_watcher.AddExtension(kExtensionFooId);
+  file_watcher.AddExtension(kExtensionBarId);
+  std::vector<std::string> extension_ids = file_watcher.GetExtensionIds();
+
+  // The list should be sorted.
+  ASSERT_EQ(2U, extension_ids.size());
+  ASSERT_EQ(kExtensionBarId, extension_ids[0]);
+  ASSERT_EQ(kExtensionFooId, extension_ids[1]);
+
+  // Remove Foo. Bar should remain.
+  file_watcher.RemoveExtension(kExtensionFooId);
+  extension_ids = file_watcher.GetExtensionIds();
+  ASSERT_EQ(1U, extension_ids.size());
+  ASSERT_EQ(kExtensionBarId, extension_ids[0]);
+
+  // Remove Bar. Nothing should remain.
+  file_watcher.RemoveExtension(kExtensionBarId);
+  extension_ids = file_watcher.GetExtensionIds();
+  ASSERT_EQ(0U, extension_ids.size());
+}
+
+TEST_F(FileManagerFileWatcherTest, AddSameExtensionMultipleTimes) {
+  const base::FilePath kVirtualPath =
+      base::FilePath::FromUTF8Unsafe("foo/bar.txt");
+  const char kExtensionId[] = "extension-id";
+
+  FileWatcher file_watcher(kVirtualPath);
+  // Add three times.
+  file_watcher.AddExtension(kExtensionId);
+  file_watcher.AddExtension(kExtensionId);
+  file_watcher.AddExtension(kExtensionId);
+
+  std::vector<std::string> extension_ids = file_watcher.GetExtensionIds();
+  ASSERT_EQ(1U, extension_ids.size());
+  ASSERT_EQ(kExtensionId, extension_ids[0]);
+
+  // Remove 1st time.
+  file_watcher.RemoveExtension(kExtensionId);
+  extension_ids = file_watcher.GetExtensionIds();
+  ASSERT_EQ(1U, extension_ids.size());
+
+  // Remove 2nd time.
+  file_watcher.RemoveExtension(kExtensionId);
+  extension_ids = file_watcher.GetExtensionIds();
+  ASSERT_EQ(1U, extension_ids.size());
+
+  // Remove 3rd time. The extension ID should be gone now.
+  file_watcher.RemoveExtension(kExtensionId);
+  extension_ids = file_watcher.GetExtensionIds();
+  ASSERT_EQ(0U, extension_ids.size());
+}
+
+TEST_F(FileManagerFileWatcherTest, WatchLocalFile) {
+  const base::FilePath kVirtualPath =
+      base::FilePath::FromUTF8Unsafe("foo/bar.txt");
+  const char kExtensionId[] = "extension-id";
+
+  // Create a temporary directory.
+  base::ScopedTempDir temp_dir;
+  ASSERT_TRUE(temp_dir.CreateUniqueTempDir());
+
+  // Create a callback that will run when a change is detected.
+  bool on_change_error = false;
+  base::FilePath changed_path;
+  base::RunLoop change_run_loop;
+  base::FilePathWatcher::Callback change_callback = CreateQuitCallback(
+      &change_run_loop,
+      CreateCopyResultCallback(&changed_path, &on_change_error));
+
+  // Create a callback that will run when the watcher is started.
+  bool watcher_created = false;
+  base::RunLoop start_run_loop;
+  FileWatcher::BoolCallback start_callback = CreateQuitCallback(
+      &start_run_loop, CreateCopyResultCallback(&watcher_created));
+
+  // Start watching changes in the temporary directory.
+  FileWatcher file_watcher(kVirtualPath);
+  file_watcher.AddExtension(kExtensionId);
+  file_watcher.WatchLocalFile(temp_dir.GetPath(), change_callback,
+                              start_callback);
+  start_run_loop.Run();
+  ASSERT_TRUE(watcher_created);
+
+  // Create a temporary file in the temporary directory. The file watcher
+  // should detect the change in the directory.
+  base::FilePath temporary_file;
+  ASSERT_TRUE(
+      base::CreateTemporaryFileInDir(temp_dir.GetPath(), &temporary_file));
+
+  // Wait until the directory change is notified. Also flush tasks in the
+  // message loop since |change_callback| can be called multiple times.
+  change_run_loop.Run();
+  FlushMessageLoopTasks();
+
+  ASSERT_FALSE(on_change_error);
+  ASSERT_EQ(temp_dir.GetPath().value(), changed_path.value());
+}
+
+}  // namespace
+}  // namespace file_manager.
diff --git a/chrome/browser/file_manager/fileapi_util.cc b/chrome/browser/file_manager/fileapi_util.cc
new file mode 100644
index 0000000000000..20e9a92583ef5
--- /dev/null
+++ b/chrome/browser/file_manager/fileapi_util.cc
@@ -0,0 +1,618 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/fileapi_util.h"
+
+#include <stddef.h>
+#include <utility>
+
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/filesystem_api_util.h"
+#include "chrome/browser/profiles/profile.h"
+#include "components/drive/file_system_core_util.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/site_instance.h"
+#include "content/public/browser/storage_partition.h"
+#include "content/public/common/file_chooser_file_info.h"
+#include "extensions/browser/extension_util.h"
+#include "extensions/common/extension.h"
+#include "google_apis/drive/task_util.h"
+#include "net/base/escape.h"
+#include "storage/browser/fileapi/file_system_context.h"
+#include "storage/browser/fileapi/isolated_context.h"
+#include "storage/browser/fileapi/open_file_system_mode.h"
+#include "storage/common/fileapi/file_system_util.h"
+#include "ui/shell_dialogs/selected_file_info.h"
+#include "url/gurl.h"
+
+using content::BrowserThread;
+
+namespace file_manager {
+namespace util {
+
+namespace {
+
+GURL ConvertRelativeFilePathToFileSystemUrl(const base::FilePath& relative_path,
+                                            const std::string& extension_id) {
+  GURL base_url = storage::GetFileSystemRootURI(
+      extensions::Extension::GetBaseURLFromExtensionId(extension_id),
+      storage::kFileSystemTypeExternal);
+  return GURL(base_url.spec() +
+              net::EscapeUrlEncodedData(relative_path.AsUTF8Unsafe(),
+                                        false));  // Space to %20 instead of +.
+}
+
+// Creates an ErrorDefinition with an error set to |error|.
+EntryDefinition CreateEntryDefinitionWithError(base::File::Error error) {
+  EntryDefinition result;
+  result.error = error;
+  return result;
+}
+
+// Helper class for performing conversions from file definitions to entry
+// definitions. It is possible to do it without a class, but the code would be
+// crazy and super tricky.
+//
+// This class copies the input |file_definition_list|,
+// so there is no need to worry about validity of passed |file_definition_list|
+// reference. Also, it automatically deletes itself after converting finished,
+// or if shutdown is invoked during ResolveURL(). Must be called on UI thread.
+class FileDefinitionListConverter {
+ public:
+  FileDefinitionListConverter(Profile* profile,
+                              const std::string& extension_id,
+                              const FileDefinitionList& file_definition_list,
+                              const EntryDefinitionListCallback& callback);
+  ~FileDefinitionListConverter() = default;
+
+ private:
+  // Converts the element under the iterator to an entry. First, converts
+  // the virtual path to an URL, and calls OnResolvedURL(). In case of error
+  // calls OnIteratorConverted with an error entry definition.
+  void ConvertNextIterator(
+      std::unique_ptr<FileDefinitionListConverter> self_deleter,
+      FileDefinitionList::const_iterator iterator);
+
+  // Creates an entry definition from the URL as well as the file definition.
+  // Then, calls OnIteratorConverted with the created entry definition.
+  void OnResolvedURL(std::unique_ptr<FileDefinitionListConverter> self_deleter,
+                     FileDefinitionList::const_iterator iterator,
+                     base::File::Error error,
+                     const storage::FileSystemInfo& info,
+                     const base::FilePath& file_path,
+                     storage::FileSystemContext::ResolvedEntryType type);
+
+  // Called when the iterator is converted. Adds the |entry_definition| to
+  // |results_| and calls ConvertNextIterator() for the next element.
+  void OnIteratorConverted(
+      std::unique_ptr<FileDefinitionListConverter> self_deleter,
+      FileDefinitionList::const_iterator iterator,
+      const EntryDefinition& entry_definition);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context_;
+  const std::string extension_id_;
+  const FileDefinitionList file_definition_list_;
+  const EntryDefinitionListCallback callback_;
+  std::unique_ptr<EntryDefinitionList> result_;
+};
+
+FileDefinitionListConverter::FileDefinitionListConverter(
+    Profile* profile,
+    const std::string& extension_id,
+    const FileDefinitionList& file_definition_list,
+    const EntryDefinitionListCallback& callback)
+    : extension_id_(extension_id),
+      file_definition_list_(file_definition_list),
+      callback_(callback),
+      result_(new EntryDefinitionList) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  // File browser APIs are meant to be used only from extension context, so
+  // the extension's site is the one in whose file system context the virtual
+  // path should be found.
+  GURL site = extensions::util::GetSiteForExtensionId(extension_id_, profile);
+  file_system_context_ =
+      content::BrowserContext::GetStoragePartitionForSite(
+          profile, site)->GetFileSystemContext();
+
+  // Deletes the converter, once the scoped pointer gets out of scope. It is
+  // either, if the conversion is finished, or ResolveURL() is terminated, and
+  // the callback not called because of shutdown.
+  std::unique_ptr<FileDefinitionListConverter> self_deleter(this);
+  ConvertNextIterator(std::move(self_deleter), file_definition_list_.begin());
+}
+
+void FileDefinitionListConverter::ConvertNextIterator(
+    std::unique_ptr<FileDefinitionListConverter> self_deleter,
+    FileDefinitionList::const_iterator iterator) {
+  if (iterator == file_definition_list_.end()) {
+    // The converter object will be destroyed since |self_deleter| gets out of
+    // scope.
+    callback_.Run(std::move(result_));
+    return;
+  }
+
+  if (!file_system_context_.get()) {
+    OnIteratorConverted(std::move(self_deleter), iterator,
+                        CreateEntryDefinitionWithError(
+                            base::File::FILE_ERROR_INVALID_OPERATION));
+    return;
+  }
+
+  storage::FileSystemURL url = file_system_context_->CreateCrackedFileSystemURL(
+      extensions::Extension::GetBaseURLFromExtensionId(extension_id_),
+      storage::kFileSystemTypeExternal,
+      iterator->virtual_path);
+  DCHECK(url.is_valid());
+
+  // The converter object will be deleted if the callback is not called because
+  // of shutdown during ResolveURL().
+  file_system_context_->ResolveURL(
+      url,
+      base::Bind(&FileDefinitionListConverter::OnResolvedURL,
+                 base::Unretained(this),
+                 base::Passed(&self_deleter),
+                 iterator));
+}
+
+void FileDefinitionListConverter::OnResolvedURL(
+    std::unique_ptr<FileDefinitionListConverter> self_deleter,
+    FileDefinitionList::const_iterator iterator,
+    base::File::Error error,
+    const storage::FileSystemInfo& info,
+    const base::FilePath& file_path,
+    storage::FileSystemContext::ResolvedEntryType type) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (error != base::File::FILE_OK) {
+    OnIteratorConverted(std::move(self_deleter), iterator,
+                        CreateEntryDefinitionWithError(error));
+    return;
+  }
+
+  EntryDefinition entry_definition;
+  entry_definition.file_system_root_url = info.root_url.spec();
+  entry_definition.file_system_name = info.name;
+  switch (type) {
+    case storage::FileSystemContext::RESOLVED_ENTRY_FILE:
+      entry_definition.is_directory = false;
+      break;
+    case storage::FileSystemContext::RESOLVED_ENTRY_DIRECTORY:
+      entry_definition.is_directory = true;
+      break;
+    case storage::FileSystemContext::RESOLVED_ENTRY_NOT_FOUND:
+      entry_definition.is_directory = iterator->is_directory;
+      break;
+  }
+  entry_definition.error = base::File::FILE_OK;
+
+  // Construct a target Entry.fullPath value from the virtual path and the
+  // root URL. Eg. Downloads/A/b.txt -> A/b.txt.
+  const base::FilePath root_virtual_path =
+      file_system_context_->CrackURL(info.root_url).virtual_path();
+  DCHECK(root_virtual_path == iterator->virtual_path ||
+         root_virtual_path.IsParent(iterator->virtual_path));
+  base::FilePath full_path;
+  root_virtual_path.AppendRelativePath(iterator->virtual_path, &full_path);
+  entry_definition.full_path = full_path;
+
+  OnIteratorConverted(std::move(self_deleter), iterator, entry_definition);
+}
+
+void FileDefinitionListConverter::OnIteratorConverted(
+    std::unique_ptr<FileDefinitionListConverter> self_deleter,
+    FileDefinitionList::const_iterator iterator,
+    const EntryDefinition& entry_definition) {
+  result_->push_back(entry_definition);
+  ConvertNextIterator(std::move(self_deleter), ++iterator);
+}
+
+// Helper function to return the converted definition entry directly, without
+// the redundant container.
+void OnConvertFileDefinitionDone(
+    const EntryDefinitionCallback& callback,
+    std::unique_ptr<EntryDefinitionList> entry_definition_list) {
+  DCHECK_EQ(1u, entry_definition_list->size());
+  callback.Run(entry_definition_list->at(0));
+}
+
+// Checks if the |file_path| points non-native location or not.
+bool IsUnderNonNativeLocalPath(const storage::FileSystemContext& context,
+                               const base::FilePath& file_path) {
+  base::FilePath virtual_path;
+  if (!context.external_backend()->GetVirtualPath(file_path, &virtual_path))
+    return false;
+
+  const storage::FileSystemURL url = context.CreateCrackedFileSystemURL(
+      GURL(), storage::kFileSystemTypeExternal, virtual_path);
+  if (!url.is_valid())
+    return false;
+
+  return IsNonNativeFileSystemType(url.type());
+}
+
+// Helper class to convert SelectedFileInfoList into ChooserFileInfoList.
+class ConvertSelectedFileInfoListToFileChooserFileInfoListImpl {
+ public:
+  // The scoped pointer to control lifetime of the instance itself. The pointer
+  // is passed to callback functions and binds the lifetime of the instance to
+  // the callback's lifetime.
+  typedef std::unique_ptr<
+      ConvertSelectedFileInfoListToFileChooserFileInfoListImpl>
+      Lifetime;
+
+  ConvertSelectedFileInfoListToFileChooserFileInfoListImpl(
+      storage::FileSystemContext* context,
+      const GURL& origin,
+      const SelectedFileInfoList& selected_info_list,
+      const FileChooserFileInfoListCallback& callback)
+      : context_(context),
+        chooser_info_list_(new FileChooserFileInfoList),
+        callback_(callback) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    Lifetime lifetime(this);
+    bool need_fill_metadata = false;
+
+    for (size_t i = 0; i < selected_info_list.size(); ++i) {
+      content::FileChooserFileInfo chooser_info;
+
+      // Native file.
+      if (!IsUnderNonNativeLocalPath(*context,
+                                     selected_info_list[i].file_path)) {
+        chooser_info.file_path = selected_info_list[i].file_path;
+        chooser_info.display_name = selected_info_list[i].display_name;
+        chooser_info_list_->push_back(chooser_info);
+        continue;
+      }
+
+      // Non-native file, but it has a native snapshot file.
+      if (!selected_info_list[i].local_path.empty()) {
+        chooser_info.file_path = selected_info_list[i].local_path;
+        chooser_info.display_name = selected_info_list[i].display_name;
+        chooser_info_list_->push_back(chooser_info);
+        continue;
+      }
+
+      // Non-native file without a snapshot file.
+      base::FilePath virtual_path;
+      if (!context->external_backend()->GetVirtualPath(
+              selected_info_list[i].file_path, &virtual_path)) {
+        NotifyError(std::move(lifetime));
+        return;
+      }
+
+      const GURL url = CreateIsolatedURLFromVirtualPath(
+                           *context_, origin, virtual_path).ToGURL();
+      if (!url.is_valid()) {
+        NotifyError(std::move(lifetime));
+        return;
+      }
+
+      chooser_info.file_path = selected_info_list[i].file_path;
+      chooser_info.file_system_url = url;
+      chooser_info_list_->push_back(chooser_info);
+      need_fill_metadata = true;
+    }
+
+    // If the list includes at least one non-native file (wihtout a snapshot
+    // file), move to IO thread to obtian metadata for the non-native file.
+    if (need_fill_metadata) {
+      BrowserThread::PostTask(
+          BrowserThread::IO, FROM_HERE,
+          base::BindOnce(
+              &ConvertSelectedFileInfoListToFileChooserFileInfoListImpl::
+                  FillMetadataOnIOThread,
+              base::Unretained(this), base::Passed(&lifetime),
+              chooser_info_list_->begin()));
+      return;
+    }
+
+    NotifyComplete(std::move(lifetime));
+  }
+
+  ~ConvertSelectedFileInfoListToFileChooserFileInfoListImpl() {
+    if (chooser_info_list_) {
+      for (size_t i = 0; i < chooser_info_list_->size(); ++i) {
+        if (chooser_info_list_->at(i).file_system_url.is_valid()) {
+          storage::IsolatedContext::GetInstance()->RevokeFileSystem(
+              context_->CrackURL(chooser_info_list_->at(i).file_system_url)
+                  .mount_filesystem_id());
+        }
+      }
+    }
+  }
+
+ private:
+  // Obtains metadata for the non-native file |it|.
+  void FillMetadataOnIOThread(Lifetime lifetime,
+                              const FileChooserFileInfoList::iterator& it) {
+    DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+    if (it == chooser_info_list_->end()) {
+      BrowserThread::PostTask(
+          BrowserThread::UI, FROM_HERE,
+          base::BindOnce(
+              &ConvertSelectedFileInfoListToFileChooserFileInfoListImpl::
+                  NotifyComplete,
+              base::Unretained(this), base::Passed(&lifetime)));
+      return;
+    }
+
+    if (!it->file_system_url.is_valid()) {
+      FillMetadataOnIOThread(std::move(lifetime), it + 1);
+      return;
+    }
+
+    context_->operation_runner()->GetMetadata(
+        context_->CrackURL(it->file_system_url),
+        storage::FileSystemOperation::GET_METADATA_FIELD_IS_DIRECTORY |
+            storage::FileSystemOperation::GET_METADATA_FIELD_SIZE |
+            storage::FileSystemOperation::GET_METADATA_FIELD_LAST_MODIFIED,
+        base::Bind(&ConvertSelectedFileInfoListToFileChooserFileInfoListImpl::
+                       OnGotMetadataOnIOThread,
+                   base::Unretained(this), base::Passed(&lifetime), it));
+  }
+
+  // Callback invoked after GetMetadata.
+  void OnGotMetadataOnIOThread(Lifetime lifetime,
+                               const FileChooserFileInfoList::iterator& it,
+                               base::File::Error result,
+                               const base::File::Info& file_info) {
+    DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+    if (result != base::File::FILE_OK) {
+      BrowserThread::PostTask(
+          BrowserThread::UI, FROM_HERE,
+          base::BindOnce(
+              &ConvertSelectedFileInfoListToFileChooserFileInfoListImpl::
+                  NotifyError,
+              base::Unretained(this), base::Passed(&lifetime)));
+      return;
+    }
+
+    it->length = file_info.size;
+    it->modification_time = file_info.last_modified;
+    it->is_directory = file_info.is_directory;
+    FillMetadataOnIOThread(std::move(lifetime), it + 1);
+  }
+
+  // Returns a result to the |callback_|.
+  void NotifyComplete(Lifetime /* lifetime */) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+    callback_.Run(*chooser_info_list_);
+    // Reset the list so that the file systems are not revoked at the
+    // destructor.
+    chooser_info_list_.reset();
+  }
+
+  // Returns an empty list to the |callback_|.
+  void NotifyError(Lifetime /* lifetime */) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+    callback_.Run(FileChooserFileInfoList());
+  }
+
+  scoped_refptr<storage::FileSystemContext> context_;
+  std::unique_ptr<FileChooserFileInfoList> chooser_info_list_;
+  const FileChooserFileInfoListCallback callback_;
+
+  DISALLOW_COPY_AND_ASSIGN(
+      ConvertSelectedFileInfoListToFileChooserFileInfoListImpl);
+};
+
+void CheckIfDirectoryExistsOnIoThread(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const storage::FileSystemURL& internal_url,
+    storage::FileSystemOperationRunner::StatusCallback callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  file_system_context->operation_runner()->DirectoryExists(internal_url,
+                                                           std::move(callback));
+}
+
+void GetMetadataForPathOnIoThread(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const storage::FileSystemURL& internal_url,
+    int fields,
+    storage::FileSystemOperationRunner::GetMetadataCallback callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  file_system_context->operation_runner()->GetMetadata(internal_url, fields,
+                                                       callback);
+}
+
+}  // namespace
+
+EntryDefinition::EntryDefinition() = default;
+
+EntryDefinition::EntryDefinition(const EntryDefinition& other) = default;
+
+EntryDefinition::~EntryDefinition() = default;
+
+storage::FileSystemContext* GetFileSystemContextForExtensionId(
+    Profile* profile,
+    const std::string& extension_id) {
+  GURL site = extensions::util::GetSiteForExtensionId(extension_id, profile);
+  return content::BrowserContext::GetStoragePartitionForSite(profile, site)->
+      GetFileSystemContext();
+}
+
+storage::FileSystemContext* GetFileSystemContextForRenderFrameHost(
+    Profile* profile,
+    content::RenderFrameHost* render_frame_host) {
+  content::SiteInstance* site_instance = render_frame_host->GetSiteInstance();
+  return content::BrowserContext::GetStoragePartition(profile, site_instance)->
+      GetFileSystemContext();
+}
+
+base::FilePath ConvertDrivePathToRelativeFileSystemPath(
+    Profile* profile,
+    const std::string& extension_id,
+    const base::FilePath& drive_path) {
+  // "/special/drive-xxx"
+  base::FilePath path = drive::util::GetDriveMountPointPath(profile);
+  // appended with (|drive_path| - "drive").
+  drive::util::GetDriveGrandRootPath().AppendRelativePath(drive_path, &path);
+
+  base::FilePath relative_path;
+  ConvertAbsoluteFilePathToRelativeFileSystemPath(profile,
+                                                  extension_id,
+                                                  path,
+                                                  &relative_path);
+  return relative_path;
+}
+
+GURL ConvertDrivePathToFileSystemUrl(Profile* profile,
+                                     const base::FilePath& drive_path,
+                                     const std::string& extension_id) {
+  const base::FilePath relative_path =
+      ConvertDrivePathToRelativeFileSystemPath(profile, extension_id,
+                                               drive_path);
+  if (relative_path.empty())
+    return GURL();
+  return ConvertRelativeFilePathToFileSystemUrl(relative_path, extension_id);
+}
+
+bool ConvertAbsoluteFilePathToFileSystemUrl(Profile* profile,
+                                            const base::FilePath& absolute_path,
+                                            const std::string& extension_id,
+                                            GURL* url) {
+  base::FilePath relative_path;
+  if (!ConvertAbsoluteFilePathToRelativeFileSystemPath(profile,
+                                                       extension_id,
+                                                       absolute_path,
+                                                       &relative_path)) {
+    return false;
+  }
+  *url = ConvertRelativeFilePathToFileSystemUrl(relative_path, extension_id);
+  return true;
+}
+
+bool ConvertAbsoluteFilePathToRelativeFileSystemPath(
+    Profile* profile,
+    const std::string& extension_id,
+    const base::FilePath& absolute_path,
+    base::FilePath* virtual_path) {
+  // File browser APIs are meant to be used only from extension context, so the
+  // extension's site is the one in whose file system context the virtual path
+  // should be found.
+  GURL site = extensions::util::GetSiteForExtensionId(extension_id, profile);
+  storage::ExternalFileSystemBackend* backend =
+      content::BrowserContext::GetStoragePartitionForSite(profile, site)
+          ->GetFileSystemContext()
+          ->external_backend();
+  if (!backend)
+    return false;
+
+  // Find if this file path is managed by the external backend.
+  if (!backend->GetVirtualPath(absolute_path, virtual_path))
+    return false;
+
+  return true;
+}
+
+void ConvertFileDefinitionListToEntryDefinitionList(
+    Profile* profile,
+    const std::string& extension_id,
+    const FileDefinitionList& file_definition_list,
+    const EntryDefinitionListCallback& callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  // The converter object destroys itself.
+  new FileDefinitionListConverter(
+      profile, extension_id, file_definition_list, callback);
+}
+
+void ConvertFileDefinitionToEntryDefinition(
+    Profile* profile,
+    const std::string& extension_id,
+    const FileDefinition& file_definition,
+    const EntryDefinitionCallback& callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  FileDefinitionList file_definition_list;
+  file_definition_list.push_back(file_definition);
+  ConvertFileDefinitionListToEntryDefinitionList(
+      profile,
+      extension_id,
+      file_definition_list,
+      base::Bind(&OnConvertFileDefinitionDone, callback));
+}
+
+void ConvertSelectedFileInfoListToFileChooserFileInfoList(
+    storage::FileSystemContext* context,
+    const GURL& origin,
+    const SelectedFileInfoList& selected_info_list,
+    const FileChooserFileInfoListCallback& callback) {
+  // The object deletes itself.
+  new ConvertSelectedFileInfoListToFileChooserFileInfoListImpl(
+      context, origin, selected_info_list, callback);
+}
+
+void CheckIfDirectoryExists(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const base::FilePath& directory_path,
+    const storage::FileSystemOperationRunner::StatusCallback& callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  storage::ExternalFileSystemBackend* const backend =
+      file_system_context->external_backend();
+  DCHECK(backend);
+  const storage::FileSystemURL internal_url =
+      backend->CreateInternalURL(file_system_context.get(), directory_path);
+
+  BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::BindOnce(&CheckIfDirectoryExistsOnIoThread, file_system_context,
+                     internal_url, google_apis::CreateRelayCallback(callback)));
+}
+
+void GetMetadataForPath(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const base::FilePath& entry_path,
+    int fields,
+    const storage::FileSystemOperationRunner::GetMetadataCallback& callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  storage::ExternalFileSystemBackend* const backend =
+      file_system_context->external_backend();
+  DCHECK(backend);
+  const storage::FileSystemURL internal_url =
+      backend->CreateInternalURL(file_system_context.get(), entry_path);
+
+  BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::BindOnce(&GetMetadataForPathOnIoThread, file_system_context,
+                     internal_url, fields,
+                     google_apis::CreateRelayCallback(callback)));
+}
+
+storage::FileSystemURL CreateIsolatedURLFromVirtualPath(
+    const storage::FileSystemContext& context,
+    const GURL& origin,
+    const base::FilePath& virtual_path) {
+  const storage::FileSystemURL original_url =
+      context.CreateCrackedFileSystemURL(
+          origin, storage::kFileSystemTypeExternal, virtual_path);
+
+  std::string register_name;
+  const std::string isolated_file_system_id =
+      storage::IsolatedContext::GetInstance()->RegisterFileSystemForPath(
+          original_url.type(),
+          original_url.filesystem_id(),
+          original_url.path(),
+          &register_name);
+  const storage::FileSystemURL isolated_url =
+      context.CreateCrackedFileSystemURL(
+          origin,
+          storage::kFileSystemTypeIsolated,
+          base::FilePath(isolated_file_system_id).Append(register_name));
+  return isolated_url;
+}
+
+}  // namespace util
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/fileapi_util.h b/chrome/browser/file_manager/fileapi_util.h
new file mode 100644
index 0000000000000..94784f1154e31
--- /dev/null
+++ b/chrome/browser/file_manager/fileapi_util.h
@@ -0,0 +1,174 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides File API related utilities.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_FILEAPI_UTIL_H_
+#define CHROME_BROWSER_FILE_MANAGER_FILEAPI_UTIL_H_
+
+#include <memory>
+#include <string>
+
+#include "base/callback_forward.h"
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "storage/browser/fileapi/file_system_operation_runner.h"
+#include "url/gurl.h"
+
+class Profile;
+
+namespace content {
+struct FileChooserFileInfo;
+class RenderFrameHost;
+}
+
+namespace storage {
+class FileSystemContext;
+}
+
+namespace ui {
+struct SelectedFileInfo;
+}
+
+namespace file_manager {
+namespace util {
+
+// Structure information necessary to create a EntryDefinition, and therefore
+// an Entry object on the JavaScript side.
+struct FileDefinition {
+  base::FilePath virtual_path;
+  base::FilePath absolute_path;
+  bool is_directory;
+};
+
+// Contains all information needed to create an Entry object in custom bindings.
+struct EntryDefinition {
+  EntryDefinition();
+  EntryDefinition(const EntryDefinition& other);
+  ~EntryDefinition();
+
+  std::string file_system_root_url;  // Used to create DOMFileSystem.
+  std::string file_system_name;      // Value of DOMFileSystem.name.
+  base::FilePath full_path;    // Value of Entry.fullPath.
+  // Whether to create FileEntry or DirectoryEntry when the corresponding entry
+  // is not found.
+  bool is_directory;
+  base::File::Error error;
+};
+
+typedef std::vector<FileDefinition> FileDefinitionList;
+typedef std::vector<EntryDefinition> EntryDefinitionList;
+typedef std::vector<ui::SelectedFileInfo> SelectedFileInfoList;
+typedef std::vector<content::FileChooserFileInfo> FileChooserFileInfoList;
+
+// The callback used by ConvertFileDefinitionToEntryDefinition. Returns the
+// result of the conversion.
+typedef base::Callback<void(const EntryDefinition& entry_definition)>
+    EntryDefinitionCallback;
+
+// The callback used by ConvertFileDefinitionListToEntryDefinitionList. Returns
+// the result of the conversion as a list.
+typedef base::Callback<void(
+    std::unique_ptr<EntryDefinitionList> entry_definition_list)>
+    EntryDefinitionListCallback;
+
+// The callback used by
+// ConvertFileSelectedInfoListToFileChooserFileInfoList. Returns the result of
+// the conversion as a list.
+typedef base::Callback<void(const FileChooserFileInfoList&)>
+    FileChooserFileInfoListCallback;
+
+// Returns a file system context associated with the given profile and the
+// extension ID.
+storage::FileSystemContext* GetFileSystemContextForExtensionId(
+    Profile* profile,
+    const std::string& extension_id);
+
+// Returns a file system context associated with the given profile and the
+// render view host.
+storage::FileSystemContext* GetFileSystemContextForRenderFrameHost(
+    Profile* profile,
+    content::RenderFrameHost* render_frame_host);
+
+// Converts DrivePath (e.g., "drive/root", which always starts with the fixed
+// "drive" directory) to a RelativeFileSystemPathrelative (e.g.,
+// "drive-xxx/root/foo". which starts from the "mount point" in the FileSystem
+// API that may be distinguished for each profile by the appended "xxx" part.)
+base::FilePath ConvertDrivePathToRelativeFileSystemPath(
+    Profile* profile,
+    const std::string& extension_id,
+    const base::FilePath& drive_path);
+
+// Converts DrivePath to FileSystem URL.
+// E.g., "drive/root" to filesystem://id/external/drive-xxx/root.
+GURL ConvertDrivePathToFileSystemUrl(Profile* profile,
+                                     const base::FilePath& drive_path,
+                                     const std::string& extension_id);
+
+// Converts AbsolutePath (e.g., "/special/drive-xxx/root" or
+// "/home/chronos/u-xxx/Downloads") into filesystem URL. Returns false
+// if |absolute_path| is not managed by the external filesystem provider.
+bool ConvertAbsoluteFilePathToFileSystemUrl(Profile* profile,
+                                            const base::FilePath& absolute_path,
+                                            const std::string& extension_id,
+                                            GURL* url);
+
+// Converts AbsolutePath into RelativeFileSystemPath (e.g.,
+// "/special/drive-xxx/root/foo" => "drive-xxx/root/foo".) Returns false if
+// |absolute_path| is not managed by the external filesystem provider.
+bool ConvertAbsoluteFilePathToRelativeFileSystemPath(
+    Profile* profile,
+    const std::string& extension_id,
+    const base::FilePath& absolute_path,
+    base::FilePath* relative_path);
+
+// Converts a file definition to a entry definition and returns the result
+// via a callback. |profile| cannot be null. Must be called on UI thread.
+void ConvertFileDefinitionToEntryDefinition(
+    Profile* profile,
+    const std::string& extension_id,
+    const FileDefinition& file_definition,
+    const EntryDefinitionCallback& callback);
+
+// Converts a list of file definitions into a list of entry definitions and
+// returns it via |callback|. The method is safe, |file_definition_list| is
+// copied internally. The output list has the same order of items and size as
+// the input vector. |profile| cannot be null. Must be called on UI thread.
+void ConvertFileDefinitionListToEntryDefinitionList(
+    Profile* profile,
+    const std::string& extension_id,
+    const FileDefinitionList& file_definition_list,
+    const EntryDefinitionListCallback& callback);
+
+// Converts SelectedFileInfoList into FileChooserFileInfoList.
+void ConvertSelectedFileInfoListToFileChooserFileInfoList(
+    storage::FileSystemContext* context,
+    const GURL& origin,
+    const SelectedFileInfoList& selected_info_list,
+    const FileChooserFileInfoListCallback& callback);
+
+// Checks if a directory exists at |directory_path| absolute path.
+void CheckIfDirectoryExists(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const base::FilePath& directory_path,
+    const storage::FileSystemOperationRunner::StatusCallback& callback);
+
+// Get metadata for an entry at |entry_path| absolute path.
+void GetMetadataForPath(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const base::FilePath& entry_path,
+    int fields,
+    const storage::FileSystemOperationRunner::GetMetadataCallback& callback);
+
+// Obtains isolated file system URL from |virtual_path| pointing a file in the
+// external file system.
+storage::FileSystemURL CreateIsolatedURLFromVirtualPath(
+    const storage::FileSystemContext& context,
+    const GURL& origin,
+    const base::FilePath& virtual_path);
+
+}  // namespace util
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_FILEAPI_UTIL_H_
diff --git a/chrome/browser/file_manager/fileapi_util_unittest.cc b/chrome/browser/file_manager/fileapi_util_unittest.cc
new file mode 100644
index 0000000000000..602e85bd4e68c
--- /dev/null
+++ b/chrome/browser/file_manager/fileapi_util_unittest.cc
@@ -0,0 +1,143 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/mount_test_util.h"
+#include "chrome/test/base/testing_browser_process.h"
+#include "chrome/test/base/testing_profile.h"
+#include "chrome/test/base/testing_profile_manager.h"
+#include "components/drive/chromeos/drive_test_util.h"
+#include "components/drive/chromeos/fake_file_system.h"
+#include "components/drive/service/fake_drive_service.h"
+#include "components/drive/service/test_util.h"
+#include "content/public/browser/storage_partition.h"
+#include "content/public/common/file_chooser_file_info.h"
+#include "content/public/test/test_browser_thread_bundle.h"
+#include "content/public/test/test_service_manager_context.h"
+#include "content/public/test/test_utils.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "ui/shell_dialogs/selected_file_info.h"
+
+namespace file_manager {
+namespace util {
+namespace {
+
+// Passes the |result| to the |output| pointer.
+void PassFileChooserFileInfoList(FileChooserFileInfoList* output,
+                                 const FileChooserFileInfoList& result) {
+  *output = result;
+}
+
+// Creates the drive integration service for the |profile|.
+drive::DriveIntegrationService* CreateDriveIntegrationService(
+    const base::FilePath temp_dir,
+    Profile* profile) {
+  drive::FakeDriveService* const drive_service = new drive::FakeDriveService;
+  if (!drive::test_util::SetUpTestEntries(drive_service))
+    return nullptr;
+
+  return new drive::DriveIntegrationService(
+      profile, nullptr, drive_service,
+      /* default mount name */ "", temp_dir,
+      new drive::test_util::FakeFileSystem(drive_service));
+}
+
+TEST(FileManagerFileAPIUtilTest,
+     ConvertSelectedFileInfoListToFileChooserFileInfoList) {
+  // Prepare the test drive environment.
+  content::TestBrowserThreadBundle threads;
+  content::TestServiceManagerContext service_manager_context;
+  TestingProfileManager profile_manager(TestingBrowserProcess::GetGlobal());
+  ASSERT_TRUE(profile_manager.SetUp());
+  base::ScopedTempDir drive_cache_dir;
+  ASSERT_TRUE(drive_cache_dir.CreateUniqueTempDir());
+  drive::DriveIntegrationServiceFactory::FactoryCallback factory_callback(
+      base::Bind(&CreateDriveIntegrationService, drive_cache_dir.GetPath()));
+  drive::DriveIntegrationServiceFactory::ScopedFactoryForTest
+      integration_service_factory_scope(&factory_callback);
+
+  // Prepare the test profile.
+  Profile* const profile = profile_manager.CreateTestingProfile("test-user");
+  drive::DriveIntegrationService* const service =
+      drive::DriveIntegrationServiceFactory::GetForProfile(profile);
+  service->SetEnabled(true);
+  test_util::WaitUntilDriveMountPointIsAdded(profile);
+  ASSERT_TRUE(service->IsMounted());
+
+  // Obtain the file system context.
+  content::StoragePartition* const partition =
+      content::BrowserContext::GetStoragePartitionForSite(
+          profile, GURL("http://example.com"));
+  ASSERT_TRUE(partition);
+  storage::FileSystemContext* const context = partition->GetFileSystemContext();
+  ASSERT_TRUE(context);
+
+  // Prepare the test input.
+  SelectedFileInfoList selected_info_list;
+
+  // Native file.
+  {
+    ui::SelectedFileInfo info;
+    info.file_path = base::FilePath(FILE_PATH_LITERAL("/native/File 1.txt"));
+    info.local_path = base::FilePath(FILE_PATH_LITERAL("/native/File 1.txt"));
+    info.display_name = "display_name";
+    selected_info_list.push_back(info);
+  }
+
+  // Non-native file with cache.
+  {
+    ui::SelectedFileInfo info;
+    info.file_path = base::FilePath(
+        FILE_PATH_LITERAL("/special/drive-test-user-hash/root/File 1.txt"));
+    info.local_path = base::FilePath(FILE_PATH_LITERAL("/native/cache/xxx"));
+    info.display_name = "display_name";
+    selected_info_list.push_back(info);
+  }
+
+  // Non-native file without.
+  {
+    ui::SelectedFileInfo info;
+    info.file_path = base::FilePath(
+        FILE_PATH_LITERAL("/special/drive-test-user-hash/root/File 1.txt"));
+    selected_info_list.push_back(info);
+  }
+
+  // Run the test target.
+  FileChooserFileInfoList result;
+  ConvertSelectedFileInfoListToFileChooserFileInfoList(
+      context,
+      GURL("http://example.com"),
+      selected_info_list,
+      base::Bind(&PassFileChooserFileInfoList, &result));
+  content::RunAllTasksUntilIdle();
+
+  // Check the result.
+  ASSERT_EQ(3u, result.size());
+
+  EXPECT_EQ(FILE_PATH_LITERAL("/native/File 1.txt"),
+            result[0].file_path.value());
+  EXPECT_EQ("display_name", result[0].display_name);
+  EXPECT_FALSE(result[0].file_system_url.is_valid());
+
+  EXPECT_EQ(FILE_PATH_LITERAL("/native/cache/xxx"),
+            result[1].file_path.value());
+  EXPECT_EQ("display_name", result[1].display_name);
+  EXPECT_FALSE(result[1].file_system_url.is_valid());
+
+  EXPECT_EQ(FILE_PATH_LITERAL("/special/drive-test-user-hash/root/File 1.txt"),
+            result[2].file_path.value());
+  EXPECT_TRUE(result[2].display_name.empty());
+  EXPECT_TRUE(result[2].file_system_url.is_valid());
+  const storage::FileSystemURL url =
+      context->CrackURL(result[2].file_system_url);
+  EXPECT_EQ(GURL("http://example.com"), url.origin());
+  EXPECT_EQ(storage::kFileSystemTypeIsolated, url.mount_type());
+  EXPECT_EQ(storage::kFileSystemTypeDrive, url.type());
+  EXPECT_EQ(26u, result[2].length);
+}
+
+}  // namespace
+}  // namespace util
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/filesystem_api_util.cc b/chrome/browser/file_manager/filesystem_api_util.cc
new file mode 100644
index 0000000000000..78901679abb09
--- /dev/null
+++ b/chrome/browser/file_manager/filesystem_api_util.cc
@@ -0,0 +1,272 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/filesystem_api_util.h"
+
+#include <memory>
+
+#include "base/callback.h"
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "chrome/browser/chromeos/arc/arc_util.h"
+#include "chrome/browser/chromeos/arc/fileapi/arc_content_file_system_url_util.h"
+#include "chrome/browser/chromeos/arc/fileapi/arc_file_system_operation_runner.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/chromeos/file_system_provider/mount_path_util.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_interface.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/extensions/extension_util.h"
+#include "chrome/browser/profiles/profile.h"
+#include "components/arc/arc_service_manager.h"
+#include "components/drive/chromeos/file_system_interface.h"
+#include "components/drive/file_errors.h"
+#include "components/drive/file_system_core_util.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/storage_partition.h"
+#include "google_apis/drive/task_util.h"
+#include "storage/browser/fileapi/file_system_context.h"
+
+namespace file_manager {
+namespace util {
+namespace {
+
+// Helper function used to implement GetNonNativeLocalPathMimeType. It extracts
+// the mime type from the passed Drive resource entry.
+void GetMimeTypeAfterGetResourceEntryForDrive(
+    const base::Callback<void(bool, const std::string&)>& callback,
+    drive::FileError error,
+    std::unique_ptr<drive::ResourceEntry> entry) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  if (error != drive::FILE_ERROR_OK || !entry->has_file_specific_info() ||
+      entry->file_specific_info().content_mime_type().empty()) {
+    callback.Run(false, std::string());
+    return;
+  }
+  callback.Run(true, entry->file_specific_info().content_mime_type());
+}
+
+// Helper function used to implement GetNonNativeLocalPathMimeType. It extracts
+// the mime type from the passed metadata from a providing extension.
+void GetMimeTypeAfterGetMetadataForProvidedFileSystem(
+    const base::Callback<void(bool, const std::string&)>& callback,
+    std::unique_ptr<chromeos::file_system_provider::EntryMetadata> metadata,
+    base::File::Error result) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  if (result != base::File::FILE_OK || !metadata->mime_type.get()) {
+    callback.Run(false, std::string());
+    return;
+  }
+  callback.Run(true, *metadata->mime_type);
+}
+
+// Helper function used to implement GetNonNativeLocalPathMimeType. It passes
+// the returned mime type to the callback.
+void GetMimeTypeAfterGetMimeTypeForArcContentFileSystem(
+    const base::Callback<void(bool, const std::string&)>& callback,
+    const base::Optional<std::string>& mime_type) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  if (mime_type.has_value()) {
+    callback.Run(true, mime_type.value());
+  } else {
+    callback.Run(false, std::string());
+  }
+}
+
+// Helper function to converts a callback that takes boolean value to that takes
+// File::Error, by regarding FILE_OK as the only successful value.
+void BoolCallbackAsFileErrorCallback(
+    const base::Callback<void(bool)>& callback,
+    base::File::Error error) {
+  return callback.Run(error == base::File::FILE_OK);
+}
+
+// Part of PrepareFileOnIOThread. It tries to create a new file if the given
+// |url| is not already inhabited.
+void PrepareFileAfterCheckExistOnIOThread(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const storage::FileSystemURL& url,
+    const storage::FileSystemOperation::StatusCallback& callback,
+    base::File::Error error) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+
+  if (error != base::File::FILE_ERROR_NOT_FOUND) {
+    callback.Run(error);
+    return;
+  }
+
+  // Call with the second argument |exclusive| set to false, meaning that it
+  // is not an error even if the file already exists (it can happen if the file
+  // is created after the previous FileExists call and before this CreateFile.)
+  //
+  // Note that the preceding call to FileExists is necessary for handling
+  // read only filesystems that blindly rejects handling CreateFile().
+  file_system_context->operation_runner()->CreateFile(url, false, callback);
+}
+
+// Checks whether a file exists at the given |url|, and try creating it if it
+// is not already there.
+void PrepareFileOnIOThread(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const storage::FileSystemURL& url,
+    const base::Callback<void(bool)>& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+
+  file_system_context->operation_runner()->FileExists(
+      url,
+      base::Bind(&PrepareFileAfterCheckExistOnIOThread,
+                 file_system_context,
+                 url,
+                 base::Bind(&BoolCallbackAsFileErrorCallback, callback)));
+}
+
+}  // namespace
+
+bool IsNonNativeFileSystemType(storage::FileSystemType type) {
+  switch (type) {
+    case storage::kFileSystemTypeNativeLocal:
+    case storage::kFileSystemTypeRestrictedNativeLocal:
+    case storage::kFileSystemTypeDriveFs:
+      return false;
+    default:
+      // The path indeed corresponds to a mount point not associated with a
+      // native local path.
+      return true;
+  }
+}
+
+bool IsUnderNonNativeLocalPath(Profile* profile,
+                        const base::FilePath& path) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  GURL url;
+  if (!util::ConvertAbsoluteFilePathToFileSystemUrl(
+           profile, path, kFileManagerAppId, &url)) {
+    return false;
+  }
+
+  storage::FileSystemURL filesystem_url =
+      GetFileSystemContextForExtensionId(profile, kFileManagerAppId)
+          ->CrackURL(url);
+  if (!filesystem_url.is_valid())
+    return false;
+
+  return IsNonNativeFileSystemType(filesystem_url.type());
+}
+
+void GetNonNativeLocalPathMimeType(
+    Profile* profile,
+    const base::FilePath& path,
+    const base::Callback<void(bool, const std::string&)>& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DCHECK(IsUnderNonNativeLocalPath(profile, path));
+
+  if (drive::util::IsUnderDriveMountPoint(path)) {
+    drive::FileSystemInterface* file_system =
+        drive::util::GetFileSystemByProfile(profile);
+    if (!file_system) {
+      content::BrowserThread::PostTask(
+          content::BrowserThread::UI, FROM_HERE,
+          base::BindOnce(callback, false, std::string()));
+      return;
+    }
+
+    file_system->GetResourceEntry(
+        drive::util::ExtractDrivePath(path),
+        base::BindOnce(&GetMimeTypeAfterGetResourceEntryForDrive, callback));
+    return;
+  }
+
+  if (chromeos::file_system_provider::util::IsFileSystemProviderLocalPath(
+          path)) {
+    chromeos::file_system_provider::util::LocalPathParser parser(profile, path);
+    if (!parser.Parse()) {
+      content::BrowserThread::PostTask(
+          content::BrowserThread::UI, FROM_HERE,
+          base::BindOnce(callback, false, std::string()));
+      return;
+    }
+
+    parser.file_system()->GetMetadata(
+        parser.file_path(),
+        chromeos::file_system_provider::ProvidedFileSystemInterface::
+            METADATA_FIELD_MIME_TYPE,
+        base::Bind(&GetMimeTypeAfterGetMetadataForProvidedFileSystem,
+                   callback));
+    return;
+  }
+
+  if (arc::IsArcAllowedForProfile(profile) &&
+      base::FilePath(arc::kContentFileSystemMountPointPath).IsParent(path)) {
+    GURL arc_url = arc::PathToArcUrl(path);
+    auto* runner =
+        arc::ArcFileSystemOperationRunner::GetForBrowserContext(profile);
+    if (!runner) {
+      content::BrowserThread::PostTask(
+          content::BrowserThread::UI, FROM_HERE,
+          base::BindOnce(callback, false, std::string()));
+      return;
+    }
+    runner->GetMimeType(
+        arc_url, base::Bind(&GetMimeTypeAfterGetMimeTypeForArcContentFileSystem,
+                            callback));
+    return;
+  }
+
+  // We don't have a way to obtain metadata other than drive and FSP. Returns an
+  // error with empty MIME type, that leads fallback guessing mime type from
+  // file extensions.
+  content::BrowserThread::PostTask(
+      content::BrowserThread::UI, FROM_HERE,
+      base::BindOnce(callback, false /* failure */, std::string()));
+}
+
+void IsNonNativeLocalPathDirectory(
+    Profile* profile,
+    const base::FilePath& path,
+    const base::Callback<void(bool)>& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DCHECK(IsUnderNonNativeLocalPath(profile, path));
+
+  util::CheckIfDirectoryExists(
+      GetFileSystemContextForExtensionId(profile, kFileManagerAppId), path,
+      base::Bind(&BoolCallbackAsFileErrorCallback, callback));
+}
+
+void PrepareNonNativeLocalFileForWritableApp(
+    Profile* profile,
+    const base::FilePath& path,
+    const base::Callback<void(bool)>& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DCHECK(IsUnderNonNativeLocalPath(profile, path));
+
+  GURL url;
+  if (!util::ConvertAbsoluteFilePathToFileSystemUrl(
+           profile, path, kFileManagerAppId, &url)) {
+    // Posting to the current thread, so that we always call back asynchronously
+    // independent from whether or not the operation succeeds.
+    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+                                     base::BindOnce(callback, false));
+    return;
+  }
+
+  scoped_refptr<storage::FileSystemContext> const file_system_context =
+      GetFileSystemContextForExtensionId(profile, kFileManagerAppId);
+  DCHECK(file_system_context);
+  storage::ExternalFileSystemBackend* const backend =
+      file_system_context->external_backend();
+  DCHECK(backend);
+  const storage::FileSystemURL internal_url =
+      backend->CreateInternalURL(file_system_context.get(), path);
+
+  content::BrowserThread::PostTask(
+      content::BrowserThread::IO, FROM_HERE,
+      base::BindOnce(&PrepareFileOnIOThread, file_system_context, internal_url,
+                     google_apis::CreateRelayCallback(callback)));
+}
+
+}  // namespace util
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/filesystem_api_util.h b/chrome/browser/file_manager/filesystem_api_util.h
new file mode 100644
index 0000000000000..8b99846b1381e
--- /dev/null
+++ b/chrome/browser/file_manager/filesystem_api_util.h
@@ -0,0 +1,59 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// The file contains utility functions to implement chrome.fileSystem API for
+// file paths that do not directly map to host machine's file system path, such
+// as Google Drive or virtual volumes provided by fileSystemProvider extensions.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_FILESYSTEM_API_UTIL_H_
+#define CHROME_BROWSER_FILE_MANAGER_FILESYSTEM_API_UTIL_H_
+
+#include <string>
+#include <vector>
+
+#include "base/callback_forward.h"
+#include "storage/common/fileapi/file_system_types.h"
+
+class Profile;
+
+namespace base {
+class FilePath;
+}  // namespace base
+
+namespace file_manager {
+namespace util {
+
+// Obtains whether |type| is non-native file system or not.
+bool IsNonNativeFileSystemType(storage::FileSystemType type);
+
+// Checks whether the given |path| points to a non-local filesystem that
+// requires special handling.
+bool IsUnderNonNativeLocalPath(Profile* profile, const base::FilePath& path);
+
+// Returns the mime type of the file pointed by |path|, and asynchronously sends
+// the result to |callback|.
+void GetNonNativeLocalPathMimeType(
+    Profile* profile,
+    const base::FilePath& path,
+    const base::Callback<void(bool, const std::string&)>& callback);
+
+// Checks whether the |path| points to a directory, and asynchronously sends
+// the result to |callback|.
+void IsNonNativeLocalPathDirectory(
+    Profile* profile,
+    const base::FilePath& path,
+    const base::Callback<void(bool)>& callback);
+
+// Ensures a file exists at |path|, i.e., it does nothing if a file is already
+// present, or creates a file there if it isn't, and asynchronously sends to
+// |callback| whether it succeeded.
+void PrepareNonNativeLocalFileForWritableApp(
+    Profile* profile,
+    const base::FilePath& path,
+    const base::Callback<void(bool)>& callback);
+
+}  // namespace util
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_FILESYSTEM_API_UTIL_H_
diff --git a/chrome/browser/file_manager/gallery_browsertest.cc b/chrome/browser/file_manager/gallery_browsertest.cc
new file mode 100644
index 0000000000000..0a4bcb22c2c2b
--- /dev/null
+++ b/chrome/browser/file_manager/gallery_browsertest.cc
@@ -0,0 +1,333 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/file_manager_browsertest_base.h"
+
+namespace file_manager {
+
+template <GuestMode MODE>
+class GalleryBrowserTestBase : public FileManagerBrowserTestBase {
+ public:
+  GalleryBrowserTestBase() = default;
+
+ protected:
+  GuestMode GetGuestMode() const override { return MODE; }
+
+  const char* GetTestCaseName() const override {
+    return test_case_name_.c_str();
+  }
+
+  std::string GetFullTestCaseName() const override {
+    return test_case_name_;
+  }
+
+  const char* GetTestExtensionManifestName() const override {
+    return "gallery_test_manifest.json";
+  }
+
+  void set_test_case_name(const std::string& name) { test_case_name_ = name; }
+
+ private:
+  std::string test_case_name_;
+
+  DISALLOW_COPY_AND_ASSIGN(GalleryBrowserTestBase);
+};
+
+typedef GalleryBrowserTestBase<NOT_IN_GUEST_MODE> GalleryBrowserTest;
+typedef GalleryBrowserTestBase<IN_GUEST_MODE> GalleryBrowserTestInGuestMode;
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, OpenSingleImageOnDownloads) {
+  set_test_case_name("openSingleImageOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTestInGuestMode,
+                       OpenSingleImageOnDownloads) {
+  set_test_case_name("openSingleImageOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, OpenSingleImageOnDrive) {
+  set_test_case_name("openSingleImageOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, OpenMultipleImagesOnDownloads) {
+  set_test_case_name("openMultipleImagesOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTestInGuestMode,
+                       OpenMultipleImagesOnDownloads) {
+  set_test_case_name("openMultipleImagesOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest,
+                       OpenMultipleImagesAndSwitchToSlideModeOnDownloads) {
+  set_test_case_name("openMultipleImagesAndChangeToSlideModeOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, OpenMultipleImagesOnDrive) {
+  set_test_case_name("openMultipleImagesOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest,
+                       CheckAvailabilityOfEditAndPrintButtons) {
+  set_test_case_name("checkAvailabilityOfEditAndPrintButtons");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, TraverseSlideImagesOnDownloads) {
+  set_test_case_name("traverseSlideImagesOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTestInGuestMode,
+                       TraverseSlideImagesOnDownloads) {
+  set_test_case_name("traverseSlideImagesOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, TraverseSlideImagesOnDrive) {
+  set_test_case_name("traverseSlideImagesOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTestInGuestMode,
+                       TraverseSlideThumbnailsOnDownloads) {
+  set_test_case_name("traverseSlideThumbnailsOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, TraverseSlideThumbnailsOnDownloads) {
+  set_test_case_name("traverseSlideThumbnailsOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, TraverseSlideThumbnailsOnDrive) {
+  set_test_case_name("traverseSlideThumbnailsOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, RenameImageOnDownloads) {
+  set_test_case_name("renameImageOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTestInGuestMode, RenameImageOnDownloads) {
+  set_test_case_name("renameImageOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, RenameImageOnDrive) {
+  set_test_case_name("renameImageOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, DeleteImageOnDownloads) {
+  set_test_case_name("deleteImageOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTestInGuestMode, DeleteImageOnDownloads) {
+  set_test_case_name("deleteImageOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, DeleteImageOnDrive) {
+  set_test_case_name("deleteImageOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest,
+                       CheckAvailabilityOfShareButtonOnDownloads) {
+  set_test_case_name("checkAvailabilityOfShareButtonOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTestInGuestMode,
+                       CheckAvailabilityOfShareButtonOnDownloads) {
+  set_test_case_name("checkAvailabilityOfShareButtonOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest,
+                       CheckAvailabilityOfShareButtonOnDrive) {
+  set_test_case_name("checkAvailabilityOfShareButtonOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, RotateImageOnDownloads) {
+  set_test_case_name("rotateImageOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTestInGuestMode, RotateImageOnDownloads) {
+  set_test_case_name("rotateImageOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, RotateImageOnDrive) {
+  set_test_case_name("rotateImageOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, CropImageOnDownloads) {
+  set_test_case_name("cropImageOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTestInGuestMode, CropImageOnDownloads) {
+  set_test_case_name("cropImageOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, CropImageOnDrive) {
+  set_test_case_name("cropImageOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, ExposureImageOnDownloads) {
+  set_test_case_name("exposureImageOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTestInGuestMode,
+                       ExposureImageOnDownloads) {
+  set_test_case_name("exposureImageOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, ExposureImageOnDrive) {
+  set_test_case_name("exposureImageOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, ResizeImageOnDownloads) {
+  set_test_case_name("resizeImageOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTestInGuestMode, ResizeImageOnDownloads) {
+  set_test_case_name("resizeImageOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, ResizeImageOnDrive) {
+  set_test_case_name("resizeImageOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest,
+                       EnableDisableOverwriteOriginalCheckboxOnDownloads) {
+  set_test_case_name("enableDisableOverwriteOriginalCheckboxOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest,
+                       EnableDisableOverwriteOriginalCheckboxOnDrive) {
+  set_test_case_name("enableDisableOverwriteOriginalCheckboxOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest,
+                       RenameImageInThumbnailModeOnDownloads) {
+  set_test_case_name("renameImageInThumbnailModeOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, RenameImageInThumbnailModeOnDrive) {
+  set_test_case_name("renameImageInThumbnailModeOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest,
+                       DeleteAllImagesInThumbnailModeOnDownloads) {
+  set_test_case_name("deleteAllImagesInThumbnailModeOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest,
+                       DeleteAllImagesInThumbnailModeOnDrive) {
+  set_test_case_name("deleteAllImagesInThumbnailModeOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest,
+                       DeleteAllImagesInThumbnailModeWithEnterKey) {
+  set_test_case_name("deleteAllImagesInThumbnailModeWithEnterKey");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest,
+                       DeleteAllImagesInThumbnailModeWithDeleteKey) {
+  set_test_case_name("deleteAllImagesInThumbnailModeWithDeleteKey");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest,
+                       EmptySpaceClickUnselectsInThumbnailModeOnDownloads) {
+  set_test_case_name("emptySpaceClickUnselectsInThumbnailModeOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest,
+                       EmptySpaceClickUnselectsInThumbnailModeOnDrive) {
+  set_test_case_name("emptySpaceClickUnselectsInThumbnailModeOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest,
+                       SelectMultipleImagesWithShiftKeyOnDownloads) {
+  set_test_case_name("selectMultipleImagesWithShiftKeyOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest,
+                       SelectAllImagesAfterImageDeletionOnDownloads) {
+  set_test_case_name("selectAllImagesAfterImageDeletionOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTestInGuestMode,
+                       SlideshowTraversalOnDownloads) {
+  set_test_case_name("slideshowTraversalOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, SlideshowTraversalOnDownloads) {
+  set_test_case_name("slideshowTraversalOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, SlideshowTraversalOnDrive) {
+  set_test_case_name("slideshowTraversalOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTestInGuestMode,
+                       StopStartSlideshowOnDownloads) {
+  set_test_case_name("stopStartSlideshowOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, StopStartSlideshowOnDownloads) {
+  set_test_case_name("stopStartSlideshowOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, StopStartSlideshowOnDrive) {
+  set_test_case_name("stopStartSlideshowOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryBrowserTest, ActivateVideoFromThumbnailMode) {
+  set_test_case_name("activateVideoFromThumbnailMode");
+  StartTest();
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/gallery_jstest.cc b/chrome/browser/file_manager/gallery_jstest.cc
new file mode 100644
index 0000000000000..eb86e00e489cc
--- /dev/null
+++ b/chrome/browser/file_manager/gallery_jstest.cc
@@ -0,0 +1,58 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/file_manager_jstest_base.h"
+
+class GalleryJsTest : public FileManagerJsTestBase {
+ protected:
+  GalleryJsTest()
+      : FileManagerJsTestBase(
+            base::FilePath(FILE_PATH_LITERAL("ui/file_manager/gallery/js"))) {}
+};
+
+IN_PROC_BROWSER_TEST_F(GalleryJsTest, ImageEncoderTest) {
+  RunGeneratedTest("/image_editor/image_encoder_unittest.html");
+}
+
+// Disabled on ASan builds due to a consistent failure. https://crbug.com/762831
+#if defined(ADDRESS_SANITIZER)
+#define MAYBE_ExifEncoderTest DISABLED_ExifEncoderTest
+#else
+#define MAYBE_ExifEncoderTest ExifEncoderTest
+#endif
+IN_PROC_BROWSER_TEST_F(GalleryJsTest, MAYBE_ExifEncoderTest) {
+  RunGeneratedTest("/image_editor/exif_encoder_unittest.html");
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryJsTest, ImageViewTest) {
+  RunGeneratedTest("/image_editor/image_view_unittest.html");
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryJsTest, EntryListWatcherTest) {
+  RunGeneratedTest("/entry_list_watcher_unittest.html");
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryJsTest, GalleryUtilTest) {
+  RunGeneratedTest("/gallery_util_unittest.html");
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryJsTest, GalleryItemTest) {
+  RunGeneratedTest("/gallery_item_unittest.html");
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryJsTest, GalleryDataModelTest) {
+  RunGeneratedTest("/gallery_data_model_unittest.html");
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryJsTest, RibbonTest) {
+  RunGeneratedTest("/ribbon_unittest.html");
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryJsTest, SlideModeTest) {
+  RunGeneratedTest("/slide_mode_unittest.html");
+}
+
+IN_PROC_BROWSER_TEST_F(GalleryJsTest, DimmableUIControllerTest) {
+  RunGeneratedTest("/dimmable_ui_controller_unittest.html");
+}
diff --git a/chrome/browser/file_manager/image_loader_jstest.cc b/chrome/browser/file_manager/image_loader_jstest.cc
new file mode 100644
index 0000000000000..0655d8cff7ef9
--- /dev/null
+++ b/chrome/browser/file_manager/image_loader_jstest.cc
@@ -0,0 +1,28 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/file_manager_jstest_base.h"
+
+class ImageLoaderJsTest : public FileManagerJsTestBase {
+ protected:
+  ImageLoaderJsTest() : FileManagerJsTestBase(
+      base::FilePath(FILE_PATH_LITERAL("ui/file_manager/image_loader"))) {}
+};
+
+IN_PROC_BROWSER_TEST_F(ImageLoaderJsTest, ImageLoaderClientTest) {
+  RunTest(base::FilePath(FILE_PATH_LITERAL(
+      "image_loader_client_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(ImageLoaderJsTest, CacheTest) {
+  RunTest(base::FilePath(FILE_PATH_LITERAL("cache_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(ImageLoaderJsTest, ImageLoaderTest) {
+  RunTest(base::FilePath(FILE_PATH_LITERAL("image_loader_unittest.html")));
+}
+
+IN_PROC_BROWSER_TEST_F(ImageLoaderJsTest, PiexLoaderTest) {
+  RunTest(base::FilePath(FILE_PATH_LITERAL("piex_loader_unittest.html")));
+}
diff --git a/chrome/browser/file_manager/mount_test_util.cc b/chrome/browser/file_manager/mount_test_util.cc
new file mode 100644
index 0000000000000..393cacd52bbf1
--- /dev/null
+++ b/chrome/browser/file_manager/mount_test_util.cc
@@ -0,0 +1,73 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/mount_test_util.h"
+
+#include "base/run_loop.h"
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+
+namespace file_manager {
+namespace test_util {
+
+namespace {
+
+// Helper class used to wait for |OnFileSystemMounted| event from a drive file
+// system.
+class DriveMountPointWaiter : public drive::DriveIntegrationServiceObserver {
+ public:
+  explicit DriveMountPointWaiter(
+      drive::DriveIntegrationService* integration_service)
+      : integration_service_(integration_service) {
+    integration_service_->AddObserver(this);
+  }
+
+  ~DriveMountPointWaiter() override {
+    integration_service_->RemoveObserver(this);
+  }
+
+  // DriveIntegrationServiceObserver override.
+  void OnFileSystemMounted() override {
+    // Note that it is OK for |run_loop_.Quit| to be called before
+    // |run_loop_.Run|. In this case |Run| will return immediately.
+    run_loop_.Quit();
+  }
+
+  // Runs loop until the file system is mounted.
+  void Wait() {
+    run_loop_.Run();
+  }
+
+ private:
+  drive::DriveIntegrationService* integration_service_;
+  base::RunLoop run_loop_;
+};
+
+}  // namespace
+
+void WaitUntilDriveMountPointIsAdded(Profile* profile) {
+  DCHECK(profile);
+
+  // Drive mount point is added by the browser when the drive system service
+  // is first initialized. It is done asynchronously after some other parts of
+  // the service are initialized (e.g. resource metadata and cache), thus racy
+  // with the test start. To handle this raciness, the test verifies that
+  // drive mount point is added before continuing. If this is not the case,
+  // drive file system is observed for FileSystemMounted event (by
+  // |mount_point_waiter|) and test continues once the event is encountered.
+  drive::DriveIntegrationService* integration_service =
+      drive::DriveIntegrationServiceFactory::FindForProfile(profile);
+  DCHECK(integration_service);
+  DCHECK(integration_service->is_enabled());
+
+  if (integration_service->IsMounted())
+    return;
+
+  DriveMountPointWaiter mount_point_waiter(integration_service);
+  VLOG(1) << "Waiting for drive mount point to get mounted.";
+  mount_point_waiter.Wait();
+  VLOG(1) << "Drive mount point found.";
+}
+
+}  // namespace test_util
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/mount_test_util.h b/chrome/browser/file_manager/mount_test_util.h
new file mode 100644
index 0000000000000..3c8a19b7852fa
--- /dev/null
+++ b/chrome/browser/file_manager/mount_test_util.h
@@ -0,0 +1,21 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_MOUNT_TEST_UTIL_H_
+#define CHROME_BROWSER_FILE_MANAGER_MOUNT_TEST_UTIL_H_
+
+class Profile;
+
+namespace file_manager {
+namespace test_util {
+
+// Waits until Drive mount point for |profile| is added. Drive mount point is
+// added by the browser but tests should use this function to ensure that the
+// Drive mount point is added before accessing Drive.
+void WaitUntilDriveMountPointIsAdded(Profile* profile);
+
+}  // namespace test_util
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_MOUNT_TEST_UTIL_H_
diff --git a/chrome/browser/file_manager/open_util.cc b/chrome/browser/file_manager/open_util.cc
new file mode 100644
index 0000000000000..2600feefc430b
--- /dev/null
+++ b/chrome/browser/file_manager/open_util.cc
@@ -0,0 +1,214 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/open_util.h"
+
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/bind.h"
+#include "base/files/file_path.h"
+#include "base/logging.h"
+#include "base/metrics/user_metrics.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/file_tasks.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/path_util.h"
+#include "chrome/browser/file_manager/url_util.h"
+#include "chrome/browser/profiles/profile.h"
+#include "content/public/browser/browser_thread.h"
+#include "extensions/browser/api/file_handlers/directory_util.h"
+#include "extensions/browser/api/file_handlers/mime_util.h"
+#include "extensions/browser/entry_info.h"
+#include "storage/browser/fileapi/file_system_backend.h"
+#include "storage/browser/fileapi/file_system_context.h"
+#include "storage/browser/fileapi/file_system_operation_runner.h"
+#include "storage/browser/fileapi/file_system_url.h"
+
+using content::BrowserThread;
+using storage::FileSystemURL;
+
+namespace file_manager {
+namespace util {
+namespace {
+
+bool shell_operations_allowed = true;
+
+void IgnoreFileTaskExecuteResult(
+    extensions::api::file_manager_private::TaskResult result) {}
+
+// Executes the |task| for the file specified by |url|.
+void ExecuteFileTaskForUrl(Profile* profile,
+                           const file_tasks::TaskDescriptor& task,
+                           const GURL& url) {
+  if (!shell_operations_allowed)
+    return;
+  storage::FileSystemContext* file_system_context =
+      GetFileSystemContextForExtensionId(profile, kFileManagerAppId);
+
+  file_tasks::ExecuteFileTask(
+      profile,
+      GetFileManagerMainPageUrl(),  // Executing task on behalf of the Files
+                                    // app.
+      task, std::vector<FileSystemURL>(1, file_system_context->CrackURL(url)),
+      base::Bind(&IgnoreFileTaskExecuteResult));
+}
+
+// Opens the file manager for the specified |url|. Used to implement
+// internal handlers of special action IDs:
+//
+// "open" - Open the file manager for the given folder.
+// "select" - Open the file manager for the given file. The folder containing
+//            the file will be opened with the file selected.
+void OpenFileManagerWithInternalActionId(Profile* profile,
+                                         const GURL& url,
+                                         const std::string& action_id) {
+  DCHECK(action_id == "open" || action_id == "select");
+  if (!shell_operations_allowed)
+    return;
+  base::RecordAction(base::UserMetricsAction("ShowFileBrowserFullTab"));
+
+  file_tasks::TaskDescriptor task(kFileManagerAppId,
+                                  file_tasks::TASK_TYPE_FILE_BROWSER_HANDLER,
+                                  action_id);
+  ExecuteFileTaskForUrl(profile, task, url);
+}
+
+void OpenFileMimeTypeAfterTasksListed(
+    Profile* profile,
+    const GURL& url,
+    const platform_util::OpenOperationCallback& callback,
+    std::unique_ptr<std::vector<file_tasks::FullTaskDescriptor>> tasks) {
+  // Select a default handler. If a default handler is not available, select
+  // the first non-generic file handler.
+  const file_tasks::FullTaskDescriptor* chosen_task = nullptr;
+  for (const auto& task : *tasks) {
+    if (!task.is_generic_file_handler()) {
+      if (task.is_default()) {
+        chosen_task = &task;
+        break;
+      }
+      if (!chosen_task)
+        chosen_task = &task;
+    }
+  }
+
+  if (chosen_task != nullptr) {
+    if (shell_operations_allowed)
+      ExecuteFileTaskForUrl(profile, chosen_task->task_descriptor(), url);
+    callback.Run(platform_util::OPEN_SUCCEEDED);
+  } else {
+    callback.Run(platform_util::OPEN_FAILED_NO_HANLDER_FOR_FILE_TYPE);
+  }
+}
+
+// Opens the file with fetched MIME type and calls the callback.
+void OpenFileWithMimeType(Profile* profile,
+                          const base::FilePath& path,
+                          const GURL& url,
+                          const platform_util::OpenOperationCallback& callback,
+                          const std::string& mime_type) {
+  std::vector<extensions::EntryInfo> entries;
+  entries.emplace_back(path, mime_type, false);
+
+  std::vector<GURL> file_urls;
+  file_urls.push_back(url);
+
+  file_tasks::FindAllTypesOfTasks(
+      profile, drive::util::GetDriveAppRegistryByProfile(profile), entries,
+      file_urls,
+      base::Bind(&OpenFileMimeTypeAfterTasksListed, profile, url, callback));
+}
+
+// Opens the file specified by |url| by finding and executing a file task for
+// the file. Calls |callback| with the result.
+void OpenFile(Profile* profile,
+              const base::FilePath& path,
+              const GURL& url,
+              const platform_util::OpenOperationCallback& callback) {
+  extensions::app_file_handler_util::GetMimeTypeForLocalPath(
+      profile, path,
+      base::Bind(&OpenFileWithMimeType, profile, path, url, callback));
+}
+
+void OpenItemWithMetadata(Profile* profile,
+                          const base::FilePath& file_path,
+                          const GURL& url,
+                          platform_util::OpenItemType expected_type,
+                          const platform_util::OpenOperationCallback& callback,
+                          base::File::Error error,
+                          const base::File::Info& file_info) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  if (error != base::File::FILE_OK) {
+    callback.Run(error == base::File::FILE_ERROR_NOT_FOUND
+                     ? platform_util::OPEN_FAILED_PATH_NOT_FOUND
+                     : platform_util::OPEN_FAILED_FILE_ERROR);
+    return;
+  }
+
+  // Note that there exists a TOCTOU race between the time the metadata for
+  // |file_path| was determined and when it is opened based on the metadata.
+  if (expected_type == platform_util::OPEN_FOLDER && file_info.is_directory) {
+    OpenFileManagerWithInternalActionId(profile, url, "open");
+    callback.Run(platform_util::OPEN_SUCCEEDED);
+    return;
+  }
+
+  if (expected_type == platform_util::OPEN_FILE && !file_info.is_directory) {
+    OpenFile(profile, file_path, url, callback);
+    return;
+  }
+
+  callback.Run(platform_util::OPEN_FAILED_INVALID_TYPE);
+}
+
+}  // namespace
+
+void OpenItem(Profile* profile,
+              const base::FilePath& file_path,
+              platform_util::OpenItemType expected_type,
+              const platform_util::OpenOperationCallback& callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  // This is unfortunately necessary as file browser handlers operate on URLs.
+  GURL url;
+  if (!ConvertAbsoluteFilePathToFileSystemUrl(profile, file_path,
+                                              kFileManagerAppId, &url)) {
+    callback.Run(platform_util::OPEN_FAILED_PATH_NOT_FOUND);
+    return;
+  }
+
+  GetMetadataForPath(
+      GetFileSystemContextForExtensionId(profile, kFileManagerAppId), file_path,
+      storage::FileSystemOperation::GET_METADATA_FIELD_IS_DIRECTORY,
+      base::Bind(&OpenItemWithMetadata, profile, file_path, url, expected_type,
+                 callback));
+}
+
+void ShowItemInFolder(Profile* profile,
+                      const base::FilePath& file_path,
+                      const platform_util::OpenOperationCallback& callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  GURL url;
+  if (!ConvertAbsoluteFilePathToFileSystemUrl(profile, file_path,
+                                              kFileManagerAppId, &url)) {
+    callback.Run(platform_util::OPEN_FAILED_PATH_NOT_FOUND);
+    return;
+  }
+
+  // This action changes the selection so we do not reuse existing tabs.
+  OpenFileManagerWithInternalActionId(profile, url, "select");
+  callback.Run(platform_util::OPEN_SUCCEEDED);
+}
+
+void DisableShellOperationsForTesting() {
+  shell_operations_allowed = false;
+}
+
+}  // namespace util
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/open_util.h b/chrome/browser/file_manager/open_util.h
new file mode 100644
index 0000000000000..a035b2f9213d0
--- /dev/null
+++ b/chrome/browser/file_manager/open_util.h
@@ -0,0 +1,54 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides functions for opening an item (file or directory) using
+// the file manager.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_OPEN_UTIL_H_
+#define CHROME_BROWSER_FILE_MANAGER_OPEN_UTIL_H_
+
+#include "base/callback_forward.h"
+#include "chrome/browser/platform_util.h"
+
+class Profile;
+
+namespace base {
+class FilePath;
+}
+
+namespace file_manager {
+namespace util {
+
+// If |item_type| is OPEN_FILE: Opens an item using a file handler, a file
+// browser handler, or the browser (open in a tab). The default handler has
+// precedence over other handlers, if defined for the type of the target file.
+//
+// If |item_type| is OPEN_FOLDER: Open the directory at |file_path| using the
+// file browser.
+//
+// It is an error for |file_path| to not match the type implied by |item_type|.
+// This error will be reported to |callback|.
+//
+// If |callback| is null, shows an error message to the user indicating the
+// error if the operation is unsuccessful. No error messages will be displayed
+// if |callback| is non-null.
+void OpenItem(Profile* profile,
+              const base::FilePath& file_path,
+              platform_util::OpenItemType item_type,
+              const platform_util::OpenOperationCallback& callback);
+
+// Opens the file manager for the folder containing the item specified by
+// |file_path|, with the item selected.
+void ShowItemInFolder(Profile* profile,
+                      const base::FilePath& file_path,
+                      const platform_util::OpenOperationCallback& callback);
+
+// Change the behavior of the above functions to do everything except launch any
+// extensions including a file browser.
+void DisableShellOperationsForTesting();
+
+}  // namespace util
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_OPEN_UTIL_H_
diff --git a/chrome/browser/file_manager/open_with_browser.cc b/chrome/browser/file_manager/open_with_browser.cc
new file mode 100644
index 0000000000000..55fe7a834e359
--- /dev/null
+++ b/chrome/browser/file_manager/open_with_browser.cc
@@ -0,0 +1,226 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/open_with_browser.h"
+
+#include <stddef.h>
+
+#include "base/bind.h"
+#include "base/command_line.h"
+#include "base/logging.h"
+#include "base/macros.h"
+#include "base/path_service.h"
+#include "base/task/post_task.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/file_manager/filesystem_api_util.h"
+#include "chrome/browser/fileapi/external_file_url_util.h"
+#include "chrome/browser/plugins/plugin_prefs.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/browser/ui/ash/multi_user/multi_user_util.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/browser_tabstrip.h"
+#include "chrome/browser/ui/browser_window.h"
+#include "chrome/browser/ui/scoped_tabbed_browser_displayer.h"
+#include "chrome/common/chrome_content_client.h"
+#include "chrome/common/chrome_paths.h"
+#include "chrome/common/chrome_switches.h"
+#include "chromeos/components/drivefs/mojom/drivefs.mojom.h"
+#include "components/drive/drive_api_util.h"
+#include "components/drive/file_system_core_util.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/plugin_service.h"
+#include "content/public/common/pepper_plugin_info.h"
+#include "net/base/filename_util.h"
+
+using content::BrowserThread;
+using content::PluginService;
+
+namespace file_manager {
+namespace util {
+namespace {
+
+const base::FilePath::CharType kPdfExtension[] = FILE_PATH_LITERAL(".pdf");
+const base::FilePath::CharType kSwfExtension[] = FILE_PATH_LITERAL(".swf");
+
+// List of file extensions viewable in the browser.
+constexpr const base::FilePath::CharType* kFileExtensionsViewableInBrowser[] = {
+    FILE_PATH_LITERAL(".bmp"),   FILE_PATH_LITERAL(".ico"),
+    FILE_PATH_LITERAL(".jpg"),   FILE_PATH_LITERAL(".jpeg"),
+    FILE_PATH_LITERAL(".png"),   FILE_PATH_LITERAL(".webp"),
+    FILE_PATH_LITERAL(".gif"),   FILE_PATH_LITERAL(".txt"),
+    FILE_PATH_LITERAL(".html"),  FILE_PATH_LITERAL(".htm"),
+    FILE_PATH_LITERAL(".mhtml"), FILE_PATH_LITERAL(".mht"),
+    FILE_PATH_LITERAL(".xhtml"), FILE_PATH_LITERAL(".xht"),
+    FILE_PATH_LITERAL(".shtml"), FILE_PATH_LITERAL(".svg"),
+};
+
+// Returns true if |file_path| is viewable in the browser (ex. HTML file).
+bool IsViewableInBrowser(const base::FilePath& file_path) {
+  for (size_t i = 0; i < arraysize(kFileExtensionsViewableInBrowser); i++) {
+    if (file_path.MatchesExtension(kFileExtensionsViewableInBrowser[i]))
+      return true;
+  }
+  return false;
+}
+
+bool IsPepperPluginEnabled(Profile* profile,
+                           const base::FilePath& plugin_path) {
+  DCHECK(profile);
+
+  content::PepperPluginInfo* pepper_info =
+      PluginService::GetInstance()->GetRegisteredPpapiPluginInfo(plugin_path);
+  if (!pepper_info)
+    return false;
+
+  scoped_refptr<PluginPrefs> plugin_prefs = PluginPrefs::GetForProfile(profile);
+  if (!plugin_prefs.get())
+    return false;
+
+  return plugin_prefs->IsPluginEnabled(pepper_info->ToWebPluginInfo());
+}
+
+bool IsPdfPluginEnabled(Profile* profile) {
+  DCHECK(profile);
+
+  static const base::FilePath plugin_path(ChromeContentClient::kPDFPluginPath);
+  return IsPepperPluginEnabled(profile, plugin_path);
+}
+
+bool IsFlashPluginEnabled(Profile* profile) {
+  DCHECK(profile);
+
+  base::FilePath plugin_path(
+      base::CommandLine::ForCurrentProcess()->GetSwitchValueNative(
+          switches::kPpapiFlashPath));
+  if (plugin_path.empty())
+    base::PathService::Get(chrome::FILE_PEPPER_FLASH_PLUGIN, &plugin_path);
+  return IsPepperPluginEnabled(profile, plugin_path);
+}
+
+void OpenNewTab(Profile* profile, const GURL& url) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  // Check the validity of the pointer so that the closure from
+  // base::Bind(&OpenNewTab, profile) can be passed between threads.
+  if (!g_browser_process->profile_manager()->IsValidProfile(profile))
+    return;
+
+  chrome::ScopedTabbedBrowserDisplayer displayer(profile);
+  chrome::AddSelectedTabWithURL(displayer.browser(), url,
+      ui::PAGE_TRANSITION_LINK);
+
+  // Since the ScopedTabbedBrowserDisplayer does not guarantee that the
+  // browser will be shown on the active desktop, we ensure the visibility.
+  multi_user_util::MoveWindowToCurrentDesktop(
+      displayer.browser()->window()->GetNativeWindow());
+}
+
+// Reads the alternate URL from a GDoc file. When it fails, returns a file URL
+// for |file_path| as fallback.
+// Note that an alternate url is a URL to open a hosted document.
+GURL ReadUrlFromGDocAsync(const base::FilePath& file_path) {
+  GURL url = drive::util::ReadUrlFromGDocFile(file_path);
+  if (url.is_empty())
+    url = net::FilePathToFileURL(file_path);
+  return url;
+}
+
+// Parse a local file to extract the Docs url and open this url.
+void OpenGDocUrlFromFile(const base::FilePath& file_path, Profile* profile) {
+  base::PostTaskWithTraitsAndReplyWithResult(
+      FROM_HERE, {base::MayBlock()},
+      base::BindOnce(&ReadUrlFromGDocAsync, file_path),
+      base::BindOnce(&OpenNewTab, profile));
+}
+
+// Open a hosted GDoc, from a path hosted in DriveFS.
+void OpenHostedDriveFsFile(const base::FilePath& file_path,
+                           Profile* profile,
+                           drive::FileError error,
+                           drivefs::mojom::FileMetadataPtr metadata) {
+  if (error != drive::FILE_ERROR_OK)
+    return;
+  if (metadata->type != drivefs::mojom::FileMetadata::Type::kHosted) {
+    OpenGDocUrlFromFile(file_path, profile);
+    return;
+  }
+  GURL hosted_url(metadata->alternate_url);
+  if (!hosted_url.is_valid())
+    return;
+
+  OpenNewTab(profile, hosted_url);
+}
+
+}  // namespace
+
+bool OpenFileWithBrowser(Profile* profile,
+                         const storage::FileSystemURL& file_system_url) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(profile);
+
+  const base::FilePath file_path = file_system_url.path();
+
+  // For things supported natively by the browser, we should open it
+  // in a tab.
+  if (IsViewableInBrowser(file_path) ||
+      ShouldBeOpenedWithPlugin(profile, file_path.Extension())) {
+    // Use external file URL if it is provided for the file system.
+    GURL page_url = chromeos::FileSystemURLToExternalFileURL(file_system_url);
+    if (page_url.is_empty())
+      page_url = net::FilePathToFileURL(file_path);
+
+    OpenNewTab(profile, page_url);
+    return true;
+  }
+
+  if (drive::util::HasHostedDocumentExtension(file_path)) {
+    if (file_manager::util::IsUnderNonNativeLocalPath(profile, file_path)) {
+      // The file is on a non-native volume. Use external file URL. If the file
+      // is on the drive volume, ExternalFileURLRequestJob redirects the URL to
+      // drive's web interface. Otherwise (e.g. MTP, FSP), the file is just
+      // downloaded in a browser tab.
+      const GURL url =
+          chromeos::FileSystemURLToExternalFileURL(file_system_url);
+      DCHECK(!url.is_empty());
+      OpenNewTab(profile, url);
+    } else {
+      drive::DriveIntegrationService* integration_service =
+          drive::DriveIntegrationServiceFactory::FindForProfile(profile);
+      base::FilePath path;
+      if (integration_service && integration_service->IsMounted() &&
+          integration_service->GetDriveFsInterface() &&
+          integration_service->GetRelativeDrivePath(file_path, &path)) {
+        integration_service->GetDriveFsInterface()->GetMetadata(
+            path, false,
+            base::BindOnce(&OpenHostedDriveFsFile, file_path, profile));
+        return true;
+      }
+      OpenGDocUrlFromFile(file_path, profile);
+    }
+    return true;
+  }
+
+  // Failed to open the file of unknown type.
+  LOG(WARNING) << "Unknown file type: " << file_path.value();
+  return false;
+}
+
+// If a bundled plugin is enabled, we should open pdf/swf files in a tab.
+bool ShouldBeOpenedWithPlugin(
+    Profile* profile,
+    const base::FilePath::StringType& file_extension) {
+  DCHECK(profile);
+
+  const base::FilePath file_path =
+      base::FilePath::FromUTF8Unsafe("dummy").AddExtension(file_extension);
+  if (file_path.MatchesExtension(kPdfExtension))
+    return IsPdfPluginEnabled(profile);
+  if (file_path.MatchesExtension(kSwfExtension))
+    return IsFlashPluginEnabled(profile);
+  return false;
+}
+
+}  // namespace util
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/open_with_browser.h b/chrome/browser/file_manager/open_with_browser.h
new file mode 100644
index 0000000000000..79758d96d08c8
--- /dev/null
+++ b/chrome/browser/file_manager/open_with_browser.h
@@ -0,0 +1,42 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides utilities for opening files with the browser.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_OPEN_WITH_BROWSER_H_
+#define CHROME_BROWSER_FILE_MANAGER_OPEN_WITH_BROWSER_H_
+
+#include "base/files/file_path.h"
+
+class Profile;
+
+namespace storage {
+class FileSystemURL;
+}
+
+namespace file_manager {
+namespace util {
+
+// Opens the file specified by |file_path| with the browser for
+// |profile|. This function takes care of the following intricacies:
+//
+// - If there is no active browser window, open it.
+// - If the file is a Drive hosted document, the hosted document will be
+//   opened in the browser by extracting the right URL for the file.
+// - If the file is on Drive, the file will be downloaded from Drive as
+//   needed.
+//
+// Returns false if failed to open. This happens if the file type is unknown.
+bool OpenFileWithBrowser(Profile* profile,
+                         const storage::FileSystemURL& file_system_url);
+
+// Checks whether a pepper plugin for |file_extension| is enabled.
+bool ShouldBeOpenedWithPlugin(
+    Profile* profile,
+    const base::FilePath::StringType& file_extension);
+
+}  // namespace util
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_OPEN_WITH_BROWSER_H_
diff --git a/chrome/browser/file_manager/path_util.cc b/chrome/browser/file_manager/path_util.cc
new file mode 100644
index 0000000000000..54702646b58ba
--- /dev/null
+++ b/chrome/browser/file_manager/path_util.cc
@@ -0,0 +1,317 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/path_util.h"
+
+#include "base/barrier_closure.h"
+#include "base/base64.h"
+#include "base/logging.h"
+#include "base/strings/string_util.h"
+#include "base/sys_info.h"
+#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_root.h"
+#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_root_map.h"
+#include "chrome/browser/chromeos/arc/fileapi/chrome_content_provider_url_util.h"
+#include "chrome/browser/chromeos/crostini/crostini_util.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/fileapi/external_file_url_util.h"
+#include "chrome/browser/chromeos/profiles/profile_helper.h"
+#include "chrome/browser/download/download_prefs.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/grit/generated_resources.h"
+#include "components/drive/file_system_core_util.h"
+#include "components/user_manager/user.h"
+#include "components/user_manager/user_manager.h"
+#include "content/public/browser/browser_thread.h"
+#include "net/base/escape.h"
+#include "net/base/filename_util.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "url/gurl.h"
+
+namespace file_manager {
+namespace util {
+
+namespace {
+
+const char kDownloadsFolderName[] = "Downloads";
+const char kGoogleDriveDisplayName[] = "Google Drive";
+const char kRootRelativeToDriveMount[] = "root";
+
+// Sync with the file provider in ARC++ side.
+constexpr char kArcFileProviderUrl[] =
+    "content://org.chromium.arc.intent_helper.fileprovider/";
+// Sync with the root name defined with the file provider in ARC++ side.
+constexpr base::FilePath::CharType kArcDownloadRoot[] =
+    FILE_PATH_LITERAL("/download");
+constexpr base::FilePath::CharType kArcExternalFilesRoot[] =
+    FILE_PATH_LITERAL("/external_files");
+// Sync with the removable media provider in ARC++ side.
+constexpr char kArcRemovableMediaProviderUrl[] =
+    "content://org.chromium.arc.removablemediaprovider/";
+
+Profile* GetPrimaryProfile() {
+  if (!user_manager::UserManager::IsInitialized())
+    return nullptr;
+  const auto* primary_user = user_manager::UserManager::Get()->GetPrimaryUser();
+  if (!primary_user)
+    return nullptr;
+  return chromeos::ProfileHelper::Get()->GetProfileByUser(primary_user);
+}
+
+// Helper function for |ConvertToContentUrls|.
+void OnSingleContentUrlResolved(const base::RepeatingClosure& barrier_closure,
+                                std::vector<GURL>* out_urls,
+                                size_t index,
+                                const GURL& url) {
+  (*out_urls)[index] = url;
+  barrier_closure.Run();
+}
+
+// Helper function for |ConvertToContentUrls|.
+void OnAllContentUrlsResolved(ConvertToContentUrlsCallback callback,
+                              std::unique_ptr<std::vector<GURL>> urls) {
+  std::move(callback).Run(*urls);
+}
+
+}  // namespace
+
+const base::FilePath::CharType kRemovableMediaPath[] =
+    FILE_PATH_LITERAL("/media/removable");
+
+const base::FilePath::CharType kAndroidFilesPath[] =
+    FILE_PATH_LITERAL("/run/arc/sdcard/write/emulated/0");
+
+base::FilePath GetDownloadsFolderForProfile(Profile* profile) {
+  // On non-ChromeOS system (test+development), the primary profile uses
+  // $HOME/Downloads for ease for accessing local files for debugging.
+  if (!base::SysInfo::IsRunningOnChromeOS() &&
+      user_manager::UserManager::IsInitialized()) {
+    const user_manager::User* const user =
+        chromeos::ProfileHelper::Get()->GetUserByProfile(
+            profile->GetOriginalProfile());
+    const user_manager::User* const primary_user =
+        user_manager::UserManager::Get()->GetPrimaryUser();
+    if (user == primary_user)
+      return DownloadPrefs::GetDefaultDownloadDirectory();
+  }
+  return profile->GetPath().AppendASCII(kDownloadsFolderName);
+}
+
+bool MigratePathFromOldFormat(Profile* profile,
+                              const base::FilePath& old_path,
+                              base::FilePath* new_path) {
+  const base::FilePath old_base = DownloadPrefs::GetDefaultDownloadDirectory();
+  const base::FilePath new_base = GetDownloadsFolderForProfile(profile);
+
+  base::FilePath relative;
+  if (old_path == old_base ||
+      old_base.AppendRelativePath(old_path, &relative)) {
+    *new_path = new_base.Append(relative);
+    return old_path != *new_path;
+  }
+
+  return false;
+}
+
+std::string GetDownloadsMountPointName(Profile* profile) {
+  // To distinguish profiles in multi-profile session, we append user name hash
+  // to "Downloads". Note that some profiles (like login or test profiles)
+  // are not associated with an user account. In that case, no suffix is added
+  // because such a profile never belongs to a multi-profile session.
+  const user_manager::User* const user =
+      user_manager::UserManager::IsInitialized()
+          ? chromeos::ProfileHelper::Get()->GetUserByProfile(
+                profile->GetOriginalProfile())
+          : nullptr;
+  const std::string id = user ? "-" + user->username_hash() : "";
+  return net::EscapeQueryParamValue(kDownloadsFolderName + id, false);
+}
+
+std::string GetCrostiniMountPointName(Profile* profile) {
+  // crostini_<hash>_termina_penguin
+  return base::JoinString(
+      {"crostini", CryptohomeIdForProfile(profile), kCrostiniDefaultVmName,
+       kCrostiniDefaultContainerName},
+      "_");
+}
+
+base::FilePath GetCrostiniMountDirectory(Profile* profile) {
+  return base::FilePath("/media/fuse/" + GetCrostiniMountPointName(profile));
+}
+
+std::vector<std::string> GetCrostiniMountOptions(
+    const std::string& hostname,
+    const std::string& host_private_key,
+    const std::string& container_public_key) {
+  const std::string port = "2222";
+  std::vector<std::string> options;
+  std::string base64_known_hosts;
+  std::string base64_identity;
+  base::Base64Encode(host_private_key, &base64_identity);
+  base::Base64Encode(
+      base::StringPrintf("[%s]:%s %s", hostname.c_str(), port.c_str(),
+                         container_public_key.c_str()),
+      &base64_known_hosts);
+  options.push_back("UserKnownHostsBase64=" + base64_known_hosts);
+  options.push_back("IdentityBase64=" + base64_identity);
+  options.push_back("Port=" + port);
+  return options;
+}
+
+std::string ConvertFileSystemURLToPathInsideCrostini(
+    Profile* profile,
+    const storage::FileSystemURL& file_system_url) {
+  DCHECK(file_system_url.mount_type() == storage::kFileSystemTypeExternal);
+  DCHECK(file_system_url.type() == storage::kFileSystemTypeNativeLocal);
+
+  // Reformat virtual_path()
+  // from <mount_label>/path/to/file
+  // to   /<home-directory>/path/to/file
+  base::FilePath folder(util::GetCrostiniMountPointName(profile));
+  base::FilePath result = HomeDirectoryForProfile(profile);
+  bool success =
+      folder.AppendRelativePath(file_system_url.virtual_path(), &result);
+  DCHECK(success);
+  return result.AsUTF8Unsafe();
+}
+
+bool ConvertPathToArcUrl(const base::FilePath& path, GURL* arc_url_out) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  // Obtain the primary profile. This information is required because currently
+  // only the file systems for the primary profile is exposed to ARC.
+  Profile* primary_profile = GetPrimaryProfile();
+  if (!primary_profile)
+    return false;
+
+  // Convert paths under primary profile's Downloads directory.
+  base::FilePath primary_downloads =
+      GetDownloadsFolderForProfile(primary_profile);
+  base::FilePath result_path(kArcDownloadRoot);
+  if (primary_downloads.AppendRelativePath(path, &result_path)) {
+    *arc_url_out = GURL(kArcFileProviderUrl)
+                       .Resolve(net::EscapePath(result_path.AsUTF8Unsafe()));
+    return true;
+  }
+
+  // Convert paths under Android files root (/run/arc/sdcard/write/emulated/0).
+  result_path = base::FilePath(kArcExternalFilesRoot);
+  if (base::FilePath(kAndroidFilesPath)
+          .AppendRelativePath(path, &result_path)) {
+    *arc_url_out = GURL(kArcFileProviderUrl)
+                       .Resolve(net::EscapePath(result_path.AsUTF8Unsafe()));
+    return true;
+  }
+
+  // Convert paths under /media/removable.
+  base::FilePath relative_path;
+  if (base::FilePath(kRemovableMediaPath)
+          .AppendRelativePath(path, &relative_path)) {
+    *arc_url_out = GURL(kArcRemovableMediaProviderUrl)
+                       .Resolve(net::EscapePath(relative_path.AsUTF8Unsafe()));
+    return true;
+  }
+
+  // Convert paths under /special.
+  GURL external_file_url =
+      chromeos::CreateExternalFileURLFromPath(primary_profile, path);
+  if (!external_file_url.is_empty()) {
+    *arc_url_out = arc::EncodeToChromeContentProviderUrl(external_file_url);
+    return true;
+  }
+
+  // TODO(kinaba): Add conversion logic once other file systems are supported.
+  return false;
+}
+
+void ConvertToContentUrls(
+    const std::vector<storage::FileSystemURL>& file_system_urls,
+    ConvertToContentUrlsCallback callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  if (file_system_urls.empty()) {
+    std::move(callback).Run(std::vector<GURL>());
+    return;
+  }
+
+  Profile* profile = GetPrimaryProfile();
+  auto* documents_provider_root_map =
+      profile ? arc::ArcDocumentsProviderRootMap::GetForBrowserContext(profile)
+              : nullptr;
+
+  // To keep the original order, prefill |out_urls| with empty URLs and
+  // specify index when updating it like (*out_urls)[index] = url.
+  auto out_urls = std::make_unique<std::vector<GURL>>(file_system_urls.size());
+  auto* out_urls_ptr = out_urls.get();
+  auto barrier = base::BarrierClosure(
+      file_system_urls.size(),
+      base::BindOnce(&OnAllContentUrlsResolved, std::move(callback),
+                     std::move(out_urls)));
+  auto single_content_url_callback =
+      base::BindRepeating(&OnSingleContentUrlResolved, barrier, out_urls_ptr);
+
+  for (size_t index = 0; index < file_system_urls.size(); ++index) {
+    const auto& file_system_url = file_system_urls[index];
+    GURL arc_url;
+    if (file_system_url.mount_type() == storage::kFileSystemTypeExternal &&
+        ConvertPathToArcUrl(file_system_url.path(), &arc_url)) {
+      single_content_url_callback.Run(index, arc_url);
+      continue;
+    }
+
+    if (!documents_provider_root_map) {
+      single_content_url_callback.Run(index, GURL());
+      continue;
+    }
+
+    base::FilePath filepath;
+    auto* documents_provider_root =
+        documents_provider_root_map->ParseAndLookup(file_system_url, &filepath);
+    if (!documents_provider_root) {
+      single_content_url_callback.Run(index, GURL());
+      continue;
+    }
+
+    documents_provider_root->ResolveToContentUrl(
+        filepath, base::BindRepeating(single_content_url_callback, index));
+  }
+}
+
+bool ReplacePrefix(std::string* s,
+                   const std::string& prefix,
+                   const std::string& replacement) {
+  if (base::StartsWith(*s, prefix, base::CompareCase::SENSITIVE)) {
+    base::ReplaceFirstSubstringAfterOffset(s, 0, prefix, replacement);
+    return true;
+  }
+  return false;
+}
+
+std::string GetDownloadLocationText(Profile* profile, const std::string& path) {
+  std::string result(path);
+  if (ReplacePrefix(&result, "/home/chronos/user/Downloads",
+                    kDownloadsFolderName)) {
+  } else if (ReplacePrefix(&result,
+                           "/home/chronos/" +
+                               profile->GetPath().BaseName().value() +
+                               "/Downloads",
+                           kDownloadsFolderName)) {
+  } else if (ReplacePrefix(&result,
+                           drive::util::GetDriveMountPointPath(profile)
+                               .Append(kRootRelativeToDriveMount)
+                               .value(),
+                           kGoogleDriveDisplayName)) {
+  } else if (ReplacePrefix(&result, kAndroidFilesPath,
+                           l10n_util::GetStringUTF8(
+                               IDS_FILE_BROWSER_ANDROID_FILES_ROOT_LABEL))) {
+  } else if (ReplacePrefix(&result, GetCrostiniMountDirectory(profile).value(),
+                           l10n_util::GetStringUTF8(
+                               IDS_FILE_BROWSER_LINUX_FILES_ROOT_LABEL))) {
+  }
+
+  base::ReplaceChars(result, "/", " \u203a ", &result);
+  return result;
+}
+
+}  // namespace util
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/path_util.h b/chrome/browser/file_manager/path_util.h
new file mode 100644
index 0000000000000..6e8e8367111e7
--- /dev/null
+++ b/chrome/browser/file_manager/path_util.h
@@ -0,0 +1,96 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_PATH_UTIL_H_
+#define CHROME_BROWSER_FILE_MANAGER_PATH_UTIL_H_
+
+#include <string>
+
+#include "base/files/file_path.h"
+#include "storage/browser/fileapi/file_system_url.h"
+
+class GURL;
+class Profile;
+
+namespace file_manager {
+namespace util {
+
+// Absolute base path for removable media on Chrome OS. Exposed here so it can
+// be used by tests.
+extern const base::FilePath::CharType kRemovableMediaPath[];
+
+// Absolute path for the folder containing Android files.
+extern const base::FilePath::CharType kAndroidFilesPath[];
+
+// Gets the absolute path for the 'Downloads' folder for the |profile|.
+base::FilePath GetDownloadsFolderForProfile(Profile* profile);
+
+// Converts |old_path| to |new_path| and returns true, if the old path points
+// to an old location of user folders (in "Downloads" or "Google Drive").
+// The |profile| argument is used for determining the location of the
+// "Downloads" folder.
+//
+// As of now (M40), the conversion is used only during initialization of
+// download_prefs, where profile unaware initialization precedes profile
+// aware stage. Below are the list of relocations we have made in the past.
+//
+// M27: crbug.com/229304, for supporting {offline, recent, shared} folders
+//   in Drive. Migration code for this is removed in M34.
+// M34-35: crbug.com/313539, 356322, for supporting multi profiles.
+//   Migration code is removed in M40.
+bool MigratePathFromOldFormat(Profile* profile,
+                              const base::FilePath& old_path,
+                              base::FilePath* new_path);
+
+// The canonical mount point name for "Downloads" folder.
+std::string GetDownloadsMountPointName(Profile* profile);
+
+// The canonical mount point name for crostini "Linux files" folder.
+std::string GetCrostiniMountPointName(Profile* profile);
+
+// The actual directory the crostini "Linux files" folder is mounted.
+base::FilePath GetCrostiniMountDirectory(Profile* profile);
+
+// The sshfs mount options for crostini "Linux files" mount.
+std::vector<std::string> GetCrostiniMountOptions(
+    const std::string& hostname,
+    const std::string& host_private_key,
+    const std::string& container_public_key);
+
+// Convert a cracked url to a path inside the Crostini VM.
+std::string ConvertFileSystemURLToPathInsideCrostini(
+    Profile* profile,
+    const storage::FileSystemURL& file_system_url);
+
+// DEPRECATED. Use |ConvertToContentUrls| instead.
+// While this function can convert paths under Downloads, /media/removable
+// and /special/drive, this CANNOT convert paths under ARC media directories
+// (/special/arc-documents-provider).
+// TODO(crbug.com/811679): Migrate all callers and remove this.
+bool ConvertPathToArcUrl(const base::FilePath& path, GURL* arc_url_out);
+
+using ConvertToContentUrlsCallback =
+    base::OnceCallback<void(const std::vector<GURL>& content_urls)>;
+
+// Asynchronously converts Chrome OS file system URLs to content:// URLs.
+// Always returns a vector of the same size as |file_system_urls|.
+// Empty GURLs are filled in the vector if conversion fails.
+void ConvertToContentUrls(
+    const std::vector<storage::FileSystemURL>& file_system_urls,
+    ConvertToContentUrlsCallback callback);
+
+// Convert download location path into a string suitable for display.
+// Replacements:
+// * /home/chronos/user/Downloads                => Downloads
+// * /home/chronos/u-<hash>/Downloads            => Downloads
+// * /special/drive-<hash>/root                  => Google Drive
+// * /run/arc/sdcard/write/emulated/0            => Play files
+// * /media/fuse/crostini_<hash>_termina_penguin => Linux files
+// * '/' with ' \u203a ' (angled quote sign) for display purposes.
+std::string GetDownloadLocationText(Profile* profile, const std::string& path);
+
+}  // namespace util
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_PATH_UTIL_H_
diff --git a/chrome/browser/file_manager/path_util_unittest.cc b/chrome/browser/file_manager/path_util_unittest.cc
new file mode 100644
index 0000000000000..9e9c12eeb4cf9
--- /dev/null
+++ b/chrome/browser/file_manager/path_util_unittest.cc
@@ -0,0 +1,457 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/path_util.h"
+
+#include "base/files/file_path.h"
+#include "base/memory/ptr_util.h"
+#include "base/sys_info.h"
+#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_util.h"
+#include "chrome/browser/chromeos/arc/fileapi/arc_file_system_operation_runner.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/chromeos/login/users/fake_chrome_user_manager.h"
+#include "chrome/browser/chromeos/profiles/profile_helper.h"
+#include "chrome/browser/chromeos/scoped_set_running_on_chromeos_for_testing.h"
+#include "chrome/browser/download/download_prefs.h"
+#include "chrome/test/base/testing_browser_process.h"
+#include "chrome/test/base/testing_profile.h"
+#include "chrome/test/base/testing_profile_manager.h"
+#include "components/account_id/account_id.h"
+#include "components/arc/arc_bridge_service.h"
+#include "components/arc/arc_service_manager.h"
+#include "components/arc/test/connection_holder_util.h"
+#include "components/arc/test/fake_file_system_instance.h"
+#include "components/user_manager/scoped_user_manager.h"
+#include "content/public/test/test_browser_thread_bundle.h"
+#include "storage/browser/fileapi/external_mount_points.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+using storage::FileSystemURL;
+
+namespace file_manager {
+namespace util {
+namespace {
+
+const char kLsbRelease[] =
+    "CHROMEOS_RELEASE_NAME=Chrome OS\n"
+    "CHROMEOS_RELEASE_VERSION=1.2.3.4\n";
+
+TEST(FileManagerPathUtilTest, GetDownloadLocationText) {
+  content::TestBrowserThreadBundle thread_bundle;
+  TestingProfile profile(base::FilePath("/home/chronos/u-0123456789abcdef"));
+  EXPECT_EQ("Downloads",
+            GetDownloadLocationText(&profile, "/home/chronos/user/Downloads"));
+  EXPECT_EQ("Downloads",
+            GetDownloadLocationText(
+                &profile, "/home/chronos/u-0123456789abcdef/Downloads"));
+  EXPECT_EQ("Google Drive \u203a foo",
+            GetDownloadLocationText(
+                &profile, "/special/drive-0123456789abcdef/root/foo"));
+  EXPECT_EQ("Play files \u203a foo \u203a bar",
+            GetDownloadLocationText(
+                &profile, "/run/arc/sdcard/write/emulated/0/foo/bar"));
+  EXPECT_EQ("Linux files \u203a foo",
+            GetDownloadLocationText(
+                &profile,
+                "/media/fuse/crostini_0123456789abcdef_termina_penguin/foo"));
+}
+
+TEST(FileManagerPathUtilTest, MultiProfileDownloadsFolderMigration) {
+  content::TestBrowserThreadBundle thread_bundle;
+  TestingProfile profile;
+  // MigratePathFromOldFormat is explicitly disabled on Linux build.
+  // So we need to fake that this is real ChromeOS system.
+  chromeos::ScopedSetRunningOnChromeOSForTesting fake_release(kLsbRelease,
+                                                              base::Time());
+
+  // This looks like "/home/chronos/u-hash/Downloads" in the production
+  // environment.
+  const base::FilePath kDownloads = GetDownloadsFolderForProfile(&profile);
+  const base::FilePath kOldDownloads =
+      DownloadPrefs::GetDefaultDownloadDirectory();
+
+  base::FilePath path;
+
+  EXPECT_TRUE(MigratePathFromOldFormat(&profile, kOldDownloads, &path));
+  EXPECT_EQ(kDownloads, path);
+
+  EXPECT_TRUE(MigratePathFromOldFormat(
+      &profile,
+      kOldDownloads.AppendASCII("a/b"),
+      &path));
+  EXPECT_EQ(kDownloads.AppendASCII("a/b"), path);
+
+  // Path already in the new format is not converted.
+  EXPECT_FALSE(MigratePathFromOldFormat(
+      &profile,
+      kDownloads.AppendASCII("a/b"),
+      &path));
+
+  // Only the "Downloads" path is converted.
+  EXPECT_FALSE(MigratePathFromOldFormat(
+      &profile,
+      base::FilePath::FromUTF8Unsafe("/home/chronos/user/dl"),
+      &path));
+}
+
+std::unique_ptr<KeyedService> CreateFileSystemOperationRunnerForTesting(
+    content::BrowserContext* context) {
+  return arc::ArcFileSystemOperationRunner::CreateForTesting(
+      context, arc::ArcServiceManager::Get()->arc_bridge_service());
+}
+
+class FileManagerPathUtilConvertUrlTest : public testing::Test {
+ public:
+  FileManagerPathUtilConvertUrlTest() = default;
+  ~FileManagerPathUtilConvertUrlTest() override = default;
+
+  void SetUp() override {
+    profile_manager_ = std::make_unique<TestingProfileManager>(
+        TestingBrowserProcess::GetGlobal());
+    ASSERT_TRUE(profile_manager_->SetUp());
+
+    // Set up fake user manager.
+    chromeos::FakeChromeUserManager* fake_user_manager =
+        new chromeos::FakeChromeUserManager();
+    const AccountId account_id(
+        AccountId::FromUserEmailGaiaId("user@gmail.com", "1111111111"));
+    const AccountId account_id_2(
+        AccountId::FromUserEmailGaiaId("user2@gmail.com", "2222222222"));
+    fake_user_manager->AddUser(account_id);
+    fake_user_manager->LoginUser(account_id);
+    fake_user_manager->AddUser(account_id_2);
+    fake_user_manager->LoginUser(account_id_2);
+    user_manager_enabler_ = std::make_unique<user_manager::ScopedUserManager>(
+        base::WrapUnique(std::move(fake_user_manager)));
+
+    Profile* primary_profile =
+        profile_manager_->CreateTestingProfile("user@gmail.com");
+    ASSERT_TRUE(primary_profile);
+    ASSERT_TRUE(profile_manager_->CreateTestingProfile("user2@gmail.com"));
+
+    // Set up an Arc service manager with a fake file system.
+    arc_service_manager_ = std::make_unique<arc::ArcServiceManager>();
+    arc_service_manager_->set_browser_context(primary_profile);
+    arc::ArcFileSystemOperationRunner::GetFactory()->SetTestingFactoryAndUse(
+        primary_profile, &CreateFileSystemOperationRunnerForTesting);
+    arc_service_manager_->arc_bridge_service()->file_system()->SetInstance(
+        &fake_file_system_);
+    arc::WaitForInstanceReady(
+        arc_service_manager_->arc_bridge_service()->file_system());
+    ASSERT_TRUE(fake_file_system_.InitCalled());
+
+    // Add a drive mount point for the primary profile.
+    drive_mount_point_ = drive::util::GetDriveMountPointPath(primary_profile);
+    const std::string mount_name = drive_mount_point_.BaseName().AsUTF8Unsafe();
+    storage::ExternalMountPoints::GetSystemInstance()->RegisterFileSystem(
+        mount_name, storage::kFileSystemTypeDrive,
+        storage::FileSystemMountOption(), drive_mount_point_);
+  }
+
+  void TearDown() override {
+    arc_service_manager_->arc_bridge_service()->file_system()->CloseInstance(
+        &fake_file_system_);
+    user_manager_enabler_.reset();
+    profile_manager_.reset();
+
+    // Run all pending tasks before destroying testing profile.
+    base::RunLoop().RunUntilIdle();
+  }
+
+ protected:
+  content::TestBrowserThreadBundle thread_bundle_;
+  arc::FakeFileSystemInstance fake_file_system_;
+  std::unique_ptr<TestingProfileManager> profile_manager_;
+  std::unique_ptr<user_manager::ScopedUserManager> user_manager_enabler_;
+  std::unique_ptr<arc::ArcServiceManager> arc_service_manager_;
+  base::FilePath drive_mount_point_;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPathUtilConvertUrlTest);
+};
+
+FileSystemURL CreateExternalURL(const base::FilePath& path) {
+  return FileSystemURL::CreateForTest(GURL(), storage::kFileSystemTypeExternal,
+                                      path);
+}
+
+TEST_F(FileManagerPathUtilConvertUrlTest, ConvertPathToArcUrl_Removable) {
+  GURL url;
+  EXPECT_TRUE(ConvertPathToArcUrl(
+      base::FilePath::FromUTF8Unsafe("/media/removable/a/b/c"), &url));
+  EXPECT_EQ(GURL("content://org.chromium.arc.removablemediaprovider/a/b/c"),
+            url);
+}
+
+TEST_F(FileManagerPathUtilConvertUrlTest,
+       ConvertPathToArcUrl_InvalidRemovable) {
+  GURL url;
+  EXPECT_FALSE(ConvertPathToArcUrl(
+      base::FilePath::FromUTF8Unsafe("/media/removable_foobar"), &url));
+}
+
+TEST_F(FileManagerPathUtilConvertUrlTest, ConvertPathToArcUrl_Downloads) {
+  // Conversion of paths under the primary profile's downloads folder.
+  GURL url;
+  const base::FilePath downloads = GetDownloadsFolderForProfile(
+      chromeos::ProfileHelper::Get()->GetProfileByUserIdHashForTest(
+          "user@gmail.com-hash"));
+  EXPECT_TRUE(ConvertPathToArcUrl(downloads.AppendASCII("a/b/c"), &url));
+  EXPECT_EQ(GURL("content://org.chromium.arc.intent_helper.fileprovider/"
+                 "download/a/b/c"),
+            url);
+}
+
+TEST_F(FileManagerPathUtilConvertUrlTest,
+       ConvertPathToArcUrl_InvalidDownloads) {
+  // Non-primary profile's downloads folder is not supported for ARC yet.
+  GURL url;
+  const base::FilePath downloads2 = GetDownloadsFolderForProfile(
+      chromeos::ProfileHelper::Get()->GetProfileByUserIdHashForTest(
+          "user2@gmail.com-hash"));
+  EXPECT_FALSE(ConvertPathToArcUrl(downloads2.AppendASCII("a/b/c"), &url));
+}
+
+TEST_F(FileManagerPathUtilConvertUrlTest, ConvertPathToArcUrl_Special) {
+  GURL url;
+  EXPECT_TRUE(
+      ConvertPathToArcUrl(drive_mount_point_.AppendASCII("a/b/c"), &url));
+  // "@" appears escaped 3 times here because escaping happens when:
+  // - creating drive mount point name for user
+  // - creating externalfile: URL from the path
+  // - encoding the URL to Chrome content provider URL
+  EXPECT_EQ(GURL("content://org.chromium.arc.chromecontentprovider/"
+                 "externalfile%3Adrive-user%252540gmail.com-hash%2Fa%2Fb%2Fc"),
+            url);
+}
+
+TEST_F(FileManagerPathUtilConvertUrlTest,
+       ConvertToContentUrls_InvalidMountType) {
+  base::RunLoop run_loop;
+  ConvertToContentUrls(
+      std::vector<FileSystemURL>{FileSystemURL::CreateForTest(
+          GURL(), storage::kFileSystemTypeTest,
+          base::FilePath::FromUTF8Unsafe("/media/removable/a/b/c"))},
+      base::BindOnce(
+          [](base::RunLoop* run_loop, const std::vector<GURL>& urls) {
+            run_loop->Quit();
+            ASSERT_EQ(1U, urls.size());
+            EXPECT_EQ(GURL(), urls[0]);
+          },
+          &run_loop));
+  run_loop.Run();
+}
+
+TEST_F(FileManagerPathUtilConvertUrlTest, ConvertToContentUrls_Removable) {
+  base::RunLoop run_loop;
+  ConvertToContentUrls(
+      std::vector<FileSystemURL>{CreateExternalURL(
+          base::FilePath::FromUTF8Unsafe("/media/removable/a/b/c"))},
+      base::BindOnce(
+          [](base::RunLoop* run_loop, const std::vector<GURL>& urls) {
+            run_loop->Quit();
+            ASSERT_EQ(1U, urls.size());
+            EXPECT_EQ(
+                GURL("content://org.chromium.arc.removablemediaprovider/a/b/c"),
+                urls[0]);
+          },
+          &run_loop));
+  run_loop.Run();
+}
+
+TEST_F(FileManagerPathUtilConvertUrlTest,
+       ConvertToContentUrls_InvalidRemovable) {
+  base::RunLoop run_loop;
+  ConvertToContentUrls(
+      std::vector<FileSystemURL>{CreateExternalURL(
+          base::FilePath::FromUTF8Unsafe("/media/removable_foobar"))},
+      base::BindOnce(
+          [](base::RunLoop* run_loop, const std::vector<GURL>& urls) {
+            run_loop->Quit();
+            ASSERT_EQ(1U, urls.size());
+            EXPECT_EQ(GURL(), urls[0]);
+          },
+          &run_loop));
+  run_loop.Run();
+}
+
+TEST_F(FileManagerPathUtilConvertUrlTest, ConvertToContentUrls_Downloads) {
+  const base::FilePath downloads = GetDownloadsFolderForProfile(
+      chromeos::ProfileHelper::Get()->GetProfileByUserIdHashForTest(
+          "user@gmail.com-hash"));
+  base::RunLoop run_loop;
+  ConvertToContentUrls(
+      std::vector<FileSystemURL>{
+          CreateExternalURL(downloads.AppendASCII("a/b/c"))},
+      base::BindOnce(
+          [](base::RunLoop* run_loop, const std::vector<GURL>& urls) {
+            run_loop->Quit();
+            ASSERT_EQ(1U, urls.size());
+            EXPECT_EQ(
+                GURL("content://org.chromium.arc.intent_helper.fileprovider/"
+                     "download/a/b/c"),
+                urls[0]);
+          },
+          &run_loop));
+  run_loop.Run();
+}
+
+TEST_F(FileManagerPathUtilConvertUrlTest,
+       ConvertToContentUrls_InvalidDownloads) {
+  const base::FilePath downloads = GetDownloadsFolderForProfile(
+      chromeos::ProfileHelper::Get()->GetProfileByUserIdHashForTest(
+          "user2@gmail.com-hash"));
+  base::RunLoop run_loop;
+  ConvertToContentUrls(
+      std::vector<FileSystemURL>{
+          CreateExternalURL(downloads.AppendASCII("a/b/c"))},
+      base::BindOnce(
+          [](base::RunLoop* run_loop, const std::vector<GURL>& urls) {
+            run_loop->Quit();
+            ASSERT_EQ(1U, urls.size());
+            EXPECT_EQ(GURL(), urls[0]);
+          },
+          &run_loop));
+  run_loop.Run();
+}
+
+TEST_F(FileManagerPathUtilConvertUrlTest, ConvertToContentUrls_Special) {
+  base::RunLoop run_loop;
+  ConvertToContentUrls(
+      std::vector<FileSystemURL>{
+          CreateExternalURL(drive_mount_point_.AppendASCII("a/b/c"))},
+      base::BindOnce(
+          [](base::RunLoop* run_loop, const std::vector<GURL>& urls) {
+            run_loop->Quit();
+            ASSERT_EQ(1U, urls.size());
+            EXPECT_EQ(GURL("content://org.chromium.arc.chromecontentprovider/"
+                           "externalfile%3Adrive-user%252540gmail.com-hash%2Fa%"
+                           "2Fb%2Fc"),
+                      urls[0]);
+          },
+          &run_loop));
+  run_loop.Run();
+}
+
+TEST_F(FileManagerPathUtilConvertUrlTest,
+       ConvertToContentUrls_ArcDocumentsProvider) {
+  // Add images_root/Download/photo.jpg to the fake file system.
+  const char kAuthority[] = "com.android.providers.media.documents";
+  fake_file_system_.AddDocument(arc::FakeFileSystemInstance::Document(
+      kAuthority, "images_root", "", "", arc::kAndroidDirectoryMimeType, -1,
+      0));
+  fake_file_system_.AddDocument(arc::FakeFileSystemInstance::Document(
+      kAuthority, "dir-id", "images_root", "Download",
+      arc::kAndroidDirectoryMimeType, -1, 22));
+  fake_file_system_.AddDocument(arc::FakeFileSystemInstance::Document(
+      kAuthority, "photo-id", "dir-id", "photo.jpg", "image/jpeg", 3, 33));
+
+  base::RunLoop run_loop;
+  ConvertToContentUrls(
+      std::vector<FileSystemURL>{FileSystemURL::CreateForTest(
+          GURL(), storage::kFileSystemTypeArcDocumentsProvider,
+          base::FilePath::FromUTF8Unsafe(
+              "/special/arc-documents-provider/"
+              "com.android.providers.media.documents/"
+              "images_root/Download/photo.jpg"))},
+      base::BindOnce(
+          [](base::RunLoop* run_loop, const std::vector<GURL>& urls) {
+            run_loop->Quit();
+            ASSERT_EQ(1U, urls.size());
+            EXPECT_EQ(GURL("content://com.android.providers.media.documents/"
+                           "document/photo-id"),
+                      urls[0]);
+          },
+          &run_loop));
+  run_loop.Run();
+}
+
+TEST_F(FileManagerPathUtilConvertUrlTest,
+       ConvertToContentUrls_ArcDocumentsProviderFileNotFound) {
+  base::RunLoop run_loop;
+  ConvertToContentUrls(
+      std::vector<FileSystemURL>{FileSystemURL::CreateForTest(
+          GURL(), storage::kFileSystemTypeArcDocumentsProvider,
+          base::FilePath::FromUTF8Unsafe(
+              "/special/arc-documents-provider/"
+              "com.android.providers.media.documents/"
+              "images_root/Download/photo.jpg"))},
+      base::BindOnce(
+          [](base::RunLoop* run_loop, const std::vector<GURL>& urls) {
+            run_loop->Quit();
+            ASSERT_EQ(1U, urls.size());
+            EXPECT_EQ(GURL(""), urls[0]);
+          },
+          &run_loop));
+  run_loop.Run();
+}
+
+TEST_F(FileManagerPathUtilConvertUrlTest, ConvertToContentUrls_AndroidFiles) {
+  base::RunLoop run_loop;
+  ConvertToContentUrls(
+      std::vector<FileSystemURL>{
+          CreateExternalURL(base::FilePath::FromUTF8Unsafe(
+              "/run/arc/sdcard/write/emulated/0/Pictures/a/b.jpg"))},
+      base::BindOnce(
+          [](base::RunLoop* run_loop, const std::vector<GURL>& urls) {
+            run_loop->Quit();
+            ASSERT_EQ(1U, urls.size());
+            EXPECT_EQ(
+                GURL("content://org.chromium.arc.intent_helper.fileprovider/"
+                     "external_files/Pictures/a/b.jpg"),
+                urls[0]);
+          },
+          &run_loop));
+}
+
+TEST_F(FileManagerPathUtilConvertUrlTest,
+       ConvertToContentUrls_InvalidAndroidFiles) {
+  base::RunLoop run_loop;
+  ConvertToContentUrls(
+      std::vector<FileSystemURL>{
+          CreateExternalURL(base::FilePath::FromUTF8Unsafe(
+              "/run/arc/sdcard/read/emulated/0/a/b/c"))},
+      base::BindOnce(
+          [](base::RunLoop* run_loop, const std::vector<GURL>& urls) {
+            run_loop->Quit();
+            ASSERT_EQ(1U, urls.size());
+            EXPECT_EQ(GURL(), urls[0]);  // Invalid URL.
+          },
+          &run_loop));
+}
+
+TEST_F(FileManagerPathUtilConvertUrlTest, ConvertToContentUrls_MultipleUrls) {
+  base::RunLoop run_loop;
+  ConvertToContentUrls(
+      std::vector<FileSystemURL>{
+          CreateExternalURL(base::FilePath::FromUTF8Unsafe("/invalid")),
+          CreateExternalURL(
+              base::FilePath::FromUTF8Unsafe("/media/removable/a/b/c")),
+          CreateExternalURL(drive_mount_point_.AppendASCII("a/b/c")),
+          CreateExternalURL(base::FilePath::FromUTF8Unsafe(
+              "/run/arc/sdcard/write/emulated/0/a/b/c"))},
+      base::BindOnce(
+          [](base::RunLoop* run_loop, const std::vector<GURL>& urls) {
+            run_loop->Quit();
+            ASSERT_EQ(4U, urls.size());
+            EXPECT_EQ(GURL(), urls[0]);  // Invalid URL.
+            EXPECT_EQ(
+                GURL("content://org.chromium.arc.removablemediaprovider/a/b/c"),
+                urls[1]);
+            EXPECT_EQ(GURL("content://org.chromium.arc.chromecontentprovider/"
+                           "externalfile%3Adrive-user%252540gmail.com-hash%2Fa%"
+                           "2Fb%2Fc"),
+                      urls[2]);
+            EXPECT_EQ(
+                GURL("content://org.chromium.arc.intent_helper.fileprovider/"
+                     "external_files/a/b/c"),
+                urls[3]);
+          },
+          &run_loop));
+  run_loop.Run();
+}
+
+}  // namespace
+}  // namespace util
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/select_file_dialog_util.cc b/chrome/browser/file_manager/select_file_dialog_util.cc
new file mode 100644
index 0000000000000..328e54e99509f
--- /dev/null
+++ b/chrome/browser/file_manager/select_file_dialog_util.cc
@@ -0,0 +1,52 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/select_file_dialog_util.h"
+
+#include "chrome/grit/generated_resources.h"
+#include "ui/base/l10n/l10n_util.h"
+
+namespace file_manager {
+namespace util {
+
+base::string16 GetSelectFileDialogTitle(
+    ui::SelectFileDialog::Type dialog_type) {
+  base::string16 title;
+  switch (dialog_type) {
+    case ui::SelectFileDialog::SELECT_NONE:
+      // Full page file manager doesn't need a title.
+      break;
+
+    case ui::SelectFileDialog::SELECT_FOLDER:
+    case ui::SelectFileDialog::SELECT_EXISTING_FOLDER:
+      title = l10n_util::GetStringUTF16(
+          IDS_FILE_BROWSER_SELECT_FOLDER_TITLE);
+      break;
+
+    case ui::SelectFileDialog::SELECT_UPLOAD_FOLDER:
+      title = l10n_util::GetStringUTF16(
+          IDS_FILE_BROWSER_SELECT_UPLOAD_FOLDER_TITLE);
+      break;
+
+    case ui::SelectFileDialog::SELECT_SAVEAS_FILE:
+      title = l10n_util::GetStringUTF16(
+          IDS_FILE_BROWSER_SELECT_SAVEAS_FILE_TITLE);
+      break;
+
+    case ui::SelectFileDialog::SELECT_OPEN_FILE:
+      title = l10n_util::GetStringUTF16(
+          IDS_FILE_BROWSER_SELECT_OPEN_FILE_TITLE);
+      break;
+
+    case ui::SelectFileDialog::SELECT_OPEN_MULTI_FILE:
+      title = l10n_util::GetStringUTF16(
+          IDS_FILE_BROWSER_SELECT_OPEN_MULTI_FILE_TITLE);
+      break;
+  }
+
+  return title;
+}
+
+}  // namespace util
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/select_file_dialog_util.h b/chrome/browser/file_manager/select_file_dialog_util.h
new file mode 100644
index 0000000000000..9aff9a34174d6
--- /dev/null
+++ b/chrome/browser/file_manager/select_file_dialog_util.h
@@ -0,0 +1,21 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides utilities related to the select file dialog.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_SELECT_FILE_DIALOG_UTIL_H_
+#define CHROME_BROWSER_FILE_MANAGER_SELECT_FILE_DIALOG_UTIL_H_
+
+#include "ui/shell_dialogs/select_file_dialog.h"
+
+namespace file_manager {
+namespace util {
+
+// Get file dialog title string from its type.
+base::string16 GetSelectFileDialogTitle(ui::SelectFileDialog::Type type);
+
+}  // namespace util
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_SELECT_FILE_DIALOG_UTIL_H_
diff --git a/chrome/browser/file_manager/snapshot_manager.cc b/chrome/browser/file_manager/snapshot_manager.cc
new file mode 100644
index 0000000000000..8cdd839eb1f63
--- /dev/null
+++ b/chrome/browser/file_manager/snapshot_manager.cc
@@ -0,0 +1,212 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/snapshot_manager.h"
+
+#include <utility>
+
+#include "base/bind.h"
+#include "base/containers/circular_deque.h"
+#include "base/sys_info.h"
+#include "base/task/post_task.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/profiles/profile.h"
+#include "content/public/browser/browser_thread.h"
+#include "google_apis/drive/task_util.h"
+#include "storage/browser/blob/shareable_file_reference.h"
+#include "storage/browser/fileapi/file_system_context.h"
+#include "third_party/cros_system_api/constants/cryptohome.h"
+
+namespace file_manager {
+namespace {
+
+typedef base::Callback<void(int64_t)> GetNecessaryFreeSpaceCallback;
+
+// Part of ComputeSpaceNeedToBeFreed.
+int64_t ComputeSpaceNeedToBeFreedAfterGetMetadataAsync(
+    const base::FilePath& path,
+    int64_t snapshot_size) {
+  int64_t free_size = base::SysInfo::AmountOfFreeDiskSpace(path);
+  if (free_size < 0)
+    return -1;
+
+  // We need to keep cryptohome::kMinFreeSpaceInBytes free space even after
+  // |snapshot_size| is occupied.
+  free_size -= snapshot_size + cryptohome::kMinFreeSpaceInBytes;
+  return (free_size < 0 ? -free_size : 0);
+}
+
+// Part of ComputeSpaceNeedToBeFreed.
+void ComputeSpaceNeedToBeFreedAfterGetMetadata(
+    const base::FilePath& path,
+    const GetNecessaryFreeSpaceCallback& callback,
+    base::File::Error result,
+    const base::File::Info& file_info) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+  if (result != base::File::FILE_OK) {
+    callback.Run(-1);
+    return;
+  }
+
+  base::PostTaskWithTraitsAndReplyWithResult(
+      FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_BLOCKING},
+      base::Bind(&ComputeSpaceNeedToBeFreedAfterGetMetadataAsync, path,
+                 file_info.size),
+      callback);
+}
+
+// Part of ComputeSpaceNeedToBeFreed.
+void GetMetadataOnIOThread(const base::FilePath& path,
+                           scoped_refptr<storage::FileSystemContext> context,
+                           const storage::FileSystemURL& url,
+                           const GetNecessaryFreeSpaceCallback& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+  context->operation_runner()->GetMetadata(
+      url, storage::FileSystemOperation::GET_METADATA_FIELD_SIZE,
+      base::Bind(&ComputeSpaceNeedToBeFreedAfterGetMetadata, path, callback));
+}
+
+// Computes the size of space that need to be __additionally__ made available
+// in the |profile|'s data directory for taking the snapshot of |url|.
+// Returns 0 if no additional space is required, or -1 in the case of an error.
+void ComputeSpaceNeedToBeFreed(
+    Profile* profile,
+    scoped_refptr<storage::FileSystemContext> context,
+    const storage::FileSystemURL& url,
+    const GetNecessaryFreeSpaceCallback& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  content::BrowserThread::PostTask(
+      content::BrowserThread::IO, FROM_HERE,
+      base::BindOnce(&GetMetadataOnIOThread, profile->GetPath(), context, url,
+                     google_apis::CreateRelayCallback(callback)));
+}
+
+// Part of CreateManagedSnapshot. Runs CreateSnapshotFile method of fileapi.
+void CreateSnapshotFileOnIOThread(
+    scoped_refptr<storage::FileSystemContext> context,
+    const storage::FileSystemURL& url,
+    storage::FileSystemOperation::SnapshotFileCallback callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+  context->operation_runner()->CreateSnapshotFile(url, std::move(callback));
+}
+
+// Utility for destructing the bound |file_refs| on IO thread. This is meant
+// to be used together with base::Bind. After this function finishes, the
+// Bind callback should destruct the bound argument.
+void FreeReferenceOnIOThread(
+    const base::circular_deque<SnapshotManager::FileReferenceWithSizeInfo>&
+        file_refs) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+}
+
+}  // namespace
+
+SnapshotManager::FileReferenceWithSizeInfo::FileReferenceWithSizeInfo(
+    scoped_refptr<storage::ShareableFileReference> ref,
+    int64_t size)
+    : file_ref(ref), file_size(size) {}
+
+SnapshotManager::FileReferenceWithSizeInfo::FileReferenceWithSizeInfo(
+    const FileReferenceWithSizeInfo& other) = default;
+
+SnapshotManager::FileReferenceWithSizeInfo::~FileReferenceWithSizeInfo() =
+    default;
+
+SnapshotManager::SnapshotManager(Profile* profile)
+    : profile_(profile), weak_ptr_factory_(this) {
+}
+
+SnapshotManager::~SnapshotManager() {
+  if (!file_refs_.empty()) {
+    bool posted = content::BrowserThread::PostTask(
+        content::BrowserThread::IO, FROM_HERE,
+        base::BindOnce(&FreeReferenceOnIOThread, file_refs_));
+    DCHECK(posted);
+  }
+}
+
+void SnapshotManager::CreateManagedSnapshot(
+    const base::FilePath& absolute_file_path,
+    const LocalPathCallback& callback) {
+  scoped_refptr<storage::FileSystemContext> context(
+      util::GetFileSystemContextForExtensionId(profile_, kFileManagerAppId));
+  DCHECK(context.get());
+
+  GURL url;
+  if (!util::ConvertAbsoluteFilePathToFileSystemUrl(
+          profile_, absolute_file_path, kFileManagerAppId, &url)) {
+    callback.Run(base::FilePath());
+    return;
+  }
+  storage::FileSystemURL filesystem_url = context->CrackURL(url);
+
+  ComputeSpaceNeedToBeFreed(profile_, context, filesystem_url,
+      base::Bind(&SnapshotManager::CreateManagedSnapshotAfterSpaceComputed,
+                 weak_ptr_factory_.GetWeakPtr(),
+                 filesystem_url,
+                 callback));
+}
+
+void SnapshotManager::CreateManagedSnapshotAfterSpaceComputed(
+    const storage::FileSystemURL& filesystem_url,
+    const LocalPathCallback& callback,
+    int64_t needed_space) {
+  scoped_refptr<storage::FileSystemContext> context(
+      util::GetFileSystemContextForExtensionId(profile_, kFileManagerAppId));
+  DCHECK(context.get());
+
+  if (needed_space < 0) {
+    callback.Run(base::FilePath());
+    return;
+  }
+
+  // Free up to the required size.
+  base::circular_deque<FileReferenceWithSizeInfo> to_free;
+  while (needed_space > 0 && !file_refs_.empty()) {
+    needed_space -= file_refs_.front().file_size;
+    to_free.push_back(file_refs_.front());
+    file_refs_.pop_front();
+  }
+  if (!to_free.empty()) {
+    bool posted = content::BrowserThread::PostTask(
+        content::BrowserThread::IO, FROM_HERE,
+        base::BindOnce(&FreeReferenceOnIOThread, to_free));
+    DCHECK(posted);
+  }
+
+  // If we still could not achieve the space requirement, abort with failure.
+  if (needed_space > 0) {
+    callback.Run(base::FilePath());
+    return;
+  }
+
+  // Start creating the snapshot.
+  content::BrowserThread::PostTask(
+      content::BrowserThread::IO, FROM_HERE,
+      base::BindOnce(&CreateSnapshotFileOnIOThread, context, filesystem_url,
+                     google_apis::CreateRelayCallback(base::Bind(
+                         &SnapshotManager::OnCreateSnapshotFile,
+                         weak_ptr_factory_.GetWeakPtr(), callback))));
+}
+
+void SnapshotManager::OnCreateSnapshotFile(
+    const LocalPathCallback& callback,
+    base::File::Error result,
+    const base::File::Info& file_info,
+    const base::FilePath& platform_path,
+    scoped_refptr<storage::ShareableFileReference> file_ref) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  if (result != base::File::FILE_OK) {
+    callback.Run(base::FilePath());
+    return;
+  }
+
+  file_refs_.push_back(
+      FileReferenceWithSizeInfo(std::move(file_ref), file_info.size));
+  callback.Run(platform_path);
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/snapshot_manager.h b/chrome/browser/file_manager/snapshot_manager.h
new file mode 100644
index 0000000000000..9d52e62a1b103
--- /dev/null
+++ b/chrome/browser/file_manager/snapshot_manager.h
@@ -0,0 +1,88 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_SNAPSHOT_MANAGER_H_
+#define CHROME_BROWSER_FILE_MANAGER_SNAPSHOT_MANAGER_H_
+
+#include <stdint.h>
+
+#include "base/callback_forward.h"
+#include "base/containers/circular_deque.h"
+#include "base/files/file.h"
+#include "base/macros.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+
+class Profile;
+
+namespace base {
+class FilePath;
+}  // namespace base
+
+namespace storage {
+class FileSystemURL;
+}  // namespace storage
+
+namespace storage {
+class ShareableFileReference;
+}  // namespace storage
+
+namespace file_manager {
+
+// Utility class for creating a snapshot of a file system file on local disk.
+// The class wraps the underlying implementation of fileapi's CreateSnapshotFile
+// and prolongs the lifetime of snapshot files so that the client code that just
+// accepts file paths works without problems.
+class SnapshotManager {
+ public:
+  // The callback type for CreateManagedSnapshot.
+  typedef base::Callback<void(const base::FilePath&)> LocalPathCallback;
+
+  explicit SnapshotManager(Profile* profile);
+  ~SnapshotManager();
+
+  // Creates a snapshot file copy of a file system file |absolute_file_path| and
+  // returns back to |callback|. Returns empty path for failure.
+  void CreateManagedSnapshot(const base::FilePath& absolute_file_path,
+                             const LocalPathCallback& callback);
+
+  // Struct for keeping the snapshot file reference with its file size used for
+  // computing the necessity of clean up.
+  struct FileReferenceWithSizeInfo {
+    FileReferenceWithSizeInfo(
+        scoped_refptr<storage::ShareableFileReference> ref,
+        int64_t size);
+    FileReferenceWithSizeInfo(const FileReferenceWithSizeInfo& other);
+    ~FileReferenceWithSizeInfo();
+    scoped_refptr<storage::ShareableFileReference> file_ref;
+    int64_t file_size;
+  };
+
+ private:
+  // Part of CreateManagedSnapshot.
+  void CreateManagedSnapshotAfterSpaceComputed(
+      const storage::FileSystemURL& filesystem_url,
+      const LocalPathCallback& callback,
+      int64_t needed_space);
+
+  // Part of CreateManagedSnapshot.
+  void OnCreateSnapshotFile(
+      const LocalPathCallback& callback,
+      base::File::Error result,
+      const base::File::Info& file_info,
+      const base::FilePath& platform_path,
+      scoped_refptr<storage::ShareableFileReference> file_ref);
+
+  Profile* profile_;
+  base::circular_deque<FileReferenceWithSizeInfo> file_refs_;
+
+  // Note: This should remain the last member so it'll be destroyed and
+  // invalidate the weak pointers before any other members are destroyed.
+  base::WeakPtrFactory<SnapshotManager> weak_ptr_factory_;
+  DISALLOW_COPY_AND_ASSIGN(SnapshotManager);
+};
+
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_SNAPSHOT_MANAGER_H_
diff --git a/chrome/browser/file_manager/url_util.cc b/chrome/browser/file_manager/url_util.cc
new file mode 100644
index 0000000000000..e79abd8b22fa0
--- /dev/null
+++ b/chrome/browser/file_manager/url_util.cc
@@ -0,0 +1,142 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/url_util.h"
+
+#include <stddef.h>
+
+#include <memory>
+
+#include "base/json/json_writer.h"
+#include "base/values.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "net/base/escape.h"
+
+namespace file_manager {
+namespace util {
+namespace {
+
+const char kAllowedPaths[] = "allowedPaths";
+const char kNativePath[] = "nativePath";
+const char kNativeOrDrivePath[] = "nativeOrDrivePath";
+const char kAnyPath[] = "anyPath";
+
+// Returns a file manager URL for the given |path|.
+GURL GetFileManagerUrl(const char* path) {
+  return GURL(std::string("chrome-extension://") + kFileManagerAppId + path);
+}
+
+// Converts a numeric dialog type to a string.
+std::string GetDialogTypeAsString(
+    ui::SelectFileDialog::Type dialog_type) {
+  std::string type_str;
+  switch (dialog_type) {
+    case ui::SelectFileDialog::SELECT_NONE:
+      type_str = "full-page";
+      break;
+
+    case ui::SelectFileDialog::SELECT_FOLDER:
+    case ui::SelectFileDialog::SELECT_EXISTING_FOLDER:
+      type_str = "folder";
+      break;
+
+    case ui::SelectFileDialog::SELECT_UPLOAD_FOLDER:
+      type_str = "upload-folder";
+      break;
+
+    case ui::SelectFileDialog::SELECT_SAVEAS_FILE:
+      type_str = "saveas-file";
+      break;
+
+    case ui::SelectFileDialog::SELECT_OPEN_FILE:
+      type_str = "open-file";
+      break;
+
+    case ui::SelectFileDialog::SELECT_OPEN_MULTI_FILE:
+      type_str = "open-multi-file";
+      break;
+  }
+
+  return type_str;
+}
+
+}  // namespace
+
+GURL GetFileManagerMainPageUrl() {
+  return GetFileManagerUrl("/main.html");
+}
+
+GURL GetFileManagerMainPageUrlWithParams(
+    ui::SelectFileDialog::Type type,
+    const base::string16& title,
+    const GURL& current_directory_url,
+    const GURL& selection_url,
+    const std::string& target_name,
+    const ui::SelectFileDialog::FileTypeInfo* file_types,
+    int file_type_index,
+    const base::FilePath::StringType& default_extension) {
+  base::DictionaryValue arg_value;
+  arg_value.SetString("type", GetDialogTypeAsString(type));
+  arg_value.SetString("title", title);
+  arg_value.SetString("currentDirectoryURL", current_directory_url.spec());
+  arg_value.SetString("selectionURL", selection_url.spec());
+  arg_value.SetString("targetName", target_name);
+  arg_value.SetString("defaultExtension", default_extension);
+
+  if (file_types) {
+    auto types_list = std::make_unique<base::ListValue>();
+    for (size_t i = 0; i < file_types->extensions.size(); ++i) {
+      auto extensions_list = std::make_unique<base::ListValue>();
+      for (size_t j = 0; j < file_types->extensions[i].size(); ++j) {
+        extensions_list->AppendString(file_types->extensions[i][j]);
+      }
+
+      auto dict = std::make_unique<base::DictionaryValue>();
+      dict->Set("extensions", std::move(extensions_list));
+
+      if (i < file_types->extension_description_overrides.size()) {
+        base::string16 desc = file_types->extension_description_overrides[i];
+        dict->SetString("description", desc);
+      }
+
+      // file_type_index is 1-based. 0 means no selection at all.
+      dict->SetBoolean("selected",
+                       (static_cast<size_t>(file_type_index) == (i + 1)));
+
+      types_list->Set(i, std::move(dict));
+    }
+    arg_value.Set("typeList", std::move(types_list));
+
+    arg_value.SetBoolean("includeAllFiles", file_types->include_all_files);
+  }
+
+  // If the caller cannot handle Drive path, the file chooser dialog need to
+  // return resolved local native paths to the selected files.
+  if (file_types) {
+    switch (file_types->allowed_paths) {
+      case ui::SelectFileDialog::FileTypeInfo::NATIVE_PATH:
+        arg_value.SetString(kAllowedPaths, kNativePath);
+        break;
+      case ui::SelectFileDialog::FileTypeInfo::NATIVE_OR_DRIVE_PATH:
+        arg_value.SetString(kAllowedPaths, kNativeOrDrivePath);
+        break;
+      case ui::SelectFileDialog::FileTypeInfo::ANY_PATH:
+        arg_value.SetString(kAllowedPaths, kAnyPath);
+        break;
+    }
+  } else {
+    arg_value.SetString(kAllowedPaths, kNativePath);
+  }
+
+  std::string json_args;
+  base::JSONWriter::Write(arg_value, &json_args);
+
+  std::string url = GetFileManagerMainPageUrl().spec() + '?' +
+      net::EscapeUrlEncodedData(json_args,
+                                false);  // Space to %20 instead of +.
+  return GURL(url);
+}
+
+}  // namespace util
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/url_util.h b/chrome/browser/file_manager/url_util.h
new file mode 100644
index 0000000000000..f514dd3172fce
--- /dev/null
+++ b/chrome/browser/file_manager/url_util.h
@@ -0,0 +1,37 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides URL-related utilities.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_URL_UTIL_H_
+#define CHROME_BROWSER_FILE_MANAGER_URL_UTIL_H_
+
+#include <string>
+
+#include "base/strings/string16.h"
+#include "ui/shell_dialogs/select_file_dialog.h"
+#include "url/gurl.h"
+
+namespace file_manager {
+namespace util {
+
+// Returns the file manager's main page URL.
+GURL GetFileManagerMainPageUrl();
+
+// Returns the file manager's main page URL with parameters encoded as JSON
+// in the query string section. |file_types| is optional.
+GURL GetFileManagerMainPageUrlWithParams(
+    ui::SelectFileDialog::Type type,
+    const base::string16& title,
+    const GURL& current_directory_url,
+    const GURL& selection_url,
+    const std::string& target_name,
+    const ui::SelectFileDialog::FileTypeInfo* file_types,
+    int file_type_index,
+    const base::FilePath::StringType& default_extension);
+
+}  // namespace util
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_URL_UTIL_H_
diff --git a/chrome/browser/file_manager/url_util_unittest.cc b/chrome/browser/file_manager/url_util_unittest.cc
new file mode 100644
index 0000000000000..478e8ae781643
--- /dev/null
+++ b/chrome/browser/file_manager/url_util_unittest.cc
@@ -0,0 +1,130 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/url_util.h"
+
+#include <memory>
+
+#include "base/files/file_path.h"
+#include "base/json/json_reader.h"
+#include "base/json/json_writer.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/values.h"
+#include "extensions/common/constants.h"
+#include "net/base/escape.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace file_manager {
+namespace util {
+namespace {
+
+// Pretty print the JSON escaped in the query string.
+std::string PrettyPrintEscapedJson(const std::string& query) {
+  const std::string json = net::UnescapeURLComponent(
+      query, net::UnescapeRule::SPACES | net::UnescapeRule::PATH_SEPARATORS |
+                 net::UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS);
+  std::unique_ptr<base::Value> value = base::JSONReader::Read(json);
+  std::string pretty_json;
+  base::JSONWriter::WriteWithOptions(
+      *value, base::JSONWriter::OPTIONS_PRETTY_PRINT, &pretty_json);
+  return pretty_json;
+}
+
+TEST(FileManagerUrlUtilTest, GetFileManagerMainPageUrl) {
+  EXPECT_EQ("chrome-extension://hhaomjibdihmijegdhdafkllkbggdgoj/main.html",
+            GetFileManagerMainPageUrl().spec());
+}
+
+TEST(FileManagerUrlUtilTest, GetFileManagerMainPageUrlWithParams_NoFileTypes) {
+  const GURL url = GetFileManagerMainPageUrlWithParams(
+      ui::SelectFileDialog::SELECT_OPEN_FILE, base::UTF8ToUTF16("some title"),
+      GURL("filesystem:chrome-extension://abc/Downloads/"),
+      GURL("filesystem:chrome-extension://abc/Downloads/foo.txt"), "foo.txt",
+      nullptr,  // No file types
+      0,        // Hence no file type index.
+      FILE_PATH_LITERAL("txt"));
+  EXPECT_EQ(extensions::kExtensionScheme, url.scheme());
+  EXPECT_EQ("hhaomjibdihmijegdhdafkllkbggdgoj", url.host());
+  EXPECT_EQ("/main.html", url.path());
+  // Confirm that "%20" is used instead of "+" in the query.
+  EXPECT_TRUE(url.query().find("+") == std::string::npos);
+  EXPECT_TRUE(url.query().find("%20") != std::string::npos);
+  // The escaped query is hard to read. Pretty print the escaped JSON.
+  EXPECT_EQ(
+      "{\n"
+      "   \"allowedPaths\": \"nativePath\",\n"
+      "   \"currentDirectoryURL\": "
+      "\"filesystem:chrome-extension://abc/Downloads/\",\n"
+      "   \"defaultExtension\": \"txt\",\n"
+      "   \"selectionURL\": "
+      "\"filesystem:chrome-extension://abc/Downloads/foo.txt\",\n"
+      "   \"targetName\": \"foo.txt\",\n"
+      "   \"title\": \"some title\",\n"
+      "   \"type\": \"open-file\"\n"
+      "}\n",
+      PrettyPrintEscapedJson(url.query()));
+}
+
+TEST(FileManagerUrlUtilTest,
+     GetFileManagerMainPageUrlWithParams_WithFileTypes) {
+  // Create a FileTypeInfo which looks like:
+  // extensions: [["htm", "html"], ["txt"]]
+  // descriptions: ["HTML", "TEXT"]
+  ui::SelectFileDialog::FileTypeInfo file_types;
+  file_types.extensions.emplace_back();
+  file_types.extensions[0].push_back(FILE_PATH_LITERAL("htm"));
+  file_types.extensions[0].push_back(FILE_PATH_LITERAL("html"));
+  file_types.extensions.emplace_back();
+  file_types.extensions[1].push_back(FILE_PATH_LITERAL("txt"));
+  file_types.extension_description_overrides.push_back(
+      base::UTF8ToUTF16("HTML"));
+  file_types.extension_description_overrides.push_back(
+      base::UTF8ToUTF16("TEXT"));
+  // "shouldReturnLocalPath" will be false if drive is supported.
+  file_types.allowed_paths = ui::SelectFileDialog::FileTypeInfo::ANY_PATH;
+
+  const GURL url = GetFileManagerMainPageUrlWithParams(
+      ui::SelectFileDialog::SELECT_OPEN_FILE,
+      base::UTF8ToUTF16("some title"),
+      GURL("filesystem:chrome-extension://abc/Downloads/"),
+      GURL("filesystem:chrome-extension://abc/Downloads/foo.txt"),
+      "foo.txt",
+      &file_types,
+      1,  // The file type index is 1-based.
+      FILE_PATH_LITERAL("txt"));
+  EXPECT_EQ(extensions::kExtensionScheme, url.scheme());
+  EXPECT_EQ("hhaomjibdihmijegdhdafkllkbggdgoj", url.host());
+  EXPECT_EQ("/main.html", url.path());
+  // Confirm that "%20" is used instead of "+" in the query.
+  EXPECT_TRUE(url.query().find("+") == std::string::npos);
+  EXPECT_TRUE(url.query().find("%20") != std::string::npos);
+  // The escaped query is hard to read. Pretty print the escaped JSON.
+  EXPECT_EQ(
+      "{\n"
+      "   \"allowedPaths\": \"anyPath\",\n"
+      "   \"currentDirectoryURL\": "
+      "\"filesystem:chrome-extension://abc/Downloads/\",\n"
+      "   \"defaultExtension\": \"txt\",\n"
+      "   \"includeAllFiles\": false,\n"
+      "   \"selectionURL\": "
+      "\"filesystem:chrome-extension://abc/Downloads/foo.txt\",\n"
+      "   \"targetName\": \"foo.txt\",\n"
+      "   \"title\": \"some title\",\n"
+      "   \"type\": \"open-file\",\n"
+      "   \"typeList\": [ {\n"
+      "      \"description\": \"HTML\",\n"
+      "      \"extensions\": [ \"htm\", \"html\" ],\n"
+      "      \"selected\": true\n"
+      "   }, {\n"
+      "      \"description\": \"TEXT\",\n"
+      "      \"extensions\": [ \"txt\" ],\n"
+      "      \"selected\": false\n"
+      "   } ]\n"
+      "}\n",
+      PrettyPrintEscapedJson(url.query()));
+}
+
+}  // namespace
+}  // namespace util
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/video_player_browsertest.cc b/chrome/browser/file_manager/video_player_browsertest.cc
new file mode 100644
index 0000000000000..e041ec581f45d
--- /dev/null
+++ b/chrome/browser/file_manager/video_player_browsertest.cc
@@ -0,0 +1,76 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/file_manager_browsertest_base.h"
+
+#include "chromeos/chromeos_switches.h"
+
+namespace file_manager {
+
+template <GuestMode MODE>
+class VideoPlayerBrowserTestBase : public FileManagerBrowserTestBase {
+ public:
+  VideoPlayerBrowserTestBase() = default;
+
+ protected:
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    command_line->AppendSwitch(
+        chromeos::switches::kEnableVideoPlayerChromecastSupport);
+
+    FileManagerBrowserTestBase::SetUpCommandLine(command_line);
+  }
+
+  GuestMode GetGuestMode() const override { return MODE; }
+
+  const char* GetTestCaseName() const override {
+    return test_case_name_.c_str();
+  }
+
+  std::string GetFullTestCaseName() const override {
+    return test_case_name_;
+  }
+
+  const char* GetTestExtensionManifestName() const override {
+    return "video_player_test_manifest.json";
+  }
+
+  void set_test_case_name(const std::string& name) { test_case_name_ = name; }
+
+ private:
+  std::string test_case_name_;
+
+  DISALLOW_COPY_AND_ASSIGN(VideoPlayerBrowserTestBase);
+};
+
+typedef VideoPlayerBrowserTestBase<NOT_IN_GUEST_MODE> VideoPlayerBrowserTest;
+typedef VideoPlayerBrowserTestBase<IN_GUEST_MODE>
+    VideoPlayerBrowserTestInGuestMode;
+
+IN_PROC_BROWSER_TEST_F(VideoPlayerBrowserTest, OpenSingleVideoOnDownloads) {
+  set_test_case_name("openSingleVideoOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(VideoPlayerBrowserTestInGuestMode,
+                       OpenSingleVideoOnDownloads) {
+  set_test_case_name("openSingleVideoOnDownloads");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(VideoPlayerBrowserTest, OpenSingleVideoOnDrive) {
+  set_test_case_name("openSingleVideoOnDrive");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(VideoPlayerBrowserTest, CheckInitialElements) {
+  set_test_case_name("checkInitialElements");
+  StartTest();
+}
+
+IN_PROC_BROWSER_TEST_F(VideoPlayerBrowserTest, ClickControlButtons) {
+  set_test_case_name("clickControlButtons");
+  StartTest();
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/volume_manager.cc b/chrome/browser/file_manager/volume_manager.cc
new file mode 100644
index 0000000000000..6f80fb154f8ca
--- /dev/null
+++ b/chrome/browser/file_manager/volume_manager.cc
@@ -0,0 +1,1200 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/volume_manager.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <utility>
+
+#include "base/bind.h"
+#include "base/command_line.h"
+#include "base/feature_list.h"
+#include "base/files/file_path.h"
+#include "base/logging.h"
+#include "base/memory/weak_ptr.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/chromeos/arc/arc_util.h"
+#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_util.h"
+#include "chrome/browser/chromeos/arc/fileapi/arc_media_view_util.h"
+#include "chrome/browser/chromeos/crostini/crostini_manager.h"
+#include "chrome/browser/chromeos/crostini/crostini_util.h"
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_info.h"
+#include "chrome/browser/chromeos/profiles/profile_helper.h"
+#include "chrome/browser/file_manager/path_util.h"
+#include "chrome/browser/file_manager/snapshot_manager.h"
+#include "chrome/browser/file_manager/volume_manager_factory.h"
+#include "chrome/browser/file_manager/volume_manager_observer.h"
+#include "chrome/browser/media_galleries/fileapi/mtp_device_map_service.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/common/pref_names.h"
+#include "chromeos/chromeos_switches.h"
+#include "chromeos/disks/disk.h"
+#include "chromeos/disks/disk_mount_manager.h"
+#include "components/drive/chromeos/file_system_interface.h"
+#include "components/prefs/pref_service.h"
+#include "components/storage_monitor/storage_monitor.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/browser_thread.h"
+#include "services/device/public/mojom/mtp_manager.mojom.h"
+#include "storage/browser/fileapi/external_mount_points.h"
+
+namespace file_manager {
+namespace {
+
+const uint32_t kAccessCapabilityReadWrite = 0;
+const uint32_t kFilesystemTypeGenericHierarchical = 2;
+const char kFileManagerMTPMountNamePrefix[] = "fileman-mtp-";
+const char kMtpVolumeIdPrefix[] = "mtp:";
+const char kRootPath[] = "/";
+const char kAndroidFilesMountPointName[] = "android_files";
+
+// Registers |path| as the "Downloads" folder to the FileSystem API backend.
+// If another folder is already mounted. It revokes and overrides the old one.
+bool RegisterDownloadsMountPoint(Profile* profile, const base::FilePath& path) {
+  // Although we show only profile's own "Downloads" folder in the Files app,
+  // in the backend we need to mount all profile's download directory globally.
+  // Otherwise, the Files app cannot support cross-profile file copies, etc.
+  // For this reason, we need to register to the global GetSystemInstance().
+  const std::string mount_point_name =
+      file_manager::util::GetDownloadsMountPointName(profile);
+  storage::ExternalMountPoints* const mount_points =
+      storage::ExternalMountPoints::GetSystemInstance();
+
+  // In some tests we want to override existing Downloads mount point, so we
+  // first revoke the existing mount point (if any).
+  mount_points->RevokeFileSystem(mount_point_name);
+  return mount_points->RegisterFileSystem(mount_point_name,
+                                          storage::kFileSystemTypeNativeLocal,
+                                          storage::FileSystemMountOption(),
+                                          path);
+}
+
+// Returns true if the "Play files" root should be shown based on the current
+// flag settings (chrome://flags/#android-files-in-files-app).
+bool IsShowAndroidFilesEnabled() {
+  return !base::CommandLine::ForCurrentProcess()->HasSwitch(
+      chromeos::switches::kHideAndroidFilesInFilesApp);
+}
+
+// Registers a mount point for Android files to ExternalMountPoints.
+bool RegisterAndroidFilesMountPoint() {
+  storage::ExternalMountPoints* const mount_points =
+      storage::ExternalMountPoints::GetSystemInstance();
+  return mount_points->RegisterFileSystem(
+      kAndroidFilesMountPointName, storage::kFileSystemTypeNativeLocal,
+      storage::FileSystemMountOption(),
+      base::FilePath(util::kAndroidFilesPath));
+}
+
+// Finds the path register as the "Downloads" folder to FileSystem API backend.
+// Returns false if it is not registered.
+bool FindDownloadsMountPointPath(Profile* profile, base::FilePath* path) {
+  const std::string mount_point_name =
+      util::GetDownloadsMountPointName(profile);
+  storage::ExternalMountPoints* const mount_points =
+      storage::ExternalMountPoints::GetSystemInstance();
+
+  return mount_points->GetRegisteredPath(mount_point_name, path);
+}
+
+VolumeType MountTypeToVolumeType(chromeos::MountType type) {
+  switch (type) {
+    case chromeos::MOUNT_TYPE_INVALID:
+      // We don't expect this value, but list here, so that when any value
+      // is added to the enum definition but this is not edited, the compiler
+      // warns it.
+      break;
+    case chromeos::MOUNT_TYPE_DEVICE:
+      return VOLUME_TYPE_REMOVABLE_DISK_PARTITION;
+    case chromeos::MOUNT_TYPE_ARCHIVE:
+      return VOLUME_TYPE_MOUNTED_ARCHIVE_FILE;
+    case chromeos::MOUNT_TYPE_NETWORK_STORAGE:
+      // Network storage mounts are handled by their mounters so
+      // MOUNT_TYPE_NETWORK_STORAGE should never need to be handled here.
+      break;
+  }
+
+  NOTREACHED();
+  return VOLUME_TYPE_DOWNLOADS_DIRECTORY;
+}
+
+// Returns a string representation of the given volume type.
+std::string VolumeTypeToString(VolumeType type) {
+  switch (type) {
+    case VOLUME_TYPE_GOOGLE_DRIVE:
+      return "drive";
+    case VOLUME_TYPE_DOWNLOADS_DIRECTORY:
+      return "downloads";
+    case VOLUME_TYPE_REMOVABLE_DISK_PARTITION:
+      return "removable";
+    case VOLUME_TYPE_MOUNTED_ARCHIVE_FILE:
+      return "archive";
+    case VOLUME_TYPE_PROVIDED:
+      return "provided";
+    case VOLUME_TYPE_MTP:
+      return "mtp";
+    case VOLUME_TYPE_MEDIA_VIEW:
+      return "media_view";
+    case VOLUME_TYPE_ANDROID_FILES:
+      return "android_files";
+    case VOLUME_TYPE_TESTING:
+      return "testing";
+    case VOLUME_TYPE_CROSTINI:
+      return "crostini";
+    case NUM_VOLUME_TYPE:
+      break;
+  }
+  NOTREACHED();
+  return "";
+}
+
+// Generates a unique volume ID for the given volume info.
+std::string GenerateVolumeId(const Volume& volume) {
+  // For the same volume type, base names are unique, as mount points are
+  // flat for the same volume type.
+  return (VolumeTypeToString(volume.type()) + ":" +
+          volume.mount_path().BaseName().AsUTF8Unsafe());
+}
+
+std::string GetMountPointNameForMediaStorage(
+    const storage_monitor::StorageInfo& info) {
+  std::string name(kFileManagerMTPMountNamePrefix);
+  name += info.device_id();
+  return name;
+}
+
+chromeos::MountAccessMode GetExternalStorageAccessMode(const Profile* profile) {
+  return profile->GetPrefs()->GetBoolean(prefs::kExternalStorageReadOnly)
+             ? chromeos::MOUNT_ACCESS_MODE_READ_ONLY
+             : chromeos::MOUNT_ACCESS_MODE_READ_WRITE;
+}
+
+}  // namespace
+
+Volume::Volume()
+    : source_(SOURCE_FILE),
+      type_(VOLUME_TYPE_GOOGLE_DRIVE),
+      device_type_(chromeos::DEVICE_TYPE_UNKNOWN),
+      mount_condition_(chromeos::disks::MOUNT_CONDITION_NONE),
+      mount_context_(MOUNT_CONTEXT_UNKNOWN),
+      is_parent_(false),
+      is_read_only_(false),
+      is_read_only_removable_device_(false),
+      has_media_(false),
+      configurable_(false),
+      watchable_(false) {
+}
+
+Volume::~Volume() = default;
+
+// static
+std::unique_ptr<Volume> Volume::CreateForDrive(
+    const base::FilePath& drive_path) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->type_ = VOLUME_TYPE_GOOGLE_DRIVE;
+  volume->device_type_ = chromeos::DEVICE_TYPE_UNKNOWN;
+  volume->source_path_ = drive_path;
+  volume->source_ = SOURCE_NETWORK;
+  volume->mount_path_ = drive_path;
+  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
+  volume->volume_id_ = GenerateVolumeId(*volume);
+  volume->watchable_ = true;
+  return volume;
+}
+
+// static
+std::unique_ptr<Volume> Volume::CreateForDownloads(
+    const base::FilePath& downloads_path) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->type_ = VOLUME_TYPE_DOWNLOADS_DIRECTORY;
+  volume->device_type_ = chromeos::DEVICE_TYPE_UNKNOWN;
+  // Keep source_path empty.
+  volume->source_ = SOURCE_SYSTEM;
+  volume->mount_path_ = downloads_path;
+  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
+  volume->volume_id_ = GenerateVolumeId(*volume);
+  volume->watchable_ = true;
+  return volume;
+}
+
+// static
+std::unique_ptr<Volume> Volume::CreateForRemovable(
+    const chromeos::disks::DiskMountManager::MountPointInfo& mount_point,
+    const chromeos::disks::Disk* disk) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->type_ = MountTypeToVolumeType(mount_point.mount_type);
+  volume->source_path_ = base::FilePath(mount_point.source_path);
+  volume->source_ = mount_point.mount_type == chromeos::MOUNT_TYPE_ARCHIVE
+                        ? SOURCE_FILE
+                        : SOURCE_DEVICE;
+  volume->mount_path_ = base::FilePath(mount_point.mount_path);
+  volume->mount_condition_ = mount_point.mount_condition;
+
+  if (disk) {
+    volume->file_system_type_ = disk->file_system_type();
+    volume->volume_label_ = disk->device_label();
+    volume->device_type_ = disk->device_type();
+    volume->system_path_prefix_ = base::FilePath(disk->system_path_prefix());
+    volume->is_parent_ = disk->is_parent();
+    volume->is_read_only_ = disk->is_read_only();
+    volume->is_read_only_removable_device_ = disk->is_read_only_hardware();
+    volume->has_media_ = disk->has_media();
+  } else {
+    volume->volume_label_ = volume->mount_path().BaseName().AsUTF8Unsafe();
+    volume->device_type_ = chromeos::DEVICE_TYPE_UNKNOWN;
+    volume->is_read_only_ =
+        (mount_point.mount_type == chromeos::MOUNT_TYPE_ARCHIVE);
+  }
+  volume->volume_id_ = GenerateVolumeId(*volume);
+  volume->watchable_ = true;
+  return volume;
+}
+
+// static
+std::unique_ptr<Volume> Volume::CreateForProvidedFileSystem(
+    const chromeos::file_system_provider::ProvidedFileSystemInfo&
+        file_system_info,
+    MountContext mount_context) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->file_system_id_ = file_system_info.file_system_id();
+  volume->provider_id_ = file_system_info.provider_id();
+  switch (file_system_info.source()) {
+    case extensions::SOURCE_FILE:
+      volume->source_ = SOURCE_FILE;
+      break;
+    case extensions::SOURCE_DEVICE:
+      volume->source_ = SOURCE_DEVICE;
+      break;
+    case extensions::SOURCE_NETWORK:
+      volume->source_ = SOURCE_NETWORK;
+      break;
+  }
+  volume->volume_label_ = file_system_info.display_name();
+  volume->type_ = VOLUME_TYPE_PROVIDED;
+  volume->mount_path_ = file_system_info.mount_path();
+  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
+  volume->mount_context_ = mount_context;
+  volume->is_parent_ = true;
+  volume->is_read_only_ = !file_system_info.writable();
+  volume->configurable_ = file_system_info.configurable();
+  volume->watchable_ = file_system_info.watchable();
+  volume->volume_id_ = GenerateVolumeId(*volume);
+  volume->icon_set_ = file_system_info.icon_set();
+  return volume;
+}
+
+// static
+std::unique_ptr<Volume> Volume::CreateForMTP(const base::FilePath& mount_path,
+                                             const std::string& label,
+                                             bool read_only) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->type_ = VOLUME_TYPE_MTP;
+  volume->mount_path_ = mount_path;
+  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
+  volume->is_parent_ = true;
+  volume->is_read_only_ = read_only;
+  volume->volume_id_ = kMtpVolumeIdPrefix + label;
+  volume->volume_label_ = label;
+  volume->source_path_ = mount_path;
+  volume->source_ = SOURCE_DEVICE;
+  volume->device_type_ = chromeos::DEVICE_TYPE_MOBILE;
+  return volume;
+}
+
+// static
+std::unique_ptr<Volume> Volume::CreateForMediaView(
+    const std::string& root_document_id) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->type_ = VOLUME_TYPE_MEDIA_VIEW;
+  volume->device_type_ = chromeos::DEVICE_TYPE_UNKNOWN;
+  volume->source_ = SOURCE_SYSTEM;
+  volume->mount_path_ = arc::GetDocumentsProviderMountPath(
+      arc::kMediaDocumentsProviderAuthority, root_document_id);
+  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
+  volume->volume_label_ = root_document_id;
+  volume->is_read_only_ = true;
+  volume->watchable_ = false;
+  volume->volume_id_ = arc::GetMediaViewVolumeId(root_document_id);
+  return volume;
+}
+
+// static
+std::unique_ptr<Volume> Volume::CreateForSshfsCrostini(
+    const base::FilePath& sshfs_mount_path) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->type_ = VOLUME_TYPE_CROSTINI;
+  volume->device_type_ = chromeos::DEVICE_TYPE_UNKNOWN;
+  // Keep source_path empty.
+  volume->source_ = SOURCE_SYSTEM;
+  volume->mount_path_ = sshfs_mount_path;
+  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
+  volume->volume_id_ = GenerateVolumeId(*volume);
+  volume->watchable_ = false;
+  return volume;
+}
+
+// static
+std::unique_ptr<Volume> Volume::CreateForAndroidFiles() {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->type_ = VOLUME_TYPE_ANDROID_FILES;
+  volume->device_type_ = chromeos::DEVICE_TYPE_UNKNOWN;
+  // Keep source_path empty.
+  volume->source_ = SOURCE_SYSTEM;
+  volume->mount_path_ = base::FilePath(util::kAndroidFilesPath);
+  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
+  volume->volume_id_ = GenerateVolumeId(*volume);
+  volume->watchable_ = true;
+  return volume;
+}
+
+// static
+std::unique_ptr<Volume> Volume::CreateForTesting(
+    const base::FilePath& path,
+    VolumeType volume_type,
+    chromeos::DeviceType device_type,
+    bool read_only) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->type_ = volume_type;
+  volume->device_type_ = device_type;
+  // Keep source_path empty.
+  volume->source_ = SOURCE_DEVICE;
+  volume->mount_path_ = path;
+  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
+  volume->is_read_only_ = read_only;
+  volume->volume_id_ = GenerateVolumeId(*volume);
+  return volume;
+}
+
+// static
+std::unique_ptr<Volume> Volume::CreateForTesting(
+    const base::FilePath& device_path,
+    const base::FilePath& mount_path) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->system_path_prefix_ = device_path;
+  volume->mount_path_ = mount_path;
+  return volume;
+}
+
+VolumeManager::VolumeManager(
+    Profile* profile,
+    drive::DriveIntegrationService* drive_integration_service,
+    chromeos::PowerManagerClient* power_manager_client,
+    chromeos::disks::DiskMountManager* disk_mount_manager,
+    chromeos::file_system_provider::Service* file_system_provider_service,
+    const GetMtpStorageInfoCallback& get_mtp_storage_info_callback)
+    : profile_(profile),
+      drive_integration_service_(drive_integration_service),
+      disk_mount_manager_(disk_mount_manager),
+      file_system_provider_service_(file_system_provider_service),
+      get_mtp_storage_info_callback_(get_mtp_storage_info_callback),
+      snapshot_manager_(new SnapshotManager(profile_)),
+      weak_ptr_factory_(this) {
+  DCHECK(disk_mount_manager);
+}
+
+VolumeManager::~VolumeManager() = default;
+
+VolumeManager* VolumeManager::Get(content::BrowserContext* context) {
+  return VolumeManagerFactory::Get(context);
+}
+
+void VolumeManager::Initialize() {
+  // If in the Sign in profile pr the lock screen app profile, skip mounting
+  // and listening for mount events.
+  if (chromeos::ProfileHelper::IsSigninProfile(profile_) ||
+      chromeos::ProfileHelper::IsLockScreenAppProfile(profile_)) {
+    return;
+  }
+
+  // Register 'Downloads' folder for the profile to the file system.
+  const base::FilePath downloads =
+      file_manager::util::GetDownloadsFolderForProfile(profile_);
+  const bool success = RegisterDownloadsMountPoint(profile_, downloads);
+  DCHECK(success);
+
+  DoMountEvent(chromeos::MOUNT_ERROR_NONE,
+               Volume::CreateForDownloads(downloads));
+
+  // Subscribe to DriveIntegrationService.
+  drive_integration_service_->AddObserver(this);
+  if (drive_integration_service_->IsMounted()) {
+    DoMountEvent(chromeos::MOUNT_ERROR_NONE,
+                 Volume::CreateForDrive(GetDriveMountPointPath()));
+  }
+
+  // Subscribe to DiskMountManager.
+  disk_mount_manager_->AddObserver(this);
+  disk_mount_manager_->EnsureMountInfoRefreshed(
+      base::Bind(&VolumeManager::OnDiskMountManagerRefreshed,
+                 weak_ptr_factory_.GetWeakPtr()),
+      false /* force */);
+
+  // Subscribe to FileSystemProviderService and register currently mounted
+  // volumes for the profile.
+  if (file_system_provider_service_) {
+    using chromeos::file_system_provider::ProvidedFileSystemInfo;
+    file_system_provider_service_->AddObserver(this);
+
+    std::vector<ProvidedFileSystemInfo> file_system_info_list =
+        file_system_provider_service_->GetProvidedFileSystemInfoList();
+    for (size_t i = 0; i < file_system_info_list.size(); ++i) {
+      std::unique_ptr<Volume> volume = Volume::CreateForProvidedFileSystem(
+          file_system_info_list[i], MOUNT_CONTEXT_AUTO);
+      DoMountEvent(chromeos::MOUNT_ERROR_NONE, std::move(volume));
+    }
+  }
+
+  // Subscribe to Profile Preference change.
+  pref_change_registrar_.Init(profile_->GetPrefs());
+  pref_change_registrar_.Add(
+      prefs::kExternalStorageDisabled,
+      base::Bind(&VolumeManager::OnExternalStorageDisabledChanged,
+                 weak_ptr_factory_.GetWeakPtr()));
+  pref_change_registrar_.Add(
+      prefs::kExternalStorageReadOnly,
+      base::Bind(&VolumeManager::OnExternalStorageReadOnlyChanged,
+                 weak_ptr_factory_.GetWeakPtr()));
+
+  // Subscribe to storage monitor for MTP notifications.
+  if (storage_monitor::StorageMonitor::GetInstance()) {
+    storage_monitor::StorageMonitor::GetInstance()->EnsureInitialized(
+        base::Bind(&VolumeManager::OnStorageMonitorInitialized,
+                   weak_ptr_factory_.GetWeakPtr()));
+  }
+
+  // Subscribe to ARC file system events.
+  if (base::FeatureList::IsEnabled(arc::kMediaViewFeature) &&
+      arc::IsArcAllowedForProfile(profile_)) {
+    // Registers a mount point for Android files only when the flag is enabled.
+    if (IsShowAndroidFilesEnabled())
+      RegisterAndroidFilesMountPoint();
+
+    arc::ArcSessionManager::Get()->AddObserver(this);
+    OnArcPlayStoreEnabledChanged(
+        arc::IsArcPlayStoreEnabledForProfile(profile_));
+  }
+}
+
+void VolumeManager::Shutdown() {
+  weak_ptr_factory_.InvalidateWeakPtrs();
+
+  snapshot_manager_.reset();
+  pref_change_registrar_.RemoveAll();
+  disk_mount_manager_->RemoveObserver(this);
+  if (storage_monitor::StorageMonitor::GetInstance())
+    storage_monitor::StorageMonitor::GetInstance()->RemoveObserver(this);
+
+  if (drive_integration_service_)
+    drive_integration_service_->RemoveObserver(this);
+
+  if (file_system_provider_service_)
+    file_system_provider_service_->RemoveObserver(this);
+
+  // Unsubscribe from ARC file system events.
+  if (base::FeatureList::IsEnabled(arc::kMediaViewFeature) &&
+      arc::IsArcAllowedForProfile(profile_)) {
+    auto* session_manager = arc::ArcSessionManager::Get();
+    // TODO(crbug.com/672829): We need nullptr check here because
+    // ArcSessionManager may or may not be alive at this point.
+    if (session_manager)
+      session_manager->RemoveObserver(this);
+  }
+}
+
+void VolumeManager::AddObserver(VolumeManagerObserver* observer) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DCHECK(observer);
+  observers_.AddObserver(observer);
+}
+
+void VolumeManager::RemoveObserver(VolumeManagerObserver* observer) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DCHECK(observer);
+  observers_.RemoveObserver(observer);
+}
+
+std::vector<base::WeakPtr<Volume>> VolumeManager::GetVolumeList() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  std::vector<base::WeakPtr<Volume>> result;
+  result.reserve(mounted_volumes_.size());
+  for (const auto& pair : mounted_volumes_) {
+    result.push_back(pair.second->AsWeakPtr());
+  }
+  return result;
+}
+
+base::WeakPtr<Volume> VolumeManager::FindVolumeById(
+    const std::string& volume_id) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  const auto it = mounted_volumes_.find(volume_id);
+  if (it != mounted_volumes_.end())
+    return it->second->AsWeakPtr();
+  return base::WeakPtr<Volume>();
+}
+
+void VolumeManager::AddSshfsCrostiniVolume(
+    const base::FilePath& sshfs_mount_path) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  std::unique_ptr<Volume> volume =
+      Volume::CreateForSshfsCrostini(sshfs_mount_path);
+  // Ignore if volume already exists.
+  if (mounted_volumes_.find(volume->volume_id()) != mounted_volumes_.end())
+    return;
+  DoMountEvent(chromeos::MOUNT_ERROR_NONE, std::move(volume));
+
+  // Listen for crostini container shutdown and remove volume.
+  crostini::CrostiniManager::GetInstance()->AddShutdownContainerCallback(
+      profile_, kCrostiniDefaultVmName, kCrostiniDefaultContainerName,
+      base::BindOnce(&VolumeManager::RemoveSshfsCrostiniVolume,
+                     weak_ptr_factory_.GetWeakPtr(), sshfs_mount_path));
+}
+
+void VolumeManager::RemoveSshfsCrostiniVolume(
+    const base::FilePath& sshfs_mount_path) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
+                 *Volume::CreateForSshfsCrostini(sshfs_mount_path));
+  disk_mount_manager_->UnmountPath(
+      sshfs_mount_path.value(), chromeos::UNMOUNT_OPTIONS_NONE,
+      chromeos::disks::DiskMountManager::UnmountPathCallback());
+}
+
+bool VolumeManager::RegisterDownloadsDirectoryForTesting(
+    const base::FilePath& path) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  base::FilePath old_path;
+  if (FindDownloadsMountPointPath(profile_, &old_path)) {
+    DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
+                   *Volume::CreateForDownloads(old_path));
+  }
+
+  bool success = RegisterDownloadsMountPoint(profile_, path);
+  DoMountEvent(
+      success ? chromeos::MOUNT_ERROR_NONE : chromeos::MOUNT_ERROR_INVALID_PATH,
+      Volume::CreateForDownloads(path));
+  return success;
+}
+
+bool VolumeManager::RegisterCrostiniDirectoryForTesting(
+    const base::FilePath& path) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  bool success =
+      storage::ExternalMountPoints::GetSystemInstance()->RegisterFileSystem(
+          file_manager::util::GetCrostiniMountPointName(profile_),
+          storage::kFileSystemTypeNativeLocal, storage::FileSystemMountOption(),
+          path);
+  DoMountEvent(
+      success ? chromeos::MOUNT_ERROR_NONE : chromeos::MOUNT_ERROR_INVALID_PATH,
+      Volume::CreateForSshfsCrostini(path));
+  return true;
+}
+
+void VolumeManager::AddVolumeForTesting(const base::FilePath& path,
+                                        VolumeType volume_type,
+                                        chromeos::DeviceType device_type,
+                                        bool read_only) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DoMountEvent(
+      chromeos::MOUNT_ERROR_NONE,
+      Volume::CreateForTesting(path, volume_type, device_type, read_only));
+}
+
+void VolumeManager::AddVolumeForTesting(std::unique_ptr<Volume> volume) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DoMountEvent(chromeos::MOUNT_ERROR_NONE, std::move(volume));
+}
+
+void VolumeManager::OnFileSystemMounted() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  // Raise mount event.
+  // We can pass chromeos::MOUNT_ERROR_NONE even when authentication is failed
+  // or network is unreachable. These two errors will be handled later.
+  DoMountEvent(chromeos::MOUNT_ERROR_NONE,
+               Volume::CreateForDrive(GetDriveMountPointPath()));
+}
+
+void VolumeManager::OnFileSystemBeingUnmounted() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
+                 *Volume::CreateForDrive(GetDriveMountPointPath()));
+}
+
+void VolumeManager::OnAutoMountableDiskEvent(
+    chromeos::disks::DiskMountManager::DiskEvent event,
+    const chromeos::disks::Disk& disk) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  // Disregard hidden devices.
+  if (disk.is_hidden())
+    return;
+
+  switch (event) {
+    case chromeos::disks::DiskMountManager::DISK_ADDED:
+    case chromeos::disks::DiskMountManager::DISK_CHANGED: {
+      if (disk.device_path().empty()) {
+        DVLOG(1) << "Empty system path for " << disk.device_path();
+        return;
+      }
+
+      bool mounting = false;
+      if (disk.mount_path().empty() && disk.has_media() &&
+          !profile_->GetPrefs()->GetBoolean(prefs::kExternalStorageDisabled)) {
+        // TODO(crbug.com/774890): Remove |mount_label| when the issue gets
+        // resolved. Currently we suggest a mount point name, because in case
+        // when disk's name contains '#', content will not load in Files App.
+        std::string mount_label = disk.device_label();
+        std::replace(mount_label.begin(), mount_label.end(), '#', '_');
+
+        // If disk is not mounted yet and it has media and there is no policy
+        // forbidding external storage, give it a try.
+        // Initiate disk mount operation. MountPath auto-detects the filesystem
+        // format if the second argument is empty. The third argument (mount
+        // label) is not used in a disk mount operation.
+        disk_mount_manager_->MountPath(disk.device_path(), std::string(),
+                                       mount_label, {},
+                                       chromeos::MOUNT_TYPE_DEVICE,
+                                       GetExternalStorageAccessMode(profile_));
+        mounting = true;
+      }
+
+      // Notify to observers.
+      for (auto& observer : observers_)
+        observer.OnDiskAdded(disk, mounting);
+      return;
+    }
+
+    case chromeos::disks::DiskMountManager::DISK_REMOVED:
+      // If the disk is already mounted, unmount it.
+      if (!disk.mount_path().empty()) {
+        disk_mount_manager_->UnmountPath(
+            disk.mount_path(), chromeos::UNMOUNT_OPTIONS_LAZY,
+            chromeos::disks::DiskMountManager::UnmountPathCallback());
+      }
+
+      // Notify to observers.
+      for (auto& observer : observers_)
+        observer.OnDiskRemoved(disk);
+      return;
+  }
+  NOTREACHED();
+}
+
+void VolumeManager::OnDeviceEvent(
+    chromeos::disks::DiskMountManager::DeviceEvent event,
+    const std::string& device_path) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  DVLOG(1) << "OnDeviceEvent: " << event << ", " << device_path;
+  switch (event) {
+    case chromeos::disks::DiskMountManager::DEVICE_ADDED:
+      for (auto& observer : observers_)
+        observer.OnDeviceAdded(device_path);
+      return;
+    case chromeos::disks::DiskMountManager::DEVICE_REMOVED: {
+      for (auto& observer : observers_)
+        observer.OnDeviceRemoved(device_path);
+      return;
+    }
+    case chromeos::disks::DiskMountManager::DEVICE_SCANNED:
+      DVLOG(1) << "Ignore SCANNED event: " << device_path;
+      return;
+  }
+  NOTREACHED();
+}
+
+void VolumeManager::OnMountEvent(
+    chromeos::disks::DiskMountManager::MountEvent event,
+    chromeos::MountError error_code,
+    const chromeos::disks::DiskMountManager::MountPointInfo& mount_info) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  switch (mount_info.mount_type) {
+    case chromeos::MOUNT_TYPE_ARCHIVE: {
+      // If the file is not mounted now, tell it to drive file system so that
+      // it can handle file caching correctly.
+      // Note that drive file system knows if the file is managed by drive file
+      // system or not, so here we report all paths.
+      if ((event == chromeos::disks::DiskMountManager::MOUNTING &&
+           error_code != chromeos::MOUNT_ERROR_NONE) ||
+          (event == chromeos::disks::DiskMountManager::UNMOUNTING &&
+           error_code == chromeos::MOUNT_ERROR_NONE)) {
+        drive::FileSystemInterface* const file_system =
+            drive::util::GetFileSystemByProfile(profile_);
+        if (file_system) {
+          file_system->MarkCacheFileAsUnmounted(
+              base::FilePath(mount_info.source_path), base::DoNothing());
+        }
+      }
+      FALLTHROUGH;
+    }
+    case chromeos::MOUNT_TYPE_DEVICE: {
+      // Notify a mounting/unmounting event to observers.
+      const chromeos::disks::Disk* const disk =
+          disk_mount_manager_->FindDiskBySourcePath(mount_info.source_path);
+      std::unique_ptr<Volume> volume =
+          Volume::CreateForRemovable(mount_info, disk);
+      switch (event) {
+        case chromeos::disks::DiskMountManager::MOUNTING: {
+          DoMountEvent(error_code, std::move(volume));
+          return;
+        }
+        case chromeos::disks::DiskMountManager::UNMOUNTING:
+          DoUnmountEvent(error_code, *volume);
+          return;
+      }
+      NOTREACHED();
+    }
+
+    // Network storage is responsible for doing its own mounting.
+    case chromeos::MOUNT_TYPE_NETWORK_STORAGE: {
+      break;
+    }
+
+    case chromeos::MOUNT_TYPE_INVALID: {
+      NOTREACHED();
+      break;
+    }
+  }
+}
+
+void VolumeManager::OnFormatEvent(
+    chromeos::disks::DiskMountManager::FormatEvent event,
+    chromeos::FormatError error_code,
+    const std::string& device_path) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DVLOG(1) << "OnDeviceEvent: " << event << ", " << error_code
+           << ", " << device_path;
+
+  switch (event) {
+    case chromeos::disks::DiskMountManager::FORMAT_STARTED:
+      for (auto& observer : observers_) {
+        observer.OnFormatStarted(device_path,
+                                 error_code == chromeos::FORMAT_ERROR_NONE);
+      }
+      return;
+    case chromeos::disks::DiskMountManager::FORMAT_COMPLETED:
+      if (error_code == chromeos::FORMAT_ERROR_NONE) {
+        // If format is completed successfully, try to mount the device.
+        // MountPath auto-detects filesystem format if second argument is
+        // empty. The third argument (mount label) is not used in a disk mount
+        // operation.
+        disk_mount_manager_->MountPath(device_path, std::string(),
+                                       std::string(), {},
+                                       chromeos::MOUNT_TYPE_DEVICE,
+                                       GetExternalStorageAccessMode(profile_));
+      }
+
+      for (auto& observer : observers_) {
+        observer.OnFormatCompleted(device_path,
+                                   error_code == chromeos::FORMAT_ERROR_NONE);
+      }
+
+      return;
+  }
+  NOTREACHED();
+}
+
+void VolumeManager::OnRenameEvent(
+    chromeos::disks::DiskMountManager::RenameEvent event,
+    chromeos::RenameError error_code,
+    const std::string& device_path) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DVLOG(1) << "OnDeviceEvent: " << event << ", " << error_code << ", "
+           << device_path;
+
+  switch (event) {
+    case chromeos::disks::DiskMountManager::RENAME_STARTED:
+      for (auto& observer : observers_) {
+        observer.OnRenameStarted(device_path,
+                                 error_code == chromeos::RENAME_ERROR_NONE);
+      }
+      return;
+    case chromeos::disks::DiskMountManager::RENAME_COMPLETED:
+      // Find previous mount point label if it exists
+      std::string mount_label = "";
+      auto disk_map_iter = disk_mount_manager_->disks().find(device_path);
+      if (disk_map_iter != disk_mount_manager_->disks().end() &&
+          !disk_map_iter->second->base_mount_path().empty()) {
+        mount_label = base::FilePath(disk_map_iter->second->base_mount_path())
+                          .BaseName()
+                          .AsUTF8Unsafe();
+      }
+
+      // Try to mount the device. MountPath auto-detects filesystem format if
+      // second argument is empty. Third argument is a mount point name of the
+      // disk when it was first time mounted (to preserve mount point regardless
+      // of the volume name).
+      disk_mount_manager_->MountPath(device_path, std::string(), mount_label,
+                                     {}, chromeos::MOUNT_TYPE_DEVICE,
+                                     GetExternalStorageAccessMode(profile_));
+
+      bool successfully_renamed = error_code == chromeos::RENAME_ERROR_NONE;
+      for (auto& observer : observers_)
+        observer.OnRenameCompleted(device_path, successfully_renamed);
+
+      return;
+  }
+  NOTREACHED();
+}
+
+void VolumeManager::OnProvidedFileSystemMount(
+    const chromeos::file_system_provider::ProvidedFileSystemInfo&
+        file_system_info,
+    chromeos::file_system_provider::MountContext context,
+    base::File::Error error) {
+  MountContext volume_context = MOUNT_CONTEXT_UNKNOWN;
+  switch (context) {
+    case chromeos::file_system_provider::MOUNT_CONTEXT_USER:
+      volume_context = MOUNT_CONTEXT_USER;
+      break;
+    case chromeos::file_system_provider::MOUNT_CONTEXT_RESTORE:
+      volume_context = MOUNT_CONTEXT_AUTO;
+      break;
+  }
+
+  std::unique_ptr<Volume> volume =
+      Volume::CreateForProvidedFileSystem(file_system_info, volume_context);
+
+  // TODO(mtomasz): Introduce own type, and avoid using MountError internally,
+  // since it is related to cros disks only.
+  chromeos::MountError mount_error;
+  switch (error) {
+    case base::File::FILE_OK:
+      mount_error = chromeos::MOUNT_ERROR_NONE;
+      break;
+    case base::File::FILE_ERROR_EXISTS:
+      mount_error = chromeos::MOUNT_ERROR_PATH_ALREADY_MOUNTED;
+      break;
+    default:
+      mount_error = chromeos::MOUNT_ERROR_UNKNOWN;
+      break;
+  }
+
+  DoMountEvent(mount_error, std::move(volume));
+}
+
+void VolumeManager::OnProvidedFileSystemUnmount(
+    const chromeos::file_system_provider::ProvidedFileSystemInfo&
+        file_system_info,
+    base::File::Error error) {
+  // TODO(mtomasz): Introduce own type, and avoid using MountError internally,
+  // since it is related to cros disks only.
+  const chromeos::MountError mount_error = error == base::File::FILE_OK
+                                               ? chromeos::MOUNT_ERROR_NONE
+                                               : chromeos::MOUNT_ERROR_UNKNOWN;
+  std::unique_ptr<Volume> volume = Volume::CreateForProvidedFileSystem(
+      file_system_info, MOUNT_CONTEXT_UNKNOWN);
+  DoUnmountEvent(mount_error, *volume);
+}
+
+void VolumeManager::OnExternalStorageDisabledChangedUnmountCallback(
+    chromeos::MountError error_code) {
+  if (disk_mount_manager_->mount_points().empty())
+    return;
+  // Repeat until unmount all paths
+  const std::string& mount_path =
+      disk_mount_manager_->mount_points().begin()->second.mount_path;
+  disk_mount_manager_->UnmountPath(
+      mount_path, chromeos::UNMOUNT_OPTIONS_NONE,
+      base::Bind(
+          &VolumeManager::OnExternalStorageDisabledChangedUnmountCallback,
+          weak_ptr_factory_.GetWeakPtr()));
+}
+
+void VolumeManager::OnArcPlayStoreEnabledChanged(bool enabled) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DCHECK(base::FeatureList::IsEnabled(arc::kMediaViewFeature));
+  DCHECK(arc::IsArcAllowedForProfile(profile_));
+
+  if (enabled == arc_volumes_mounted_)
+    return;
+
+  if (enabled) {
+    DoMountEvent(chromeos::MOUNT_ERROR_NONE,
+                 Volume::CreateForMediaView(arc::kImagesRootDocumentId));
+    DoMountEvent(chromeos::MOUNT_ERROR_NONE,
+                 Volume::CreateForMediaView(arc::kVideosRootDocumentId));
+    DoMountEvent(chromeos::MOUNT_ERROR_NONE,
+                 Volume::CreateForMediaView(arc::kAudioRootDocumentId));
+    if (IsShowAndroidFilesEnabled())
+      DoMountEvent(chromeos::MOUNT_ERROR_NONE, Volume::CreateForAndroidFiles());
+  } else {
+    DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
+                   *Volume::CreateForMediaView(arc::kImagesRootDocumentId));
+    DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
+                   *Volume::CreateForMediaView(arc::kVideosRootDocumentId));
+    DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
+                   *Volume::CreateForMediaView(arc::kAudioRootDocumentId));
+    if (IsShowAndroidFilesEnabled()) {
+      DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
+                     *Volume::CreateForAndroidFiles());
+    }
+  }
+
+  arc_volumes_mounted_ = enabled;
+}
+
+void VolumeManager::OnExternalStorageDisabledChanged() {
+  // If the policy just got disabled we have to unmount every device currently
+  // mounted. The opposite is fine - we can let the user re-plug their device to
+  // make it available.
+  if (profile_->GetPrefs()->GetBoolean(prefs::kExternalStorageDisabled)) {
+    // We do not iterate on mount_points directly, because mount_points can
+    // be changed by UnmountPath().
+    // TODO(hidehiko): Is it necessary to unmount mounted archives, too, here?
+    if (disk_mount_manager_->mount_points().empty())
+      return;
+    const std::string& mount_path =
+        disk_mount_manager_->mount_points().begin()->second.mount_path;
+    disk_mount_manager_->UnmountPath(
+        mount_path, chromeos::UNMOUNT_OPTIONS_NONE,
+        base::Bind(
+            &VolumeManager::OnExternalStorageDisabledChangedUnmountCallback,
+            weak_ptr_factory_.GetWeakPtr()));
+  }
+}
+
+void VolumeManager::OnExternalStorageReadOnlyChanged() {
+  disk_mount_manager_->RemountAllRemovableDrives(
+      GetExternalStorageAccessMode(profile_));
+}
+
+void VolumeManager::OnRemovableStorageAttached(
+    const storage_monitor::StorageInfo& info) {
+  if (!storage_monitor::StorageInfo::IsMTPDevice(info.device_id()))
+    return;
+  if (profile_->GetPrefs()->GetBoolean(prefs::kExternalStorageDisabled))
+    return;
+
+  // Resolve mtp storage name and get MtpStorageInfo.
+  std::string storage_name;
+  base::RemoveChars(info.location(), kRootPath, &storage_name);
+  DCHECK(!storage_name.empty());
+  if (get_mtp_storage_info_callback_.is_null()) {
+    storage_monitor::StorageMonitor::GetInstance()
+        ->media_transfer_protocol_manager()
+        ->GetStorageInfo(storage_name,
+                         base::BindOnce(&VolumeManager::DoAttachMtpStorage,
+                                        weak_ptr_factory_.GetWeakPtr(), info));
+  } else {
+    get_mtp_storage_info_callback_.Run(
+        storage_name, base::BindOnce(&VolumeManager::DoAttachMtpStorage,
+                                     weak_ptr_factory_.GetWeakPtr(), info));
+  }
+}
+
+void VolumeManager::DoAttachMtpStorage(
+    const storage_monitor::StorageInfo& info,
+    device::mojom::MtpStorageInfoPtr mtp_storage_info) {
+  if (!mtp_storage_info) {
+    // |mtp_storage_info| can be null. e.g. As OnRemovableStorageAttached and
+    // DoAttachMtpStorage are called asynchronously, there can be a race
+    // condition where the storage has been already removed in
+    // MediaTransferProtocolManager at the time when this method is called.
+    return;
+  }
+
+  // Mtp write is enabled only when the device is writable, supports generic
+  // hierarchical file system, and writing to external storage devices is not
+  // prohibited by the preference.
+  const bool read_only =
+      base::CommandLine::ForCurrentProcess()->HasSwitch(
+          chromeos::switches::kDisableMtpWriteSupport) ||
+      mtp_storage_info->access_capability != kAccessCapabilityReadWrite ||
+      mtp_storage_info->filesystem_type !=
+          kFilesystemTypeGenericHierarchical ||
+      GetExternalStorageAccessMode(profile_) ==
+          chromeos::MOUNT_ACCESS_MODE_READ_ONLY;
+
+  const base::FilePath path = base::FilePath::FromUTF8Unsafe(info.location());
+  const std::string fsid = GetMountPointNameForMediaStorage(info);
+  const std::string base_name = base::UTF16ToUTF8(info.model_name());
+
+  // Assign a fresh volume ID based on the volume name.
+  std::string label = base_name;
+  for (int i = 2; mounted_volumes_.count(kMtpVolumeIdPrefix + label); ++i)
+    label = base_name + base::StringPrintf(" (%d)", i);
+
+  bool result =
+      storage::ExternalMountPoints::GetSystemInstance()->RegisterFileSystem(
+          fsid, storage::kFileSystemTypeDeviceMediaAsFileStorage,
+          storage::FileSystemMountOption(), path);
+  DCHECK(result);
+
+  content::BrowserThread::PostTask(
+      content::BrowserThread::IO, FROM_HERE,
+      base::BindOnce(&MTPDeviceMapService::RegisterMTPFileSystem,
+                     base::Unretained(MTPDeviceMapService::GetInstance()),
+                     info.location(), fsid, read_only));
+
+  std::unique_ptr<Volume> volume = Volume::CreateForMTP(path, label, read_only);
+  DoMountEvent(chromeos::MOUNT_ERROR_NONE, std::move(volume));
+}
+
+void VolumeManager::OnRemovableStorageDetached(
+    const storage_monitor::StorageInfo& info) {
+  if (!storage_monitor::StorageInfo::IsMTPDevice(info.device_id()))
+    return;
+
+  for (const auto& mounted_volume : mounted_volumes_) {
+    if (mounted_volume.second->source_path().value() == info.location()) {
+      DoUnmountEvent(chromeos::MOUNT_ERROR_NONE, *mounted_volume.second.get());
+
+      const std::string fsid = GetMountPointNameForMediaStorage(info);
+      storage::ExternalMountPoints::GetSystemInstance()->RevokeFileSystem(fsid);
+      content::BrowserThread::PostTask(
+          content::BrowserThread::IO, FROM_HERE,
+          base::BindOnce(&MTPDeviceMapService::RevokeMTPFileSystem,
+                         base::Unretained(MTPDeviceMapService::GetInstance()),
+                         fsid));
+      return;
+    }
+  }
+}
+
+void VolumeManager::OnDiskMountManagerRefreshed(bool success) {
+  if (!success) {
+    LOG(ERROR) << "Failed to refresh disk mount manager";
+    return;
+  }
+
+  std::vector<std::unique_ptr<Volume>> archives;
+
+  const chromeos::disks::DiskMountManager::MountPointMap& mount_points =
+      disk_mount_manager_->mount_points();
+  for (const auto& mount_point : mount_points) {
+    switch (mount_point.second.mount_type) {
+      case chromeos::MOUNT_TYPE_ARCHIVE: {
+        // Archives are mounted after other types of volume. See below.
+        archives.push_back(
+            Volume::CreateForRemovable(mount_point.second, nullptr));
+        break;
+      }
+      case chromeos::MOUNT_TYPE_DEVICE: {
+        DoMountEvent(
+            chromeos::MOUNT_ERROR_NONE,
+            Volume::CreateForRemovable(
+                mount_point.second, disk_mount_manager_->FindDiskBySourcePath(
+                                        mount_point.second.source_path)));
+        break;
+      }
+      case chromeos::MOUNT_TYPE_NETWORK_STORAGE: {
+        break;
+      }
+      case chromeos::MOUNT_TYPE_INVALID: {
+        NOTREACHED();
+      }
+    }
+  }
+
+  // We mount archives only if they are opened from currently mounted volumes.
+  // To check the condition correctly in DoMountEvent, we care about the order.
+  std::vector<bool> done(archives.size(), false);
+  for (size_t i = 0; i < archives.size(); ++i) {
+    if (done[i])
+      continue;
+
+    std::vector<std::unique_ptr<Volume>> chain;
+    // done[x] = true means archives[x] is null and that volume is in |chain|.
+    done[i] = true;
+    chain.push_back(std::move(archives[i]));
+
+    // If archives[i]'s source_path is in another archive, mount it first.
+    for (size_t parent = i + 1; parent < archives.size(); ++parent) {
+      if (!done[parent] &&
+          archives[parent]->mount_path().IsParent(
+              chain.back()->source_path())) {
+        // done[parent] started false, so archives[parent] is non-null.
+        done[parent] = true;
+        chain.push_back(std::move(archives[parent]));
+        parent = i + 1;  // Search archives[parent]'s parent from the beginning.
+      }
+    }
+
+    // Mount from the tail of chain.
+    for (size_t i = chain.size(); i > 0; --i) {
+      DoMountEvent(chromeos::MOUNT_ERROR_NONE, std::move(chain[i - 1]));
+    }
+  }
+}
+
+void VolumeManager::OnStorageMonitorInitialized() {
+  std::vector<storage_monitor::StorageInfo> storages =
+      storage_monitor::StorageMonitor::GetInstance()->GetAllAvailableStorages();
+  for (size_t i = 0; i < storages.size(); ++i)
+    OnRemovableStorageAttached(storages[i]);
+  storage_monitor::StorageMonitor::GetInstance()->AddObserver(this);
+}
+
+void VolumeManager::DoMountEvent(chromeos::MountError error_code,
+                                 std::unique_ptr<Volume> volume) {
+  // Archive files are mounted globally in system. We however don't want to show
+  // archives from profile-specific folders (Drive/Downloads) of other users in
+  // multi-profile session. To this end, we filter out archives not on the
+  // volumes already mounted on this VolumeManager instance.
+  if (volume->type() == VOLUME_TYPE_MOUNTED_ARCHIVE_FILE) {
+    // Source may be in Drive cache folder under the current profile directory.
+    bool from_current_profile =
+        profile_->GetPath().IsParent(volume->source_path());
+    for (const auto& mounted_volume : mounted_volumes_) {
+      if (mounted_volume.second->mount_path().IsParent(volume->source_path())) {
+        from_current_profile = true;
+        break;
+      }
+    }
+    if (!from_current_profile)
+      return;
+  }
+
+  // Filter out removable disks if forbidden by policy for this profile.
+  if (volume->type() == VOLUME_TYPE_REMOVABLE_DISK_PARTITION &&
+      profile_->GetPrefs()->GetBoolean(prefs::kExternalStorageDisabled)) {
+    return;
+  }
+
+  Volume* raw_volume = volume.get();
+  if (error_code == chromeos::MOUNT_ERROR_NONE || volume->mount_condition()) {
+    mounted_volumes_[volume->volume_id()] = std::move(volume);
+    UMA_HISTOGRAM_ENUMERATION("FileBrowser.VolumeType", raw_volume->type(),
+                              NUM_VOLUME_TYPE);
+  }
+
+  for (auto& observer : observers_)
+    observer.OnVolumeMounted(error_code, *raw_volume);
+}
+
+void VolumeManager::DoUnmountEvent(chromeos::MountError error_code,
+                                   const Volume& volume) {
+  auto iter = mounted_volumes_.find(volume.volume_id());
+  if (iter == mounted_volumes_.end())
+    return;
+  std::unique_ptr<Volume> volume_ref;
+  if (error_code == chromeos::MOUNT_ERROR_NONE) {
+    // It is important to hold a reference to the removed Volume from
+    // |mounted_volumes_|, because OnVolumeMounted() will access it.
+    volume_ref = std::move(iter->second);
+    mounted_volumes_.erase(iter);
+  }
+
+  for (auto& observer : observers_)
+    observer.OnVolumeUnmounted(error_code, volume);
+}
+
+base::FilePath VolumeManager::GetDriveMountPointPath() const {
+  return drive_integration_service_->GetMountPointPath();
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/volume_manager.h b/chrome/browser/file_manager/volume_manager.h
new file mode 100644
index 0000000000000..3c7664fad0f8e
--- /dev/null
+++ b/chrome/browser/file_manager/volume_manager.h
@@ -0,0 +1,400 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_VOLUME_MANAGER_H_
+#define CHROME_BROWSER_FILE_MANAGER_VOLUME_MANAGER_H_
+
+#include <map>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/callback.h"
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/observer_list.h"
+#include "chrome/browser/chromeos/arc/arc_session_manager.h"
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/chromeos/file_system_provider/icon_set.h"
+#include "chrome/browser/chromeos/file_system_provider/observer.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_info.h"
+#include "chrome/browser/chromeos/file_system_provider/service.h"
+#include "chromeos/dbus/cros_disks_client.h"
+#include "chromeos/disks/disk_mount_manager.h"
+#include "components/keyed_service/core/keyed_service.h"
+#include "components/prefs/pref_change_registrar.h"
+#include "components/storage_monitor/removable_storage_observer.h"
+#include "services/device/public/mojom/mtp_manager.mojom.h"
+
+class Profile;
+
+namespace chromeos {
+class PowerManagerClient;
+
+namespace disks {
+class Disk;
+}  // namespace disks
+
+}  // namespace chromeos
+
+namespace content {
+class BrowserContext;
+}  // namespace content
+
+namespace file_manager {
+
+class SnapshotManager;
+class VolumeManagerObserver;
+
+// Identifiers for volume types managed by Chrome OS file manager.
+enum VolumeType {
+  VOLUME_TYPE_TESTING = -1,  // Used only in tests.
+  VOLUME_TYPE_GOOGLE_DRIVE = 0,
+  VOLUME_TYPE_DOWNLOADS_DIRECTORY,
+  VOLUME_TYPE_REMOVABLE_DISK_PARTITION,
+  VOLUME_TYPE_MOUNTED_ARCHIVE_FILE,
+  VOLUME_TYPE_PROVIDED,  // File system provided by the FileSystemProvider API.
+  VOLUME_TYPE_MTP,
+  VOLUME_TYPE_MEDIA_VIEW,
+  VOLUME_TYPE_CROSTINI,
+  VOLUME_TYPE_ANDROID_FILES,
+  // The enum values must be kept in sync with FileManagerVolumeType in
+  // tools/metrics/histograms/histograms.xml. Since enums for histograms are
+  // append-only (for keeping the number consistent across versions), new values
+  // for this enum also has to be always appended at the end (i.e., here).
+  NUM_VOLUME_TYPE,
+};
+
+// Says how was the mount performed, whether due to user interaction, or
+// automatic. User interaction includes both hardware (pluggins a USB stick)
+// or software (mounting a ZIP archive) interaction.
+enum MountContext {
+  MOUNT_CONTEXT_USER,
+  MOUNT_CONTEXT_AUTO,
+  MOUNT_CONTEXT_UNKNOWN
+};
+
+// Source of a volume's data.
+enum Source { SOURCE_FILE, SOURCE_DEVICE, SOURCE_NETWORK, SOURCE_SYSTEM };
+
+// Represents a volume (mount point) in the volume manager. Validity of the data
+// is guaranteed by the weak pointer. Simply saying, the weak pointer should be
+// valid as long as the volume is mounted.
+class Volume : public base::SupportsWeakPtr<Volume> {
+ public:
+  ~Volume();
+
+  // Factory static methods for different volume types.
+  static std::unique_ptr<Volume> CreateForDrive(
+      const base::FilePath& drive_path);
+  static std::unique_ptr<Volume> CreateForDownloads(
+      const base::FilePath& downloads_path);
+  static std::unique_ptr<Volume> CreateForRemovable(
+      const chromeos::disks::DiskMountManager::MountPointInfo& mount_point,
+      const chromeos::disks::Disk* disk);
+  static std::unique_ptr<Volume> CreateForProvidedFileSystem(
+      const chromeos::file_system_provider::ProvidedFileSystemInfo&
+          file_system_info,
+      MountContext mount_context);
+  static std::unique_ptr<Volume> CreateForMTP(const base::FilePath& mount_path,
+                                              const std::string& label,
+                                              bool read_only);
+  static std::unique_ptr<Volume> CreateForMediaView(
+      const std::string& root_document_id);
+  static std::unique_ptr<Volume> CreateForSshfsCrostini(
+      const base::FilePath& crostini_path);
+  static std::unique_ptr<Volume> CreateForAndroidFiles();
+  static std::unique_ptr<Volume> CreateForTesting(
+      const base::FilePath& path,
+      VolumeType volume_type,
+      chromeos::DeviceType device_type,
+      bool read_only);
+  static std::unique_ptr<Volume> CreateForTesting(
+      const base::FilePath& device_path,
+      const base::FilePath& mount_path);
+
+  // Getters for all members. See below for details.
+  const std::string& volume_id() const { return volume_id_; }
+  const std::string& file_system_id() const { return file_system_id_; }
+  const chromeos::file_system_provider::ProviderId& provider_id() const {
+    return provider_id_;
+  }
+  Source source() const { return source_; }
+  VolumeType type() const { return type_; }
+  chromeos::DeviceType device_type() const { return device_type_; }
+  const base::FilePath& source_path() const { return source_path_; }
+  const base::FilePath& mount_path() const { return mount_path_; }
+  chromeos::disks::MountCondition mount_condition() const {
+    return mount_condition_;
+  }
+  MountContext mount_context() const { return mount_context_; }
+  const base::FilePath& system_path_prefix() const {
+    return system_path_prefix_;
+  }
+  const std::string& volume_label() const { return volume_label_; }
+  bool is_parent() const { return is_parent_; }
+  // Whether the applications can write to the volume. True if not writable.
+  // For example, when write access to external storage is restricted by the
+  // policy (ExternalStorageReadOnly), is_read_only() will be true even when
+  // is_read_only_removable_device() is false.
+  bool is_read_only() const { return is_read_only_; }
+  // Whether the device is write-protected by hardware. This field is valid
+  // only when device_type is VOLUME_TYPE_REMOVABLE_DISK_PARTITION and
+  // source is SOURCE_DEVICE.
+  // When this value is true, is_read_only() is also true.
+  bool is_read_only_removable_device() const {
+    return is_read_only_removable_device_;
+  }
+  bool has_media() const { return has_media_; }
+  bool configurable() const { return configurable_; }
+  bool watchable() const { return watchable_; }
+  const std::string& file_system_type() const { return file_system_type_; }
+  const chromeos::file_system_provider::IconSet& icon_set() const {
+    return icon_set_;
+  }
+
+ private:
+  Volume();
+
+  // The ID of the volume.
+  std::string volume_id_;
+
+  // The ID for provided file systems. If other type, then empty string. Unique
+  // per providing extension or native provider.
+  std::string file_system_id_;
+
+  // The ID of an extension or native provider providing the file system. If
+  // other type, then equal to a ProviderId of the type INVALID.
+  chromeos::file_system_provider::ProviderId provider_id_;
+
+  // The source of the volume's data.
+  Source source_;
+
+  // The type of mounted volume.
+  VolumeType type_;
+
+  // The type of device. (e.g. USB, SD card, DVD etc.)
+  chromeos::DeviceType device_type_;
+
+  // The source path of the volume.
+  // E.g.:
+  // - /home/chronos/user/Downloads/zipfile_path.zip
+  base::FilePath source_path_;
+
+  // The mount path of the volume.
+  // E.g.:
+  // - /home/chronos/user/Downloads
+  // - /media/removable/usb1
+  // - /media/archive/zip1
+  base::FilePath mount_path_;
+
+  // The mounting condition. See the enum for the details.
+  chromeos::disks::MountCondition mount_condition_;
+
+  // The context of the mount. Whether mounting was performed due to a user
+  // interaction or not.
+  MountContext mount_context_;
+
+  // Path of the system device this device's block is a part of.
+  // (e.g. /sys/devices/pci0000:00/.../8:0:0:0/)
+  base::FilePath system_path_prefix_;
+
+  // Label for the volume if the volume is either removable or a provided
+  // file system. In case of removables, if disk is a parent, then its label,
+  // else parents label (e.g. "TransMemory").
+  std::string volume_label_;
+
+  // Is the device is a parent device (i.e. sdb rather than sdb1).
+  bool is_parent_;
+
+  // True if the volume is not writable by applications.
+  bool is_read_only_;
+
+  // True if the volume is made read_only due to its hardware.
+  // This implies is_read_only_.
+  bool is_read_only_removable_device_;
+
+  // True if the volume contains media.
+  bool has_media_;
+
+  // True if the volume is configurable.
+  bool configurable_;
+
+  // True if the volume notifies about changes via file/directory watchers.
+  bool watchable_;
+
+  // Identifier for the file system type
+  std::string file_system_type_;
+
+  // Volume icon set.
+  chromeos::file_system_provider::IconSet icon_set_;
+
+  DISALLOW_COPY_AND_ASSIGN(Volume);
+};
+
+// Manages Volumes for file manager. Example of Volumes:
+// - Drive File System.
+// - Downloads directory.
+// - Removable disks (volume will be created for each partition, not only one
+//   for a device).
+// - Mounted zip archives.
+// - Linux/Crostini file system.
+// - Android/Arc++ file system.
+// - File System Providers.
+class VolumeManager : public KeyedService,
+                      public arc::ArcSessionManager::Observer,
+                      public drive::DriveIntegrationServiceObserver,
+                      public chromeos::disks::DiskMountManager::Observer,
+                      public chromeos::file_system_provider::Observer,
+                      public storage_monitor::RemovableStorageObserver {
+ public:
+  // An alternate to device::mojom::MtpManager::GetStorageInfo.
+  // Used for injecting fake MTP manager for testing in VolumeManagerTest.
+  using GetMtpStorageInfoCallback = base::RepeatingCallback<void(
+      const std::string&,
+      device::mojom::MtpManager::GetStorageInfoCallback)>;
+
+  VolumeManager(
+      Profile* profile,
+      drive::DriveIntegrationService* drive_integration_service,
+      chromeos::PowerManagerClient* power_manager_client,
+      chromeos::disks::DiskMountManager* disk_mount_manager,
+      chromeos::file_system_provider::Service* file_system_provider_service,
+      const GetMtpStorageInfoCallback& get_mtp_storage_info_callback);
+  ~VolumeManager() override;
+
+  // Returns the instance corresponding to the |context|.
+  static VolumeManager* Get(content::BrowserContext* context);
+
+  // Initializes this instance.
+  void Initialize();
+
+  // Disposes this instance.
+  void Shutdown() override;
+
+  // Adds an observer.
+  void AddObserver(VolumeManagerObserver* observer);
+
+  // Removes the observer.
+  void RemoveObserver(VolumeManagerObserver* observer);
+
+  // Returns the information about all volumes currently mounted. The returned
+  // weak pointers are valid as long as the volumes are mounted.
+  std::vector<base::WeakPtr<Volume>> GetVolumeList();
+
+  // Finds Volume for the given volume ID. If found, then the returned weak
+  // pointer is valid. It is invalidated as soon as the volume is removed from
+  // the volume manager.
+  base::WeakPtr<Volume> FindVolumeById(const std::string& volume_id);
+
+  // Add sshfs crostini volume mounted at specified path.
+  void AddSshfsCrostiniVolume(const base::FilePath& sshfs_mount_path);
+
+  // Removes specified sshfs crostini mount.
+  void RemoveSshfsCrostiniVolume(const base::FilePath& sshfs_mount_path);
+
+  // For testing purpose, registers a native local file system pointing to
+  // |path| with DOWNLOADS type, and adds its volume info.
+  bool RegisterDownloadsDirectoryForTesting(const base::FilePath& path);
+
+  // For testing purpose, registers a native local file system pointing to
+  // |path| with CROSTINI type, and adds its volume info.
+  bool RegisterCrostiniDirectoryForTesting(const base::FilePath& path);
+
+  // For testing purpose, adds a volume info pointing to |path|, with TESTING
+  // type. Assumes that the mount point is already registered.
+  void AddVolumeForTesting(const base::FilePath& path,
+                           VolumeType volume_type,
+                           chromeos::DeviceType device_type,
+                           bool read_only);
+
+  // For testing purpose, adds the volume info to the volume manager.
+  void AddVolumeForTesting(std::unique_ptr<Volume> volume);
+
+  // drive::DriveIntegrationServiceObserver overrides.
+  void OnFileSystemMounted() override;
+  void OnFileSystemBeingUnmounted() override;
+
+  // chromeos::disks::DiskMountManager::Observer overrides.
+  void OnAutoMountableDiskEvent(
+      chromeos::disks::DiskMountManager::DiskEvent event,
+      const chromeos::disks::Disk& disk) override;
+  void OnDeviceEvent(chromeos::disks::DiskMountManager::DeviceEvent event,
+                     const std::string& device_path) override;
+  void OnMountEvent(chromeos::disks::DiskMountManager::MountEvent event,
+                    chromeos::MountError error_code,
+                    const chromeos::disks::DiskMountManager::MountPointInfo&
+                        mount_info) override;
+  void OnFormatEvent(chromeos::disks::DiskMountManager::FormatEvent event,
+                     chromeos::FormatError error_code,
+                     const std::string& device_path) override;
+  void OnRenameEvent(chromeos::disks::DiskMountManager::RenameEvent event,
+                     chromeos::RenameError error_code,
+                     const std::string& device_path) override;
+
+  // chromeos::file_system_provider::Observer overrides.
+  void OnProvidedFileSystemMount(
+      const chromeos::file_system_provider::ProvidedFileSystemInfo&
+          file_system_info,
+      chromeos::file_system_provider::MountContext context,
+      base::File::Error error) override;
+  void OnProvidedFileSystemUnmount(
+      const chromeos::file_system_provider::ProvidedFileSystemInfo&
+          file_system_info,
+      base::File::Error error) override;
+
+  // arc::ArcSessionManager::Observer overrides.
+  void OnArcPlayStoreEnabledChanged(bool enabled) override;
+
+  // Called on change to kExternalStorageDisabled pref.
+  void OnExternalStorageDisabledChanged();
+
+  // Called on change to kExternalStorageReadOnly pref.
+  void OnExternalStorageReadOnlyChanged();
+
+  // RemovableStorageObserver overrides.
+  void OnRemovableStorageAttached(
+      const storage_monitor::StorageInfo& info) override;
+  void OnRemovableStorageDetached(
+      const storage_monitor::StorageInfo& info) override;
+
+  SnapshotManager* snapshot_manager() { return snapshot_manager_.get(); }
+
+ private:
+  void OnDiskMountManagerRefreshed(bool success);
+  void OnStorageMonitorInitialized();
+  void DoAttachMtpStorage(const storage_monitor::StorageInfo& info,
+                          device::mojom::MtpStorageInfoPtr mtp_storage_info);
+  void DoMountEvent(chromeos::MountError error_code,
+                    std::unique_ptr<Volume> volume);
+  void DoUnmountEvent(chromeos::MountError error_code, const Volume& volume);
+  void OnExternalStorageDisabledChangedUnmountCallback(
+      chromeos::MountError error_code);
+
+  // Returns the path of the mount point for drive.
+  base::FilePath GetDriveMountPointPath() const;
+
+  Profile* profile_;
+  drive::DriveIntegrationService* drive_integration_service_;  // Not owned.
+  chromeos::disks::DiskMountManager* disk_mount_manager_;      // Not owned.
+  PrefChangeRegistrar pref_change_registrar_;
+  base::ObserverList<VolumeManagerObserver>::Unchecked observers_;
+  chromeos::file_system_provider::Service*
+      file_system_provider_service_;  // Not owned by this class.
+  GetMtpStorageInfoCallback get_mtp_storage_info_callback_;
+  std::map<std::string, std::unique_ptr<Volume>> mounted_volumes_;
+  std::unique_ptr<SnapshotManager> snapshot_manager_;
+  bool arc_volumes_mounted_ = false;
+
+  // Note: This should remain the last member so it'll be destroyed and
+  // invalidate its weak pointers before any other members are destroyed.
+  base::WeakPtrFactory<VolumeManager> weak_ptr_factory_;
+  DISALLOW_COPY_AND_ASSIGN(VolumeManager);
+};
+
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_VOLUME_MANAGER_H_
diff --git a/chrome/browser/file_manager/volume_manager_factory.cc b/chrome/browser/file_manager/volume_manager_factory.cc
new file mode 100644
index 0000000000000..8e694c3ec6d78
--- /dev/null
+++ b/chrome/browser/file_manager/volume_manager_factory.cc
@@ -0,0 +1,67 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/volume_manager_factory.h"
+
+#include "base/bind.h"
+#include "base/memory/singleton.h"
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/chromeos/file_system_provider/service_factory.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/browser/profiles/incognito_helpers.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
+#include "chromeos/disks/disk_mount_manager.h"
+#include "components/keyed_service/content/browser_context_dependency_manager.h"
+#include "components/storage_monitor/storage_monitor.h"
+
+namespace file_manager {
+
+VolumeManager* VolumeManagerFactory::Get(content::BrowserContext* context) {
+  return static_cast<VolumeManager*>(
+      GetInstance()->GetServiceForBrowserContext(context, true));
+}
+
+VolumeManagerFactory* VolumeManagerFactory::GetInstance() {
+  return base::Singleton<VolumeManagerFactory>::get();
+}
+
+content::BrowserContext* VolumeManagerFactory::GetBrowserContextToUse(
+    content::BrowserContext* context) const {
+  // Explicitly allow this manager in guest login mode.
+  return chrome::GetBrowserContextOwnInstanceInIncognito(context);
+}
+
+bool VolumeManagerFactory::ServiceIsCreatedWithBrowserContext() const {
+  return true;
+}
+
+bool VolumeManagerFactory::ServiceIsNULLWhileTesting() const {
+  return true;
+}
+
+KeyedService* VolumeManagerFactory::BuildServiceInstanceFor(
+    content::BrowserContext* context) const {
+  Profile* const profile = Profile::FromBrowserContext(context);
+  VolumeManager* instance = new VolumeManager(
+      profile, drive::DriveIntegrationServiceFactory::GetForProfile(profile),
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient(),
+      chromeos::disks::DiskMountManager::GetInstance(),
+      chromeos::file_system_provider::ServiceFactory::Get(context),
+      VolumeManager::GetMtpStorageInfoCallback());
+  instance->Initialize();
+  return instance;
+}
+
+VolumeManagerFactory::VolumeManagerFactory()
+    : BrowserContextKeyedServiceFactory(
+          "VolumeManagerFactory",
+          BrowserContextDependencyManager::GetInstance()) {
+  DependsOn(drive::DriveIntegrationServiceFactory::GetInstance());
+  DependsOn(chromeos::file_system_provider::ServiceFactory::GetInstance());
+}
+
+VolumeManagerFactory::~VolumeManagerFactory() = default;
+
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/volume_manager_factory.h b/chrome/browser/file_manager/volume_manager_factory.h
new file mode 100644
index 0000000000000..c3f5fc534d334
--- /dev/null
+++ b/chrome/browser/file_manager/volume_manager_factory.h
@@ -0,0 +1,55 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_VOLUME_MANAGER_FACTORY_H_
+#define CHROME_BROWSER_FILE_MANAGER_VOLUME_MANAGER_FACTORY_H_
+
+#include "base/macros.h"
+#include "components/keyed_service/content/browser_context_keyed_service_factory.h"
+
+namespace base {
+template <typename T>
+struct DefaultSingletonTraits;
+}  // namespace base
+
+namespace content {
+class BrowserContext;
+}  // namespace content
+
+namespace file_manager {
+
+class VolumeManager;
+
+// Factory to create VolumeManager.
+class VolumeManagerFactory : public BrowserContextKeyedServiceFactory {
+ public:
+  // Returns VolumeManager instance.
+  static VolumeManager* Get(content::BrowserContext* context);
+
+  static VolumeManagerFactory* GetInstance();
+
+ protected:
+  // BrowserContextKeyedBaseFactory overrides:
+  content::BrowserContext* GetBrowserContextToUse(
+      content::BrowserContext* context) const override;
+  bool ServiceIsCreatedWithBrowserContext() const override;
+  bool ServiceIsNULLWhileTesting() const override;
+
+  // BrowserContextKeyedServiceFactory overrides:
+  KeyedService* BuildServiceInstanceFor(
+      content::BrowserContext* context) const override;
+
+ private:
+  // For Singleton.
+  friend struct base::DefaultSingletonTraits<VolumeManagerFactory>;
+
+  VolumeManagerFactory();
+  ~VolumeManagerFactory() override;
+
+  DISALLOW_COPY_AND_ASSIGN(VolumeManagerFactory);
+};
+
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_VOLUME_MANAGER_FACTORY_H_
diff --git a/chrome/browser/file_manager/volume_manager_observer.h b/chrome/browser/file_manager/volume_manager_observer.h
new file mode 100644
index 0000000000000..227ea52546852
--- /dev/null
+++ b/chrome/browser/file_manager/volume_manager_observer.h
@@ -0,0 +1,67 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_VOLUME_MANAGER_OBSERVER_H_
+#define CHROME_BROWSER_FILE_MANAGER_VOLUME_MANAGER_OBSERVER_H_
+
+#include <string>
+
+#include "chromeos/dbus/cros_disks_client.h"
+
+namespace chromeos {
+namespace disks {
+class Disk;
+}  // namespace disks
+}  // namespace chromeos
+
+namespace file_manager {
+
+class Volume;
+
+// Observer interface of volume related events.
+class VolumeManagerObserver {
+ public:
+  virtual ~VolumeManagerObserver() = default;
+
+  // Fired when a new disk is added.
+  virtual void OnDiskAdded(const chromeos::disks::Disk& disk,
+                           bool mounting) = 0;
+
+  // Fired when a disk is removed.
+  virtual void OnDiskRemoved(const chromeos::disks::Disk& disk) = 0;
+
+  // Fired when a new device is added.
+  virtual void OnDeviceAdded(const std::string& device_path) = 0;
+
+  // Fired when a device is removed.
+  virtual void OnDeviceRemoved(const std::string& device_path) = 0;
+
+  // Fired when a volume is mounted.
+  virtual void OnVolumeMounted(chromeos::MountError error_code,
+                               const Volume& volume) = 0;
+
+  // Fired when a volume is unmounted.
+  virtual void OnVolumeUnmounted(chromeos::MountError error_code,
+                                 const Volume& volume) = 0;
+
+  // Fired when formatting a device is started (or failed to start).
+  virtual void OnFormatStarted(
+      const std::string& device_path, bool success) = 0;
+
+  // Fired when formatting a device is completed (or terminated on error).
+  virtual void OnFormatCompleted(
+      const std::string& device_path, bool success) = 0;
+
+  // Fired when renaming a device is started (or failed to start).
+  virtual void OnRenameStarted(const std::string& device_path,
+                               bool success) = 0;
+
+  // Fired when renaming a device is completed (or terminated on error).
+  virtual void OnRenameCompleted(const std::string& device_path,
+                                 bool success) = 0;
+};
+
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_VOLUME_MANAGER_OBSERVER_H_
diff --git a/chrome/browser/file_manager/volume_manager_unittest.cc b/chrome/browser/file_manager/volume_manager_unittest.cc
new file mode 100644
index 0000000000000..d198ce016b689
--- /dev/null
+++ b/chrome/browser/file_manager/volume_manager_unittest.cc
@@ -0,0 +1,1002 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/volume_manager.h"
+
+#include <stddef.h>
+
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/chromeos/file_system_provider/fake_extension_provider.h"
+#include "chrome/browser/chromeos/file_system_provider/service.h"
+#include "chrome/browser/file_manager/fake_disk_mount_manager.h"
+#include "chrome/browser/file_manager/volume_manager_observer.h"
+#include "chrome/common/pref_names.h"
+#include "chrome/test/base/testing_profile.h"
+#include "chromeos/dbus/fake_power_manager_client.h"
+#include "chromeos/dbus/power_manager/suspend.pb.h"
+#include "chromeos/disks/disk.h"
+#include "chromeos/disks/disk_mount_manager.h"
+#include "components/drive/chromeos/dummy_file_system.h"
+#include "components/drive/service/dummy_drive_service.h"
+#include "components/prefs/pref_service.h"
+#include "components/storage_monitor/storage_info.h"
+#include "content/public/test/test_browser_thread_bundle.h"
+#include "content/public/test/test_service_manager_context.h"
+#include "extensions/browser/extension_registry.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+using chromeos::disks::Disk;
+using chromeos::disks::DiskMountManager;
+
+namespace file_manager {
+namespace {
+
+class LoggingObserver : public VolumeManagerObserver {
+ public:
+  struct Event {
+    enum EventType {
+      DISK_ADDED,
+      DISK_REMOVED,
+      DEVICE_ADDED,
+      DEVICE_REMOVED,
+      VOLUME_MOUNTED,
+      VOLUME_UNMOUNTED,
+      FORMAT_STARTED,
+      FORMAT_COMPLETED,
+      RENAME_STARTED,
+      RENAME_COMPLETED
+    } type;
+
+    // Available on DEVICE_ADDED, DEVICE_REMOVED, VOLUME_MOUNTED,
+    // VOLUME_UNMOUNTED, FORMAT_STARTED and FORMAT_COMPLETED.
+    std::string device_path;
+
+    // Available on DISK_ADDED.
+    bool mounting;
+
+    // Available on VOLUME_MOUNTED and VOLUME_UNMOUNTED.
+    chromeos::MountError mount_error;
+
+    // Available on FORMAT_STARTED and FORMAT_COMPLETED.
+    bool success;
+  };
+
+  LoggingObserver() = default;
+  ~LoggingObserver() override = default;
+
+  const std::vector<Event>& events() const { return events_; }
+
+  // VolumeManagerObserver overrides.
+  void OnDiskAdded(const Disk& disk, bool mounting) override {
+    Event event;
+    event.type = Event::DISK_ADDED;
+    event.device_path = disk.device_path();  // Keep only device_path.
+    event.mounting = mounting;
+    events_.push_back(event);
+  }
+
+  void OnDiskRemoved(const Disk& disk) override {
+    Event event;
+    event.type = Event::DISK_REMOVED;
+    event.device_path = disk.device_path();  // Keep only device_path.
+    events_.push_back(event);
+  }
+
+  void OnDeviceAdded(const std::string& device_path) override {
+    Event event;
+    event.type = Event::DEVICE_ADDED;
+    event.device_path = device_path;
+    events_.push_back(event);
+  }
+
+  void OnDeviceRemoved(const std::string& device_path) override {
+    Event event;
+    event.type = Event::DEVICE_REMOVED;
+    event.device_path = device_path;
+    events_.push_back(event);
+  }
+
+  void OnVolumeMounted(chromeos::MountError error_code,
+                       const Volume& volume) override {
+    Event event;
+    event.type = Event::VOLUME_MOUNTED;
+    event.device_path = volume.source_path().AsUTF8Unsafe();
+    event.mount_error = error_code;
+    events_.push_back(event);
+  }
+
+  void OnVolumeUnmounted(chromeos::MountError error_code,
+                         const Volume& volume) override {
+    Event event;
+    event.type = Event::VOLUME_UNMOUNTED;
+    event.device_path = volume.source_path().AsUTF8Unsafe();
+    event.mount_error = error_code;
+    events_.push_back(event);
+  }
+
+  void OnFormatStarted(const std::string& device_path, bool success) override {
+    Event event;
+    event.type = Event::FORMAT_STARTED;
+    event.device_path = device_path;
+    event.success = success;
+    events_.push_back(event);
+  }
+
+  void OnFormatCompleted(const std::string& device_path,
+                         bool success) override {
+    Event event;
+    event.type = Event::FORMAT_COMPLETED;
+    event.device_path = device_path;
+    event.success = success;
+    events_.push_back(event);
+  }
+
+  void OnRenameStarted(const std::string& device_path, bool success) override {
+    Event event;
+    event.type = Event::RENAME_STARTED;
+    event.device_path = device_path;
+    event.success = success;
+    events_.push_back(event);
+  }
+
+  void OnRenameCompleted(const std::string& device_path,
+                         bool success) override {
+    Event event;
+    event.type = Event::RENAME_COMPLETED;
+    event.device_path = device_path;
+    event.success = success;
+    events_.push_back(event);
+  }
+
+ private:
+  std::vector<Event> events_;
+
+  DISALLOW_COPY_AND_ASSIGN(LoggingObserver);
+};
+
+}  // namespace
+
+class VolumeManagerTest : public testing::Test {
+ protected:
+  // Helper class that contains per-profile objects.
+  class ProfileEnvironment {
+   public:
+    ProfileEnvironment(chromeos::PowerManagerClient* power_manager_client,
+                       DiskMountManager* disk_manager)
+        : profile_(std::make_unique<TestingProfile>()),
+          extension_registry_(
+              std::make_unique<extensions::ExtensionRegistry>(profile_.get())),
+          file_system_provider_service_(
+              std::make_unique<chromeos::file_system_provider::Service>(
+                  profile_.get(),
+                  extension_registry_.get())),
+          drive_integration_service_(
+              std::make_unique<drive::DriveIntegrationService>(
+                  profile_.get(),
+                  nullptr,
+                  new drive::DummyDriveService(),
+                  std::string(),
+                  base::FilePath(),
+                  new drive::DummyFileSystem())),
+          volume_manager_(std::make_unique<VolumeManager>(
+              profile_.get(),
+              drive_integration_service_.get(),  // DriveIntegrationService
+              power_manager_client,
+              disk_manager,
+              file_system_provider_service_.get(),
+              base::Bind(&ProfileEnvironment::GetFakeMtpStorageInfo,
+                         base::Unretained(this)))) {}
+
+    Profile* profile() const { return profile_.get(); }
+    VolumeManager* volume_manager() const { return volume_manager_.get(); }
+
+   private:
+    void GetFakeMtpStorageInfo(
+        const std::string& storage_name,
+        device::mojom::MtpManager::GetStorageInfoCallback callback) {
+      std::move(callback).Run(device::mojom::MtpStorageInfo::New());
+    }
+
+    std::unique_ptr<TestingProfile> profile_;
+    std::unique_ptr<extensions::ExtensionRegistry> extension_registry_;
+    std::unique_ptr<chromeos::file_system_provider::Service>
+        file_system_provider_service_;
+    std::unique_ptr<drive::DriveIntegrationService> drive_integration_service_;
+    std::unique_ptr<VolumeManager> volume_manager_;
+  };
+
+  void SetUp() override {
+    power_manager_client_ =
+        std::make_unique<chromeos::FakePowerManagerClient>();
+    disk_mount_manager_ = std::make_unique<FakeDiskMountManager>();
+    main_profile_ = std::make_unique<ProfileEnvironment>(
+        power_manager_client_.get(), disk_mount_manager_.get());
+  }
+
+  Profile* profile() const { return main_profile_->profile(); }
+  VolumeManager* volume_manager() const {
+    return main_profile_->volume_manager();
+  }
+
+  content::TestBrowserThreadBundle thread_bundle_;
+  content::TestServiceManagerContext context_;
+  std::unique_ptr<chromeos::FakePowerManagerClient> power_manager_client_;
+  std::unique_ptr<FakeDiskMountManager> disk_mount_manager_;
+  std::unique_ptr<ProfileEnvironment> main_profile_;
+};
+
+TEST_F(VolumeManagerTest, OnDriveFileSystemMountAndUnmount) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  volume_manager()->OnFileSystemMounted();
+
+  ASSERT_EQ(1U, observer.events().size());
+  LoggingObserver::Event event = observer.events()[0];
+  EXPECT_EQ(LoggingObserver::Event::VOLUME_MOUNTED, event.type);
+  EXPECT_EQ(drive::util::GetDriveMountPointPath(profile()).AsUTF8Unsafe(),
+            event.device_path);
+  EXPECT_EQ(chromeos::MOUNT_ERROR_NONE, event.mount_error);
+
+  volume_manager()->OnFileSystemBeingUnmounted();
+
+  ASSERT_EQ(2U, observer.events().size());
+  event = observer.events()[1];
+  EXPECT_EQ(LoggingObserver::Event::VOLUME_UNMOUNTED, event.type);
+  EXPECT_EQ(drive::util::GetDriveMountPointPath(profile()).AsUTF8Unsafe(),
+            event.device_path);
+  EXPECT_EQ(chromeos::MOUNT_ERROR_NONE, event.mount_error);
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnDriveFileSystemUnmountWithoutMount) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+  volume_manager()->OnFileSystemBeingUnmounted();
+
+  // Unmount event for non-mounted volume is not reported.
+  ASSERT_EQ(0U, observer.events().size());
+  volume_manager()->RemoveObserver(&observer);
+}
+TEST_F(VolumeManagerTest, OnBootDeviceDiskEvent) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  std::unique_ptr<const Disk> disk =
+      Disk::Builder().SetDevicePath("device1").SetOnBootDevice(true).Build();
+
+  volume_manager()->OnBootDeviceDiskEvent(DiskMountManager::DISK_ADDED, *disk);
+  EXPECT_EQ(0U, observer.events().size());
+
+  volume_manager()->OnBootDeviceDiskEvent(DiskMountManager::DISK_REMOVED,
+                                          *disk);
+  EXPECT_EQ(0U, observer.events().size());
+
+  volume_manager()->OnBootDeviceDiskEvent(DiskMountManager::DISK_CHANGED,
+                                          *disk);
+  EXPECT_EQ(0U, observer.events().size());
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnAutoMountableDiskEvent_Hidden) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  std::unique_ptr<const Disk> disk =
+      Disk::Builder().SetDevicePath("device1").SetIsHidden(true).Build();
+
+  volume_manager()->OnAutoMountableDiskEvent(DiskMountManager::DISK_ADDED,
+                                             *disk);
+  EXPECT_EQ(0U, observer.events().size());
+
+  volume_manager()->OnAutoMountableDiskEvent(DiskMountManager::DISK_REMOVED,
+                                             *disk);
+  EXPECT_EQ(0U, observer.events().size());
+
+  volume_manager()->OnAutoMountableDiskEvent(DiskMountManager::DISK_CHANGED,
+                                             *disk);
+  EXPECT_EQ(0U, observer.events().size());
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnAutoMountableDiskEvent_Added) {
+  // Enable external storage.
+  profile()->GetPrefs()->SetBoolean(prefs::kExternalStorageDisabled, false);
+
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  std::unique_ptr<const Disk> empty_device_path_disk = Disk::Builder().Build();
+  volume_manager()->OnAutoMountableDiskEvent(DiskMountManager::DISK_ADDED,
+                                             *empty_device_path_disk);
+  EXPECT_EQ(0U, observer.events().size());
+
+  std::unique_ptr<const Disk> media_disk =
+      Disk::Builder().SetDevicePath("device1").SetHasMedia(true).Build();
+  volume_manager()->OnAutoMountableDiskEvent(DiskMountManager::DISK_ADDED,
+                                             *media_disk);
+  ASSERT_EQ(1U, observer.events().size());
+  const LoggingObserver::Event& event = observer.events()[0];
+  EXPECT_EQ(LoggingObserver::Event::DISK_ADDED, event.type);
+  EXPECT_EQ("device1", event.device_path);
+  EXPECT_TRUE(event.mounting);
+
+  ASSERT_EQ(1U, disk_mount_manager_->mount_requests().size());
+  const FakeDiskMountManager::MountRequest& mount_request =
+      disk_mount_manager_->mount_requests()[0];
+  EXPECT_EQ("device1", mount_request.source_path);
+  EXPECT_EQ("", mount_request.source_format);
+  EXPECT_EQ("", mount_request.mount_label);
+  EXPECT_EQ(chromeos::MOUNT_TYPE_DEVICE, mount_request.type);
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnAutoMountableDiskEvent_AddedNonMounting) {
+  // Enable external storage.
+  profile()->GetPrefs()->SetBoolean(prefs::kExternalStorageDisabled, false);
+
+  // Device which is already mounted.
+  {
+    LoggingObserver observer;
+    volume_manager()->AddObserver(&observer);
+
+    std::unique_ptr<const Disk> mounted_media_disk =
+        Disk::Builder()
+            .SetDevicePath("device1")
+            .SetMountPath("mounted")
+            .SetHasMedia(true)
+            .Build();
+    volume_manager()->OnAutoMountableDiskEvent(DiskMountManager::DISK_ADDED,
+                                               *mounted_media_disk);
+    ASSERT_EQ(1U, observer.events().size());
+    const LoggingObserver::Event& event = observer.events()[0];
+    EXPECT_EQ(LoggingObserver::Event::DISK_ADDED, event.type);
+    EXPECT_EQ("device1", event.device_path);
+    EXPECT_FALSE(event.mounting);
+
+    ASSERT_EQ(0U, disk_mount_manager_->mount_requests().size());
+
+    volume_manager()->RemoveObserver(&observer);
+  }
+
+  // Device without media.
+  {
+    LoggingObserver observer;
+    volume_manager()->AddObserver(&observer);
+
+    std::unique_ptr<const Disk> no_media_disk =
+        Disk::Builder().SetDevicePath("device1").Build();
+    volume_manager()->OnAutoMountableDiskEvent(DiskMountManager::DISK_ADDED,
+                                               *no_media_disk);
+    ASSERT_EQ(1U, observer.events().size());
+    const LoggingObserver::Event& event = observer.events()[0];
+    EXPECT_EQ(LoggingObserver::Event::DISK_ADDED, event.type);
+    EXPECT_EQ("device1", event.device_path);
+    EXPECT_FALSE(event.mounting);
+
+    ASSERT_EQ(0U, disk_mount_manager_->mount_requests().size());
+
+    volume_manager()->RemoveObserver(&observer);
+  }
+
+  // External storage is disabled.
+  {
+    profile()->GetPrefs()->SetBoolean(prefs::kExternalStorageDisabled, true);
+
+    LoggingObserver observer;
+    volume_manager()->AddObserver(&observer);
+
+    std::unique_ptr<const Disk> media_disk =
+        Disk::Builder().SetDevicePath("device1").SetHasMedia(true).Build();
+    volume_manager()->OnAutoMountableDiskEvent(DiskMountManager::DISK_ADDED,
+                                               *media_disk);
+    ASSERT_EQ(1U, observer.events().size());
+    const LoggingObserver::Event& event = observer.events()[0];
+    EXPECT_EQ(LoggingObserver::Event::DISK_ADDED, event.type);
+    EXPECT_EQ("device1", event.device_path);
+    EXPECT_FALSE(event.mounting);
+
+    ASSERT_EQ(0U, disk_mount_manager_->mount_requests().size());
+
+    volume_manager()->RemoveObserver(&observer);
+  }
+}
+
+TEST_F(VolumeManagerTest, OnDiskAutoMountableEvent_Removed) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  std::unique_ptr<const Disk> mounted_disk = Disk::Builder()
+                                                 .SetDevicePath("device1")
+                                                 .SetMountPath("mount_path")
+                                                 .Build();
+  volume_manager()->OnAutoMountableDiskEvent(DiskMountManager::DISK_REMOVED,
+                                             *mounted_disk);
+
+  ASSERT_EQ(1U, observer.events().size());
+  const LoggingObserver::Event& event = observer.events()[0];
+  EXPECT_EQ(LoggingObserver::Event::DISK_REMOVED, event.type);
+  EXPECT_EQ("device1", event.device_path);
+
+  ASSERT_EQ(1U, disk_mount_manager_->unmount_requests().size());
+  const FakeDiskMountManager::UnmountRequest& unmount_request =
+      disk_mount_manager_->unmount_requests()[0];
+  EXPECT_EQ("mount_path", unmount_request.mount_path);
+  EXPECT_EQ(chromeos::UNMOUNT_OPTIONS_LAZY, unmount_request.options);
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnAutoMountableDiskEvent_RemovedNotMounted) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  std::unique_ptr<const Disk> not_mounted_disk =
+      Disk::Builder().SetDevicePath("device1").Build();
+  volume_manager()->OnAutoMountableDiskEvent(DiskMountManager::DISK_REMOVED,
+                                             *not_mounted_disk);
+
+  ASSERT_EQ(1U, observer.events().size());
+  const LoggingObserver::Event& event = observer.events()[0];
+  EXPECT_EQ(LoggingObserver::Event::DISK_REMOVED, event.type);
+  EXPECT_EQ("device1", event.device_path);
+
+  ASSERT_EQ(0U, disk_mount_manager_->unmount_requests().size());
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnAutoMountableDiskEvent_Changed) {
+  // Changed event should cause mounting (if possible).
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  std::unique_ptr<const Disk> disk =
+      Disk::Builder().SetDevicePath("device1").SetHasMedia(true).Build();
+  volume_manager()->OnAutoMountableDiskEvent(DiskMountManager::DISK_CHANGED,
+                                             *disk);
+
+  EXPECT_EQ(1U, observer.events().size());
+  EXPECT_EQ(1U, disk_mount_manager_->mount_requests().size());
+  EXPECT_EQ(0U, disk_mount_manager_->unmount_requests().size());
+  // Read-write mode by default.
+  EXPECT_EQ(chromeos::MOUNT_ACCESS_MODE_READ_WRITE,
+            disk_mount_manager_->mount_requests()[0].access_mode);
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnAutoMountableDiskEvent_ChangedInReadonly) {
+  profile()->GetPrefs()->SetBoolean(prefs::kExternalStorageReadOnly, true);
+
+  // Changed event should cause mounting (if possible).
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  std::unique_ptr<const Disk> disk =
+      Disk::Builder().SetDevicePath("device1").SetHasMedia(true).Build();
+  volume_manager()->OnAutoMountableDiskEvent(DiskMountManager::DISK_CHANGED,
+                                             *disk);
+
+  EXPECT_EQ(1U, observer.events().size());
+  EXPECT_EQ(1U, disk_mount_manager_->mount_requests().size());
+  EXPECT_EQ(0U, disk_mount_manager_->unmount_requests().size());
+  // Shoule mount a disk in read-only mode.
+  EXPECT_EQ(chromeos::MOUNT_ACCESS_MODE_READ_ONLY,
+            disk_mount_manager_->mount_requests()[0].access_mode);
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnDeviceEvent_Added) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  volume_manager()->OnDeviceEvent(DiskMountManager::DEVICE_ADDED, "device1");
+
+  ASSERT_EQ(1U, observer.events().size());
+  const LoggingObserver::Event& event = observer.events()[0];
+  EXPECT_EQ(LoggingObserver::Event::DEVICE_ADDED, event.type);
+  EXPECT_EQ("device1", event.device_path);
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnDeviceEvent_Removed) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  volume_manager()->OnDeviceEvent(DiskMountManager::DEVICE_REMOVED, "device1");
+
+  ASSERT_EQ(1U, observer.events().size());
+  const LoggingObserver::Event& event = observer.events()[0];
+  EXPECT_EQ(LoggingObserver::Event::DEVICE_REMOVED, event.type);
+  EXPECT_EQ("device1", event.device_path);
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnDeviceEvent_Scanned) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  volume_manager()->OnDeviceEvent(DiskMountManager::DEVICE_SCANNED, "device1");
+
+  // SCANNED event is just ignored.
+  EXPECT_EQ(0U, observer.events().size());
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnMountEvent_MountingAndUnmounting) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  const DiskMountManager::MountPointInfo kMountPoint(
+      "device1", "mount1", chromeos::MOUNT_TYPE_DEVICE,
+      chromeos::disks::MOUNT_CONDITION_NONE);
+
+  volume_manager()->OnMountEvent(DiskMountManager::MOUNTING,
+                                 chromeos::MOUNT_ERROR_NONE, kMountPoint);
+
+  ASSERT_EQ(1U, observer.events().size());
+  LoggingObserver::Event event = observer.events()[0];
+  EXPECT_EQ(LoggingObserver::Event::VOLUME_MOUNTED, event.type);
+  EXPECT_EQ("device1", event.device_path);
+  EXPECT_EQ(chromeos::MOUNT_ERROR_NONE, event.mount_error);
+
+  volume_manager()->OnMountEvent(DiskMountManager::UNMOUNTING,
+                                 chromeos::MOUNT_ERROR_NONE, kMountPoint);
+
+  ASSERT_EQ(2U, observer.events().size());
+  event = observer.events()[1];
+  EXPECT_EQ(LoggingObserver::Event::VOLUME_UNMOUNTED, event.type);
+  EXPECT_EQ("device1", event.device_path);
+  EXPECT_EQ(chromeos::MOUNT_ERROR_NONE, event.mount_error);
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnMountEvent_Remounting) {
+  std::unique_ptr<Disk> disk = Disk::Builder()
+                                   .SetDevicePath("device1")
+                                   .SetFileSystemUUID("uuid1")
+                                   .Build();
+  disk_mount_manager_->AddDiskForTest(std::move(disk));
+  disk_mount_manager_->MountPath("device1", "", "", {},
+                                 chromeos::MOUNT_TYPE_DEVICE,
+                                 chromeos::MOUNT_ACCESS_MODE_READ_WRITE);
+
+  const DiskMountManager::MountPointInfo kMountPoint(
+      "device1", "mount1", chromeos::MOUNT_TYPE_DEVICE,
+      chromeos::disks::MOUNT_CONDITION_NONE);
+
+  volume_manager()->OnMountEvent(DiskMountManager::MOUNTING,
+                                 chromeos::MOUNT_ERROR_NONE, kMountPoint);
+
+  LoggingObserver observer;
+
+  // Emulate system suspend and then resume.
+  {
+    power_manager_client_->SendSuspendImminent(
+        power_manager::SuspendImminent_Reason_OTHER);
+    power_manager_client_->SendSuspendDone();
+
+    // After resume, the device is unmounted and then mounted.
+    volume_manager()->OnMountEvent(DiskMountManager::UNMOUNTING,
+                                   chromeos::MOUNT_ERROR_NONE, kMountPoint);
+
+    // Observe what happened for the mount event.
+    volume_manager()->AddObserver(&observer);
+
+    volume_manager()->OnMountEvent(DiskMountManager::MOUNTING,
+                                   chromeos::MOUNT_ERROR_NONE, kMountPoint);
+  }
+
+  ASSERT_EQ(1U, observer.events().size());
+  const LoggingObserver::Event& event = observer.events()[0];
+  EXPECT_EQ(LoggingObserver::Event::VOLUME_MOUNTED, event.type);
+  EXPECT_EQ("device1", event.device_path);
+  EXPECT_EQ(chromeos::MOUNT_ERROR_NONE, event.mount_error);
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnMountEvent_UnmountingWithoutMounting) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  const DiskMountManager::MountPointInfo kMountPoint(
+      "device1", "mount1", chromeos::MOUNT_TYPE_DEVICE,
+      chromeos::disks::MOUNT_CONDITION_NONE);
+
+  volume_manager()->OnMountEvent(DiskMountManager::UNMOUNTING,
+                                 chromeos::MOUNT_ERROR_NONE, kMountPoint);
+
+  // Unmount event for a disk not mounted in this manager is not reported.
+  ASSERT_EQ(0U, observer.events().size());
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnFormatEvent_Started) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  volume_manager()->OnFormatEvent(DiskMountManager::FORMAT_STARTED,
+                                  chromeos::FORMAT_ERROR_NONE, "device1");
+
+  ASSERT_EQ(1U, observer.events().size());
+  const LoggingObserver::Event& event = observer.events()[0];
+  EXPECT_EQ(LoggingObserver::Event::FORMAT_STARTED, event.type);
+  EXPECT_EQ("device1", event.device_path);
+  EXPECT_TRUE(event.success);
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnFormatEvent_StartFailed) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  volume_manager()->OnFormatEvent(DiskMountManager::FORMAT_STARTED,
+                                  chromeos::FORMAT_ERROR_UNKNOWN, "device1");
+
+  ASSERT_EQ(1U, observer.events().size());
+  const LoggingObserver::Event& event = observer.events()[0];
+  EXPECT_EQ(LoggingObserver::Event::FORMAT_STARTED, event.type);
+  EXPECT_EQ("device1", event.device_path);
+  EXPECT_FALSE(event.success);
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnFormatEvent_Completed) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  volume_manager()->OnFormatEvent(DiskMountManager::FORMAT_COMPLETED,
+                                  chromeos::FORMAT_ERROR_NONE, "device1");
+
+  ASSERT_EQ(1U, observer.events().size());
+  const LoggingObserver::Event& event = observer.events()[0];
+  EXPECT_EQ(LoggingObserver::Event::FORMAT_COMPLETED, event.type);
+  EXPECT_EQ("device1", event.device_path);
+  EXPECT_TRUE(event.success);
+
+  // When "format" is successfully done, VolumeManager requests to mount it.
+  ASSERT_EQ(1U, disk_mount_manager_->mount_requests().size());
+  const FakeDiskMountManager::MountRequest& mount_request =
+      disk_mount_manager_->mount_requests()[0];
+  EXPECT_EQ("device1", mount_request.source_path);
+  EXPECT_EQ("", mount_request.source_format);
+  EXPECT_EQ("", mount_request.mount_label);
+  EXPECT_EQ(chromeos::MOUNT_TYPE_DEVICE, mount_request.type);
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnFormatEvent_CompletedFailed) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  volume_manager()->OnFormatEvent(DiskMountManager::FORMAT_COMPLETED,
+                                  chromeos::FORMAT_ERROR_UNKNOWN, "device1");
+
+  ASSERT_EQ(1U, observer.events().size());
+  const LoggingObserver::Event& event = observer.events()[0];
+  EXPECT_EQ(LoggingObserver::Event::FORMAT_COMPLETED, event.type);
+  EXPECT_EQ("device1", event.device_path);
+  EXPECT_FALSE(event.success);
+
+  EXPECT_EQ(0U, disk_mount_manager_->mount_requests().size());
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnExternalStorageDisabledChanged) {
+  // Here create two mount points.
+  disk_mount_manager_->MountPath("mount1", "", "", {},
+                                 chromeos::MOUNT_TYPE_DEVICE,
+                                 chromeos::MOUNT_ACCESS_MODE_READ_WRITE);
+  disk_mount_manager_->MountPath("mount2", "", "", {},
+                                 chromeos::MOUNT_TYPE_DEVICE,
+                                 chromeos::MOUNT_ACCESS_MODE_READ_ONLY);
+
+  // Initially, there are two mount points.
+  ASSERT_EQ(2U, disk_mount_manager_->mount_points().size());
+  ASSERT_EQ(0U, disk_mount_manager_->unmount_requests().size());
+
+  // Emulate to set kExternalStorageDisabled to false.
+  profile()->GetPrefs()->SetBoolean(prefs::kExternalStorageDisabled, false);
+  volume_manager()->OnExternalStorageDisabledChanged();
+
+  // Expect no effects.
+  EXPECT_EQ(2U, disk_mount_manager_->mount_points().size());
+  EXPECT_EQ(0U, disk_mount_manager_->unmount_requests().size());
+
+  // Emulate to set kExternalStorageDisabled to true.
+  profile()->GetPrefs()->SetBoolean(prefs::kExternalStorageDisabled, true);
+  volume_manager()->OnExternalStorageDisabledChanged();
+
+  // Wait until all unmount request finishes, so that callback chain to unmount
+  // all the mount points will be invoked.
+  disk_mount_manager_->FinishAllUnmountPathRequests();
+
+  // The all mount points should be unmounted.
+  EXPECT_EQ(0U, disk_mount_manager_->mount_points().size());
+
+  EXPECT_EQ(2U, disk_mount_manager_->unmount_requests().size());
+  const FakeDiskMountManager::UnmountRequest& unmount_request1 =
+      disk_mount_manager_->unmount_requests()[0];
+  EXPECT_EQ("mount1", unmount_request1.mount_path);
+
+  const FakeDiskMountManager::UnmountRequest& unmount_request2 =
+      disk_mount_manager_->unmount_requests()[1];
+  EXPECT_EQ("mount2", unmount_request2.mount_path);
+}
+
+TEST_F(VolumeManagerTest, ExternalStorageDisabledPolicyMultiProfile) {
+  ProfileEnvironment secondary(power_manager_client_.get(),
+                               disk_mount_manager_.get());
+  volume_manager()->Initialize();
+  secondary.volume_manager()->Initialize();
+
+  // Simulates the case that the main profile has kExternalStorageDisabled set
+  // as false, and the secondary profile has the config set to true.
+  profile()->GetPrefs()->SetBoolean(prefs::kExternalStorageDisabled, false);
+  secondary.profile()->GetPrefs()->SetBoolean(prefs::kExternalStorageDisabled,
+                                              true);
+
+  LoggingObserver main_observer, secondary_observer;
+  volume_manager()->AddObserver(&main_observer);
+  secondary.volume_manager()->AddObserver(&secondary_observer);
+
+  // Add 1 disk.
+  std::unique_ptr<const Disk> media_disk =
+      Disk::Builder().SetDevicePath("device1").SetHasMedia(true).Build();
+  volume_manager()->OnAutoMountableDiskEvent(DiskMountManager::DISK_ADDED,
+                                             *media_disk);
+  secondary.volume_manager()->OnAutoMountableDiskEvent(
+      DiskMountManager::DISK_ADDED, *media_disk);
+
+  // The profile with external storage enabled should have mounted the volume.
+  bool has_volume_mounted = false;
+  for (size_t i = 0; i < main_observer.events().size(); ++i) {
+    if (main_observer.events()[i].type ==
+        LoggingObserver::Event::VOLUME_MOUNTED)
+      has_volume_mounted = true;
+  }
+  EXPECT_TRUE(has_volume_mounted);
+
+  // The other profiles with external storage disabled should have not.
+  has_volume_mounted = false;
+  for (size_t i = 0; i < secondary_observer.events().size(); ++i) {
+    if (secondary_observer.events()[i].type ==
+        LoggingObserver::Event::VOLUME_MOUNTED)
+      has_volume_mounted = true;
+  }
+  EXPECT_FALSE(has_volume_mounted);
+
+  volume_manager()->RemoveObserver(&main_observer);
+  secondary.volume_manager()->RemoveObserver(&secondary_observer);
+}
+
+TEST_F(VolumeManagerTest, OnExternalStorageReadOnlyChanged) {
+  // Emulate updates of kExternalStorageReadOnly (change to true, then false).
+  profile()->GetPrefs()->SetBoolean(prefs::kExternalStorageReadOnly, true);
+  volume_manager()->OnExternalStorageReadOnlyChanged();
+  profile()->GetPrefs()->SetBoolean(prefs::kExternalStorageReadOnly, false);
+  volume_manager()->OnExternalStorageReadOnlyChanged();
+
+  // Verify that remount of removable disks is triggered for each update.
+  ASSERT_EQ(2U, disk_mount_manager_->remount_all_requests().size());
+  const FakeDiskMountManager::RemountAllRequest& remount_request1 =
+      disk_mount_manager_->remount_all_requests()[0];
+  EXPECT_EQ(chromeos::MOUNT_ACCESS_MODE_READ_ONLY,
+            remount_request1.access_mode);
+  const FakeDiskMountManager::RemountAllRequest& remount_request2 =
+      disk_mount_manager_->remount_all_requests()[1];
+  EXPECT_EQ(chromeos::MOUNT_ACCESS_MODE_READ_WRITE,
+            remount_request2.access_mode);
+}
+
+TEST_F(VolumeManagerTest, GetVolumeList) {
+  volume_manager()->Initialize();  // Adds "Downloads"
+  std::vector<base::WeakPtr<Volume>> volume_list =
+      volume_manager()->GetVolumeList();
+  ASSERT_EQ(1u, volume_list.size());
+  EXPECT_EQ("downloads:Downloads", volume_list[0]->volume_id());
+  EXPECT_EQ(VOLUME_TYPE_DOWNLOADS_DIRECTORY, volume_list[0]->type());
+}
+
+TEST_F(VolumeManagerTest, FindVolumeById) {
+  volume_manager()->Initialize();  // Adds "Downloads"
+  base::WeakPtr<Volume> bad_volume =
+      volume_manager()->FindVolumeById("nonexistent");
+  ASSERT_FALSE(bad_volume.get());
+  base::WeakPtr<Volume> good_volume =
+      volume_manager()->FindVolumeById("downloads:Downloads");
+  ASSERT_TRUE(good_volume.get());
+  EXPECT_EQ("downloads:Downloads", good_volume->volume_id());
+  EXPECT_EQ(VOLUME_TYPE_DOWNLOADS_DIRECTORY, good_volume->type());
+}
+
+TEST_F(VolumeManagerTest, ArchiveSourceFiltering) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  // Mount a USB stick.
+  volume_manager()->OnMountEvent(
+      DiskMountManager::MOUNTING, chromeos::MOUNT_ERROR_NONE,
+      DiskMountManager::MountPointInfo("/removable/usb", "/removable/usb",
+                                       chromeos::MOUNT_TYPE_DEVICE,
+                                       chromeos::disks::MOUNT_CONDITION_NONE));
+
+  // Mount a zip archive in the stick.
+  volume_manager()->OnMountEvent(
+      DiskMountManager::MOUNTING, chromeos::MOUNT_ERROR_NONE,
+      DiskMountManager::MountPointInfo("/removable/usb/1.zip", "/archive/1",
+                                       chromeos::MOUNT_TYPE_ARCHIVE,
+                                       chromeos::disks::MOUNT_CONDITION_NONE));
+  base::WeakPtr<Volume> volume = volume_manager()->FindVolumeById("archive:1");
+  ASSERT_TRUE(volume.get());
+  EXPECT_EQ("/archive/1", volume->mount_path().AsUTF8Unsafe());
+  EXPECT_EQ(2u, observer.events().size());
+
+  // Mount a zip archive in the previous zip archive.
+  volume_manager()->OnMountEvent(
+      DiskMountManager::MOUNTING, chromeos::MOUNT_ERROR_NONE,
+      DiskMountManager::MountPointInfo("/archive/1/2.zip", "/archive/2",
+                                       chromeos::MOUNT_TYPE_ARCHIVE,
+                                       chromeos::disks::MOUNT_CONDITION_NONE));
+  base::WeakPtr<Volume> second_volume =
+      volume_manager()->FindVolumeById("archive:2");
+  ASSERT_TRUE(second_volume.get());
+  EXPECT_EQ("/archive/2", second_volume->mount_path().AsUTF8Unsafe());
+  EXPECT_EQ(3u, observer.events().size());
+
+  // A zip file is mounted from other profile. It must be ignored in the current
+  // VolumeManager.
+  volume_manager()->OnMountEvent(
+      DiskMountManager::MOUNTING, chromeos::MOUNT_ERROR_NONE,
+      DiskMountManager::MountPointInfo(
+          "/other/profile/drive/folder/3.zip", "/archive/3",
+          chromeos::MOUNT_TYPE_ARCHIVE, chromeos::disks::MOUNT_CONDITION_NONE));
+  base::WeakPtr<Volume> third_volume =
+      volume_manager()->FindVolumeById("archive:3");
+  ASSERT_FALSE(third_volume.get());
+  EXPECT_EQ(3u, observer.events().size());
+}
+
+TEST_F(VolumeManagerTest, MTPPlugAndUnplug) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  storage_monitor::StorageInfo info(
+      storage_monitor::StorageInfo::MakeDeviceId(
+          storage_monitor::StorageInfo::MTP_OR_PTP, "dummy-device-id"),
+      FILE_PATH_LITERAL("/dummy/device/location"),
+      base::UTF8ToUTF16("label"),
+      base::UTF8ToUTF16("vendor"),
+      base::UTF8ToUTF16("model"),
+      12345 /* size */);
+
+  storage_monitor::StorageInfo non_mtp_info(
+      storage_monitor::StorageInfo::MakeDeviceId(
+          storage_monitor::StorageInfo::FIXED_MASS_STORAGE, "dummy-device-id2"),
+      FILE_PATH_LITERAL("/dummy/device/location2"),
+      base::UTF8ToUTF16("label2"),
+      base::UTF8ToUTF16("vendor2"),
+      base::UTF8ToUTF16("model2"),
+      12345 /* size */);
+
+  // Attach
+  volume_manager()->OnRemovableStorageAttached(info);
+  ASSERT_EQ(1u, observer.events().size());
+  EXPECT_EQ(LoggingObserver::Event::VOLUME_MOUNTED, observer.events()[0].type);
+
+  base::WeakPtr<Volume> volume = volume_manager()->FindVolumeById("mtp:model");
+  EXPECT_EQ(VOLUME_TYPE_MTP, volume->type());
+
+  // Non MTP events from storage monitor are ignored.
+  volume_manager()->OnRemovableStorageAttached(non_mtp_info);
+  EXPECT_EQ(1u, observer.events().size());
+
+  // Detach
+  volume_manager()->OnRemovableStorageDetached(info);
+  ASSERT_EQ(2u, observer.events().size());
+  EXPECT_EQ(LoggingObserver::Event::VOLUME_UNMOUNTED,
+            observer.events()[1].type);
+
+  EXPECT_FALSE(volume.get());
+}
+
+TEST_F(VolumeManagerTest, OnRenameEvent_Started) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  volume_manager()->OnRenameEvent(DiskMountManager::RENAME_STARTED,
+                                  chromeos::RENAME_ERROR_NONE, "device1");
+
+  ASSERT_EQ(1U, observer.events().size());
+  const LoggingObserver::Event& event = observer.events()[0];
+  EXPECT_EQ(LoggingObserver::Event::RENAME_STARTED, event.type);
+  EXPECT_EQ("device1", event.device_path);
+  EXPECT_TRUE(event.success);
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnRenameEvent_StartFailed) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  volume_manager()->OnRenameEvent(DiskMountManager::RENAME_STARTED,
+                                  chromeos::RENAME_ERROR_UNKNOWN, "device1");
+
+  ASSERT_EQ(1U, observer.events().size());
+  const LoggingObserver::Event& event = observer.events()[0];
+  EXPECT_EQ(LoggingObserver::Event::RENAME_STARTED, event.type);
+  EXPECT_EQ("device1", event.device_path);
+  EXPECT_FALSE(event.success);
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnRenameEvent_Completed) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  volume_manager()->OnRenameEvent(DiskMountManager::RENAME_COMPLETED,
+                                  chromeos::RENAME_ERROR_NONE, "device1");
+
+  ASSERT_EQ(1U, observer.events().size());
+  const LoggingObserver::Event& event = observer.events()[0];
+  EXPECT_EQ(LoggingObserver::Event::RENAME_COMPLETED, event.type);
+  EXPECT_EQ("device1", event.device_path);
+  EXPECT_TRUE(event.success);
+
+  // When "rename" is successfully done, VolumeManager requests to mount it.
+  ASSERT_EQ(1U, disk_mount_manager_->mount_requests().size());
+  const FakeDiskMountManager::MountRequest& mount_request =
+      disk_mount_manager_->mount_requests()[0];
+  EXPECT_EQ("device1", mount_request.source_path);
+  EXPECT_EQ("", mount_request.source_format);
+  EXPECT_EQ(chromeos::MOUNT_TYPE_DEVICE, mount_request.type);
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+TEST_F(VolumeManagerTest, OnRenameEvent_CompletedFailed) {
+  LoggingObserver observer;
+  volume_manager()->AddObserver(&observer);
+
+  volume_manager()->OnRenameEvent(DiskMountManager::RENAME_COMPLETED,
+                                  chromeos::RENAME_ERROR_UNKNOWN, "device1");
+
+  ASSERT_EQ(1U, observer.events().size());
+  const LoggingObserver::Event& event = observer.events()[0];
+  EXPECT_EQ(LoggingObserver::Event::RENAME_COMPLETED, event.type);
+  EXPECT_EQ("device1", event.device_path);
+  EXPECT_FALSE(event.success);
+
+  EXPECT_EQ(1U, disk_mount_manager_->mount_requests().size());
+
+  volume_manager()->RemoveObserver(&observer);
+}
+
+}  // namespace file_manager

From d1636d871586d8673eccceaa5c01ae357218e1c6 Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Wed, 22 Aug 2018 17:31:50 +0900
Subject: [PATCH 21/32] Add fileapi to chrome/browser/

It adds fileapi for managing files to chrome/browser/
to share them with Linux/Ozone build.
It was used only for ChromeOS and the original code is
from chrome/browser/chromeos/fileapi.
---
 chrome/browser/fileapi/DEPS                   |   3 +
 chrome/browser/fileapi/OWNERS                 |   3 +
 .../fileapi/external_file_protocol_handler.cc |  28 +
 .../fileapi/external_file_protocol_handler.h  |  33 ++
 .../fileapi/external_file_url_request_job.cc  | 384 +++++++++++++
 .../fileapi/external_file_url_request_job.h   | 123 +++++
 .../external_file_url_request_job_unittest.cc | 415 ++++++++++++++
 .../browser/fileapi/external_file_url_util.cc |  81 +++
 .../browser/fileapi/external_file_url_util.h  |  46 ++
 .../external_file_url_util_unittest.cc        | 116 ++++
 .../fileapi/file_access_permissions.cc        |  49 ++
 .../browser/fileapi/file_access_permissions.h |  46 ++
 .../file_access_permissions_unittest.cc       |  62 +++
 chrome/browser/fileapi/file_system_backend.cc | 510 ++++++++++++++++++
 chrome/browser/fileapi/file_system_backend.h  | 189 +++++++
 .../fileapi/file_system_backend_delegate.h    |  70 +++
 .../fileapi/file_system_backend_unittest.cc   | 259 +++++++++
 .../mtp_file_system_backend_delegate.cc       |  70 +++
 .../mtp_file_system_backend_delegate.h        |  68 +++
 chrome/browser/fileapi/mtp_watcher_manager.cc |  39 ++
 chrome/browser/fileapi/mtp_watcher_manager.h  |  40 ++
 .../fileapi/recent_arc_media_source.cc        | 373 +++++++++++++
 .../browser/fileapi/recent_arc_media_source.h |  67 +++
 .../recent_arc_media_source_unittest.cc       | 208 +++++++
 .../browser/fileapi/recent_download_source.cc | 210 ++++++++
 .../browser/fileapi/recent_download_source.h  |  79 +++
 .../recent_download_source_unittest.cc        | 152 ++++++
 chrome/browser/fileapi/recent_drive_source.cc | 168 ++++++
 chrome/browser/fileapi/recent_drive_source.h  |  74 +++
 chrome/browser/fileapi/recent_file.cc         |  28 +
 chrome/browser/fileapi/recent_file.h          |  37 ++
 chrome/browser/fileapi/recent_model.cc        | 204 +++++++
 chrome/browser/fileapi/recent_model.h         | 121 +++++
 .../browser/fileapi/recent_model_factory.cc   |  78 +++
 chrome/browser/fileapi/recent_model_factory.h |  52 ++
 .../browser/fileapi/recent_model_unittest.cc  | 136 +++++
 chrome/browser/fileapi/recent_source.cc       |  34 ++
 chrome/browser/fileapi/recent_source.h        |  97 ++++
 .../fileapi/test/fake_recent_source.cc        |  25 +
 .../browser/fileapi/test/fake_recent_source.h |  39 ++
 40 files changed, 4816 insertions(+)
 create mode 100644 chrome/browser/fileapi/DEPS
 create mode 100644 chrome/browser/fileapi/OWNERS
 create mode 100644 chrome/browser/fileapi/external_file_protocol_handler.cc
 create mode 100644 chrome/browser/fileapi/external_file_protocol_handler.h
 create mode 100644 chrome/browser/fileapi/external_file_url_request_job.cc
 create mode 100644 chrome/browser/fileapi/external_file_url_request_job.h
 create mode 100644 chrome/browser/fileapi/external_file_url_request_job_unittest.cc
 create mode 100644 chrome/browser/fileapi/external_file_url_util.cc
 create mode 100644 chrome/browser/fileapi/external_file_url_util.h
 create mode 100644 chrome/browser/fileapi/external_file_url_util_unittest.cc
 create mode 100644 chrome/browser/fileapi/file_access_permissions.cc
 create mode 100644 chrome/browser/fileapi/file_access_permissions.h
 create mode 100644 chrome/browser/fileapi/file_access_permissions_unittest.cc
 create mode 100644 chrome/browser/fileapi/file_system_backend.cc
 create mode 100644 chrome/browser/fileapi/file_system_backend.h
 create mode 100644 chrome/browser/fileapi/file_system_backend_delegate.h
 create mode 100644 chrome/browser/fileapi/file_system_backend_unittest.cc
 create mode 100644 chrome/browser/fileapi/mtp_file_system_backend_delegate.cc
 create mode 100644 chrome/browser/fileapi/mtp_file_system_backend_delegate.h
 create mode 100644 chrome/browser/fileapi/mtp_watcher_manager.cc
 create mode 100644 chrome/browser/fileapi/mtp_watcher_manager.h
 create mode 100644 chrome/browser/fileapi/recent_arc_media_source.cc
 create mode 100644 chrome/browser/fileapi/recent_arc_media_source.h
 create mode 100644 chrome/browser/fileapi/recent_arc_media_source_unittest.cc
 create mode 100644 chrome/browser/fileapi/recent_download_source.cc
 create mode 100644 chrome/browser/fileapi/recent_download_source.h
 create mode 100644 chrome/browser/fileapi/recent_download_source_unittest.cc
 create mode 100644 chrome/browser/fileapi/recent_drive_source.cc
 create mode 100644 chrome/browser/fileapi/recent_drive_source.h
 create mode 100644 chrome/browser/fileapi/recent_file.cc
 create mode 100644 chrome/browser/fileapi/recent_file.h
 create mode 100644 chrome/browser/fileapi/recent_model.cc
 create mode 100644 chrome/browser/fileapi/recent_model.h
 create mode 100644 chrome/browser/fileapi/recent_model_factory.cc
 create mode 100644 chrome/browser/fileapi/recent_model_factory.h
 create mode 100644 chrome/browser/fileapi/recent_model_unittest.cc
 create mode 100644 chrome/browser/fileapi/recent_source.cc
 create mode 100644 chrome/browser/fileapi/recent_source.h
 create mode 100644 chrome/browser/fileapi/test/fake_recent_source.cc
 create mode 100644 chrome/browser/fileapi/test/fake_recent_source.h

diff --git a/chrome/browser/fileapi/DEPS b/chrome/browser/fileapi/DEPS
new file mode 100644
index 0000000000000..cdad3c26c29a9
--- /dev/null
+++ b/chrome/browser/fileapi/DEPS
@@ -0,0 +1,3 @@
+include_rules = [
+  "+components/drive",
+]
diff --git a/chrome/browser/fileapi/OWNERS b/chrome/browser/fileapi/OWNERS
new file mode 100644
index 0000000000000..af6116913f76b
--- /dev/null
+++ b/chrome/browser/fileapi/OWNERS
@@ -0,0 +1,3 @@
+fukino@chromium.org
+yamaguchi@chromium.org
+
diff --git a/chrome/browser/fileapi/external_file_protocol_handler.cc b/chrome/browser/fileapi/external_file_protocol_handler.cc
new file mode 100644
index 0000000000000..f4c2f22d906f7
--- /dev/null
+++ b/chrome/browser/fileapi/external_file_protocol_handler.cc
@@ -0,0 +1,28 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/external_file_protocol_handler.h"
+
+#include "base/logging.h"
+#include "chrome/browser/fileapi/external_file_url_request_job.h"
+#include "net/url_request/url_request.h"
+#include "url/gurl.h"
+
+namespace chromeos {
+
+ExternalFileProtocolHandler::ExternalFileProtocolHandler(void* profile_id)
+    : profile_id_(profile_id) {
+}
+
+ExternalFileProtocolHandler::~ExternalFileProtocolHandler() {
+}
+
+net::URLRequestJob* ExternalFileProtocolHandler::MaybeCreateJob(
+    net::URLRequest* request,
+    net::NetworkDelegate* network_delegate) const {
+  DVLOG(1) << "Handling url: " << request->url().spec();
+  return new ExternalFileURLRequestJob(profile_id_, request, network_delegate);
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/external_file_protocol_handler.h b/chrome/browser/fileapi/external_file_protocol_handler.h
new file mode 100644
index 0000000000000..d39da8c8ae95b
--- /dev/null
+++ b/chrome/browser/fileapi/external_file_protocol_handler.h
@@ -0,0 +1,33 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILEAPI_EXTERNAL_FILE_PROTOCOL_HANDLER_H_
+#define CHROME_BROWSER_FILEAPI_EXTERNAL_FILE_PROTOCOL_HANDLER_H_
+
+#include "base/macros.h"
+#include "net/url_request/url_request_job_factory.h"
+
+namespace chromeos {
+
+class ExternalFileProtocolHandler
+    : public net::URLRequestJobFactory::ProtocolHandler {
+ public:
+  explicit ExternalFileProtocolHandler(void* profile_id);
+  ~ExternalFileProtocolHandler() override;
+
+  // Creates URLRequestJobs for drive:// URLs.
+  net::URLRequestJob* MaybeCreateJob(
+      net::URLRequest* request,
+      net::NetworkDelegate* network_delegate) const override;
+
+ private:
+  // The profile for processing Drive accesses. Should not be NULL.
+  void* profile_id_;
+
+  DISALLOW_COPY_AND_ASSIGN(ExternalFileProtocolHandler);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROME_BROWSER_FILEAPI_EXTERNAL_FILE_PROTOCOL_HANDLER_H_
diff --git a/chrome/browser/fileapi/external_file_url_request_job.cc b/chrome/browser/fileapi/external_file_url_request_job.cc
new file mode 100644
index 0000000000000..ecac362638e96
--- /dev/null
+++ b/chrome/browser/fileapi/external_file_url_request_job.cc
@@ -0,0 +1,384 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/external_file_url_request_job.h"
+
+#include <algorithm>
+#include <utility>
+#include <vector>
+
+#include "base/bind.h"
+#include "base/logging.h"
+#include "base/macros.h"
+#include "base/memory/ref_counted.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/fileapi/external_file_url_util.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "components/drive/file_system_core_util.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/storage_partition.h"
+#include "content/public/common/url_constants.h"
+#include "extensions/browser/api/file_handlers/mime_util.h"
+#include "net/http/http_byte_range.h"
+#include "net/http/http_request_headers.h"
+#include "net/http/http_response_info.h"
+#include "net/http/http_util.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_status.h"
+#include "storage/browser/fileapi/external_mount_points.h"
+#include "storage/browser/fileapi/file_system_backend.h"
+#include "storage/browser/fileapi/file_system_context.h"
+#include "storage/browser/fileapi/file_system_operation_runner.h"
+#include "storage/browser/fileapi/isolated_context.h"
+
+using content::BrowserThread;
+
+namespace chromeos {
+namespace {
+
+const char kMimeTypeForRFC822[] = "message/rfc822";
+const char kMimeTypeForMHTML[] = "multipart/related";
+
+// Helper for obtaining FileSystemContext, FileSystemURL, and mime type on the
+// UI thread.
+class URLHelper {
+ public:
+  // The scoped pointer to control lifetime of the instance itself. The pointer
+  // is passed to callback functions and binds the lifetime of the instance to
+  // the callback's lifetime.
+  typedef std::unique_ptr<URLHelper> Lifetime;
+
+  URLHelper(void* profile_id,
+            const GURL& url,
+            const ExternalFileURLRequestJob::HelperCallback& callback)
+      : profile_id_(profile_id), url_(url), callback_(callback) {
+    DCHECK_CURRENTLY_ON(BrowserThread::IO);
+    Lifetime lifetime(this);
+    BrowserThread::PostTask(BrowserThread::UI,
+                            FROM_HERE,
+                            base::Bind(&URLHelper::RunOnUIThread,
+                                       base::Unretained(this),
+                                       base::Passed(&lifetime)));
+  }
+
+ private:
+  void RunOnUIThread(Lifetime lifetime) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+    if (!g_browser_process->profile_manager()->IsValidProfile(profile_id_)) {
+      ReplyResult(net::ERR_FAILED);
+      return;
+    }
+    Profile* const profile = reinterpret_cast<Profile*>(profile_id_);
+    content::StoragePartition* const storage =
+        content::BrowserContext::GetStoragePartitionForSite(profile, url_);
+    DCHECK(storage);
+
+    scoped_refptr<storage::FileSystemContext> context =
+        storage->GetFileSystemContext();
+    DCHECK(context.get());
+
+    // Obtain the absolute path in the file system.
+    const base::FilePath virtual_path = ExternalFileURLToVirtualPath(url_);
+
+    // Obtain the file system URL.
+    file_system_url_ = file_manager::util::CreateIsolatedURLFromVirtualPath(
+        *context, /* empty origin */ GURL(), virtual_path);
+
+    // Check if the obtained path providing external file URL or not.
+    if (!file_system_url_.is_valid()) {
+      ReplyResult(net::ERR_INVALID_URL);
+      return;
+    }
+
+    isolated_file_system_scope_.reset(
+        new ExternalFileURLRequestJob::IsolatedFileSystemScope(
+            file_system_url_.filesystem_id()));
+
+    if (!IsExternalFileURLType(file_system_url_.type())) {
+      ReplyResult(net::ERR_FAILED);
+      return;
+    }
+
+    file_system_context_ = context;
+    extensions::app_file_handler_util::GetMimeTypeForLocalPath(
+        profile,
+        file_system_url_.path(),
+        base::Bind(&URLHelper::OnGotMimeTypeOnUIThread,
+                   base::Unretained(this),
+                   base::Passed(&lifetime)));
+  }
+
+  void OnGotMimeTypeOnUIThread(Lifetime lifetime,
+                               const std::string& mime_type) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+    mime_type_ = mime_type;
+
+    if (mime_type_ == kMimeTypeForRFC822)
+      mime_type_ = kMimeTypeForMHTML;
+
+    ReplyResult(net::OK);
+  }
+
+  void ReplyResult(net::Error error) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    BrowserThread::PostTask(
+        BrowserThread::IO,
+        FROM_HERE,
+        base::Bind(callback_,
+                   error,
+                   file_system_context_,
+                   base::Passed(&isolated_file_system_scope_),
+                   file_system_url_,
+                   mime_type_));
+  }
+
+  void* const profile_id_;
+  const GURL url_;
+  const ExternalFileURLRequestJob::HelperCallback callback_;
+  scoped_refptr<storage::FileSystemContext> file_system_context_;
+  std::unique_ptr<ExternalFileURLRequestJob::IsolatedFileSystemScope>
+      isolated_file_system_scope_;
+  storage::FileSystemURL file_system_url_;
+  std::string mime_type_;
+
+  DISALLOW_COPY_AND_ASSIGN(URLHelper);
+};
+
+}  // namespace
+
+ExternalFileURLRequestJob::IsolatedFileSystemScope::IsolatedFileSystemScope(
+    const std::string& file_system_id)
+    : file_system_id_(file_system_id) {
+}
+
+ExternalFileURLRequestJob::IsolatedFileSystemScope::~IsolatedFileSystemScope() {
+  storage::IsolatedContext::GetInstance()->RevokeFileSystem(file_system_id_);
+}
+
+ExternalFileURLRequestJob::ExternalFileURLRequestJob(
+    void* profile_id,
+    net::URLRequest* request,
+    net::NetworkDelegate* network_delegate)
+    : net::URLRequestJob(request, network_delegate),
+      profile_id_(profile_id),
+      range_parse_result_(net::OK),
+      remaining_bytes_(0),
+      weak_ptr_factory_(this) {}
+
+void ExternalFileURLRequestJob::SetExtraRequestHeaders(
+    const net::HttpRequestHeaders& headers) {
+  std::string range_header;
+  if (headers.GetHeader(net::HttpRequestHeaders::kRange, &range_header)) {
+    // Currently this job only cares about the Range header, and only supports
+    // single range requests. Note that validation is deferred to Start,
+    // because NotifyStartError is not legal to call since the job has not
+    // started.
+    std::vector<net::HttpByteRange> ranges;
+    if (net::HttpUtil::ParseRangeHeader(range_header, &ranges) &&
+        ranges.size() == 1) {
+      byte_range_ = ranges[0];
+    } else {
+      range_parse_result_ = net::ERR_REQUEST_RANGE_NOT_SATISFIABLE;
+    }
+  }
+}
+
+void ExternalFileURLRequestJob::Start() {
+  // Post a task to invoke StartAsync asynchronously to avoid re-entering the
+  // delegate, because NotifyStartError is not legal to call synchronously in
+  // Start().
+  base::ThreadTaskRunnerHandle::Get()->PostTask(
+      FROM_HERE, base::Bind(&ExternalFileURLRequestJob::StartAsync,
+                            weak_ptr_factory_.GetWeakPtr()));
+}
+
+void ExternalFileURLRequestJob::StartAsync() {
+  DVLOG(1) << "Starting request";
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  DCHECK(!stream_reader_);
+
+  if (range_parse_result_ != net::OK) {
+    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
+                                           range_parse_result_));
+    return;
+  }
+
+  // We only support GET request.
+  if (request()->method() != "GET") {
+    LOG(WARNING) << "Failed to start request: " << request()->method()
+                 << " method is not supported";
+    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
+                                           net::ERR_METHOD_NOT_SUPPORTED));
+    return;
+  }
+
+  // Check if the scheme is correct.
+  if (!request()->url().SchemeIs(content::kExternalFileScheme)) {
+    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
+                                           net::ERR_INVALID_URL));
+    return;
+  }
+
+  // Owned by itself.
+  new URLHelper(profile_id_,
+                request()->url(),
+                base::Bind(&ExternalFileURLRequestJob::OnHelperResultObtained,
+                           weak_ptr_factory_.GetWeakPtr()));
+}
+
+void ExternalFileURLRequestJob::OnHelperResultObtained(
+    net::Error error,
+    const scoped_refptr<storage::FileSystemContext>& file_system_context,
+    std::unique_ptr<IsolatedFileSystemScope> isolated_file_system_scope,
+    const storage::FileSystemURL& file_system_url,
+    const std::string& mime_type) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  if (error != net::OK) {
+    NotifyStartError(
+        net::URLRequestStatus(net::URLRequestStatus::FAILED, error));
+    return;
+  }
+
+  DCHECK(file_system_context.get());
+  file_system_context_ = file_system_context;
+  isolated_file_system_scope_ = std::move(isolated_file_system_scope);
+  file_system_url_ = file_system_url;
+  mime_type_ = mime_type;
+
+  // Check if the entry has a redirect URL.
+  file_system_context_->external_backend()->GetRedirectURLForContents(
+      file_system_url_,
+      base::Bind(&ExternalFileURLRequestJob::OnRedirectURLObtained,
+                 weak_ptr_factory_.GetWeakPtr()));
+}
+
+void ExternalFileURLRequestJob::OnRedirectURLObtained(
+    const GURL& redirect_url) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  redirect_url_ = redirect_url;
+  if (!redirect_url_.is_empty()) {
+    NotifyHeadersComplete();
+    return;
+  }
+
+  // Obtain file system context.
+  file_system_context_->operation_runner()->GetMetadata(
+      file_system_url_,
+      storage::FileSystemOperation::GET_METADATA_FIELD_IS_DIRECTORY |
+          storage::FileSystemOperation::GET_METADATA_FIELD_SIZE,
+      base::Bind(&ExternalFileURLRequestJob::OnFileInfoObtained,
+                 weak_ptr_factory_.GetWeakPtr()));
+}
+
+void ExternalFileURLRequestJob::OnFileInfoObtained(
+    base::File::Error result,
+    const base::File::Info& file_info) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  if (result == base::File::FILE_ERROR_NOT_FOUND) {
+    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
+                                           net::ERR_FILE_NOT_FOUND));
+    return;
+  }
+
+  if (result != base::File::FILE_OK || file_info.is_directory ||
+      file_info.size < 0) {
+    NotifyStartError(
+        net::URLRequestStatus(net::URLRequestStatus::FAILED, net::ERR_FAILED));
+    return;
+  }
+
+  // Compute content size.
+  if (!byte_range_.ComputeBounds(file_info.size)) {
+    NotifyStartError(net::URLRequestStatus(
+        net::URLRequestStatus::FAILED, net::ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+    return;
+  }
+  const int64_t offset = byte_range_.first_byte_position();
+  const int64_t size =
+      byte_range_.last_byte_position() + 1 - byte_range_.first_byte_position();
+  set_expected_content_size(size);
+  remaining_bytes_ = size;
+
+  // Create file stream reader.
+  stream_reader_ = file_system_context_->CreateFileStreamReader(
+      file_system_url_, offset, size, base::Time());
+  if (!stream_reader_) {
+    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
+                                           net::ERR_FILE_NOT_FOUND));
+    return;
+  }
+
+  NotifyHeadersComplete();
+}
+
+void ExternalFileURLRequestJob::Kill() {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  stream_reader_.reset();
+  isolated_file_system_scope_.reset();
+  file_system_context_ = NULL;
+  net::URLRequestJob::Kill();
+  weak_ptr_factory_.InvalidateWeakPtrs();
+}
+
+bool ExternalFileURLRequestJob::GetMimeType(std::string* mime_type) const {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  mime_type->assign(mime_type_);
+  return !mime_type->empty();
+}
+
+bool ExternalFileURLRequestJob::IsRedirectResponse(
+    GURL* location,
+    int* http_status_code,
+    bool* insecure_scheme_was_upgraded) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  if (redirect_url_.is_empty())
+    return false;
+
+  // Redirect a hosted document.
+  *insecure_scheme_was_upgraded = false;
+  *location = redirect_url_;
+  const int kHttpFound = 302;
+  *http_status_code = kHttpFound;
+  return true;
+}
+
+int ExternalFileURLRequestJob::ReadRawData(net::IOBuffer* buf, int buf_size) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  DCHECK(stream_reader_);
+
+  if (remaining_bytes_ == 0)
+    return 0;
+
+  const int result = stream_reader_->Read(
+      buf, std::min<int64_t>(buf_size, remaining_bytes_),
+      base::Bind(&ExternalFileURLRequestJob::OnReadCompleted,
+                 weak_ptr_factory_.GetWeakPtr()));
+
+  if (result < 0)
+    return result;
+
+  remaining_bytes_ -= result;
+  return result;
+}
+
+ExternalFileURLRequestJob::~ExternalFileURLRequestJob() {
+}
+
+void ExternalFileURLRequestJob::OnReadCompleted(int read_result) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  if (read_result > 0)
+    remaining_bytes_ -= read_result;
+
+  ReadRawDataComplete(read_result);
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/external_file_url_request_job.h b/chrome/browser/fileapi/external_file_url_request_job.h
new file mode 100644
index 0000000000000..fd3846e372883
--- /dev/null
+++ b/chrome/browser/fileapi/external_file_url_request_job.h
@@ -0,0 +1,123 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILEAPI_EXTERNAL_FILE_URL_REQUEST_JOB_H_
+#define CHROME_BROWSER_FILEAPI_EXTERNAL_FILE_URL_REQUEST_JOB_H_
+
+#include <stdint.h>
+
+#include <string>
+
+#include "base/callback.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "components/drive/file_errors.h"
+#include "net/base/net_errors.h"
+#include "net/http/http_byte_range.h"
+#include "net/url_request/url_request_job.h"
+#include "storage/browser/fileapi/file_stream_reader.h"
+#include "storage/browser/fileapi/file_system_url.h"
+
+namespace net {
+class IOBuffer;
+class NetworkDelegate;
+class URLRequest;
+}  // namespace net
+
+namespace chromeos {
+
+// ExternalFileURLRequestJob is the gateway between network-level drive:...
+// requests for drive resources and FileSystem.  It exposes content URLs
+// formatted as drive:<drive-file-path>.
+// The methods should be run on IO thread.
+// TODO(hirono): After removing MHTML support, stop to use the special
+// externalfile: scheme and use filesystem: URL directly.  crbug.com/415455
+class ExternalFileURLRequestJob : public net::URLRequestJob {
+ public:
+  // Scope of isolated file system.
+  class IsolatedFileSystemScope {
+   public:
+    explicit IsolatedFileSystemScope(const std::string& file_system_id);
+    ~IsolatedFileSystemScope();
+
+   private:
+    std::string file_system_id_;
+    DISALLOW_COPY_AND_ASSIGN(IsolatedFileSystemScope);
+  };
+
+  // Callback to take results from an internal helper defined in
+  // drive_url_request_job.cc.
+  typedef base::Callback<void(
+      net::Error,
+      const scoped_refptr<storage::FileSystemContext>& file_system_context,
+      std::unique_ptr<IsolatedFileSystemScope> isolated_file_system_scope,
+      const storage::FileSystemURL& file_system_url,
+      const std::string& mime_type)>
+      HelperCallback;
+
+  ExternalFileURLRequestJob(void* profile_id,
+                            net::URLRequest* request,
+                            net::NetworkDelegate* network_delegate);
+
+  // net::URLRequestJob overrides:
+  void SetExtraRequestHeaders(const net::HttpRequestHeaders& headers) override;
+  void Start() override;
+  void Kill() override;
+  bool GetMimeType(std::string* mime_type) const override;
+  bool IsRedirectResponse(GURL* location,
+                          int* http_status_code,
+                          bool* insecure_scheme_was_upgraded) override;
+  int ReadRawData(net::IOBuffer* buf, int buf_size) override;
+
+ protected:
+  ~ExternalFileURLRequestJob() override;
+
+ private:
+  // Helper method to start the job. Should be called asynchronously because
+  // NotifyStartError() is not legal to call synchronously in
+  // URLRequestJob::Start().
+  void StartAsync();
+
+  // Called from an internal helper class defined in drive_url_request_job.cc,
+  // which is running on the UI thread.
+  void OnHelperResultObtained(
+      net::Error error,
+      const scoped_refptr<storage::FileSystemContext>& file_system_context,
+      std::unique_ptr<IsolatedFileSystemScope> isolated_file_system_scope,
+      const storage::FileSystemURL& file_system_url,
+      const std::string& mime_type);
+
+  // Called from FileSystemBackend::GetRedirectURLForContents.
+  void OnRedirectURLObtained(const GURL& redirect_url);
+
+  // Called from DriveURLRequestJob::OnFileInfoObtained.
+  void OnFileInfoObtained(base::File::Error result,
+                          const base::File::Info& file_info);
+
+  // Called when DriveFileStreamReader::Read is completed.
+  void OnReadCompleted(int read_result);
+
+  void* const profile_id_;
+
+  // The range of the file to be returned.
+  net::Error range_parse_result_;
+  net::HttpByteRange byte_range_;
+  int64_t remaining_bytes_;
+
+  scoped_refptr<storage::FileSystemContext> file_system_context_;
+  std::unique_ptr<IsolatedFileSystemScope> isolated_file_system_scope_;
+  storage::FileSystemURL file_system_url_;
+  std::string mime_type_;
+  std::unique_ptr<storage::FileStreamReader> stream_reader_;
+  GURL redirect_url_;
+
+  // This should remain the last member so it'll be destroyed first and
+  // invalidate its weak pointers before other members are destroyed.
+  base::WeakPtrFactory<ExternalFileURLRequestJob> weak_ptr_factory_;
+  DISALLOW_COPY_AND_ASSIGN(ExternalFileURLRequestJob);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROME_BROWSER_FILEAPI_EXTERNAL_FILE_URL_REQUEST_JOB_H_
diff --git a/chrome/browser/fileapi/external_file_url_request_job_unittest.cc b/chrome/browser/fileapi/external_file_url_request_job_unittest.cc
new file mode 100644
index 0000000000000..b4e9f17f48fe8
--- /dev/null
+++ b/chrome/browser/fileapi/external_file_url_request_job_unittest.cc
@@ -0,0 +1,415 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/external_file_url_request_job.h"
+
+#include <stddef.h>
+
+#include <memory>
+
+#include "base/bind.h"
+#include "base/files/file_util.h"
+#include "base/macros.h"
+#include "base/memory/ref_counted.h"
+#include "base/run_loop.h"
+#include "base/threading/thread.h"
+#include "chrome/browser/chromeos/drive/drive_file_stream_reader.h"
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/prefs/browser_prefs.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/test/base/testing_browser_process.h"
+#include "chrome/test/base/testing_profile.h"
+#include "chrome/test/base/testing_profile_manager.h"
+#include "components/drive/chromeos/drive_test_util.h"
+#include "components/drive/chromeos/fake_file_system.h"
+#include "components/drive/service/fake_drive_service.h"
+#include "components/drive/service/test_util.h"
+#include "components/pref_registry/pref_registry_syncable.h"
+#include "components/sync_preferences/pref_service_syncable.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/common/url_constants.h"
+#include "content/public/test/test_browser_thread_bundle.h"
+#include "content/public/test/test_service_manager_context.h"
+#include "google_apis/drive/test_util.h"
+#include "net/base/request_priority.h"
+#include "net/base/test_completion_callback.h"
+#include "net/http/http_byte_range.h"
+#include "net/url_request/redirect_info.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_context.h"
+#include "net/url_request/url_request_test_util.h"
+#include "storage/browser/fileapi/external_mount_points.h"
+#include "storage/browser/fileapi/file_system_context.h"
+#include "storage/browser/test/test_file_system_options.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "url/gurl.h"
+
+namespace chromeos {
+namespace {
+
+// A simple URLRequestJobFactory implementation to create
+// ExternalFileURLRequestJob.
+class TestURLRequestJobFactory : public net::URLRequestJobFactory {
+ public:
+  explicit TestURLRequestJobFactory(void* profile_id)
+      : profile_id_(profile_id) {}
+
+  ~TestURLRequestJobFactory() override {}
+
+  // net::URLRequestJobFactory override:
+  net::URLRequestJob* MaybeCreateJobWithProtocolHandler(
+      const std::string& scheme,
+      net::URLRequest* request,
+      net::NetworkDelegate* network_delegate) const override {
+    return new ExternalFileURLRequestJob(
+        profile_id_, request, network_delegate);
+  }
+
+  net::URLRequestJob* MaybeInterceptRedirect(
+      net::URLRequest* request,
+      net::NetworkDelegate* network_delegate,
+      const GURL& location) const override {
+    return nullptr;
+  }
+
+  net::URLRequestJob* MaybeInterceptResponse(
+      net::URLRequest* request,
+      net::NetworkDelegate* network_delegate) const override {
+    return nullptr;
+  }
+
+  bool IsHandledProtocol(const std::string& scheme) const override {
+    return scheme == content::kExternalFileScheme;
+  }
+
+  bool IsSafeRedirectTarget(const GURL& location) const override {
+    return true;
+  }
+
+ private:
+  void* const profile_id_;
+  DISALLOW_COPY_AND_ASSIGN(TestURLRequestJobFactory);
+};
+
+class TestDelegate : public net::TestDelegate {
+ public:
+  TestDelegate() {}
+
+  const GURL& redirect_url() const { return redirect_url_; }
+
+  // net::TestDelegate override.
+  void OnReceivedRedirect(net::URLRequest* request,
+                          const net::RedirectInfo& redirect_info,
+                          bool* defer_redirect) override {
+    redirect_url_ = redirect_info.new_url;
+    net::TestDelegate::OnReceivedRedirect(request, redirect_info,
+                                          defer_redirect);
+  }
+
+ private:
+  GURL redirect_url_;
+
+  DISALLOW_COPY_AND_ASSIGN(TestDelegate);
+};
+
+}  // namespace
+
+class ExternalFileURLRequestJobTest : public testing::Test {
+ protected:
+  ExternalFileURLRequestJobTest()
+      : thread_bundle_(content::TestBrowserThreadBundle::IO_MAINLOOP),
+        integration_service_factory_callback_(base::Bind(
+            &ExternalFileURLRequestJobTest::CreateDriveIntegrationService,
+            base::Unretained(this))),
+        fake_file_system_(NULL) {}
+
+  ~ExternalFileURLRequestJobTest() override {}
+
+  void SetUp() override {
+    // Create a testing profile.
+    profile_manager_.reset(
+        new TestingProfileManager(TestingBrowserProcess::GetGlobal()));
+    ASSERT_TRUE(profile_manager_->SetUp());
+    Profile* const profile =
+        profile_manager_->CreateTestingProfile("test-user");
+
+    // Create the drive integration service for the profile.
+    integration_service_factory_scope_.reset(
+        new drive::DriveIntegrationServiceFactory::ScopedFactoryForTest(
+            &integration_service_factory_callback_));
+    drive::DriveIntegrationServiceFactory::GetForProfile(profile);
+
+    // Create the URL request job factory.
+    test_network_delegate_.reset(new net::TestNetworkDelegate);
+    test_url_request_job_factory_.reset(new TestURLRequestJobFactory(profile));
+    url_request_context_.reset(new net::URLRequestContext());
+    url_request_context_->set_job_factory(test_url_request_job_factory_.get());
+    url_request_context_->set_network_delegate(test_network_delegate_.get());
+    test_delegate_.reset(new TestDelegate);
+  }
+
+  void TearDown() override { profile_manager_.reset(); }
+
+  bool ReadDriveFileSync(const base::FilePath& file_path,
+                         std::string* out_content) {
+    std::unique_ptr<base::Thread> worker_thread(
+        new base::Thread("ReadDriveFileSync"));
+    if (!worker_thread->Start())
+      return false;
+
+    std::unique_ptr<drive::DriveFileStreamReader> reader(
+        new drive::DriveFileStreamReader(
+            base::Bind(&ExternalFileURLRequestJobTest::GetFileSystem,
+                       base::Unretained(this)),
+            worker_thread->task_runner().get()));
+    int error = net::ERR_FAILED;
+    std::unique_ptr<drive::ResourceEntry> entry;
+    {
+      base::RunLoop run_loop;
+      reader->Initialize(file_path,
+                         net::HttpByteRange(),
+                         google_apis::test_util::CreateQuitCallback(
+                             &run_loop,
+                             google_apis::test_util::CreateCopyResultCallback(
+                                 &error, &entry)));
+      run_loop.Run();
+    }
+    if (error != net::OK || !entry)
+      return false;
+
+    // Read data from the reader.
+    std::string content;
+    if (drive::test_util::ReadAllData(reader.get(), &content) != net::OK)
+      return false;
+
+    if (static_cast<size_t>(entry->file_info().size()) != content.size())
+      return false;
+
+    *out_content = content;
+    return true;
+  }
+
+  std::unique_ptr<net::URLRequestContext> url_request_context_;
+  std::unique_ptr<TestDelegate> test_delegate_;
+
+ private:
+  // Create the drive integration service for the |profile|
+  drive::DriveIntegrationService* CreateDriveIntegrationService(
+      Profile* profile) {
+    drive::FakeDriveService* const drive_service = new drive::FakeDriveService;
+    if (!drive::test_util::SetUpTestEntries(drive_service))
+      return NULL;
+
+    const std::string& drive_mount_name =
+        drive::util::GetDriveMountPointPath(profile).BaseName().AsUTF8Unsafe();
+    storage::ExternalMountPoints::GetSystemInstance()->RegisterFileSystem(
+        drive_mount_name,
+        storage::kFileSystemTypeDrive,
+        storage::FileSystemMountOption(),
+        drive::util::GetDriveMountPointPath(profile));
+    DCHECK(!fake_file_system_);
+    fake_file_system_ = new drive::test_util::FakeFileSystem(drive_service);
+    if (!drive_cache_dir_.CreateUniqueTempDir())
+      return NULL;
+    return new drive::DriveIntegrationService(
+        profile, nullptr, drive_service, drive_mount_name,
+        drive_cache_dir_.GetPath(), fake_file_system_);
+  }
+
+  drive::FileSystemInterface* GetFileSystem() { return fake_file_system_; }
+
+  content::TestBrowserThreadBundle thread_bundle_;
+  content::TestServiceManagerContext context_;
+  drive::DriveIntegrationServiceFactory::FactoryCallback
+      integration_service_factory_callback_;
+  std::unique_ptr<drive::DriveIntegrationServiceFactory::ScopedFactoryForTest>
+      integration_service_factory_scope_;
+  std::unique_ptr<drive::DriveIntegrationService> integration_service_;
+  drive::test_util::FakeFileSystem* fake_file_system_;
+
+  std::unique_ptr<net::TestNetworkDelegate> test_network_delegate_;
+  std::unique_ptr<TestURLRequestJobFactory> test_url_request_job_factory_;
+
+  std::unique_ptr<TestingProfileManager> profile_manager_;
+  base::ScopedTempDir drive_cache_dir_;
+  scoped_refptr<storage::FileSystemContext> file_system_context_;
+};
+
+TEST_F(ExternalFileURLRequestJobTest, NonGetMethod) {
+  std::unique_ptr<net::URLRequest> request(url_request_context_->CreateRequest(
+      GURL("externalfile:drive-test-user-hash/root/File 1.txt"),
+      net::DEFAULT_PRIORITY, test_delegate_.get()));
+  request->set_method("POST");  // Set non "GET" method.
+  request->Start();
+
+  base::RunLoop().Run();
+
+  EXPECT_EQ(net::ERR_METHOD_NOT_SUPPORTED, test_delegate_->request_status());
+}
+
+TEST_F(ExternalFileURLRequestJobTest, RegularFile) {
+  const GURL kTestUrl("externalfile:drive-test-user-hash/root/File 1.txt");
+  const base::FilePath kTestFilePath("drive/root/File 1.txt");
+
+  // For the first time, the file should be fetched from the server.
+  {
+    std::unique_ptr<net::URLRequest> request(
+        url_request_context_->CreateRequest(kTestUrl, net::DEFAULT_PRIORITY,
+                                            test_delegate_.get()));
+    request->Start();
+
+    base::RunLoop().Run();
+
+    EXPECT_EQ(net::OK, test_delegate_->request_status());
+    // It looks weird, but the mime type for the "File 1.txt" is "audio/mpeg"
+    // on the server.
+    std::string mime_type;
+    request->GetMimeType(&mime_type);
+    EXPECT_EQ("audio/mpeg", mime_type);
+
+    // Reading file must be done after |request| runs, otherwise
+    // it'll create a local cache file, and we cannot test correctly.
+    std::string expected_data;
+    ASSERT_TRUE(ReadDriveFileSync(kTestFilePath, &expected_data));
+    EXPECT_EQ(expected_data, test_delegate_->data_received());
+  }
+
+  // For the second time, the locally cached file should be used.
+  // The caching emulation is done by FakeFileSystem.
+  {
+    test_delegate_.reset(new TestDelegate);
+    std::unique_ptr<net::URLRequest> request(
+        url_request_context_->CreateRequest(
+            GURL("externalfile:drive-test-user-hash/root/File 1.txt"),
+            net::DEFAULT_PRIORITY, test_delegate_.get()));
+    request->Start();
+
+    base::RunLoop().Run();
+
+    EXPECT_EQ(net::OK, test_delegate_->request_status());
+
+    std::string mime_type;
+    request->GetMimeType(&mime_type);
+    EXPECT_EQ("audio/mpeg", mime_type);
+
+    std::string expected_data;
+    ASSERT_TRUE(ReadDriveFileSync(kTestFilePath, &expected_data));
+    EXPECT_EQ(expected_data, test_delegate_->data_received());
+  }
+}
+
+TEST_F(ExternalFileURLRequestJobTest, HostedDocument) {
+  // Open a gdoc file.
+  std::unique_ptr<net::URLRequest> request(url_request_context_->CreateRequest(
+      GURL("externalfile:drive-test-user-hash/root/Document 1 "
+           "excludeDir-test.gdoc"),
+      net::DEFAULT_PRIORITY, test_delegate_.get()));
+  request->Start();
+
+  test_delegate_->RunUntilRedirect();
+
+  // Make sure that a hosted document triggers redirection.
+  EXPECT_TRUE(request->is_redirecting());
+  EXPECT_TRUE(test_delegate_->redirect_url().is_valid());
+}
+
+TEST_F(ExternalFileURLRequestJobTest, RootDirectory) {
+  std::unique_ptr<net::URLRequest> request(url_request_context_->CreateRequest(
+      GURL("externalfile:drive-test-user-hash/root"), net::DEFAULT_PRIORITY,
+      test_delegate_.get()));
+  request->Start();
+
+  base::RunLoop().Run();
+
+  EXPECT_EQ(net::ERR_FAILED, test_delegate_->request_status());
+}
+
+TEST_F(ExternalFileURLRequestJobTest, Directory) {
+  std::unique_ptr<net::URLRequest> request(url_request_context_->CreateRequest(
+      GURL("externalfile:drive-test-user-hash/root/Directory 1"),
+      net::DEFAULT_PRIORITY, test_delegate_.get()));
+  request->Start();
+
+  base::RunLoop().Run();
+
+  EXPECT_EQ(net::ERR_FAILED, test_delegate_->request_status());
+}
+
+TEST_F(ExternalFileURLRequestJobTest, NonExistingFile) {
+  std::unique_ptr<net::URLRequest> request(url_request_context_->CreateRequest(
+      GURL("externalfile:drive-test-user-hash/root/non-existing-file.txt"),
+      net::DEFAULT_PRIORITY, test_delegate_.get()));
+  request->Start();
+
+  base::RunLoop().Run();
+
+  EXPECT_EQ(net::ERR_FILE_NOT_FOUND, test_delegate_->request_status());
+}
+
+TEST_F(ExternalFileURLRequestJobTest, WrongFormat) {
+  std::unique_ptr<net::URLRequest> request(url_request_context_->CreateRequest(
+      GURL("externalfile:"), net::DEFAULT_PRIORITY, test_delegate_.get()));
+  request->Start();
+
+  base::RunLoop().Run();
+
+  EXPECT_EQ(net::ERR_INVALID_URL, test_delegate_->request_status());
+}
+
+TEST_F(ExternalFileURLRequestJobTest, Cancel) {
+  std::unique_ptr<net::URLRequest> request(url_request_context_->CreateRequest(
+      GURL("externalfile:drive-test-user-hash/root/File 1.txt"),
+      net::DEFAULT_PRIORITY, test_delegate_.get()));
+
+  // Start the request, and cancel it immediately after it.
+  request->Start();
+  request->Cancel();
+
+  base::RunLoop().Run();
+
+  EXPECT_EQ(net::ERR_ABORTED, test_delegate_->request_status());
+}
+
+TEST_F(ExternalFileURLRequestJobTest, RangeHeader) {
+  const GURL kTestUrl("externalfile:drive-test-user-hash/root/File 1.txt");
+  const base::FilePath kTestFilePath("drive/root/File 1.txt");
+
+  std::unique_ptr<net::URLRequest> request(url_request_context_->CreateRequest(
+      kTestUrl, net::DEFAULT_PRIORITY, test_delegate_.get()));
+
+  // Set range header.
+  request->SetExtraRequestHeaderByName(
+      "Range", "bytes=3-5", false /* overwrite */);
+  request->Start();
+
+  base::RunLoop().Run();
+
+  EXPECT_EQ(net::OK, test_delegate_->request_status());
+
+  // Reading file must be done after |request| runs, otherwise
+  // it'll create a local cache file, and we cannot test correctly.
+  std::string expected_data;
+  ASSERT_TRUE(ReadDriveFileSync(kTestFilePath, &expected_data));
+  EXPECT_EQ(expected_data.substr(3, 3), test_delegate_->data_received());
+}
+
+TEST_F(ExternalFileURLRequestJobTest, WrongRangeHeader) {
+  const GURL kTestUrl("externalfile:drive-test-user-hash/root/File 1.txt");
+
+  std::unique_ptr<net::URLRequest> request(url_request_context_->CreateRequest(
+      kTestUrl, net::DEFAULT_PRIORITY, test_delegate_.get()));
+
+  // Set range header.
+  request->SetExtraRequestHeaderByName(
+      "Range", "Wrong Range Header Value", false /* overwrite */);
+  request->Start();
+
+  base::RunLoop().Run();
+
+  EXPECT_EQ(net::ERR_REQUEST_RANGE_NOT_SATISFIABLE,
+            test_delegate_->request_status());
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/external_file_url_util.cc b/chrome/browser/fileapi/external_file_url_util.cc
new file mode 100644
index 0000000000000..5d2d74963c807
--- /dev/null
+++ b/chrome/browser/fileapi/external_file_url_util.cc
@@ -0,0 +1,81 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/external_file_url_util.h"
+
+#include <string>
+#include <vector>
+
+#include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/extensions/extension_util.h"
+#include "chrome/browser/profiles/profile.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/storage_partition.h"
+#include "content/public/common/url_constants.h"
+#include "net/base/escape.h"
+#include "storage/browser/fileapi/file_system_url.h"
+
+using content::BrowserThread;
+
+namespace chromeos {
+
+bool IsExternalFileURLType(storage::FileSystemType type) {
+  return type == storage::kFileSystemTypeDrive ||
+         type == storage::kFileSystemTypeDeviceMediaAsFileStorage ||
+         type == storage::kFileSystemTypeProvided ||
+         type == storage::kFileSystemTypeArcContent;
+}
+
+GURL FileSystemURLToExternalFileURL(
+    const storage::FileSystemURL& file_system_url) {
+  if (file_system_url.mount_type() != storage::kFileSystemTypeExternal ||
+      !IsExternalFileURLType(file_system_url.type())) {
+    return GURL();
+  }
+
+  return VirtualPathToExternalFileURL(file_system_url.virtual_path());
+}
+
+base::FilePath ExternalFileURLToVirtualPath(const GURL& url) {
+  if (!url.is_valid() || url.scheme() != content::kExternalFileScheme)
+    return base::FilePath();
+  std::string path_string;
+  net::UnescapeBinaryURLComponent(url.path(), &path_string);
+  return base::FilePath::FromUTF8Unsafe(path_string);
+}
+
+GURL VirtualPathToExternalFileURL(const base::FilePath& virtual_path) {
+  return GURL(
+      base::StringPrintf("%s:%s", content::kExternalFileScheme,
+                         net::EscapePath(virtual_path.AsUTF8Unsafe()).c_str()));
+}
+
+GURL CreateExternalFileURLFromPath(Profile* profile,
+                                   const base::FilePath& path) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  GURL raw_file_system_url;
+  if (!file_manager::util::ConvertAbsoluteFilePathToFileSystemUrl(
+          profile,
+          path,
+          file_manager::kFileManagerAppId,
+          &raw_file_system_url)) {
+    return GURL();
+  }
+
+  const storage::FileSystemURL file_system_url =
+      file_manager::util::GetFileSystemContextForExtensionId(
+          profile, file_manager::kFileManagerAppId)
+          ->CrackURL(raw_file_system_url);
+  if (!file_system_url.is_valid())
+    return GURL();
+
+  return FileSystemURLToExternalFileURL(file_system_url);
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/external_file_url_util.h b/chrome/browser/fileapi/external_file_url_util.h
new file mode 100644
index 0000000000000..cebd710abd845
--- /dev/null
+++ b/chrome/browser/fileapi/external_file_url_util.h
@@ -0,0 +1,46 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILEAPI_EXTERNAL_FILE_URL_UTIL_H_
+#define CHROME_BROWSER_FILEAPI_EXTERNAL_FILE_URL_UTIL_H_
+
+#include "storage/common/fileapi/file_system_types.h"
+
+class GURL;
+class Profile;
+
+namespace base {
+class FilePath;
+}
+
+namespace storage {
+class FileSystemURL;
+}
+
+namespace chromeos {
+
+// Returns whether the external file URL is provided for the |type| or not.
+bool IsExternalFileURLType(storage::FileSystemType type);
+
+// Obtains the external file url formatted as "externalfile:<path>" from file
+// path. Returns empty URL if the file system does not provide the external file
+// URL.
+GURL FileSystemURLToExternalFileURL(
+    const storage::FileSystemURL& file_system_url);
+
+// Converts a externalfile: URL back to a virtual path of FileSystemURL.
+base::FilePath ExternalFileURLToVirtualPath(const GURL& url);
+
+// Converts a virtual path of FileSystemURL to an externalfile: URL.
+GURL VirtualPathToExternalFileURL(const base::FilePath& virtual_path);
+
+// Obtains external file URL (e.g. external:drive/root/sample.txt) from file
+// path (e.g. /special/drive-xxx/root/sample.txt), if the |path| points an
+// external location (drive, MTP, or FSP). Otherwise, it returns empty URL.
+GURL CreateExternalFileURLFromPath(Profile* profile,
+                                   const base::FilePath& path);
+
+}  // namespace chromeos
+
+#endif  // CHROME_BROWSER_FILEAPI_EXTERNAL_FILE_URL_UTIL_H_
diff --git a/chrome/browser/fileapi/external_file_url_util_unittest.cc b/chrome/browser/fileapi/external_file_url_util_unittest.cc
new file mode 100644
index 0000000000000..8f8b01db7e016
--- /dev/null
+++ b/chrome/browser/fileapi/external_file_url_util_unittest.cc
@@ -0,0 +1,116 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/external_file_url_util.h"
+
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/test/base/testing_browser_process.h"
+#include "chrome/test/base/testing_profile_manager.h"
+#include "components/drive/file_system_core_util.h"
+#include "content/public/common/url_constants.h"
+#include "content/public/test/test_browser_thread_bundle.h"
+#include "storage/browser/fileapi/file_system_url.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace chromeos {
+
+namespace {
+
+// Sets up ProfileManager for testing and marks the current thread as UI by
+// TestBrowserThreadBundle. We need the thread since Profile objects must be
+// touched from UI and hence has CHECK/DCHECKs for it.
+class ExternalFileURLUtilTest : public testing::Test {
+ protected:
+  ExternalFileURLUtilTest()
+      : testing_profile_manager_(TestingBrowserProcess::GetGlobal()) {}
+
+  void SetUp() override { ASSERT_TRUE(testing_profile_manager_.SetUp()); }
+
+  TestingProfileManager& testing_profile_manager() {
+    return testing_profile_manager_;
+  }
+
+  storage::FileSystemURL CreateExpectedURL(const base::FilePath& path) {
+    return storage::FileSystemURL::CreateForTest(
+        GURL("chrome-extension://xxx"),
+        storage::kFileSystemTypeExternal,
+        base::FilePath("drive-test-user-hash").Append(path),
+        "",
+        storage::kFileSystemTypeDrive,
+        base::FilePath(),
+        "",
+        storage::FileSystemMountOption());
+  }
+
+ private:
+  content::TestBrowserThreadBundle thread_bundle_;
+  TestingProfileManager testing_profile_manager_;
+};
+
+}  // namespace
+
+TEST_F(ExternalFileURLUtilTest, FilePathToExternalFileURL) {
+  storage::FileSystemURL url;
+
+  // Path with alphabets and numbers.
+  url = CreateExpectedURL(base::FilePath("foo/bar012.txt"));
+  EXPECT_EQ(url.virtual_path(),
+            ExternalFileURLToVirtualPath(FileSystemURLToExternalFileURL(url)));
+
+  // Path with symbols.
+  url = CreateExpectedURL(base::FilePath(" !\"#$%&'()*+,-.:;<=>?@[\\]^_`{|}~"));
+  EXPECT_EQ(url.virtual_path(),
+            ExternalFileURLToVirtualPath(FileSystemURLToExternalFileURL(url)));
+
+  // Path with '%'.
+  url = CreateExpectedURL(base::FilePath("%19%20%21.txt"));
+  EXPECT_EQ(url.virtual_path(),
+            ExternalFileURLToVirtualPath(FileSystemURLToExternalFileURL(url)));
+
+  // Path with multi byte characters.
+  base::string16 utf16_string;
+  utf16_string.push_back(0x307b);  // HIRAGANA_LETTER_HO
+  utf16_string.push_back(0x3052);  // HIRAGANA_LETTER_GE
+  url = CreateExpectedURL(
+      base::FilePath::FromUTF8Unsafe(base::UTF16ToUTF8(utf16_string) + ".txt"));
+  EXPECT_EQ(url.virtual_path().AsUTF8Unsafe(),
+            ExternalFileURLToVirtualPath(FileSystemURLToExternalFileURL(url))
+                .AsUTF8Unsafe());
+}
+
+// Tests that given virtual path is encoded to an expected externalfile: URL
+// and then the original path is reconstructed from it.
+void ExpectVirtualPathRoundtrip(
+    const base::FilePath::StringType& virtual_path_string,
+    std::string expected_url) {
+  base::FilePath virtual_path(virtual_path_string);
+  GURL result = VirtualPathToExternalFileURL(virtual_path);
+  EXPECT_TRUE(result.is_valid());
+  EXPECT_EQ(content::kExternalFileScheme, result.scheme());
+  EXPECT_EQ(expected_url, result.path());
+  EXPECT_EQ(virtual_path.value(), ExternalFileURLToVirtualPath(result).value());
+}
+
+TEST_F(ExternalFileURLUtilTest, VirtualPathToExternalFileURL) {
+  ExpectVirtualPathRoundtrip(FILE_PATH_LITERAL("foo/bar012.txt"),
+                             "foo/bar012.txt");
+
+  // Path containing precent character, which is also used for URL encoding.
+  ExpectVirtualPathRoundtrip(FILE_PATH_LITERAL("foo/bar012%41%.txt"),
+                             "foo/bar012%2541%25.txt");
+
+  // Path containing some ASCII characters that are escaped by URL enconding.
+  ExpectVirtualPathRoundtrip(FILE_PATH_LITERAL("foo/bar \"#<>?`{}.txt"),
+                             "foo/bar%20%22%23%3C%3E%3F%60%7B%7D.txt");
+
+  // (U+3000) IDEOGRAPHIC SPACE and (U+1F512) LOCK are examples of characters
+  // potentially used for URL spoofing. Those are blacklisted from unescaping
+  // when a URL is displayed, but this should not prevent it from being
+  // unescaped when converting a URL to a virtual file path. See
+  // crbug.com/585422 for detail.
+  ExpectVirtualPathRoundtrip(FILE_PATH_LITERAL("foo/bar/space\u3000lock�.zip"),
+                             "foo/bar/space%E3%80%80lock%F0%9F%94%92.zip");
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/file_access_permissions.cc b/chrome/browser/fileapi/file_access_permissions.cc
new file mode 100644
index 0000000000000..76aef28856d4b
--- /dev/null
+++ b/chrome/browser/fileapi/file_access_permissions.cc
@@ -0,0 +1,49 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/file_access_permissions.h"
+
+#include "base/logging.h"
+
+namespace chromeos {
+
+FileAccessPermissions::FileAccessPermissions() {}
+
+FileAccessPermissions::~FileAccessPermissions() {}
+
+void FileAccessPermissions::GrantAccessPermission(
+    const std::string& extension_id, const base::FilePath& path) {
+  DCHECK(!path.empty());
+  base::AutoLock locker(lock_);
+  path_map_[extension_id].insert(path);
+}
+
+bool FileAccessPermissions::HasAccessPermission(
+    const std::string& extension_id, const base::FilePath& path) const {
+  base::AutoLock locker(lock_);
+  PathAccessMap::const_iterator path_map_iter = path_map_.find(extension_id);
+  if (path_map_iter == path_map_.end())
+    return false;
+  const PathSet& path_set = path_map_iter->second;
+
+  // Check this file and walk up its directory tree to find if this extension
+  // has access to it.
+  base::FilePath current_path = path.StripTrailingSeparators();
+  base::FilePath last_path;
+  while (current_path != last_path) {
+    if (path_set.find(current_path) != path_set.end())
+      return true;
+    last_path = current_path;
+    current_path = current_path.DirName();
+  }
+  return false;
+}
+
+void FileAccessPermissions::RevokePermissions(
+    const std::string& extension_id) {
+  base::AutoLock locker(lock_);
+  path_map_.erase(extension_id);
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/file_access_permissions.h b/chrome/browser/fileapi/file_access_permissions.h
new file mode 100644
index 0000000000000..d74a3675fc89c
--- /dev/null
+++ b/chrome/browser/fileapi/file_access_permissions.h
@@ -0,0 +1,46 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILEAPI_FILE_ACCESS_PERMISSIONS_H_
+#define CHROME_BROWSER_FILEAPI_FILE_ACCESS_PERMISSIONS_H_
+
+#include <map>
+#include <set>
+#include <string>
+
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/synchronization/lock.h"
+
+namespace chromeos {
+
+// In a thread safe manner maintains the set of paths allowed to access for
+// each extension.
+class FileAccessPermissions {
+ public:
+  FileAccessPermissions();
+  virtual ~FileAccessPermissions();
+
+  // Grants |extension_id| access to |path|.
+  void GrantAccessPermission(const std::string& extension_id,
+                             const base::FilePath& path);
+  // Checks id |extension_id| has permission to access to |path|.
+  bool HasAccessPermission(const std::string& extension_id,
+                           const base::FilePath& path) const;
+  // Revokes all file permissions for |extension_id|.
+  void RevokePermissions(const std::string& extension_id);
+
+ private:
+  typedef std::set<base::FilePath> PathSet;
+  typedef std::map<std::string, PathSet> PathAccessMap;
+
+  mutable base::Lock lock_;  // Synchronize all access to path_map_.
+  PathAccessMap path_map_;
+
+  DISALLOW_COPY_AND_ASSIGN(FileAccessPermissions);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROME_BROWSER_FILEAPI_FILE_ACCESS_PERMISSIONS_H_
diff --git a/chrome/browser/fileapi/file_access_permissions_unittest.cc b/chrome/browser/fileapi/file_access_permissions_unittest.cc
new file mode 100644
index 0000000000000..715d50957c054
--- /dev/null
+++ b/chrome/browser/fileapi/file_access_permissions_unittest.cc
@@ -0,0 +1,62 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/file_access_permissions.h"
+
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace chromeos {
+
+TEST(FileAccessPermissionsTest, FileAccessChecks) {
+  base::FilePath good_dir(FILE_PATH_LITERAL("/root/dir"));
+  base::FilePath bad_dir(FILE_PATH_LITERAL("/root"));
+  base::FilePath good_file(FILE_PATH_LITERAL("/root/dir/good_file.txt"));
+  base::FilePath bad_file(FILE_PATH_LITERAL("/root/dir/bad_file.txt"));
+
+  std::string extension1("ddammdhioacbehjngdmkjcjbnfginlla");
+  std::string extension2("jkhdjkhkhsdkfhsdkhrterwmtermeter");
+
+  FileAccessPermissions permissions;
+  // By default extension have no access to any local file.
+  EXPECT_FALSE(permissions.HasAccessPermission(extension1, good_dir));
+  EXPECT_FALSE(permissions.HasAccessPermission(extension1, good_file));
+  EXPECT_FALSE(permissions.HasAccessPermission(extension1, bad_file));
+  EXPECT_FALSE(permissions.HasAccessPermission(extension2, good_dir));
+  EXPECT_FALSE(permissions.HasAccessPermission(extension2, good_file));
+  EXPECT_FALSE(permissions.HasAccessPermission(extension2, bad_file));
+
+  // After granting file access to the handler extension for a given file, it
+  // can only access that file an nothing else.
+  permissions.GrantAccessPermission(extension1, good_file);
+  EXPECT_FALSE(permissions.HasAccessPermission(extension1, good_dir));
+  EXPECT_TRUE(permissions.HasAccessPermission(extension1, good_file));
+  EXPECT_FALSE(permissions.HasAccessPermission(extension1, bad_file));
+  EXPECT_FALSE(permissions.HasAccessPermission(extension2, good_dir));
+  EXPECT_FALSE(permissions.HasAccessPermission(extension2, good_file));
+  EXPECT_FALSE(permissions.HasAccessPermission(extension2, bad_file));
+
+
+  // After granting file access to the handler extension for a given directory,
+  // it can access that directory and all files within it.
+  permissions.GrantAccessPermission(extension2, good_dir);
+  EXPECT_FALSE(permissions.HasAccessPermission(extension1, good_dir));
+  EXPECT_TRUE(permissions.HasAccessPermission(extension1, good_file));
+  EXPECT_FALSE(permissions.HasAccessPermission(extension1, bad_file));
+  EXPECT_TRUE(permissions.HasAccessPermission(extension2, good_dir));
+  EXPECT_TRUE(permissions.HasAccessPermission(extension2, good_file));
+  EXPECT_TRUE(permissions.HasAccessPermission(extension2, bad_file));
+
+  // After revoking rights for extensions, they should not be able to access
+  // any file system element anymore.
+  permissions.RevokePermissions(extension1);
+  permissions.RevokePermissions(extension2);
+  EXPECT_FALSE(permissions.HasAccessPermission(extension1, good_dir));
+  EXPECT_FALSE(permissions.HasAccessPermission(extension1, good_file));
+  EXPECT_FALSE(permissions.HasAccessPermission(extension1, bad_file));
+  EXPECT_FALSE(permissions.HasAccessPermission(extension2, good_dir));
+  EXPECT_FALSE(permissions.HasAccessPermission(extension2, good_file));
+  EXPECT_FALSE(permissions.HasAccessPermission(extension2, bad_file));
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/file_system_backend.cc b/chrome/browser/fileapi/file_system_backend.cc
new file mode 100644
index 0000000000000..34e6062ac6e8d
--- /dev/null
+++ b/chrome/browser/fileapi/file_system_backend.cc
@@ -0,0 +1,510 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/file_system_backend.h"
+
+#include <stddef.h>
+
+#include <memory>
+#include <utility>
+
+#include "base/command_line.h"
+#include "base/logging.h"
+#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_util.h"
+#include "chrome/browser/fileapi/file_access_permissions.h"
+#include "chrome/browser/fileapi/file_system_backend_delegate.h"
+#include "chrome/browser/media_galleries/fileapi/media_file_system_backend.h"
+#include "chrome/common/url_constants.h"
+#include "chromeos/chromeos_switches.h"
+#include "chromeos/dbus/cros_disks_client.h"
+#include "net/base/escape.h"
+#include "storage/browser/fileapi/async_file_util.h"
+#include "storage/browser/fileapi/external_mount_points.h"
+#include "storage/browser/fileapi/file_stream_reader.h"
+#include "storage/browser/fileapi/file_stream_writer.h"
+#include "storage/browser/fileapi/file_system_context.h"
+#include "storage/browser/fileapi/file_system_operation.h"
+#include "storage/browser/fileapi/file_system_operation_context.h"
+#include "storage/browser/fileapi/file_system_url.h"
+#include "storage/common/fileapi/file_system_mount_option.h"
+#include "storage/common/fileapi/file_system_util.h"
+
+namespace chromeos {
+namespace {
+
+// TODO(mtomasz): Remove this hacky whitelist.
+// See: crbug.com/271946
+const char* kOemAccessibleExtensions[] = {
+    "mlbmkoenclnokonejhlfakkeabdlmpek",  // TimeScapes,
+    "nhpmmldpbfjofkipjaieeomhnmcgihfm",  // Retail Demo (public session),
+    "klimoghijjogocdbaikffefjfcfheiel",  // Retail Demo (OOBE),
+};
+
+}  // namespace
+
+// static
+bool FileSystemBackend::CanHandleURL(const storage::FileSystemURL& url) {
+  if (!url.is_valid())
+    return false;
+  return url.type() == storage::kFileSystemTypeNativeLocal ||
+         url.type() == storage::kFileSystemTypeRestrictedNativeLocal ||
+         url.type() == storage::kFileSystemTypeDrive ||
+         url.type() == storage::kFileSystemTypeProvided ||
+         url.type() == storage::kFileSystemTypeDeviceMediaAsFileStorage ||
+         url.type() == storage::kFileSystemTypeArcContent ||
+         url.type() == storage::kFileSystemTypeArcDocumentsProvider ||
+         url.type() == storage::kFileSystemTypeDriveFs;
+}
+
+FileSystemBackend::FileSystemBackend(
+    std::unique_ptr<FileSystemBackendDelegate> drive_delegate,
+    std::unique_ptr<FileSystemBackendDelegate> file_system_provider_delegate,
+    std::unique_ptr<FileSystemBackendDelegate> mtp_delegate,
+    std::unique_ptr<FileSystemBackendDelegate> arc_content_delegate,
+    std::unique_ptr<FileSystemBackendDelegate> arc_documents_provider_delegate,
+    std::unique_ptr<FileSystemBackendDelegate> drivefs_delegate,
+    scoped_refptr<storage::ExternalMountPoints> mount_points,
+    storage::ExternalMountPoints* system_mount_points)
+    : file_access_permissions_(new FileAccessPermissions()),
+      local_file_util_(storage::AsyncFileUtil::CreateForLocalFileSystem()),
+      drive_delegate_(std::move(drive_delegate)),
+      file_system_provider_delegate_(std::move(file_system_provider_delegate)),
+      mtp_delegate_(std::move(mtp_delegate)),
+      arc_content_delegate_(std::move(arc_content_delegate)),
+      arc_documents_provider_delegate_(
+          std::move(arc_documents_provider_delegate)),
+      drivefs_delegate_(std::move(drivefs_delegate)),
+      mount_points_(mount_points),
+      system_mount_points_(system_mount_points) {}
+
+FileSystemBackend::~FileSystemBackend() {
+}
+
+void FileSystemBackend::AddSystemMountPoints() {
+  // RegisterFileSystem() is no-op if the mount point with the same name
+  // already exists, hence it's safe to call without checking if a mount
+  // point already exists or not.
+  system_mount_points_->RegisterFileSystem(
+      "archive",
+      storage::kFileSystemTypeNativeLocal,
+      storage::FileSystemMountOption(),
+      chromeos::CrosDisksClient::GetArchiveMountPoint());
+  system_mount_points_->RegisterFileSystem(
+      "removable", storage::kFileSystemTypeNativeLocal,
+      storage::FileSystemMountOption(storage::FlushPolicy::FLUSH_ON_COMPLETION),
+      chromeos::CrosDisksClient::GetRemovableDiskMountPoint());
+  system_mount_points_->RegisterFileSystem(
+      "oem",
+      storage::kFileSystemTypeRestrictedNativeLocal,
+      storage::FileSystemMountOption(),
+      base::FilePath(FILE_PATH_LITERAL("/usr/share/oem")));
+}
+
+bool FileSystemBackend::CanHandleType(storage::FileSystemType type) const {
+  switch (type) {
+    case storage::kFileSystemTypeExternal:
+    case storage::kFileSystemTypeDrive:
+    case storage::kFileSystemTypeRestrictedNativeLocal:
+    case storage::kFileSystemTypeNativeLocal:
+    case storage::kFileSystemTypeNativeForPlatformApp:
+    case storage::kFileSystemTypeDeviceMediaAsFileStorage:
+    case storage::kFileSystemTypeProvided:
+    case storage::kFileSystemTypeArcContent:
+    case storage::kFileSystemTypeArcDocumentsProvider:
+    case storage::kFileSystemTypeDriveFs:
+      return true;
+    default:
+      return false;
+  }
+}
+
+void FileSystemBackend::Initialize(storage::FileSystemContext* context) {
+}
+
+void FileSystemBackend::ResolveURL(const storage::FileSystemURL& url,
+                                   storage::OpenFileSystemMode mode,
+                                   OpenFileSystemCallback callback) {
+  std::string id;
+  storage::FileSystemType type;
+  std::string cracked_id;
+  base::FilePath path;
+  storage::FileSystemMountOption option;
+  if (!mount_points_->CrackVirtualPath(
+           url.virtual_path(), &id, &type, &cracked_id, &path, &option) &&
+      !system_mount_points_->CrackVirtualPath(
+           url.virtual_path(), &id, &type, &cracked_id, &path, &option)) {
+    // Not under a mount point, so return an error, since the root is not
+    // accessible.
+    GURL root_url = GURL(storage::GetExternalFileSystemRootURIString(
+        url.origin(), std::string()));
+    std::move(callback).Run(root_url, std::string(),
+                            base::File::FILE_ERROR_SECURITY);
+    return;
+  }
+
+  std::string name;
+  // Construct a URL restricted to the found mount point.
+  std::string root_url =
+      storage::GetExternalFileSystemRootURIString(url.origin(), id);
+
+  // For removable and archives, the file system root is the external mount
+  // point plus the inner mount point.
+  if (id == "archive" || id == "removable") {
+    std::vector<std::string> components;
+    url.virtual_path().GetComponents(&components);
+    DCHECK_EQ(id, components.at(0));
+    if (components.size() < 2) {
+      // Unable to access /archive and /removable directories directly. The
+      // inner mount name must be specified.
+      std::move(callback).Run(GURL(root_url), std::string(),
+                              base::File::FILE_ERROR_SECURITY);
+      return;
+    }
+    std::string inner_mount_name = components[1];
+    root_url += inner_mount_name + "/";
+    name = inner_mount_name;
+  } else if (id == arc::kDocumentsProviderMountPointName) {
+    // For ARC documents provider file system, volumes are mounted per document
+    // provider root, so we need to fix up |root_url| to point to an individual
+    // root.
+    std::string authority;
+    std::string root_document_id;
+    base::FilePath unused_path;
+    if (!arc::ParseDocumentsProviderUrl(url, &authority, &root_document_id,
+                                        &unused_path)) {
+      std::move(callback).Run(GURL(root_url), std::string(),
+                              base::File::FILE_ERROR_SECURITY);
+      return;
+    }
+    base::FilePath mount_path =
+        arc::GetDocumentsProviderMountPath(authority, root_document_id);
+    base::FilePath relative_mount_path;
+    base::FilePath(arc::kDocumentsProviderMountPointPath)
+        .AppendRelativePath(mount_path, &relative_mount_path);
+    root_url +=
+        net::EscapePath(storage::FilePathToString(relative_mount_path)) + "/";
+    name = authority + ":" + root_document_id;
+  } else {
+    name = id;
+  }
+
+  std::move(callback).Run(GURL(root_url), name, base::File::FILE_OK);
+}
+
+storage::FileSystemQuotaUtil* FileSystemBackend::GetQuotaUtil() {
+  // No quota support.
+  return NULL;
+}
+
+const storage::UpdateObserverList* FileSystemBackend::GetUpdateObservers(
+    storage::FileSystemType type) const {
+  return NULL;
+}
+
+const storage::ChangeObserverList* FileSystemBackend::GetChangeObservers(
+    storage::FileSystemType type) const {
+  return NULL;
+}
+
+const storage::AccessObserverList* FileSystemBackend::GetAccessObservers(
+    storage::FileSystemType type) const {
+  return NULL;
+}
+
+bool FileSystemBackend::IsAccessAllowed(
+    const storage::FileSystemURL& url) const {
+  if (!url.is_valid())
+    return false;
+
+  // No extra check is needed for isolated file systems.
+  if (url.mount_type() == storage::kFileSystemTypeIsolated)
+    return true;
+
+  if (!CanHandleURL(url))
+    return false;
+
+  // If there is no origin set, then it's an internal access.
+  if (url.origin().is_empty())
+    return true;
+
+  const std::string& extension_id = url.origin().host();
+  if (url.type() == storage::kFileSystemTypeRestrictedNativeLocal) {
+    for (size_t i = 0; i < arraysize(kOemAccessibleExtensions); ++i) {
+      if (extension_id == kOemAccessibleExtensions[i])
+        return true;
+    }
+  }
+
+  return file_access_permissions_->HasAccessPermission(extension_id,
+                                                       url.virtual_path());
+}
+
+void FileSystemBackend::GrantFileAccessToExtension(
+    const std::string& extension_id, const base::FilePath& virtual_path) {
+  std::string id;
+  storage::FileSystemType type;
+  std::string cracked_id;
+  base::FilePath path;
+  storage::FileSystemMountOption option;
+  if (!mount_points_->CrackVirtualPath(virtual_path, &id, &type, &cracked_id,
+                                       &path, &option) &&
+      !system_mount_points_->CrackVirtualPath(virtual_path, &id, &type,
+                                              &cracked_id, &path, &option)) {
+    return;
+  }
+
+  file_access_permissions_->GrantAccessPermission(extension_id, virtual_path);
+}
+
+void FileSystemBackend::RevokeAccessForExtension(
+      const std::string& extension_id) {
+  file_access_permissions_->RevokePermissions(extension_id);
+}
+
+std::vector<base::FilePath> FileSystemBackend::GetRootDirectories() const {
+  std::vector<storage::MountPoints::MountPointInfo> mount_points;
+  mount_points_->AddMountPointInfosTo(&mount_points);
+  system_mount_points_->AddMountPointInfosTo(&mount_points);
+
+  std::vector<base::FilePath> root_dirs;
+  for (size_t i = 0; i < mount_points.size(); ++i)
+    root_dirs.push_back(mount_points[i].path);
+  return root_dirs;
+}
+
+storage::AsyncFileUtil* FileSystemBackend::GetAsyncFileUtil(
+    storage::FileSystemType type) {
+  switch (type) {
+    case storage::kFileSystemTypeDrive:
+      return drive_delegate_->GetAsyncFileUtil(type);
+    case storage::kFileSystemTypeProvided:
+      return file_system_provider_delegate_->GetAsyncFileUtil(type);
+    case storage::kFileSystemTypeNativeLocal:
+    case storage::kFileSystemTypeRestrictedNativeLocal:
+      return local_file_util_.get();
+    case storage::kFileSystemTypeDeviceMediaAsFileStorage:
+      return mtp_delegate_->GetAsyncFileUtil(type);
+    case storage::kFileSystemTypeArcContent:
+      return arc_content_delegate_->GetAsyncFileUtil(type);
+    case storage::kFileSystemTypeArcDocumentsProvider:
+      return arc_documents_provider_delegate_->GetAsyncFileUtil(type);
+    case storage::kFileSystemTypeDriveFs:
+      return drivefs_delegate_->GetAsyncFileUtil(type);
+    default:
+      NOTREACHED();
+  }
+  return NULL;
+}
+
+storage::WatcherManager* FileSystemBackend::GetWatcherManager(
+    storage::FileSystemType type) {
+  if (type == storage::kFileSystemTypeProvided)
+    return file_system_provider_delegate_->GetWatcherManager(type);
+
+  if (type == storage::kFileSystemTypeDeviceMediaAsFileStorage &&
+      !base::CommandLine::ForCurrentProcess()->HasSwitch(
+          chromeos::switches::kDisableMtpWriteSupport)) {
+    return mtp_delegate_->GetWatcherManager(type);
+  }
+
+  if (type == storage::kFileSystemTypeArcDocumentsProvider)
+    return arc_documents_provider_delegate_->GetWatcherManager(type);
+
+  // TODO(mtomasz): Add support for other backends.
+  return NULL;
+}
+
+storage::CopyOrMoveFileValidatorFactory*
+FileSystemBackend::GetCopyOrMoveFileValidatorFactory(
+    storage::FileSystemType type,
+    base::File::Error* error_code) {
+  DCHECK(error_code);
+  *error_code = base::File::FILE_OK;
+  return NULL;
+}
+
+storage::FileSystemOperation* FileSystemBackend::CreateFileSystemOperation(
+    const storage::FileSystemURL& url,
+    storage::FileSystemContext* context,
+    base::File::Error* error_code) const {
+  DCHECK(url.is_valid());
+
+  if (!IsAccessAllowed(url)) {
+    *error_code = base::File::FILE_ERROR_SECURITY;
+    return NULL;
+  }
+
+  if (url.type() == storage::kFileSystemTypeDeviceMediaAsFileStorage) {
+    // MTP file operations run on MediaTaskRunner.
+    return storage::FileSystemOperation::Create(
+        url, context,
+        std::make_unique<storage::FileSystemOperationContext>(
+            context, MediaFileSystemBackend::MediaTaskRunner().get()));
+  }
+
+  DCHECK(url.type() == storage::kFileSystemTypeNativeLocal ||
+         url.type() == storage::kFileSystemTypeRestrictedNativeLocal ||
+         url.type() == storage::kFileSystemTypeDrive ||
+         url.type() == storage::kFileSystemTypeProvided ||
+         url.type() == storage::kFileSystemTypeArcContent ||
+         url.type() == storage::kFileSystemTypeArcDocumentsProvider ||
+         url.type() == storage::kFileSystemTypeDriveFs);
+  return storage::FileSystemOperation::Create(
+      url, context,
+      std::make_unique<storage::FileSystemOperationContext>(context));
+}
+
+bool FileSystemBackend::SupportsStreaming(
+    const storage::FileSystemURL& url) const {
+  return url.type() == storage::kFileSystemTypeDrive ||
+         url.type() == storage::kFileSystemTypeProvided ||
+         url.type() == storage::kFileSystemTypeDeviceMediaAsFileStorage ||
+         url.type() == storage::kFileSystemTypeArcContent ||
+         url.type() == storage::kFileSystemTypeArcDocumentsProvider;
+}
+
+bool FileSystemBackend::HasInplaceCopyImplementation(
+    storage::FileSystemType type) const {
+  switch (type) {
+    case storage::kFileSystemTypeDrive:
+    case storage::kFileSystemTypeProvided:
+    case storage::kFileSystemTypeDeviceMediaAsFileStorage:
+      return true;
+    case storage::kFileSystemTypeNativeLocal:
+    case storage::kFileSystemTypeRestrictedNativeLocal:
+    case storage::kFileSystemTypeArcContent:
+    case storage::kFileSystemTypeArcDocumentsProvider:
+    case storage::kFileSystemTypeDriveFs:
+      return false;
+    default:
+      NOTREACHED();
+  }
+  return true;
+}
+
+std::unique_ptr<storage::FileStreamReader>
+FileSystemBackend::CreateFileStreamReader(
+    const storage::FileSystemURL& url,
+    int64_t offset,
+    int64_t max_bytes_to_read,
+    const base::Time& expected_modification_time,
+    storage::FileSystemContext* context) const {
+  DCHECK(url.is_valid());
+
+  if (!IsAccessAllowed(url))
+    return std::unique_ptr<storage::FileStreamReader>();
+
+  switch (url.type()) {
+    case storage::kFileSystemTypeDrive:
+      return drive_delegate_->CreateFileStreamReader(
+          url, offset, max_bytes_to_read, expected_modification_time, context);
+    case storage::kFileSystemTypeProvided:
+      return file_system_provider_delegate_->CreateFileStreamReader(
+          url, offset, max_bytes_to_read, expected_modification_time, context);
+    case storage::kFileSystemTypeNativeLocal:
+    case storage::kFileSystemTypeRestrictedNativeLocal:
+    case storage::kFileSystemTypeDriveFs:
+      return std::unique_ptr<storage::FileStreamReader>(
+          storage::FileStreamReader::CreateForFileSystemFile(
+              context, url, offset, expected_modification_time));
+    case storage::kFileSystemTypeDeviceMediaAsFileStorage:
+      return mtp_delegate_->CreateFileStreamReader(
+          url, offset, max_bytes_to_read, expected_modification_time, context);
+    case storage::kFileSystemTypeArcContent:
+      return arc_content_delegate_->CreateFileStreamReader(
+          url, offset, max_bytes_to_read, expected_modification_time, context);
+    case storage::kFileSystemTypeArcDocumentsProvider:
+      return arc_documents_provider_delegate_->CreateFileStreamReader(
+          url, offset, max_bytes_to_read, expected_modification_time, context);
+    default:
+      NOTREACHED();
+  }
+  return std::unique_ptr<storage::FileStreamReader>();
+}
+
+std::unique_ptr<storage::FileStreamWriter>
+FileSystemBackend::CreateFileStreamWriter(
+    const storage::FileSystemURL& url,
+    int64_t offset,
+    storage::FileSystemContext* context) const {
+  DCHECK(url.is_valid());
+
+  if (!IsAccessAllowed(url))
+    return std::unique_ptr<storage::FileStreamWriter>();
+
+  switch (url.type()) {
+    case storage::kFileSystemTypeDrive:
+      return drive_delegate_->CreateFileStreamWriter(url, offset, context);
+    case storage::kFileSystemTypeProvided:
+      return file_system_provider_delegate_->CreateFileStreamWriter(
+          url, offset, context);
+    case storage::kFileSystemTypeNativeLocal:
+    case storage::kFileSystemTypeDriveFs:
+      return std::unique_ptr<storage::FileStreamWriter>(
+          storage::FileStreamWriter::CreateForLocalFile(
+              context->default_file_task_runner(), url.path(), offset,
+              storage::FileStreamWriter::OPEN_EXISTING_FILE));
+    case storage::kFileSystemTypeDeviceMediaAsFileStorage:
+      return mtp_delegate_->CreateFileStreamWriter(url, offset, context);
+    // Read only file systems.
+    case storage::kFileSystemTypeRestrictedNativeLocal:
+    case storage::kFileSystemTypeArcContent:
+    case storage::kFileSystemTypeArcDocumentsProvider:
+      return std::unique_ptr<storage::FileStreamWriter>();
+    default:
+      NOTREACHED();
+  }
+  return std::unique_ptr<storage::FileStreamWriter>();
+}
+
+bool FileSystemBackend::GetVirtualPath(const base::FilePath& filesystem_path,
+                                       base::FilePath* virtual_path) const {
+  return mount_points_->GetVirtualPath(filesystem_path, virtual_path) ||
+         system_mount_points_->GetVirtualPath(filesystem_path, virtual_path);
+}
+
+void FileSystemBackend::GetRedirectURLForContents(
+    const storage::FileSystemURL& url,
+    const storage::URLCallback& callback) const {
+  DCHECK(url.is_valid());
+
+  if (!IsAccessAllowed(url))
+    return callback.Run(GURL());
+
+  switch (url.type()) {
+    case storage::kFileSystemTypeDrive:
+      drive_delegate_->GetRedirectURLForContents(url, callback);
+      return;
+    case storage::kFileSystemTypeProvided:
+      file_system_provider_delegate_->GetRedirectURLForContents(url,
+                                                                  callback);
+      return;
+    case storage::kFileSystemTypeDeviceMediaAsFileStorage:
+      mtp_delegate_->GetRedirectURLForContents(url, callback);
+      return;
+    case storage::kFileSystemTypeNativeLocal:
+    case storage::kFileSystemTypeRestrictedNativeLocal:
+    case storage::kFileSystemTypeArcContent:
+    case storage::kFileSystemTypeArcDocumentsProvider:
+    case storage::kFileSystemTypeDriveFs:
+      callback.Run(GURL());
+      return;
+    default:
+      NOTREACHED();
+  }
+  callback.Run(GURL());
+}
+
+storage::FileSystemURL FileSystemBackend::CreateInternalURL(
+    storage::FileSystemContext* context,
+    const base::FilePath& entry_path) const {
+  base::FilePath virtual_path;
+  if (!GetVirtualPath(entry_path, &virtual_path))
+    return storage::FileSystemURL();
+
+  return context->CreateCrackedFileSystemURL(
+      GURL() /* origin */, storage::kFileSystemTypeExternal, virtual_path);
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/file_system_backend.h b/chrome/browser/fileapi/file_system_backend.h
new file mode 100644
index 0000000000000..2d02d51de3e31
--- /dev/null
+++ b/chrome/browser/fileapi/file_system_backend.h
@@ -0,0 +1,189 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILEAPI_FILE_SYSTEM_BACKEND_H_
+#define CHROME_BROWSER_FILEAPI_FILE_SYSTEM_BACKEND_H_
+
+#include <stdint.h>
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/compiler_specific.h"
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/memory/ref_counted.h"
+#include "storage/browser/fileapi/file_system_backend.h"
+#include "storage/browser/fileapi/task_runner_bound_observer_list.h"
+#include "storage/common/fileapi/file_system_types.h"
+
+namespace storage {
+class CopyOrMoveFileValidatorFactory;
+class ExternalMountPoints;
+class FileSystemURL;
+class WatcherManager;
+}  // namespace storage
+
+namespace chromeos {
+
+class FileSystemBackendDelegate;
+class FileAccessPermissions;
+
+// FileSystemBackend is a Chrome OS specific implementation of
+// ExternalFileSystemBackend. This class is responsible for a
+// number of things, including:
+//
+// - Add system mount points
+// - Grant/revoke/check file access permissions
+// - Create FileSystemOperation per file system type
+// - Create FileStreamReader/Writer per file system type
+//
+// Chrome OS specific mount points:
+//
+// "Downloads" is a mount point for user's Downloads directory on the local
+// disk, where downloaded files are stored by default.
+//
+// "archive" is a mount point for an archive file, such as a zip file. This
+// mount point exposes contents of an archive file via cros_disks and AVFS
+// <http://avf.sourceforge.net/>.
+//
+// "removable" is a mount point for removable media such as an SD card.
+// Insertion and removal of removable media are handled by cros_disks.
+//
+// "oem" is a read-only mount point for a directory containing OEM data.
+//
+// "drive" is a mount point for Google Drive. Drive is integrated with the
+// FileSystem API layer via drive::FileSystemProxy. This mount point is added
+// by drive::DriveIntegrationService.
+//
+// These mount points are placed under the "external" namespace, and file
+// system URLs for these mount points look like:
+//
+//   filesystem:<origin>/external/<mount_name>/...
+//
+class FileSystemBackend : public storage::ExternalFileSystemBackend {
+ public:
+  using storage::FileSystemBackend::OpenFileSystemCallback;
+
+  // |system_mount_points| should outlive FileSystemBackend instance.
+  FileSystemBackend(
+      std::unique_ptr<FileSystemBackendDelegate> drive_delegate,
+      std::unique_ptr<FileSystemBackendDelegate> file_system_provider_delegate,
+      std::unique_ptr<FileSystemBackendDelegate> mtp_delegate,
+      std::unique_ptr<FileSystemBackendDelegate> arc_content_delegate,
+      std::unique_ptr<FileSystemBackendDelegate>
+          arc_documents_provider_delegate,
+      std::unique_ptr<FileSystemBackendDelegate> drivefs_delegate,
+      scoped_refptr<storage::ExternalMountPoints> mount_points,
+      storage::ExternalMountPoints* system_mount_points);
+  ~FileSystemBackend() override;
+
+  // Adds system mount points, such as "archive", and "removable". This
+  // function is no-op if these mount points are already present.
+  void AddSystemMountPoints();
+
+  // Returns true if CrosMountpointProvider can handle |url|, i.e. its
+  // file system type matches with what this provider supports.
+  // This could be called on any threads.
+  static bool CanHandleURL(const storage::FileSystemURL& url);
+
+  // storage::FileSystemBackend overrides.
+  bool CanHandleType(storage::FileSystemType type) const override;
+  void Initialize(storage::FileSystemContext* context) override;
+  void ResolveURL(const storage::FileSystemURL& url,
+                  storage::OpenFileSystemMode mode,
+                  OpenFileSystemCallback callback) override;
+  storage::AsyncFileUtil* GetAsyncFileUtil(
+      storage::FileSystemType type) override;
+  storage::WatcherManager* GetWatcherManager(
+      storage::FileSystemType type) override;
+  storage::CopyOrMoveFileValidatorFactory* GetCopyOrMoveFileValidatorFactory(
+      storage::FileSystemType type,
+      base::File::Error* error_code) override;
+  storage::FileSystemOperation* CreateFileSystemOperation(
+      const storage::FileSystemURL& url,
+      storage::FileSystemContext* context,
+      base::File::Error* error_code) const override;
+  bool SupportsStreaming(const storage::FileSystemURL& url) const override;
+  bool HasInplaceCopyImplementation(
+      storage::FileSystemType type) const override;
+  std::unique_ptr<storage::FileStreamReader> CreateFileStreamReader(
+      const storage::FileSystemURL& path,
+      int64_t offset,
+      int64_t max_bytes_to_read,
+      const base::Time& expected_modification_time,
+      storage::FileSystemContext* context) const override;
+  std::unique_ptr<storage::FileStreamWriter> CreateFileStreamWriter(
+      const storage::FileSystemURL& url,
+      int64_t offset,
+      storage::FileSystemContext* context) const override;
+  storage::FileSystemQuotaUtil* GetQuotaUtil() override;
+  const storage::UpdateObserverList* GetUpdateObservers(
+      storage::FileSystemType type) const override;
+  const storage::ChangeObserverList* GetChangeObservers(
+      storage::FileSystemType type) const override;
+  const storage::AccessObserverList* GetAccessObservers(
+      storage::FileSystemType type) const override;
+
+  // storage::ExternalFileSystemBackend overrides.
+  bool IsAccessAllowed(const storage::FileSystemURL& url) const override;
+  std::vector<base::FilePath> GetRootDirectories() const override;
+  void GrantFileAccessToExtension(const std::string& extension_id,
+                                  const base::FilePath& virtual_path) override;
+  void RevokeAccessForExtension(const std::string& extension_id) override;
+  bool GetVirtualPath(const base::FilePath& filesystem_path,
+                      base::FilePath* virtual_path) const override;
+  void GetRedirectURLForContents(
+      const storage::FileSystemURL& url,
+      const storage::URLCallback& callback) const override;
+  storage::FileSystemURL CreateInternalURL(
+      storage::FileSystemContext* context,
+      const base::FilePath& entry_path) const override;
+
+ private:
+  std::unique_ptr<FileAccessPermissions> file_access_permissions_;
+  std::unique_ptr<storage::AsyncFileUtil> local_file_util_;
+
+  // The delegate instance for the drive file system related operations.
+  std::unique_ptr<FileSystemBackendDelegate> drive_delegate_;
+
+  // The delegate instance for the provided file system related operations.
+  std::unique_ptr<FileSystemBackendDelegate> file_system_provider_delegate_;
+
+  // The delegate instance for the MTP file system related operations.
+  std::unique_ptr<FileSystemBackendDelegate> mtp_delegate_;
+
+  // The delegate instance for the ARC content file system related operations.
+  std::unique_ptr<FileSystemBackendDelegate> arc_content_delegate_;
+
+  // The delegate instance for the ARC documents provider related operations.
+  std::unique_ptr<FileSystemBackendDelegate> arc_documents_provider_delegate_;
+
+  // The delegate instance for the DriveFS file system related operations.
+  std::unique_ptr<FileSystemBackendDelegate> drivefs_delegate_;
+
+  // Mount points specific to the owning context (i.e. per-profile mount
+  // points).
+  //
+  // It is legal to have mount points with the same name as in
+  // system_mount_points_. Also, mount point paths may overlap with mount point
+  // paths in system_mount_points_. In both cases mount points in
+  // |mount_points_| will have a priority.
+  // E.g. if |mount_points_| map 'foo1' to '/foo/foo1' and
+  // |file_system_mount_points_| map 'xxx' to '/foo/foo1/xxx', |GetVirtualPaths|
+  // will resolve '/foo/foo1/xxx/yyy' as 'foo1/xxx/yyy' (i.e. the mapping from
+  // |mount_points_| will be used).
+  scoped_refptr<storage::ExternalMountPoints> mount_points_;
+
+  // Globally visible mount points. System MountPonts instance should outlive
+  // all FileSystemBackend instances, so raw pointer is safe.
+  storage::ExternalMountPoints* system_mount_points_;
+
+  DISALLOW_COPY_AND_ASSIGN(FileSystemBackend);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROME_BROWSER_FILEAPI_FILE_SYSTEM_BACKEND_H_
diff --git a/chrome/browser/fileapi/file_system_backend_delegate.h b/chrome/browser/fileapi/file_system_backend_delegate.h
new file mode 100644
index 0000000000000..30090f586a3d9
--- /dev/null
+++ b/chrome/browser/fileapi/file_system_backend_delegate.h
@@ -0,0 +1,70 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILEAPI_FILE_SYSTEM_BACKEND_DELEGATE_H_
+#define CHROME_BROWSER_FILEAPI_FILE_SYSTEM_BACKEND_DELEGATE_H_
+
+#include <stdint.h>
+
+#include <memory>
+
+#include "base/callback_forward.h"
+#include "storage/browser/fileapi/file_system_backend.h"
+#include "storage/common/fileapi/file_system_types.h"
+
+namespace base {
+class Time;
+}  // namespace base
+
+namespace storage {
+class AsyncFileUtil;
+class FileSystemContext;
+class FileStreamReader;
+class FileSystemURL;
+class FileStreamWriter;
+class WatcherManager;
+}  // namespace storage
+
+namespace chromeos {
+
+// This is delegate interface to inject the implementation of the some methods
+// of FileSystemBackend.
+class FileSystemBackendDelegate {
+ public:
+  virtual ~FileSystemBackendDelegate() {}
+
+  // Called from FileSystemBackend::GetAsyncFileUtil().
+  virtual storage::AsyncFileUtil* GetAsyncFileUtil(
+      storage::FileSystemType type) = 0;
+
+  // Called from FileSystemBackend::CreateFileStreamReader().
+  virtual std::unique_ptr<storage::FileStreamReader> CreateFileStreamReader(
+      const storage::FileSystemURL& url,
+      int64_t offset,
+      int64_t max_bytes_to_read,
+      const base::Time& expected_modification_time,
+      storage::FileSystemContext* context) = 0;
+
+  // Called from FileSystemBackend::CreateFileStreamWriter().
+  virtual std::unique_ptr<storage::FileStreamWriter> CreateFileStreamWriter(
+      const storage::FileSystemURL& url,
+      int64_t offset,
+      storage::FileSystemContext* context) = 0;
+
+  // Called from the FileSystemWatcherService class. The returned pointer must
+  // stay valid until shutdown.
+  virtual storage::WatcherManager* GetWatcherManager(
+      storage::FileSystemType type) = 0;
+
+  // Called from FileSystemBackend::GetRedirectURLForContents.  Please ensure
+  // that the returned URL is secure to be opened in a browser tab, or referred
+  // from <img>, <video>, XMLHttpRequest, etc...
+  virtual void GetRedirectURLForContents(
+      const storage::FileSystemURL& url,
+      const storage::URLCallback& callback) = 0;
+};
+
+}  // namespace chromeos
+
+#endif  // CHROME_BROWSER_FILEAPI_FILE_SYSTEM_BACKEND_DELEGATE_H_
diff --git a/chrome/browser/fileapi/file_system_backend_unittest.cc b/chrome/browser/fileapi/file_system_backend_unittest.cc
new file mode 100644
index 0000000000000..372c76f0bd07b
--- /dev/null
+++ b/chrome/browser/fileapi/file_system_backend_unittest.cc
@@ -0,0 +1,259 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/file_system_backend.h"
+
+#include <stddef.h>
+
+#include <set>
+
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "chrome/browser/fileapi/file_system_backend_delegate.h"
+#include "chromeos/dbus/cros_disks_client.h"
+#include "extensions/common/constants.h"
+#include "storage/browser/fileapi/external_mount_points.h"
+#include "storage/browser/fileapi/file_system_url.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "url/url_util.h"
+
+#define FPL(x) FILE_PATH_LITERAL(x)
+
+using storage::ExternalMountPoints;
+using storage::FileSystemURL;
+
+namespace {
+
+FileSystemURL CreateFileSystemURL(const std::string& extension,
+                                  const char* path,
+                                  ExternalMountPoints* mount_points) {
+  return mount_points->CreateCrackedFileSystemURL(
+      GURL("chrome-extension://" + extension + "/"),
+      storage::kFileSystemTypeExternal,
+      base::FilePath::FromUTF8Unsafe(path));
+}
+
+TEST(ChromeOSFileSystemBackendTest, DefaultMountPoints) {
+  // Make sure no system-level mount points are registered before testing
+  // to avoid flakiness.
+  storage::ExternalMountPoints::GetSystemInstance()->RevokeAllFileSystems();
+
+  scoped_refptr<storage::ExternalMountPoints> mount_points(
+      storage::ExternalMountPoints::CreateRefCounted());
+  chromeos::FileSystemBackend backend(
+      nullptr,  // drive_delegate
+      nullptr,  // file_system_provider_delegate
+      nullptr,  // mtp_delegate
+      nullptr,  // arc_content_delegate
+      nullptr,  // arc_documents_provider_delegate
+      nullptr,  // drivefs_delegate
+      mount_points.get(), storage::ExternalMountPoints::GetSystemInstance());
+  backend.AddSystemMountPoints();
+  std::vector<base::FilePath> root_dirs = backend.GetRootDirectories();
+  std::set<base::FilePath> root_dirs_set(root_dirs.begin(), root_dirs.end());
+
+  // By default there should be 3 mount points (in system mount points):
+  EXPECT_EQ(3u, root_dirs.size());
+
+  EXPECT_TRUE(root_dirs_set.count(
+      chromeos::CrosDisksClient::GetRemovableDiskMountPoint()));
+  EXPECT_TRUE(root_dirs_set.count(
+      chromeos::CrosDisksClient::GetArchiveMountPoint()));
+  EXPECT_TRUE(root_dirs_set.count(base::FilePath(FPL("/usr/share/oem"))));
+}
+
+TEST(ChromeOSFileSystemBackendTest, GetRootDirectories) {
+  scoped_refptr<storage::ExternalMountPoints> mount_points(
+      storage::ExternalMountPoints::CreateRefCounted());
+
+  scoped_refptr<storage::ExternalMountPoints> system_mount_points(
+      storage::ExternalMountPoints::CreateRefCounted());
+
+  chromeos::FileSystemBackend backend(
+      nullptr,  // drive_delegate
+      nullptr,  // file_system_provider_delegate
+      nullptr,  // mtp_delegate
+      nullptr,  // arc_content_delegate
+      nullptr,  // arc_documents_provider_delegate
+      nullptr,  // drivefs_delegate
+      mount_points.get(), system_mount_points.get());
+
+  const size_t initial_root_dirs_size = backend.GetRootDirectories().size();
+
+  // Register 'local' test mount points.
+  mount_points->RegisterFileSystem("c",
+                                   storage::kFileSystemTypeNativeLocal,
+                                   storage::FileSystemMountOption(),
+                                   base::FilePath(FPL("/a/b/c")));
+  mount_points->RegisterFileSystem("d",
+                                   storage::kFileSystemTypeNativeLocal,
+                                   storage::FileSystemMountOption(),
+                                   base::FilePath(FPL("/b/c/d")));
+
+  // Register system test mount points.
+  system_mount_points->RegisterFileSystem("d",
+                                          storage::kFileSystemTypeNativeLocal,
+                                          storage::FileSystemMountOption(),
+                                          base::FilePath(FPL("/g/c/d")));
+  system_mount_points->RegisterFileSystem("e",
+                                          storage::kFileSystemTypeNativeLocal,
+                                          storage::FileSystemMountOption(),
+                                          base::FilePath(FPL("/g/d/e")));
+
+  std::vector<base::FilePath> root_dirs = backend.GetRootDirectories();
+  std::set<base::FilePath> root_dirs_set(root_dirs.begin(), root_dirs.end());
+  EXPECT_EQ(initial_root_dirs_size + 4, root_dirs.size());
+  EXPECT_TRUE(root_dirs_set.count(base::FilePath(FPL("/a/b/c"))));
+  EXPECT_TRUE(root_dirs_set.count(base::FilePath(FPL("/b/c/d"))));
+  EXPECT_TRUE(root_dirs_set.count(base::FilePath(FPL("/g/c/d"))));
+  EXPECT_TRUE(root_dirs_set.count(base::FilePath(FPL("/g/d/e"))));
+}
+
+TEST(ChromeOSFileSystemBackendTest, AccessPermissions) {
+  url::AddStandardScheme(extensions::kExtensionScheme, url::SCHEME_WITH_HOST);
+
+  scoped_refptr<storage::ExternalMountPoints> mount_points(
+      storage::ExternalMountPoints::CreateRefCounted());
+  scoped_refptr<storage::ExternalMountPoints> system_mount_points(
+      storage::ExternalMountPoints::CreateRefCounted());
+  chromeos::FileSystemBackend backend(
+      nullptr,  // drive_delegate
+      nullptr,  // file_system_provider_delegate
+      nullptr,  // mtp_delegate
+      nullptr,  // arc_content_delegate
+      nullptr,  // arc_documents_provider_delegate
+      nullptr,  // drivefs_delegate
+      mount_points.get(), system_mount_points.get());
+
+  std::string extension("ddammdhioacbehjngdmkjcjbnfginlla");
+
+  // Initialize mount points.
+  ASSERT_TRUE(system_mount_points->RegisterFileSystem(
+      "system",
+      storage::kFileSystemTypeNativeLocal,
+      storage::FileSystemMountOption(),
+      base::FilePath(FPL("/g/system"))));
+  ASSERT_TRUE(mount_points->RegisterFileSystem(
+      "removable",
+      storage::kFileSystemTypeNativeLocal,
+      storage::FileSystemMountOption(),
+      base::FilePath(FPL("/media/removable"))));
+  ASSERT_TRUE(mount_points->RegisterFileSystem(
+      "oem",
+      storage::kFileSystemTypeRestrictedNativeLocal,
+      storage::FileSystemMountOption(),
+      base::FilePath(FPL("/usr/share/oem"))));
+
+  // Backend specific mount point access.
+  EXPECT_FALSE(backend.IsAccessAllowed(
+      CreateFileSystemURL(extension, "removable/foo", mount_points.get())));
+
+  backend.GrantFileAccessToExtension(extension,
+                                      base::FilePath(FPL("removable/foo")));
+  EXPECT_TRUE(backend.IsAccessAllowed(
+      CreateFileSystemURL(extension, "removable/foo", mount_points.get())));
+  EXPECT_FALSE(backend.IsAccessAllowed(
+      CreateFileSystemURL(extension, "removable/foo1", mount_points.get())));
+
+  // System mount point access.
+  EXPECT_FALSE(backend.IsAccessAllowed(
+      CreateFileSystemURL(extension, "system/foo", system_mount_points.get())));
+
+  backend.GrantFileAccessToExtension(extension,
+                                      base::FilePath(FPL("system/foo")));
+  EXPECT_TRUE(backend.IsAccessAllowed(
+      CreateFileSystemURL(extension, "system/foo", system_mount_points.get())));
+  EXPECT_FALSE(backend.IsAccessAllowed(
+      CreateFileSystemURL(extension, "system/foo1",
+                          system_mount_points.get())));
+
+  // The extension cannot access new mount points.
+  // TODO(tbarzic): This should probably be changed.
+  ASSERT_TRUE(
+      mount_points->RegisterFileSystem("test",
+                                       storage::kFileSystemTypeNativeLocal,
+                                       storage::FileSystemMountOption(),
+                                       base::FilePath(FPL("/foo/test"))));
+  EXPECT_FALSE(backend.IsAccessAllowed(
+      CreateFileSystemURL(extension, "test_/foo", mount_points.get())));
+
+  backend.RevokeAccessForExtension(extension);
+  EXPECT_FALSE(backend.IsAccessAllowed(
+      CreateFileSystemURL(extension, "removable/foo", mount_points.get())));
+}
+
+TEST(ChromeOSFileSystemBackendTest, GetVirtualPathConflictWithSystemPoints) {
+  scoped_refptr<storage::ExternalMountPoints> mount_points(
+      storage::ExternalMountPoints::CreateRefCounted());
+  scoped_refptr<storage::ExternalMountPoints> system_mount_points(
+      storage::ExternalMountPoints::CreateRefCounted());
+  chromeos::FileSystemBackend backend(
+      nullptr,  // drive_delegate
+      nullptr,  // file_system_provider_delegate
+      nullptr,  // mtp_delegate
+      nullptr,  // arc_content_delegate
+      nullptr,  // arc_documents_provider_delegate
+      nullptr,  // drivefs_delegate
+      mount_points.get(), system_mount_points.get());
+
+  const storage::FileSystemType type = storage::kFileSystemTypeNativeLocal;
+  const storage::FileSystemMountOption option =
+      storage::FileSystemMountOption();
+
+  // Backend specific mount points.
+  ASSERT_TRUE(mount_points->RegisterFileSystem(
+      "b", type, option, base::FilePath(FPL("/a/b"))));
+  ASSERT_TRUE(mount_points->RegisterFileSystem(
+      "y", type, option, base::FilePath(FPL("/z/y"))));
+  ASSERT_TRUE(mount_points->RegisterFileSystem(
+      "n", type, option, base::FilePath(FPL("/m/n"))));
+
+  // System mount points
+  ASSERT_TRUE(system_mount_points->RegisterFileSystem(
+      "gb", type, option, base::FilePath(FPL("/a/b"))));
+  ASSERT_TRUE(
+      system_mount_points->RegisterFileSystem(
+          "gz", type, option, base::FilePath(FPL("/z"))));
+  ASSERT_TRUE(system_mount_points->RegisterFileSystem(
+       "gp", type, option, base::FilePath(FPL("/m/n/o/p"))));
+
+  struct TestCase {
+    const base::FilePath::CharType* const local_path;
+    bool success;
+    const base::FilePath::CharType* const virtual_path;
+  };
+
+  const TestCase kTestCases[] = {
+    // Same paths in both mount points.
+    { FPL("/a/b/c/d"), true, FPL("b/c/d") },
+    // System mount points path more specific.
+    { FPL("/m/n/o/p/r/s"), true, FPL("n/o/p/r/s") },
+    // System mount points path less specific.
+    { FPL("/z/y/x"), true, FPL("y/x") },
+    // Only system mount points path matches.
+    { FPL("/z/q/r/s"), true, FPL("gz/q/r/s") },
+    // No match.
+    { FPL("/foo/xxx"), false, FPL("") },
+  };
+
+  for (size_t i = 0; i < arraysize(kTestCases); ++i) {
+    // Initialize virtual path with a value.
+    base::FilePath virtual_path(FPL("/mount"));
+    base::FilePath local_path(kTestCases[i].local_path);
+    EXPECT_EQ(kTestCases[i].success,
+              backend.GetVirtualPath(local_path, &virtual_path))
+        << "Resolving " << kTestCases[i].local_path;
+
+    // There are no guarantees for |virtual_path| value if |GetVirtualPath|
+    // fails.
+    if (!kTestCases[i].success)
+      continue;
+
+    base::FilePath expected_virtual_path(kTestCases[i].virtual_path);
+    EXPECT_EQ(expected_virtual_path, virtual_path)
+        << "Resolving " << kTestCases[i].local_path;
+  }
+}
+
+}  // namespace
diff --git a/chrome/browser/fileapi/mtp_file_system_backend_delegate.cc b/chrome/browser/fileapi/mtp_file_system_backend_delegate.cc
new file mode 100644
index 0000000000000..b933c705fd975
--- /dev/null
+++ b/chrome/browser/fileapi/mtp_file_system_backend_delegate.cc
@@ -0,0 +1,70 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/mtp_file_system_backend_delegate.h"
+#include "chrome/browser/media_galleries/fileapi/device_media_async_file_util.h"
+#include "storage/browser/fileapi/file_stream_reader.h"
+#include "storage/browser/fileapi/file_stream_writer.h"
+#include "storage/browser/fileapi/file_system_url.h"
+
+namespace chromeos {
+
+MTPFileSystemBackendDelegate::MTPFileSystemBackendDelegate(
+    const base::FilePath& storage_partition_path)
+    : device_media_async_file_util_(
+          DeviceMediaAsyncFileUtil::Create(storage_partition_path,
+                                           NO_MEDIA_FILE_VALIDATION)),
+      mtp_watcher_manager_(
+          new MTPWatcherManager(device_media_async_file_util_.get())) {
+}
+
+MTPFileSystemBackendDelegate::~MTPFileSystemBackendDelegate() {
+}
+
+storage::AsyncFileUtil* MTPFileSystemBackendDelegate::GetAsyncFileUtil(
+    storage::FileSystemType type) {
+  DCHECK_EQ(storage::kFileSystemTypeDeviceMediaAsFileStorage, type);
+
+  return device_media_async_file_util_.get();
+}
+
+std::unique_ptr<storage::FileStreamReader>
+MTPFileSystemBackendDelegate::CreateFileStreamReader(
+    const storage::FileSystemURL& url,
+    int64_t offset,
+    int64_t max_bytes_to_read,
+    const base::Time& expected_modification_time,
+    storage::FileSystemContext* context) {
+  DCHECK_EQ(storage::kFileSystemTypeDeviceMediaAsFileStorage, url.type());
+
+  return device_media_async_file_util_->GetFileStreamReader(
+      url, offset, expected_modification_time, context);
+}
+
+std::unique_ptr<storage::FileStreamWriter>
+MTPFileSystemBackendDelegate::CreateFileStreamWriter(
+    const storage::FileSystemURL& url,
+    int64_t offset,
+    storage::FileSystemContext* context) {
+  DCHECK_EQ(storage::kFileSystemTypeDeviceMediaAsFileStorage, url.type());
+
+  // TODO(kinaba): support writing.
+  return std::unique_ptr<storage::FileStreamWriter>();
+}
+
+storage::WatcherManager* MTPFileSystemBackendDelegate::GetWatcherManager(
+    storage::FileSystemType type) {
+  DCHECK_EQ(storage::kFileSystemTypeDeviceMediaAsFileStorage, type);
+  return mtp_watcher_manager_.get();
+}
+
+void MTPFileSystemBackendDelegate::GetRedirectURLForContents(
+    const storage::FileSystemURL& url,
+    const storage::URLCallback& callback) {
+  DCHECK_EQ(storage::kFileSystemTypeDeviceMediaAsFileStorage, url.type());
+
+  callback.Run(GURL());
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/mtp_file_system_backend_delegate.h b/chrome/browser/fileapi/mtp_file_system_backend_delegate.h
new file mode 100644
index 0000000000000..3f3f272339824
--- /dev/null
+++ b/chrome/browser/fileapi/mtp_file_system_backend_delegate.h
@@ -0,0 +1,68 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILEAPI_MTP_FILE_SYSTEM_BACKEND_DELEGATE_H_
+#define CHROME_BROWSER_FILEAPI_MTP_FILE_SYSTEM_BACKEND_DELEGATE_H_
+
+#include <stdint.h>
+
+#include <memory>
+
+#include "base/macros.h"
+#include "chrome/browser/fileapi/file_system_backend_delegate.h"
+#include "chrome/browser/fileapi/mtp_watcher_manager.h"
+
+namespace base {
+class FilePath;
+}  // namespace base
+
+namespace storage {
+class AsyncFileUtil;
+class FileSystemContext;
+class FileStreamReader;
+class FileSystemURL;
+class FileStreamWriter;
+class WatcherManager;
+}  // namespace storage
+
+class DeviceMediaAsyncFileUtil;
+
+namespace chromeos {
+
+// This is delegate interface to inject the MTP device file system in Chrome OS
+// file API backend.
+class MTPFileSystemBackendDelegate : public FileSystemBackendDelegate {
+ public:
+  explicit MTPFileSystemBackendDelegate(
+      const base::FilePath& storage_partition_path);
+  ~MTPFileSystemBackendDelegate() override;
+
+  // FileSystemBackendDelegate overrides.
+  storage::AsyncFileUtil* GetAsyncFileUtil(
+      storage::FileSystemType type) override;
+  std::unique_ptr<storage::FileStreamReader> CreateFileStreamReader(
+      const storage::FileSystemURL& url,
+      int64_t offset,
+      int64_t max_bytes_to_read,
+      const base::Time& expected_modification_time,
+      storage::FileSystemContext* context) override;
+  std::unique_ptr<storage::FileStreamWriter> CreateFileStreamWriter(
+      const storage::FileSystemURL& url,
+      int64_t offset,
+      storage::FileSystemContext* context) override;
+  storage::WatcherManager* GetWatcherManager(
+      storage::FileSystemType type) override;
+  void GetRedirectURLForContents(const storage::FileSystemURL& url,
+                                 const storage::URLCallback& callback) override;
+
+ private:
+  std::unique_ptr<DeviceMediaAsyncFileUtil> device_media_async_file_util_;
+  std::unique_ptr<MTPWatcherManager> mtp_watcher_manager_;
+
+  DISALLOW_COPY_AND_ASSIGN(MTPFileSystemBackendDelegate);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROME_BROWSER_FILEAPI_MTP_FILE_SYSTEM_BACKEND_DELEGATE_H_
diff --git a/chrome/browser/fileapi/mtp_watcher_manager.cc b/chrome/browser/fileapi/mtp_watcher_manager.cc
new file mode 100644
index 0000000000000..6166293b3b38a
--- /dev/null
+++ b/chrome/browser/fileapi/mtp_watcher_manager.cc
@@ -0,0 +1,39 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/mtp_watcher_manager.h"
+
+#include "content/public/browser/browser_thread.h"
+
+using content::BrowserThread;
+
+namespace chromeos {
+
+MTPWatcherManager::MTPWatcherManager(
+    DeviceMediaAsyncFileUtil* device_media_async_file_util)
+    : device_media_async_file_util_(device_media_async_file_util) {
+  DCHECK(device_media_async_file_util != NULL);
+}
+
+MTPWatcherManager::~MTPWatcherManager() {
+}
+
+void MTPWatcherManager::AddWatcher(
+    const storage::FileSystemURL& url,
+    bool recursive,
+    const StatusCallback& callback,
+    const NotificationCallback& notification_callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  device_media_async_file_util_->AddWatcher(url, recursive, callback,
+                                            notification_callback);
+}
+
+void MTPWatcherManager::RemoveWatcher(const storage::FileSystemURL& url,
+                                      bool recursive,
+                                      const StatusCallback& callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  device_media_async_file_util_->RemoveWatcher(url, recursive, callback);
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/mtp_watcher_manager.h b/chrome/browser/fileapi/mtp_watcher_manager.h
new file mode 100644
index 0000000000000..fdf4da8ddc79c
--- /dev/null
+++ b/chrome/browser/fileapi/mtp_watcher_manager.h
@@ -0,0 +1,40 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILEAPI_MTP_WATCHER_MANAGER_H_
+#define CHROME_BROWSER_FILEAPI_MTP_WATCHER_MANAGER_H_
+
+#include "chrome/browser/media_galleries/fileapi/device_media_async_file_util.h"
+#include "storage/browser/fileapi/watcher_manager.h"
+
+namespace storage {
+
+class FileSystemURL;
+
+}  // namespace storage
+
+namespace chromeos {
+
+class MTPWatcherManager : public storage::WatcherManager {
+ public:
+  explicit MTPWatcherManager(
+      DeviceMediaAsyncFileUtil* device_media_async_file_util);
+  ~MTPWatcherManager() override;
+
+  void AddWatcher(const storage::FileSystemURL& url,
+                  bool recursive,
+                  const StatusCallback& callback,
+                  const NotificationCallback& notification_callback) override;
+
+  void RemoveWatcher(const storage::FileSystemURL& url,
+                     bool recursive,
+                     const StatusCallback& callback) override;
+
+ private:
+  DeviceMediaAsyncFileUtil* const device_media_async_file_util_;
+};
+
+}  // namespace chromeos
+
+#endif  // CHROME_BROWSER_FILEAPI_MTP_WATCHER_MANAGER_H_
diff --git a/chrome/browser/fileapi/recent_arc_media_source.cc b/chrome/browser/fileapi/recent_arc_media_source.cc
new file mode 100644
index 0000000000000..e067d9c09e00b
--- /dev/null
+++ b/chrome/browser/fileapi/recent_arc_media_source.cc
@@ -0,0 +1,373 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/recent_arc_media_source.h"
+
+#include <algorithm>
+#include <iterator>
+#include <map>
+#include <string>
+#include <utility>
+
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/optional.h"
+#include "base/strings/string_util.h"
+#include "chrome/browser/chromeos/arc/arc_util.h"
+#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_root.h"
+#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_root_map.h"
+#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_util.h"
+#include "chrome/browser/fileapi/recent_file.h"
+#include "chrome/browser/profiles/profile.h"
+#include "components/arc/common/file_system.mojom.h"
+#include "content/public/browser/browser_thread.h"
+#include "storage/browser/fileapi/external_mount_points.h"
+
+using content::BrowserThread;
+
+namespace chromeos {
+
+namespace {
+
+const char kAndroidDownloadDirPrefix[] = "/storage/emulated/0/Download/";
+
+const char kMediaDocumentsProviderAuthority[] =
+    "com.android.providers.media.documents";
+const char* kMediaDocumentsProviderRootIds[] = {
+    "images_root", "videos_root",
+};
+
+base::FilePath GetRelativeMountPath(const std::string& root_id) {
+  base::FilePath mount_path = arc::GetDocumentsProviderMountPath(
+      kMediaDocumentsProviderAuthority,
+      // In MediaDocumentsProvider, |root_id| and |root_document_id| are
+      // the same.
+      root_id);
+  base::FilePath relative_mount_path;
+  base::FilePath(arc::kDocumentsProviderMountPointPath)
+      .AppendRelativePath(mount_path, &relative_mount_path);
+  return relative_mount_path;
+}
+
+}  // namespace
+
+const char RecentArcMediaSource::kLoadHistogramName[] =
+    "FileBrowser.Recent.LoadArcMedia";
+
+// Handles GetRecentFiles() for a root in MediaDocumentsProvider.
+//
+// It gathers recent files in following steps:
+//
+// 1. Call ArcFileSystemOperationRunner::GetRecentDocuments() to get the
+//    list of IDs of recently modified documents.
+//
+// 2. Call ArcDocumentsProviderRoot::ReadDirectory() recursively to
+//    look for file paths of recently modified documents on Media View.
+//
+// 3. After the whole tree is scanned, build FileSystemURLs for paths
+//    found and return them.
+//
+class RecentArcMediaSource::MediaRoot {
+ public:
+  MediaRoot(const std::string& root_id, Profile* profile);
+  ~MediaRoot();
+
+  void GetRecentFiles(Params params);
+
+ private:
+  void OnGetRecentDocuments(
+      base::Optional<std::vector<arc::mojom::DocumentPtr>> maybe_documents);
+  void ScanDirectory(const base::FilePath& path);
+  void OnReadDirectory(
+      const base::FilePath& path,
+      base::File::Error result,
+      std::vector<arc::ArcDocumentsProviderRoot::ThinFileInfo> files);
+  void OnComplete();
+
+  storage::FileSystemURL BuildDocumentsProviderUrl(
+      const base::FilePath& path) const;
+
+  // Set in the constructor.
+  const std::string root_id_;
+  Profile* const profile_;
+  const base::FilePath relative_mount_path_;
+
+  // Set at the beginning of GetRecentFiles().
+  base::Optional<Params> params_;
+
+  // Number of in-flight ReadDirectory() calls by ScanDirectory().
+  int num_inflight_readdirs_ = 0;
+
+  // Maps a document ID to a RecentFile.
+  // In OnGetRecentDocuments(), this map is initialized with document IDs
+  // returned by GetRecentDocuments(), and its values are filled as we scan the
+  // tree in ScanDirectory().
+  // In case of multiple files with the same document ID found, the file with
+  // lexicographically smallest URL is kept. A nullopt value means the
+  // corresponding file is not (yet) found.
+  std::map<std::string, base::Optional<RecentFile>> document_id_to_file_;
+
+  base::WeakPtrFactory<MediaRoot> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(MediaRoot);
+};
+
+RecentArcMediaSource::MediaRoot::MediaRoot(const std::string& root_id,
+                                           Profile* profile)
+    : root_id_(root_id),
+      profile_(profile),
+      relative_mount_path_(GetRelativeMountPath(root_id)),
+      weak_ptr_factory_(this) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+}
+
+RecentArcMediaSource::MediaRoot::~MediaRoot() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+}
+
+void RecentArcMediaSource::MediaRoot::GetRecentFiles(Params params) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(!params_.has_value());
+  DCHECK_EQ(0, num_inflight_readdirs_);
+  DCHECK(document_id_to_file_.empty());
+
+  params_.emplace(std::move(params));
+
+  auto* runner =
+      arc::ArcFileSystemOperationRunner::GetForBrowserContext(profile_);
+  if (!runner) {
+    // This happens when ARC is not allowed in this profile.
+    OnComplete();
+    return;
+  }
+
+  runner->GetRecentDocuments(kMediaDocumentsProviderAuthority, root_id_,
+                             base::Bind(&MediaRoot::OnGetRecentDocuments,
+                                        weak_ptr_factory_.GetWeakPtr()));
+}
+
+void RecentArcMediaSource::MediaRoot::OnGetRecentDocuments(
+    base::Optional<std::vector<arc::mojom::DocumentPtr>> maybe_documents) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(params_.has_value());
+  DCHECK_EQ(0, num_inflight_readdirs_);
+  DCHECK(document_id_to_file_.empty());
+
+  // Initialize |document_id_to_file_| with recent document IDs returned.
+  if (maybe_documents.has_value()) {
+    for (const auto& document : maybe_documents.value()) {
+      // Exclude media files under Downloads directory since they are covered
+      // by RecentDownloadSource.
+      if (document->android_file_system_path.has_value() &&
+          base::StartsWith(document->android_file_system_path.value(),
+                           kAndroidDownloadDirPrefix,
+                           base::CompareCase::SENSITIVE))
+        continue;
+
+      document_id_to_file_.emplace(document->document_id, base::nullopt);
+    }
+  }
+
+  if (document_id_to_file_.empty()) {
+    OnComplete();
+    return;
+  }
+
+  // We have several recent documents, so start searching their real paths.
+  ScanDirectory(base::FilePath());
+}
+
+void RecentArcMediaSource::MediaRoot::ScanDirectory(
+    const base::FilePath& path) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(params_.has_value());
+
+  ++num_inflight_readdirs_;
+
+  auto* root_map =
+      arc::ArcDocumentsProviderRootMap::GetForBrowserContext(profile_);
+  if (!root_map) {
+    // We already checked ARC is allowed for this profile (indirectly), so
+    // this should never happen.
+    LOG(ERROR) << "ArcDocumentsProviderRootMap is not available";
+    OnReadDirectory(path, base::File::FILE_ERROR_FAILED, {});
+    return;
+  }
+
+  // In MediaDocumentsProvider, |root_id| and |root_document_id| are the same.
+  auto* root = root_map->Lookup(kMediaDocumentsProviderAuthority, root_id_);
+  if (!root) {
+    // Media roots should always exist.
+    LOG(ERROR) << "ArcDocumentsProviderRoot is missing";
+    OnReadDirectory(path, base::File::FILE_ERROR_NOT_FOUND, {});
+    return;
+  }
+
+  root->ReadDirectory(
+      path, base::Bind(&RecentArcMediaSource::MediaRoot::OnReadDirectory,
+                       weak_ptr_factory_.GetWeakPtr(), path));
+}
+
+void RecentArcMediaSource::MediaRoot::OnReadDirectory(
+    const base::FilePath& path,
+    base::File::Error result,
+    std::vector<arc::ArcDocumentsProviderRoot::ThinFileInfo> files) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(params_.has_value());
+
+  for (const auto& file : files) {
+    base::FilePath subpath = path.Append(file.name);
+    if (file.is_directory) {
+      ScanDirectory(subpath);
+      continue;
+    }
+
+    auto iter = document_id_to_file_.find(file.document_id);
+    if (iter == document_id_to_file_.end())
+      continue;
+
+    // Update |document_id_to_file_|.
+    // We keep the lexicographically smallest URL to stabilize the results when
+    // there are multiple files with the same document ID.
+    auto url = BuildDocumentsProviderUrl(subpath);
+    base::Optional<RecentFile>& entry = iter->second;
+    if (!entry.has_value() ||
+        storage::FileSystemURL::Comparator()(url, entry.value().url()))
+      entry = RecentFile(url, file.last_modified);
+  }
+
+  --num_inflight_readdirs_;
+  DCHECK_LE(0, num_inflight_readdirs_);
+
+  if (num_inflight_readdirs_ == 0)
+    OnComplete();
+}
+
+void RecentArcMediaSource::MediaRoot::OnComplete() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(params_.has_value());
+  DCHECK_EQ(0, num_inflight_readdirs_);
+
+  std::vector<RecentFile> files;
+  for (const auto& entry : document_id_to_file_) {
+    const base::Optional<RecentFile>& file = entry.second;
+    if (file.has_value())
+      files.emplace_back(file.value());
+  }
+  document_id_to_file_.clear();
+
+  Params params = std::move(params_.value());
+  params_.reset();
+  std::move(params.callback()).Run(std::move(files));
+}
+
+storage::FileSystemURL
+RecentArcMediaSource::MediaRoot::BuildDocumentsProviderUrl(
+    const base::FilePath& path) const {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(params_.has_value());
+
+  storage::ExternalMountPoints* mount_points =
+      storage::ExternalMountPoints::GetSystemInstance();
+
+  return mount_points->CreateExternalFileSystemURL(
+      params_.value().origin(), arc::kDocumentsProviderMountPointName,
+      relative_mount_path_.Append(path));
+}
+
+RecentArcMediaSource::RecentArcMediaSource(Profile* profile)
+    : profile_(profile), weak_ptr_factory_(this) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  for (const char* root_id : kMediaDocumentsProviderRootIds)
+    roots_.emplace_back(std::make_unique<MediaRoot>(root_id, profile_));
+}
+
+RecentArcMediaSource::~RecentArcMediaSource() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+}
+
+void RecentArcMediaSource::GetRecentFiles(Params params) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(!params_.has_value());
+  DCHECK(build_start_time_.is_null());
+  DCHECK_EQ(0, num_inflight_roots_);
+  DCHECK(files_.empty());
+
+  // If ARC file system operations will be deferred, return immediately without
+  // recording UMA metrics.
+  //
+  // TODO(nya): Return files progressively rather than simply giving up.
+  // Also, it is wrong to assume all following operations will not be deferred
+  // just because this function returned true. However, in practice, it is rare
+  // ArcFileSystemOperationRunner's deferring state switches from disabled to
+  // enabled (one such case is when ARC container crashes).
+  if (!WillArcFileSystemOperationsRunImmediately()) {
+    std::move(params.callback()).Run({});
+    return;
+  }
+
+  params_.emplace(std::move(params));
+
+  build_start_time_ = base::TimeTicks::Now();
+
+  num_inflight_roots_ = roots_.size();
+  if (num_inflight_roots_ == 0) {
+    OnComplete();
+    return;
+  }
+
+  for (auto& root : roots_) {
+    root->GetRecentFiles(
+        Params(params_.value().file_system_context(), params_.value().origin(),
+               params_.value().max_files(), params_.value().cutoff_time(),
+               base::BindOnce(&RecentArcMediaSource::OnGetRecentFilesForRoot,
+                              weak_ptr_factory_.GetWeakPtr())));
+  }
+}
+
+void RecentArcMediaSource::OnGetRecentFilesForRoot(
+    std::vector<RecentFile> files) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(params_.has_value());
+
+  files_.insert(files_.end(), std::make_move_iterator(files.begin()),
+                std::make_move_iterator(files.end()));
+
+  --num_inflight_roots_;
+  if (num_inflight_roots_ == 0)
+    OnComplete();
+}
+
+void RecentArcMediaSource::OnComplete() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(params_.has_value());
+  DCHECK(!build_start_time_.is_null());
+  DCHECK_EQ(0, num_inflight_roots_);
+
+  UMA_HISTOGRAM_TIMES(kLoadHistogramName,
+                      base::TimeTicks::Now() - build_start_time_);
+  build_start_time_ = base::TimeTicks();
+
+  Params params = std::move(params_.value());
+  params_.reset();
+  std::vector<RecentFile> files = std::move(files_);
+  files_.clear();
+  std::move(params.callback()).Run(std::move(files));
+}
+
+bool RecentArcMediaSource::WillArcFileSystemOperationsRunImmediately() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  auto* runner =
+      arc::ArcFileSystemOperationRunner::GetForBrowserContext(profile_);
+
+  // If ARC is not allowed the user, |runner| is nullptr.
+  if (!runner)
+    return false;
+
+  return !runner->WillDefer();
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/recent_arc_media_source.h b/chrome/browser/fileapi/recent_arc_media_source.h
new file mode 100644
index 0000000000000..8b09efc099a49
--- /dev/null
+++ b/chrome/browser/fileapi/recent_arc_media_source.h
@@ -0,0 +1,67 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILEAPI_RECENT_ARC_MEDIA_SOURCE_H_
+#define CHROME_BROWSER_FILEAPI_RECENT_ARC_MEDIA_SOURCE_H_
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/gtest_prod_util.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/optional.h"
+#include "base/time/time.h"
+#include "chrome/browser/fileapi/recent_source.h"
+
+class Profile;
+
+namespace chromeos {
+
+class RecentFile;
+
+// RecentSource implementation for ARC media view.
+//
+// All member functions must be called on the UI thread.
+class RecentArcMediaSource : public RecentSource {
+ public:
+  explicit RecentArcMediaSource(Profile* profile);
+  ~RecentArcMediaSource() override;
+
+  // RecentSource overrides:
+  void GetRecentFiles(Params params) override;
+
+ private:
+  FRIEND_TEST_ALL_PREFIXES(RecentArcMediaSourceTest, UmaStats);
+  FRIEND_TEST_ALL_PREFIXES(RecentArcMediaSourceTest, UmaStats_Deferred);
+
+  class MediaRoot;
+
+  static const char kLoadHistogramName[];
+
+  void OnGetRecentFilesForRoot(std::vector<RecentFile> files);
+  void OnComplete();
+
+  bool WillArcFileSystemOperationsRunImmediately();
+
+  Profile* const profile_;
+  std::vector<std::unique_ptr<MediaRoot>> roots_;
+
+  base::Optional<Params> params_;
+
+  // Time when the build started.
+  base::TimeTicks build_start_time_;
+
+  int num_inflight_roots_ = 0;
+  std::vector<RecentFile> files_;
+
+  base::WeakPtrFactory<RecentArcMediaSource> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(RecentArcMediaSource);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROME_BROWSER_FILEAPI_RECENT_ARC_MEDIA_SOURCE_H_
diff --git a/chrome/browser/fileapi/recent_arc_media_source_unittest.cc b/chrome/browser/fileapi/recent_arc_media_source_unittest.cc
new file mode 100644
index 0000000000000..dedaf6fdfe730
--- /dev/null
+++ b/chrome/browser/fileapi/recent_arc_media_source_unittest.cc
@@ -0,0 +1,208 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <utility>
+
+#include "base/run_loop.h"
+#include "base/test/metrics/histogram_tester.h"
+#include "base/time/time.h"
+#include "chrome/browser/chromeos/arc/arc_util.h"
+#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_util.h"
+#include "chrome/browser/chromeos/arc/fileapi/arc_file_system_mounter.h"
+#include "chrome/browser/chromeos/arc/fileapi/arc_file_system_operation_runner.h"
+#include "chrome/browser/fileapi/recent_arc_media_source.h"
+#include "chrome/browser/fileapi/recent_file.h"
+#include "chrome/browser/fileapi/recent_source.h"
+#include "chrome/test/base/testing_profile.h"
+#include "components/arc/arc_bridge_service.h"
+#include "components/arc/arc_service_manager.h"
+#include "components/arc/common/file_system.mojom.h"
+#include "components/arc/test/connection_holder_util.h"
+#include "components/arc/test/fake_file_system_instance.h"
+#include "components/keyed_service/content/browser_context_keyed_service_factory.h"
+#include "content/public/test/test_browser_thread_bundle.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace chromeos {
+namespace {
+
+const char kMediaDocumentsProviderAuthority[] =
+    "com.android.providers.media.documents";
+const char kImagesRootId[] = "images_root";
+
+std::unique_ptr<KeyedService> CreateFileSystemOperationRunnerForTesting(
+    content::BrowserContext* context) {
+  return arc::ArcFileSystemOperationRunner::CreateForTesting(
+      context, arc::ArcServiceManager::Get()->arc_bridge_service());
+}
+
+arc::FakeFileSystemInstance::Document MakeDocument(
+    const std::string& document_id,
+    const std::string& parent_document_id,
+    const std::string& display_name,
+    const std::string& mime_type,
+    const base::Time& last_modified) {
+  return arc::FakeFileSystemInstance::Document(
+      kMediaDocumentsProviderAuthority,  // authority
+      document_id,                       // document_id
+      parent_document_id,                // parent_document_id
+      display_name,                      // display_name
+      mime_type,                         // mime_type
+      0,                                 // size
+      last_modified.ToJavaTime());       // last_modified
+}
+
+}  // namespace
+
+class RecentArcMediaSourceTest : public testing::Test {
+ public:
+  RecentArcMediaSourceTest() = default;
+
+  void SetUp() override {
+    arc_service_manager_ = std::make_unique<arc::ArcServiceManager>();
+    profile_ = std::make_unique<TestingProfile>();
+    arc_service_manager_->set_browser_context(profile_.get());
+    runner_ = static_cast<arc::ArcFileSystemOperationRunner*>(
+        arc::ArcFileSystemOperationRunner::GetFactory()
+            ->SetTestingFactoryAndUse(
+                profile_.get(), &CreateFileSystemOperationRunnerForTesting));
+
+    // Mount ARC file systems.
+    arc::ArcFileSystemMounter::GetForBrowserContext(profile_.get());
+
+    // Add documents to FakeFileSystemInstance. Note that they are not available
+    // until EnableFakeFileSystemInstance() is called.
+    AddDocumentsToFakeFileSystemInstance();
+
+    source_ = std::make_unique<RecentArcMediaSource>(profile_.get());
+  }
+
+  void TearDown() override {
+    arc_service_manager_->arc_bridge_service()->file_system()->CloseInstance(
+        &fake_file_system_);
+  }
+
+ protected:
+  void AddDocumentsToFakeFileSystemInstance() {
+    auto root_doc =
+        MakeDocument(kImagesRootId, "", "", arc::kAndroidDirectoryMimeType,
+                     base::Time::FromJavaTime(1));
+    auto cat_doc = MakeDocument("cat", kImagesRootId, "cat.png", "image/png",
+                                base::Time::FromJavaTime(2));
+    auto dog_doc = MakeDocument("dog", kImagesRootId, "dog.jpg", "image/jpeg",
+                                base::Time::FromJavaTime(3));
+    auto fox_doc = MakeDocument("fox", kImagesRootId, "fox.gif", "image/gif",
+                                base::Time::FromJavaTime(4));
+    auto elk_doc = MakeDocument("elk", kImagesRootId, "elk.tiff", "image/tiff",
+                                base::Time::FromJavaTime(5));
+    fake_file_system_.AddDocument(root_doc);
+    fake_file_system_.AddDocument(cat_doc);
+    fake_file_system_.AddDocument(dog_doc);
+    fake_file_system_.AddDocument(fox_doc);
+    fake_file_system_.AddRecentDocument(kImagesRootId, root_doc);
+    fake_file_system_.AddRecentDocument(kImagesRootId, cat_doc);
+    fake_file_system_.AddRecentDocument(kImagesRootId, dog_doc);
+    fake_file_system_.AddRecentDocument(kImagesRootId, elk_doc);
+  }
+
+  void EnableFakeFileSystemInstance() {
+    arc_service_manager_->arc_bridge_service()->file_system()->SetInstance(
+        &fake_file_system_);
+    arc::WaitForInstanceReady(
+        arc_service_manager_->arc_bridge_service()->file_system());
+  }
+
+  std::vector<RecentFile> GetRecentFiles() {
+    std::vector<RecentFile> files;
+
+    base::RunLoop run_loop;
+
+    source_->GetRecentFiles(RecentSource::Params(
+        nullptr /* file_system_context */, GURL() /* origin */,
+        1 /* max_files: ignored */, base::Time() /* cutoff_time: ignored */,
+        base::BindOnce(
+            [](base::RunLoop* run_loop, std::vector<RecentFile>* out_files,
+               std::vector<RecentFile> files) {
+              run_loop->Quit();
+              *out_files = std::move(files);
+            },
+            &run_loop, &files)));
+
+    run_loop.Run();
+
+    return files;
+  }
+
+  void EnableDefer() { runner_->SetShouldDefer(true); }
+
+  content::TestBrowserThreadBundle thread_bundle_;
+  arc::FakeFileSystemInstance fake_file_system_;
+
+  // Use the same initialization/destruction order as
+  // ChromeBrowserMainPartsChromeos.
+  std::unique_ptr<arc::ArcServiceManager> arc_service_manager_;
+  std::unique_ptr<TestingProfile> profile_;
+
+  arc::ArcFileSystemOperationRunner* runner_;
+
+  std::unique_ptr<RecentArcMediaSource> source_;
+};
+
+TEST_F(RecentArcMediaSourceTest, Normal) {
+  EnableFakeFileSystemInstance();
+
+  std::vector<RecentFile> files = GetRecentFiles();
+
+  ASSERT_EQ(2u, files.size());
+  EXPECT_EQ(arc::GetDocumentsProviderMountPath(kMediaDocumentsProviderAuthority,
+                                               kImagesRootId)
+                .Append("cat.png"),
+            files[0].url().path());
+  EXPECT_EQ(base::Time::FromJavaTime(2), files[0].last_modified());
+  EXPECT_EQ(arc::GetDocumentsProviderMountPath(kMediaDocumentsProviderAuthority,
+                                               kImagesRootId)
+                .Append("dog.jpg"),
+            files[1].url().path());
+  EXPECT_EQ(base::Time::FromJavaTime(3), files[1].last_modified());
+}
+
+TEST_F(RecentArcMediaSourceTest, ArcNotAvailable) {
+  std::vector<RecentFile> files = GetRecentFiles();
+
+  EXPECT_EQ(0u, files.size());
+}
+
+TEST_F(RecentArcMediaSourceTest, Deferred) {
+  EnableFakeFileSystemInstance();
+  EnableDefer();
+
+  std::vector<RecentFile> files = GetRecentFiles();
+
+  EXPECT_EQ(0u, files.size());
+}
+
+TEST_F(RecentArcMediaSourceTest, UmaStats) {
+  EnableFakeFileSystemInstance();
+
+  base::HistogramTester histogram_tester;
+
+  GetRecentFiles();
+
+  histogram_tester.ExpectTotalCount(RecentArcMediaSource::kLoadHistogramName,
+                                    1);
+}
+
+TEST_F(RecentArcMediaSourceTest, UmaStats_Deferred) {
+  EnableFakeFileSystemInstance();
+  EnableDefer();
+
+  base::HistogramTester histogram_tester;
+
+  GetRecentFiles();
+
+  histogram_tester.ExpectTotalCount(RecentArcMediaSource::kLoadHistogramName,
+                                    0);
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/recent_download_source.cc b/chrome/browser/fileapi/recent_download_source.cc
new file mode 100644
index 0000000000000..e110698dea005
--- /dev/null
+++ b/chrome/browser/fileapi/recent_download_source.cc
@@ -0,0 +1,210 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/recent_download_source.h"
+
+#include <utility>
+
+#include "base/files/file_path.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/time/time.h"
+#include "chrome/browser/file_manager/path_util.h"
+#include "content/public/browser/browser_thread.h"
+#include "storage/browser/fileapi/external_mount_points.h"
+#include "storage/browser/fileapi/file_system_context.h"
+#include "storage/browser/fileapi/file_system_operation.h"
+#include "storage/browser/fileapi/file_system_operation_runner.h"
+#include "storage/browser/fileapi/file_system_url.h"
+
+using content::BrowserThread;
+
+namespace chromeos {
+
+namespace {
+
+void OnReadDirectoryOnIOThread(
+    const storage::FileSystemOperation::ReadDirectoryCallback& callback,
+    base::File::Error result,
+    storage::FileSystemOperation::FileEntryList entries,
+    bool has_more) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  BrowserThread::PostTask(
+      BrowserThread::UI, FROM_HERE,
+      base::BindOnce(callback, result, std::move(entries), has_more));
+}
+
+void ReadDirectoryOnIOThread(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const storage::FileSystemURL& url,
+    const storage::FileSystemOperation::ReadDirectoryCallback& callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  file_system_context->operation_runner()->ReadDirectory(
+      url, base::BindRepeating(&OnReadDirectoryOnIOThread, callback));
+}
+
+void OnGetMetadataOnIOThread(
+    const storage::FileSystemOperation::GetMetadataCallback& callback,
+    base::File::Error result,
+    const base::File::Info& info) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
+                          base::BindOnce(callback, result, info));
+}
+
+void GetMetadataOnIOThread(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const storage::FileSystemURL& url,
+    int fields,
+    const storage::FileSystemOperation::GetMetadataCallback& callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  file_system_context->operation_runner()->GetMetadata(
+      url, fields, base::Bind(&OnGetMetadataOnIOThread, callback));
+}
+
+}  // namespace
+
+const char RecentDownloadSource::kLoadHistogramName[] =
+    "FileBrowser.Recent.LoadDownloads";
+
+RecentDownloadSource::RecentDownloadSource(Profile* profile)
+    : mount_point_name_(
+          file_manager::util::GetDownloadsMountPointName(profile)),
+      weak_ptr_factory_(this) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+}
+
+RecentDownloadSource::~RecentDownloadSource() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+}
+
+void RecentDownloadSource::GetRecentFiles(Params params) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(!params_.has_value());
+  DCHECK(build_start_time_.is_null());
+  DCHECK_EQ(0, inflight_readdirs_);
+  DCHECK_EQ(0, inflight_stats_);
+  DCHECK(recent_files_.empty());
+
+  params_.emplace(std::move(params));
+
+  DCHECK(params_.has_value());
+
+  build_start_time_ = base::TimeTicks::Now();
+
+  ScanDirectory(base::FilePath());
+}
+
+void RecentDownloadSource::ScanDirectory(const base::FilePath& path) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(params_.has_value());
+
+  storage::FileSystemURL url = BuildDownloadsURL(path);
+
+  ++inflight_readdirs_;
+  BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::BindOnce(
+          &ReadDirectoryOnIOThread,
+          base::WrapRefCounted(params_.value().file_system_context()), url,
+          base::Bind(&RecentDownloadSource::OnReadDirectory,
+                     weak_ptr_factory_.GetWeakPtr(), path)));
+}
+
+void RecentDownloadSource::OnReadDirectory(
+    const base::FilePath& path,
+    base::File::Error result,
+    storage::FileSystemOperation::FileEntryList entries,
+    bool has_more) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(params_.has_value());
+
+  for (const auto& entry : entries) {
+    base::FilePath subpath = path.Append(entry.name);
+    if (entry.type == filesystem::mojom::FsFileType::DIRECTORY) {
+      ScanDirectory(subpath);
+    } else {
+      storage::FileSystemURL url = BuildDownloadsURL(subpath);
+      ++inflight_stats_;
+      BrowserThread::PostTask(
+          BrowserThread::IO, FROM_HERE,
+          base::BindOnce(
+              &GetMetadataOnIOThread,
+              base::WrapRefCounted(params_.value().file_system_context()), url,
+              storage::FileSystemOperation::GET_METADATA_FIELD_LAST_MODIFIED,
+              base::Bind(&RecentDownloadSource::OnGetMetadata,
+                         weak_ptr_factory_.GetWeakPtr(), url)));
+    }
+  }
+
+  if (has_more)
+    return;
+
+  --inflight_readdirs_;
+  OnReadOrStatFinished();
+}
+
+void RecentDownloadSource::OnGetMetadata(const storage::FileSystemURL& url,
+                                         base::File::Error result,
+                                         const base::File::Info& info) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(params_.has_value());
+
+  if (result == base::File::FILE_OK &&
+      info.last_modified >= params_.value().cutoff_time()) {
+    recent_files_.emplace(RecentFile(url, info.last_modified));
+    while (recent_files_.size() > params_.value().max_files())
+      recent_files_.pop();
+  }
+
+  --inflight_stats_;
+  OnReadOrStatFinished();
+}
+
+void RecentDownloadSource::OnReadOrStatFinished() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (inflight_readdirs_ > 0 || inflight_stats_ > 0)
+    return;
+
+  // All reads/scans completed.
+  std::vector<RecentFile> files;
+  while (!recent_files_.empty()) {
+    files.emplace_back(recent_files_.top());
+    recent_files_.pop();
+  }
+
+  DCHECK(!build_start_time_.is_null());
+  UMA_HISTOGRAM_TIMES(kLoadHistogramName,
+                      base::TimeTicks::Now() - build_start_time_);
+  build_start_time_ = base::TimeTicks();
+
+  Params params = std::move(params_.value());
+  params_.reset();
+
+  DCHECK(!params_.has_value());
+  DCHECK(build_start_time_.is_null());
+  DCHECK_EQ(0, inflight_readdirs_);
+  DCHECK_EQ(0, inflight_stats_);
+  DCHECK(recent_files_.empty());
+
+  std::move(params.callback()).Run(std::move(files));
+}
+
+storage::FileSystemURL RecentDownloadSource::BuildDownloadsURL(
+    const base::FilePath& path) const {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(params_.has_value());
+
+  storage::ExternalMountPoints* mount_points =
+      storage::ExternalMountPoints::GetSystemInstance();
+
+  return mount_points->CreateExternalFileSystemURL(params_.value().origin(),
+                                                   mount_point_name_, path);
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/recent_download_source.h b/chrome/browser/fileapi/recent_download_source.h
new file mode 100644
index 0000000000000..99494684c6d50
--- /dev/null
+++ b/chrome/browser/fileapi/recent_download_source.h
@@ -0,0 +1,79 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILEAPI_RECENT_DOWNLOAD_SOURCE_H_
+#define CHROME_BROWSER_FILEAPI_RECENT_DOWNLOAD_SOURCE_H_
+
+#include <memory>
+#include <queue>
+#include <string>
+#include <vector>
+
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "base/gtest_prod_util.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/optional.h"
+#include "base/time/time.h"
+#include "chrome/browser/fileapi/recent_file.h"
+#include "chrome/browser/fileapi/recent_model.h"
+#include "chrome/browser/fileapi/recent_source.h"
+#include "storage/browser/fileapi/file_system_operation.h"
+
+class Profile;
+
+namespace chromeos {
+
+// RecentSource implementation for Downloads files.
+//
+// All member functions must be called on the UI thread.
+class RecentDownloadSource : public RecentSource {
+ public:
+  explicit RecentDownloadSource(Profile* profile);
+  ~RecentDownloadSource() override;
+
+  // RecentSource overrides:
+  void GetRecentFiles(Params params) override;
+
+ private:
+  FRIEND_TEST_ALL_PREFIXES(RecentDownloadSourceTest, GetRecentFiles_UmaStats);
+
+  static const char kLoadHistogramName[];
+
+  void ScanDirectory(const base::FilePath& path);
+  void OnReadDirectory(const base::FilePath& path,
+                       base::File::Error result,
+                       storage::FileSystemOperation::FileEntryList entries,
+                       bool has_more);
+  void OnGetMetadata(const storage::FileSystemURL& url,
+                     base::File::Error result,
+                     const base::File::Info& info);
+  void OnReadOrStatFinished();
+
+  storage::FileSystemURL BuildDownloadsURL(const base::FilePath& path) const;
+
+  const std::string mount_point_name_;
+
+  // Parameters given to GetRecentFiles().
+  base::Optional<Params> params_;
+
+  // Time when the build started.
+  base::TimeTicks build_start_time_;
+  // Number of ReadDirectory() calls in flight.
+  int inflight_readdirs_ = 0;
+  // Number of GetMetadata() calls in flight.
+  int inflight_stats_ = 0;
+  // Most recently modified files.
+  std::priority_queue<RecentFile, std::vector<RecentFile>, RecentFileComparator>
+      recent_files_;
+
+  base::WeakPtrFactory<RecentDownloadSource> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(RecentDownloadSource);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROME_BROWSER_FILEAPI_RECENT_DOWNLOAD_SOURCE_H_
diff --git a/chrome/browser/fileapi/recent_download_source_unittest.cc b/chrome/browser/fileapi/recent_download_source_unittest.cc
new file mode 100644
index 0000000000000..9600a1932c453
--- /dev/null
+++ b/chrome/browser/fileapi/recent_download_source_unittest.cc
@@ -0,0 +1,152 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <algorithm>
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/files/file.h"
+#include "base/files/scoped_temp_dir.h"
+#include "base/run_loop.h"
+#include "base/test/metrics/histogram_tester.h"
+#include "base/time/time.h"
+#include "chrome/browser/file_manager/path_util.h"
+#include "chrome/browser/fileapi/recent_download_source.h"
+#include "chrome/browser/fileapi/recent_file.h"
+#include "chrome/browser/fileapi/recent_source.h"
+#include "chrome/test/base/testing_profile.h"
+#include "content/public/test/test_browser_thread_bundle.h"
+#include "storage/browser/fileapi/external_mount_points.h"
+#include "storage/browser/fileapi/file_system_context.h"
+#include "storage/browser/fileapi/file_system_url.h"
+#include "storage/browser/test/test_file_system_context.h"
+#include "storage/common/fileapi/file_system_mount_option.h"
+#include "storage/common/fileapi/file_system_types.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "url/gurl.h"
+
+namespace chromeos {
+
+class RecentDownloadSourceTest : public testing::Test {
+ public:
+  RecentDownloadSourceTest() : origin_("https://example.com/") {}
+
+  void SetUp() override {
+    profile_ = std::make_unique<TestingProfile>();
+
+    ASSERT_TRUE(temp_dir_.CreateUniqueTempDir());
+
+    file_system_context_ = content::CreateFileSystemContextForTesting(
+        nullptr, temp_dir_.GetPath());
+
+    RegisterFakeDownloadsFileSystem();
+
+    source_ = std::make_unique<RecentDownloadSource>(profile_.get());
+  }
+
+ protected:
+  void RegisterFakeDownloadsFileSystem() const {
+    storage::ExternalMountPoints* mount_points =
+        storage::ExternalMountPoints::GetSystemInstance();
+    std::string mount_point_name =
+        file_manager::util::GetDownloadsMountPointName(profile_.get());
+
+    mount_points->RevokeFileSystem(mount_point_name);
+    ASSERT_TRUE(mount_points->RegisterFileSystem(
+        mount_point_name, storage::kFileSystemTypeTest,
+        storage::FileSystemMountOption(), base::FilePath()));
+  }
+
+  bool CreateEmptyFile(const std::string& filename, const base::Time& time) {
+    base::File file(temp_dir_.GetPath().Append(filename),
+                    base::File::FLAG_CREATE | base::File::FLAG_WRITE);
+    if (!file.IsValid())
+      return false;
+
+    return file.SetTimes(time, time);
+  }
+
+  std::vector<RecentFile> GetRecentFiles(size_t max_files,
+                                         const base::Time& cutoff_time) {
+    std::vector<RecentFile> files;
+
+    base::RunLoop run_loop;
+
+    source_->GetRecentFiles(RecentSource::Params(
+        file_system_context_.get(), origin_, max_files, cutoff_time,
+        base::BindOnce(
+            [](base::RunLoop* run_loop, std::vector<RecentFile>* out_files,
+               std::vector<RecentFile> files) {
+              run_loop->Quit();
+              *out_files = std::move(files);
+            },
+            &run_loop, &files)));
+
+    run_loop.Run();
+
+    return files;
+  }
+
+  content::TestBrowserThreadBundle thread_bundle_;
+  const GURL origin_;
+  std::unique_ptr<TestingProfile> profile_;
+  base::ScopedTempDir temp_dir_;
+  scoped_refptr<storage::FileSystemContext> file_system_context_;
+  std::unique_ptr<RecentDownloadSource> source_;
+  base::Time base_time_;
+};
+
+TEST_F(RecentDownloadSourceTest, GetRecentFiles) {
+  // Oldest
+  ASSERT_TRUE(CreateEmptyFile("1.jpg", base::Time::FromJavaTime(1000)));
+  ASSERT_TRUE(CreateEmptyFile("2.jpg", base::Time::FromJavaTime(2000)));
+  ASSERT_TRUE(CreateEmptyFile("3.jpg", base::Time::FromJavaTime(3000)));
+  ASSERT_TRUE(CreateEmptyFile("4.jpg", base::Time::FromJavaTime(4000)));
+  // Newest
+
+  std::vector<RecentFile> files = GetRecentFiles(3, base::Time());
+
+  std::sort(files.begin(), files.end(), RecentFileComparator());
+
+  ASSERT_EQ(3u, files.size());
+  EXPECT_EQ("4.jpg", files[0].url().path().BaseName().value());
+  EXPECT_EQ(base::Time::FromJavaTime(4000), files[0].last_modified());
+  EXPECT_EQ("3.jpg", files[1].url().path().BaseName().value());
+  EXPECT_EQ(base::Time::FromJavaTime(3000), files[1].last_modified());
+  EXPECT_EQ("2.jpg", files[2].url().path().BaseName().value());
+  EXPECT_EQ(base::Time::FromJavaTime(2000), files[2].last_modified());
+}
+
+TEST_F(RecentDownloadSourceTest, GetRecentFiles_CutoffTime) {
+  // Oldest
+  ASSERT_TRUE(CreateEmptyFile("1.jpg", base::Time::FromJavaTime(1000)));
+  ASSERT_TRUE(CreateEmptyFile("2.jpg", base::Time::FromJavaTime(2000)));
+  ASSERT_TRUE(CreateEmptyFile("3.jpg", base::Time::FromJavaTime(3000)));
+  ASSERT_TRUE(CreateEmptyFile("4.jpg", base::Time::FromJavaTime(4000)));
+  // Newest
+
+  std::vector<RecentFile> files =
+      GetRecentFiles(3, base::Time::FromJavaTime(2500));
+
+  std::sort(files.begin(), files.end(), RecentFileComparator());
+
+  ASSERT_EQ(2u, files.size());
+  EXPECT_EQ("4.jpg", files[0].url().path().BaseName().value());
+  EXPECT_EQ(base::Time::FromJavaTime(4000), files[0].last_modified());
+  EXPECT_EQ("3.jpg", files[1].url().path().BaseName().value());
+  EXPECT_EQ(base::Time::FromJavaTime(3000), files[1].last_modified());
+}
+
+TEST_F(RecentDownloadSourceTest, GetRecentFiles_UmaStats) {
+  base::HistogramTester histogram_tester;
+
+  GetRecentFiles(3, base::Time());
+
+  histogram_tester.ExpectTotalCount(RecentDownloadSource::kLoadHistogramName,
+                                    1);
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/recent_drive_source.cc b/chrome/browser/fileapi/recent_drive_source.cc
new file mode 100644
index 0000000000000..6703eb90feaa6
--- /dev/null
+++ b/chrome/browser/fileapi/recent_drive_source.cc
@@ -0,0 +1,168 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/recent_drive_source.h"
+
+#include <utility>
+#include <vector>
+
+#include "base/files/file_path.h"
+#include "base/metrics/histogram_macros.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/fileapi/recent_file.h"
+#include "content/public/browser/browser_thread.h"
+#include "storage/browser/fileapi/file_system_operation.h"
+#include "storage/browser/fileapi/file_system_operation_runner.h"
+#include "storage/browser/fileapi/file_system_url.h"
+#include "storage/common/fileapi/file_system_types.h"
+
+using content::BrowserThread;
+
+namespace chromeos {
+
+namespace {
+
+void OnGetMetadataOnIOThread(
+    const storage::FileSystemOperation::GetMetadataCallback& callback,
+    base::File::Error result,
+    const base::File::Info& info) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
+                          base::BindOnce(callback, result, info));
+}
+
+void GetMetadataOnIOThread(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const storage::FileSystemURL& url,
+    int fields,
+    const storage::FileSystemOperation::GetMetadataCallback& callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  file_system_context->operation_runner()->GetMetadata(
+      url, fields, base::Bind(&OnGetMetadataOnIOThread, callback));
+}
+
+}  // namespace
+
+const char RecentDriveSource::kLoadHistogramName[] =
+    "FileBrowser.Recent.LoadDrive";
+
+RecentDriveSource::RecentDriveSource(Profile* profile)
+    : profile_(profile), weak_ptr_factory_(this) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+}
+
+RecentDriveSource::~RecentDriveSource() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+}
+
+void RecentDriveSource::GetRecentFiles(Params params) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(!params_.has_value());
+  DCHECK(files_.empty());
+  DCHECK_EQ(0, num_inflight_stats_);
+  DCHECK(build_start_time_.is_null());
+
+  params_.emplace(std::move(params));
+
+  build_start_time_ = base::TimeTicks::Now();
+
+  drive::FileSystemInterface* file_system =
+      drive::util::GetFileSystemByProfile(profile_);
+  if (!file_system) {
+    // |file_system| is nullptr if Drive is disabled.
+    OnSearchMetadata(drive::FILE_ERROR_FAILED, nullptr);
+    return;
+  }
+
+  file_system->SearchMetadata(
+      "" /* query */, drive::SEARCH_METADATA_EXCLUDE_DIRECTORIES,
+      params_.value().max_files(), drive::MetadataSearchOrder::LAST_MODIFIED,
+      base::Bind(&RecentDriveSource::OnSearchMetadata,
+                 weak_ptr_factory_.GetWeakPtr()));
+}
+
+void RecentDriveSource::OnSearchMetadata(
+    drive::FileError error,
+    std::unique_ptr<drive::MetadataSearchResultVector> results) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(params_.has_value());
+  DCHECK(files_.empty());
+  DCHECK_EQ(0, num_inflight_stats_);
+  DCHECK(!build_start_time_.is_null());
+
+  if (error != drive::FILE_ERROR_OK) {
+    OnComplete();
+    return;
+  }
+
+  DCHECK(results.get());
+
+  std::string extension_id = params_.value().origin().host();
+
+  for (const auto& result : *results) {
+    if (result.is_directory)
+      continue;
+
+    base::FilePath virtual_path =
+        file_manager::util::ConvertDrivePathToRelativeFileSystemPath(
+            profile_, extension_id, result.path);
+    storage::FileSystemURL url =
+        params_.value().file_system_context()->CreateCrackedFileSystemURL(
+            params_.value().origin(), storage::kFileSystemTypeExternal,
+            virtual_path);
+    ++num_inflight_stats_;
+    BrowserThread::PostTask(
+        BrowserThread::IO, FROM_HERE,
+        base::BindOnce(
+            &GetMetadataOnIOThread,
+            base::WrapRefCounted(params_.value().file_system_context()), url,
+            storage::FileSystemOperation::GET_METADATA_FIELD_LAST_MODIFIED,
+            base::Bind(&RecentDriveSource::OnGetMetadata,
+                       weak_ptr_factory_.GetWeakPtr(), url)));
+  }
+
+  if (num_inflight_stats_ == 0)
+    OnComplete();
+}
+
+void RecentDriveSource::OnGetMetadata(const storage::FileSystemURL& url,
+                                      base::File::Error result,
+                                      const base::File::Info& info) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (result == base::File::FILE_OK)
+    files_.emplace_back(url, info.last_modified);
+
+  --num_inflight_stats_;
+  if (num_inflight_stats_ == 0)
+    OnComplete();
+}
+
+void RecentDriveSource::OnComplete() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(params_.has_value());
+  DCHECK_EQ(0, num_inflight_stats_);
+  DCHECK(!build_start_time_.is_null());
+
+  UMA_HISTOGRAM_TIMES(kLoadHistogramName,
+                      base::TimeTicks::Now() - build_start_time_);
+  build_start_time_ = base::TimeTicks();
+
+  Params params = std::move(params_.value());
+  params_.reset();
+  std::vector<RecentFile> files = std::move(files_);
+  files_.clear();
+
+  DCHECK(!params_.has_value());
+  DCHECK(files_.empty());
+  DCHECK_EQ(0, num_inflight_stats_);
+  DCHECK(build_start_time_.is_null());
+
+  std::move(params.callback()).Run(std::move(files));
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/recent_drive_source.h b/chrome/browser/fileapi/recent_drive_source.h
new file mode 100644
index 0000000000000..f2ba6ba181d4f
--- /dev/null
+++ b/chrome/browser/fileapi/recent_drive_source.h
@@ -0,0 +1,74 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILEAPI_RECENT_DRIVE_SOURCE_H_
+#define CHROME_BROWSER_FILEAPI_RECENT_DRIVE_SOURCE_H_
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/files/file.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/optional.h"
+#include "base/time/time.h"
+#include "chrome/browser/fileapi/recent_source.h"
+#include "components/drive/chromeos/file_system_interface.h"
+#include "components/drive/file_errors.h"
+
+class Profile;
+
+namespace storage {
+
+class FileSystemURL;
+
+}  // namespace storage
+
+namespace chromeos {
+
+class RecentFile;
+
+// RecentSource implementation for Drive files.
+//
+// All member functions must be called on the UI thread.
+//
+// TODO(nya): Write unit tests.
+class RecentDriveSource : public RecentSource {
+ public:
+  explicit RecentDriveSource(Profile* profile);
+  ~RecentDriveSource() override;
+
+  // RecentSource overrides:
+  void GetRecentFiles(Params params) override;
+
+ private:
+  static const char kLoadHistogramName[];
+
+  void OnSearchMetadata(
+      drive::FileError error,
+      std::unique_ptr<drive::MetadataSearchResultVector> results);
+  void OnGetMetadata(const storage::FileSystemURL& url,
+                     base::File::Error result,
+                     const base::File::Info& info);
+  void OnComplete();
+
+  Profile* const profile_;
+
+  // Set at the beginning of GetRecentFiles().
+  base::Optional<Params> params_;
+
+  base::TimeTicks build_start_time_;
+
+  int num_inflight_stats_ = 0;
+  std::vector<RecentFile> files_;
+
+  base::WeakPtrFactory<RecentDriveSource> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(RecentDriveSource);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROME_BROWSER_FILEAPI_RECENT_DRIVE_SOURCE_H_
diff --git a/chrome/browser/fileapi/recent_file.cc b/chrome/browser/fileapi/recent_file.cc
new file mode 100644
index 0000000000000..07fa2f2957c51
--- /dev/null
+++ b/chrome/browser/fileapi/recent_file.cc
@@ -0,0 +1,28 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/recent_file.h"
+
+namespace chromeos {
+
+RecentFile::RecentFile() = default;
+
+RecentFile::RecentFile(const storage::FileSystemURL& url,
+                       const base::Time& last_modified)
+    : url_(url), last_modified_(last_modified) {}
+
+RecentFile::RecentFile(const RecentFile& other) = default;
+
+RecentFile::~RecentFile() = default;
+
+RecentFile& RecentFile::operator=(const RecentFile& other) = default;
+
+bool RecentFileComparator::operator()(const RecentFile& a,
+                                      const RecentFile& b) {
+  if (a.last_modified() != b.last_modified())
+    return a.last_modified() > b.last_modified();
+  return storage::FileSystemURL::Comparator()(a.url(), b.url());
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/recent_file.h b/chrome/browser/fileapi/recent_file.h
new file mode 100644
index 0000000000000..3e6b62d837e39
--- /dev/null
+++ b/chrome/browser/fileapi/recent_file.h
@@ -0,0 +1,37 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILEAPI_RECENT_FILE_H_
+#define CHROME_BROWSER_FILEAPI_RECENT_FILE_H_
+
+#include "base/time/time.h"
+#include "storage/browser/fileapi/file_system_url.h"
+
+namespace chromeos {
+
+class RecentFile {
+ public:
+  RecentFile();
+  RecentFile(const storage::FileSystemURL& url,
+             const base::Time& last_modified);
+  RecentFile(const RecentFile& other);
+  ~RecentFile();
+  RecentFile& operator=(const RecentFile& other);
+
+  const storage::FileSystemURL& url() const { return url_; }
+  const base::Time& last_modified() const { return last_modified_; }
+
+ private:
+  storage::FileSystemURL url_;
+  base::Time last_modified_;
+};
+
+// A comparator that sorts files in *descending* order of last modified time.
+struct RecentFileComparator {
+  bool operator()(const RecentFile& a, const RecentFile& b);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROME_BROWSER_FILEAPI_RECENT_FILE_H_
diff --git a/chrome/browser/fileapi/recent_model.cc b/chrome/browser/fileapi/recent_model.cc
new file mode 100644
index 0000000000000..56b761de0153e
--- /dev/null
+++ b/chrome/browser/fileapi/recent_model.cc
@@ -0,0 +1,204 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/recent_model.h"
+
+#include <algorithm>
+#include <iterator>
+#include <string>
+#include <utility>
+
+#include "base/files/file_path.h"
+#include "base/memory/ptr_util.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/strings/stringprintf.h"
+#include "base/time/time.h"
+#include "chrome/browser/fileapi/recent_arc_media_source.h"
+#include "chrome/browser/fileapi/recent_download_source.h"
+#include "chrome/browser/fileapi/recent_drive_source.h"
+#include "chrome/browser/fileapi/recent_file.h"
+#include "chrome/browser/fileapi/recent_model_factory.h"
+#include "content/public/browser/browser_thread.h"
+#include "storage/browser/fileapi/file_system_context.h"
+
+using content::BrowserThread;
+
+namespace chromeos {
+
+namespace {
+
+// Cut-off time. Files older than this are filtered out.
+constexpr base::TimeDelta kCutoffTimeDelta = base::TimeDelta::FromDays(30);
+
+// Recent file cache will be cleared this duration after it is built.
+// Note: Do not make this value large. When cache is used, cut-off criteria is
+// not strictly honored.
+constexpr base::TimeDelta kCacheExpiration = base::TimeDelta::FromSeconds(10);
+
+std::vector<std::unique_ptr<RecentSource>> CreateDefaultSources(
+    Profile* profile) {
+  std::vector<std::unique_ptr<RecentSource>> sources;
+  sources.emplace_back(std::make_unique<RecentArcMediaSource>(profile));
+  sources.emplace_back(std::make_unique<RecentDownloadSource>(profile));
+  sources.emplace_back(std::make_unique<RecentDriveSource>(profile));
+  return sources;
+}
+
+}  // namespace
+
+const char RecentModel::kLoadHistogramName[] = "FileBrowser.Recent.LoadTotal";
+
+// static
+RecentModel* RecentModel::GetForProfile(Profile* profile) {
+  return RecentModelFactory::GetForProfile(profile);
+}
+
+// static
+std::unique_ptr<RecentModel> RecentModel::CreateForTest(
+    std::vector<std::unique_ptr<RecentSource>> sources) {
+  return base::WrapUnique(new RecentModel(std::move(sources)));
+}
+
+RecentModel::RecentModel(Profile* profile)
+    : RecentModel(CreateDefaultSources(profile)) {}
+
+RecentModel::RecentModel(std::vector<std::unique_ptr<RecentSource>> sources)
+    : sources_(std::move(sources)), weak_ptr_factory_(this) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+}
+
+RecentModel::~RecentModel() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(sources_.empty());
+}
+
+void RecentModel::GetRecentFiles(
+    storage::FileSystemContext* file_system_context,
+    const GURL& origin,
+    GetRecentFilesCallback callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  // Use cache if available.
+  if (cached_files_.has_value()) {
+    std::move(callback).Run(cached_files_.value());
+    return;
+  }
+
+  bool builder_already_running = !pending_callbacks_.empty();
+  pending_callbacks_.emplace_back(std::move(callback));
+
+  // If a builder is already running, just enqueue the callback and return.
+  if (builder_already_running)
+    return;
+
+  // Start building a recent file list.
+  DCHECK_EQ(0, num_inflight_sources_);
+  DCHECK(intermediate_files_.empty());
+  DCHECK(build_start_time_.is_null());
+
+  build_start_time_ = base::TimeTicks::Now();
+
+  num_inflight_sources_ = sources_.size();
+  if (sources_.empty()) {
+    OnGetRecentFilesCompleted();
+    return;
+  }
+
+  base::Time cutoff_time = forced_cutoff_time_.has_value()
+                               ? forced_cutoff_time_.value()
+                               : base::Time::Now() - kCutoffTimeDelta;
+
+  for (const auto& source : sources_) {
+    source->GetRecentFiles(RecentSource::Params(
+        file_system_context, origin, max_files_, cutoff_time,
+        base::BindOnce(&RecentModel::OnGetRecentFiles,
+                       weak_ptr_factory_.GetWeakPtr(), max_files_,
+                       cutoff_time)));
+  }
+}
+
+void RecentModel::Shutdown() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  // Some RecentSource implementations have references to other KeyedServices,
+  // so we destruct them here.
+  sources_.clear();
+}
+
+void RecentModel::OnGetRecentFiles(size_t max_files,
+                                   const base::Time& cutoff_time,
+                                   std::vector<RecentFile> files) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  DCHECK_LT(0, num_inflight_sources_);
+
+  for (const auto& file : files) {
+    if (file.last_modified() >= cutoff_time)
+      intermediate_files_.emplace(file);
+  }
+
+  while (intermediate_files_.size() > max_files)
+    intermediate_files_.pop();
+
+  --num_inflight_sources_;
+  if (num_inflight_sources_ == 0)
+    OnGetRecentFilesCompleted();
+}
+
+void RecentModel::OnGetRecentFilesCompleted() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  DCHECK_EQ(0, num_inflight_sources_);
+  DCHECK(!cached_files_.has_value());
+  DCHECK(!build_start_time_.is_null());
+
+  std::vector<RecentFile> files;
+  while (!intermediate_files_.empty()) {
+    files.emplace_back(intermediate_files_.top());
+    intermediate_files_.pop();
+  }
+  std::reverse(files.begin(), files.end());
+  cached_files_ = std::move(files);
+
+  DCHECK(cached_files_.has_value());
+  DCHECK(intermediate_files_.empty());
+
+  UMA_HISTOGRAM_TIMES(kLoadHistogramName,
+                      base::TimeTicks::Now() - build_start_time_);
+  build_start_time_ = base::TimeTicks();
+
+  // Starts a timer to clear cache.
+  cache_clear_timer_.Start(
+      FROM_HERE, kCacheExpiration,
+      base::Bind(&RecentModel::ClearCache, weak_ptr_factory_.GetWeakPtr()));
+
+  // Invoke all pending callbacks.
+  std::vector<GetRecentFilesCallback> callbacks_to_call;
+  callbacks_to_call.swap(pending_callbacks_);
+  DCHECK(pending_callbacks_.empty());
+  DCHECK(!callbacks_to_call.empty());
+  for (auto& callback : callbacks_to_call)
+    std::move(callback).Run(cached_files_.value());
+}
+
+void RecentModel::ClearCache() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  cached_files_.reset();
+}
+
+void RecentModel::SetMaxFilesForTest(size_t max_files) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  max_files_ = max_files;
+}
+
+void RecentModel::SetForcedCutoffTimeForTest(
+    const base::Time& forced_cutoff_time) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  forced_cutoff_time_ = forced_cutoff_time;
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/recent_model.h b/chrome/browser/fileapi/recent_model.h
new file mode 100644
index 0000000000000..054a5de673441
--- /dev/null
+++ b/chrome/browser/fileapi/recent_model.h
@@ -0,0 +1,121 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILEAPI_RECENT_MODEL_H_
+#define CHROME_BROWSER_FILEAPI_RECENT_MODEL_H_
+
+#include <memory>
+#include <queue>
+#include <vector>
+
+#include "base/callback_forward.h"
+#include "base/files/file_path.h"
+#include "base/gtest_prod_util.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/optional.h"
+#include "base/time/time.h"
+#include "base/timer/timer.h"
+#include "chrome/browser/fileapi/recent_file.h"
+#include "chrome/browser/fileapi/recent_source.h"
+#include "components/keyed_service/core/keyed_service.h"
+#include "storage/browser/fileapi/file_system_url.h"
+
+class GURL;
+class Profile;
+
+namespace storage {
+
+class FileSystemContext;
+
+}  // namespace storage
+
+namespace chromeos {
+
+class RecentModelFactory;
+
+// Provides a list of recently modified files.
+//
+// All member functions must be called on the UI thread.
+class RecentModel : public KeyedService {
+ public:
+  using GetRecentFilesCallback =
+      base::OnceCallback<void(const std::vector<RecentFile>& files)>;
+
+  ~RecentModel() override;
+
+  // Returns an instance for the given profile.
+  static RecentModel* GetForProfile(Profile* profile);
+
+  // Creates an instance with given sources. Only for testing.
+  static std::unique_ptr<RecentModel> CreateForTest(
+      std::vector<std::unique_ptr<RecentSource>> sources);
+
+  // Returns a list of recent files by querying sources.
+  // Files are sorted by descending order of last modified time.
+  // Results might be internally cached for better performance.
+  void GetRecentFiles(storage::FileSystemContext* file_system_context,
+                      const GURL& origin,
+                      GetRecentFilesCallback callback);
+
+  // KeyedService overrides:
+  void Shutdown() override;
+
+ private:
+  friend class RecentModelFactory;
+  friend class RecentModelTest;
+  FRIEND_TEST_ALL_PREFIXES(RecentModelTest, GetRecentFiles_UmaStats);
+
+  static const char kLoadHistogramName[];
+
+  explicit RecentModel(Profile* profile);
+  explicit RecentModel(std::vector<std::unique_ptr<RecentSource>> sources);
+
+  void OnGetRecentFiles(size_t max_files,
+                        const base::Time& cutoff_time,
+                        std::vector<RecentFile> files);
+  void OnGetRecentFilesCompleted();
+  void ClearCache();
+
+  void SetMaxFilesForTest(size_t max_files);
+  void SetForcedCutoffTimeForTest(const base::Time& forced_cutoff_time);
+
+  std::vector<std::unique_ptr<RecentSource>> sources_;
+
+  // The maximum number of files in Recent. This value won't be changed from
+  // default except for unit tests.
+  size_t max_files_ = 1000;
+
+  // If this is set to non-null, it is used as a cut-off time. Should be used
+  // only in unit tests.
+  base::Optional<base::Time> forced_cutoff_time_;
+
+  // Cached GetRecentFiles() response.
+  base::Optional<std::vector<RecentFile>> cached_files_ = base::nullopt;
+
+  // Timer to clear the cache.
+  base::OneShotTimer cache_clear_timer_;
+
+  // Time when the build started.
+  base::TimeTicks build_start_time_;
+
+  // While a recent file list is built, this vector contains callbacks to be
+  // invoked with the new list.
+  std::vector<GetRecentFilesCallback> pending_callbacks_;
+
+  // Number of in-flight sources building recent file lists.
+  int num_inflight_sources_ = 0;
+
+  // Intermediate container of recent files while building a list.
+  std::priority_queue<RecentFile, std::vector<RecentFile>, RecentFileComparator>
+      intermediate_files_;
+
+  base::WeakPtrFactory<RecentModel> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(RecentModel);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROME_BROWSER_FILEAPI_RECENT_MODEL_H_
diff --git a/chrome/browser/fileapi/recent_model_factory.cc b/chrome/browser/fileapi/recent_model_factory.cc
new file mode 100644
index 0000000000000..5d8c9c453a928
--- /dev/null
+++ b/chrome/browser/fileapi/recent_model_factory.cc
@@ -0,0 +1,78 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/recent_model_factory.h"
+
+#include <algorithm>
+#include <iterator>
+#include <string>
+#include <utility>
+
+#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_root_map_factory.h"
+#include "chrome/browser/fileapi/recent_model.h"
+#include "chrome/browser/profiles/incognito_helpers.h"
+#include "chrome/browser/profiles/profile.h"
+#include "components/keyed_service/content/browser_context_dependency_manager.h"
+
+namespace chromeos {
+
+// static
+RecentModel* RecentModelFactory::model_for_test_ = nullptr;
+
+// static
+RecentModel* RecentModelFactory::GetForProfile(Profile* profile) {
+  return static_cast<RecentModel*>(
+      GetInstance()->GetServiceForBrowserContext(profile, true));
+}
+
+// static
+RecentModel* RecentModelFactory::SetForProfileAndUseForTest(
+    Profile* profile,
+    std::unique_ptr<RecentModel> model) {
+  DCHECK(model);
+  DCHECK(!model_for_test_);
+
+  RecentModel* saved_model = model.get();
+  model_for_test_ = model.release();
+
+  KeyedService* used_model = GetInstance()->SetTestingFactoryAndUse(
+      profile,
+      [](content::BrowserContext* context) -> std::unique_ptr<KeyedService> {
+        std::unique_ptr<KeyedService> model(model_for_test_);
+        model_for_test_ = nullptr;
+        return model;
+      });
+
+  DCHECK_EQ(used_model, saved_model);
+  DCHECK(!model_for_test_);
+
+  return saved_model;
+}
+
+RecentModelFactory::RecentModelFactory()
+    : BrowserContextKeyedServiceFactory(
+          "RecentModel",
+          BrowserContextDependencyManager::GetInstance()) {
+  DependsOn(arc::ArcDocumentsProviderRootMapFactory::GetInstance());
+}
+
+RecentModelFactory::~RecentModelFactory() = default;
+
+// static
+RecentModelFactory* RecentModelFactory::GetInstance() {
+  return base::Singleton<RecentModelFactory>::get();
+}
+
+content::BrowserContext* RecentModelFactory::GetBrowserContextToUse(
+    content::BrowserContext* context) const {
+  return chrome::GetBrowserContextRedirectedInIncognito(context);
+}
+
+KeyedService* RecentModelFactory::BuildServiceInstanceFor(
+    content::BrowserContext* context) const {
+  Profile* profile = Profile::FromBrowserContext(context);
+  return new RecentModel(profile);
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/recent_model_factory.h b/chrome/browser/fileapi/recent_model_factory.h
new file mode 100644
index 0000000000000..200f4e8fa853e
--- /dev/null
+++ b/chrome/browser/fileapi/recent_model_factory.h
@@ -0,0 +1,52 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILEAPI_RECENT_MODEL_FACTORY_H_
+#define CHROME_BROWSER_FILEAPI_RECENT_MODEL_FACTORY_H_
+
+#include <memory>
+
+#include "base/macros.h"
+#include "base/memory/singleton.h"
+#include "components/keyed_service/content/browser_context_keyed_service_factory.h"
+
+class Profile;
+
+namespace chromeos {
+
+class RecentModel;
+
+class RecentModelFactory : public BrowserContextKeyedServiceFactory {
+ public:
+  // Returns the RecentModel for |profile|, creating it if not created yet.
+  static RecentModel* GetForProfile(Profile* profile);
+
+  // Sets the RecentModel for |profile| for testing.
+  static RecentModel* SetForProfileAndUseForTest(
+      Profile* profile,
+      std::unique_ptr<RecentModel> model);
+
+  // Returns the singleton RecentModelFactory instance.
+  static RecentModelFactory* GetInstance();
+
+ private:
+  friend struct base::DefaultSingletonTraits<RecentModelFactory>;
+
+  RecentModelFactory();
+  ~RecentModelFactory() override;
+
+  // BrowserContextKeyedServiceFactory overrides.
+  content::BrowserContext* GetBrowserContextToUse(
+      content::BrowserContext* context) const override;
+  KeyedService* BuildServiceInstanceFor(
+      content::BrowserContext* context) const override;
+
+  static RecentModel* model_for_test_;
+
+  DISALLOW_COPY_AND_ASSIGN(RecentModelFactory);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROME_BROWSER_FILEAPI_RECENT_MODEL_FACTORY_H_
diff --git a/chrome/browser/fileapi/recent_model_unittest.cc b/chrome/browser/fileapi/recent_model_unittest.cc
new file mode 100644
index 0000000000000..dfd39aa8a3781
--- /dev/null
+++ b/chrome/browser/fileapi/recent_model_unittest.cc
@@ -0,0 +1,136 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <algorithm>
+#include <string>
+#include <utility>
+
+#include "base/files/file_path.h"
+#include "base/run_loop.h"
+#include "base/test/metrics/histogram_tester.h"
+#include "chrome/browser/fileapi/recent_file.h"
+#include "chrome/browser/fileapi/recent_model.h"
+#include "chrome/browser/fileapi/recent_model_factory.h"
+#include "chrome/browser/fileapi/test/fake_recent_source.h"
+#include "chrome/test/base/testing_profile.h"
+#include "content/public/test/test_browser_thread_bundle.h"
+#include "storage/browser/fileapi/file_system_url.h"
+#include "storage/common/fileapi/file_system_types.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace chromeos {
+
+namespace {
+
+RecentFile MakeRecentFile(const std::string& name,
+                          const base::Time& last_modified) {
+  storage::FileSystemURL url = storage::FileSystemURL::CreateForTest(
+      GURL(),  // origin
+      storage::kFileSystemTypeNativeLocal, base::FilePath(name));
+  return RecentFile(url, last_modified);
+}
+
+}  // namespace
+
+class RecentModelTest : public testing::Test {
+ public:
+  RecentModelTest() = default;
+
+ protected:
+  std::vector<std::unique_ptr<RecentSource>> BuildDefaultSources() {
+    auto source1 = std::make_unique<FakeRecentSource>();
+    source1->AddFile(MakeRecentFile("aaa.jpg", base::Time::FromJavaTime(1000)));
+    source1->AddFile(MakeRecentFile("ccc.jpg", base::Time::FromJavaTime(3000)));
+
+    auto source2 = std::make_unique<FakeRecentSource>();
+    source2->AddFile(MakeRecentFile("bbb.jpg", base::Time::FromJavaTime(2000)));
+    source2->AddFile(MakeRecentFile("ddd.jpg", base::Time::FromJavaTime(4000)));
+
+    std::vector<std::unique_ptr<RecentSource>> sources;
+    sources.emplace_back(std::move(source1));
+    sources.emplace_back(std::move(source2));
+    return sources;
+  }
+
+  std::vector<RecentFile> BuildModelAndGetRecentFiles(
+      std::vector<std::unique_ptr<RecentSource>> sources,
+      size_t max_files,
+      const base::Time& cutoff_time) {
+    RecentModel* model = RecentModelFactory::SetForProfileAndUseForTest(
+        &profile_, RecentModel::CreateForTest(std::move(sources)));
+
+    model->SetMaxFilesForTest(max_files);
+    model->SetForcedCutoffTimeForTest(cutoff_time);
+
+    std::vector<RecentFile> files;
+
+    base::RunLoop run_loop;
+
+    model->GetRecentFiles(
+        nullptr /* file_system_context */, GURL() /* origin */,
+        base::BindOnce(
+            [](base::RunLoop* run_loop, std::vector<RecentFile>* files_out,
+               const std::vector<RecentFile>& files) {
+              *files_out = files;
+              run_loop->Quit();
+            },
+            &run_loop, &files));
+
+    run_loop.Run();
+
+    return files;
+  }
+
+  content::TestBrowserThreadBundle thread_bundle_;
+  TestingProfile profile_;
+};
+
+TEST_F(RecentModelTest, GetRecentFiles) {
+  std::vector<RecentFile> files =
+      BuildModelAndGetRecentFiles(BuildDefaultSources(), 10, base::Time());
+
+  ASSERT_EQ(4u, files.size());
+  EXPECT_EQ("ddd.jpg", files[0].url().path().value());
+  EXPECT_EQ(base::Time::FromJavaTime(4000), files[0].last_modified());
+  EXPECT_EQ("ccc.jpg", files[1].url().path().value());
+  EXPECT_EQ(base::Time::FromJavaTime(3000), files[1].last_modified());
+  EXPECT_EQ("bbb.jpg", files[2].url().path().value());
+  EXPECT_EQ(base::Time::FromJavaTime(2000), files[2].last_modified());
+  EXPECT_EQ("aaa.jpg", files[3].url().path().value());
+  EXPECT_EQ(base::Time::FromJavaTime(1000), files[3].last_modified());
+}
+
+TEST_F(RecentModelTest, GetRecentFiles_MaxFiles) {
+  std::vector<RecentFile> files =
+      BuildModelAndGetRecentFiles(BuildDefaultSources(), 3, base::Time());
+
+  ASSERT_EQ(3u, files.size());
+  EXPECT_EQ("ddd.jpg", files[0].url().path().value());
+  EXPECT_EQ(base::Time::FromJavaTime(4000), files[0].last_modified());
+  EXPECT_EQ("ccc.jpg", files[1].url().path().value());
+  EXPECT_EQ(base::Time::FromJavaTime(3000), files[1].last_modified());
+  EXPECT_EQ("bbb.jpg", files[2].url().path().value());
+  EXPECT_EQ(base::Time::FromJavaTime(2000), files[2].last_modified());
+}
+
+TEST_F(RecentModelTest, GetRecentFiles_CutoffTime) {
+  std::vector<RecentFile> files = BuildModelAndGetRecentFiles(
+      BuildDefaultSources(), 10, base::Time::FromJavaTime(2500));
+
+  ASSERT_EQ(2u, files.size());
+  EXPECT_EQ("ddd.jpg", files[0].url().path().value());
+  EXPECT_EQ(base::Time::FromJavaTime(4000), files[0].last_modified());
+  EXPECT_EQ("ccc.jpg", files[1].url().path().value());
+  EXPECT_EQ(base::Time::FromJavaTime(3000), files[1].last_modified());
+}
+
+TEST_F(RecentModelTest, GetRecentFiles_UmaStats) {
+  base::HistogramTester histogram_tester;
+
+  BuildModelAndGetRecentFiles({}, 10, base::Time());
+
+  histogram_tester.ExpectTotalCount(RecentModel::kLoadHistogramName, 1);
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/recent_source.cc b/chrome/browser/fileapi/recent_source.cc
new file mode 100644
index 0000000000000..e61697de85467
--- /dev/null
+++ b/chrome/browser/fileapi/recent_source.cc
@@ -0,0 +1,34 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/recent_source.h"
+
+#include <utility>
+
+#include "base/logging.h"
+
+namespace chromeos {
+
+RecentSource::Params::Params(storage::FileSystemContext* file_system_context,
+                             const GURL& origin,
+                             size_t max_files,
+                             const base::Time& cutoff_time,
+                             GetRecentFilesCallback callback)
+    : file_system_context_(file_system_context),
+      origin_(origin),
+      max_files_(max_files),
+      cutoff_time_(cutoff_time),
+      callback_(std::move(callback)) {
+  DCHECK(!callback_.is_null());
+}
+
+RecentSource::Params::Params(Params&& other) = default;
+
+RecentSource::Params::~Params() = default;
+
+RecentSource::RecentSource() = default;
+
+RecentSource::~RecentSource() = default;
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/recent_source.h b/chrome/browser/fileapi/recent_source.h
new file mode 100644
index 0000000000000..adacf1f3ee5cd
--- /dev/null
+++ b/chrome/browser/fileapi/recent_source.h
@@ -0,0 +1,97 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILEAPI_RECENT_SOURCE_H_
+#define CHROME_BROWSER_FILEAPI_RECENT_SOURCE_H_
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/callback_forward.h"
+#include "base/memory/ref_counted.h"
+#include "base/time/time.h"
+#include "storage/browser/fileapi/file_system_context.h"
+#include "storage/browser/fileapi/file_system_url.h"
+#include "url/gurl.h"
+
+namespace chromeos {
+
+class RecentFile;
+
+// Interface class for a source of recent files.
+//
+// Recent file system retrieves recent files from several sources such as
+// local directories and cloud storages. To provide files to Recent file
+// system, this interface should be implemented for each source.
+//
+// Note: If a source implementation depends on KeyedServices, remember to add
+// dependencies in RecentModelFactory.
+//
+// All member functions must be called on the UI thread.
+class RecentSource {
+ public:
+  using GetRecentFilesCallback =
+      base::OnceCallback<void(std::vector<RecentFile> files)>;
+
+  // Parameters passed to GetRecentFiles().
+  class Params {
+   public:
+    Params(storage::FileSystemContext* file_system_context,
+           const GURL& origin,
+           size_t max_files,
+           const base::Time& cutoff_time,
+           GetRecentFilesCallback callback);
+
+    Params(const Params& other) = delete;
+    Params(Params&& other);
+    ~Params();
+    Params& operator=(const Params& other) = delete;
+
+    // FileSystemContext that can be used for file system operations.
+    storage::FileSystemContext* file_system_context() const {
+      return file_system_context_.get();
+    }
+
+    // Origin of external file system URLs.
+    // E.g. "chrome-extension://<extension-ID>/"
+    const GURL& origin() const { return origin_; }
+
+    // Maximum number of files a RecentSource is expected to return. It is fine
+    // to return more files than requested here, but excessive items will be
+    // filtered out by RecentModel.
+    size_t max_files() const { return max_files_; }
+
+    // Cut-off last modified time. RecentSource is expected to return files
+    // modified at this time or later. It is fine to return older files than
+    // requested here, but they will be filtered out by RecentModel.
+    const base::Time& cutoff_time() const { return cutoff_time_; }
+
+    // Callback to be called for the result of GetRecentFiles().
+    GetRecentFilesCallback& callback() { return callback_; }
+
+   private:
+    scoped_refptr<storage::FileSystemContext> file_system_context_;
+    GURL origin_;
+    size_t max_files_;
+    base::Time cutoff_time_;
+    GetRecentFilesCallback callback_;
+  };
+
+  virtual ~RecentSource();
+
+  // Retrieves a list of recent files from this source.
+  //
+  // You can assume that, once this function is called, it is not called again
+  // until the callback is invoked. This means that you can safely save internal
+  // states to compute recent files in member variables.
+  virtual void GetRecentFiles(Params params) = 0;
+
+ protected:
+  RecentSource();
+};
+
+}  // namespace chromeos
+
+#endif  // CHROME_BROWSER_FILEAPI_RECENT_SOURCE_H_
diff --git a/chrome/browser/fileapi/test/fake_recent_source.cc b/chrome/browser/fileapi/test/fake_recent_source.cc
new file mode 100644
index 0000000000000..e684d11456d3b
--- /dev/null
+++ b/chrome/browser/fileapi/test/fake_recent_source.cc
@@ -0,0 +1,25 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/fileapi/test/fake_recent_source.h"
+
+#include <utility>
+
+#include "chrome/browser/fileapi/recent_file.h"
+
+namespace chromeos {
+
+FakeRecentSource::FakeRecentSource() = default;
+
+FakeRecentSource::~FakeRecentSource() = default;
+
+void FakeRecentSource::AddFile(const RecentFile& file) {
+  canned_files_.emplace_back(file);
+}
+
+void FakeRecentSource::GetRecentFiles(Params params) {
+  std::move(params.callback()).Run(canned_files_);
+}
+
+}  // namespace chromeos
diff --git a/chrome/browser/fileapi/test/fake_recent_source.h b/chrome/browser/fileapi/test/fake_recent_source.h
new file mode 100644
index 0000000000000..7e7740bad0342
--- /dev/null
+++ b/chrome/browser/fileapi/test/fake_recent_source.h
@@ -0,0 +1,39 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILEAPI_TEST_FAKE_RECENT_SOURCE_H_
+#define CHROME_BROWSER_FILEAPI_TEST_FAKE_RECENT_SOURCE_H_
+
+#include <vector>
+
+#include "base/macros.h"
+#include "chrome/browser/fileapi/recent_source.h"
+
+namespace chromeos {
+
+class RecentFile;
+
+// Fake implementation of RecentSource that returns a canned set of files.
+//
+// All member functions must be called on the UI thread.
+class FakeRecentSource : public RecentSource {
+ public:
+  FakeRecentSource();
+  ~FakeRecentSource() override;
+
+  // Add a file to the canned set.
+  void AddFile(const RecentFile& file);
+
+  // RecentSource overrides:
+  void GetRecentFiles(Params params) override;
+
+ private:
+  std::vector<RecentFile> canned_files_;
+
+  DISALLOW_COPY_AND_ASSIGN(FakeRecentSource);
+};
+
+}  // namespace chromeos
+
+#endif  // CHROME_BROWSER_FILEAPI_TEST_FAKE_RECENT_SOURCE_H_

From feb25a538004b30557f200ef465929dc12aa90ae Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Wed, 22 Aug 2018 17:53:40 +0900
Subject: [PATCH 22/32] Add file_system_provider to
 chrome/browser/extensions/api

It adds file_system_provider for extension APIs to
chrome/browser/extensions/api to share them with Linux/Ozone
build.
It was used only for ChromeOS and the original code is
from chrome/browser/chromeos/extension/file_system_provider.
---
 .../api/file_system_provider/OWNERS           |   2 +
 .../file_system_provider_api.cc               | 372 ++++++++++++++++++
 .../file_system_provider_api.h                | 152 +++++++
 .../file_system_provider_apitest.cc           | 303 ++++++++++++++
 .../file_system_provider/provider_function.cc | 176 +++++++++
 .../file_system_provider/provider_function.h  |  79 ++++
 6 files changed, 1084 insertions(+)
 create mode 100644 chrome/browser/extensions/api/file_system_provider/OWNERS
 create mode 100644 chrome/browser/extensions/api/file_system_provider/file_system_provider_api.cc
 create mode 100644 chrome/browser/extensions/api/file_system_provider/file_system_provider_api.h
 create mode 100644 chrome/browser/extensions/api/file_system_provider/file_system_provider_apitest.cc
 create mode 100644 chrome/browser/extensions/api/file_system_provider/provider_function.cc
 create mode 100644 chrome/browser/extensions/api/file_system_provider/provider_function.h

diff --git a/chrome/browser/extensions/api/file_system_provider/OWNERS b/chrome/browser/extensions/api/file_system_provider/OWNERS
new file mode 100644
index 0000000000000..4de4587c1c834
--- /dev/null
+++ b/chrome/browser/extensions/api/file_system_provider/OWNERS
@@ -0,0 +1,2 @@
+fukino@chromium.org
+yamaguchi@chromium.org
diff --git a/chrome/browser/extensions/api/file_system_provider/file_system_provider_api.cc b/chrome/browser/extensions/api/file_system_provider/file_system_provider_api.cc
new file mode 100644
index 0000000000000..3a5beb756977c
--- /dev/null
+++ b/chrome/browser/extensions/api/file_system_provider/file_system_provider_api.cc
@@ -0,0 +1,372 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_system_provider/file_system_provider_api.h"
+
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/memory/ptr_util.h"
+#include "base/trace_event/trace_event.h"
+#include "base/values.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_info.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_interface.h"
+#include "chrome/browser/chromeos/file_system_provider/request_manager.h"
+#include "chrome/browser/chromeos/file_system_provider/request_value.h"
+#include "chrome/browser/chromeos/file_system_provider/service.h"
+#include "chrome/common/extensions/api/file_system_provider.h"
+#include "chrome/common/extensions/api/file_system_provider_internal.h"
+#include "storage/browser/fileapi/watcher_manager.h"
+
+using chromeos::file_system_provider::MountOptions;
+using chromeos::file_system_provider::OpenedFiles;
+using chromeos::file_system_provider::ProvidedFileSystemInfo;
+using chromeos::file_system_provider::ProvidedFileSystemInterface;
+using chromeos::file_system_provider::ProvidedFileSystemObserver;
+using chromeos::file_system_provider::ProviderId;
+using chromeos::file_system_provider::RequestValue;
+using chromeos::file_system_provider::Service;
+using chromeos::file_system_provider::Watchers;
+
+namespace extensions {
+namespace {
+
+// Converts the change type from the IDL type to a native type. |changed_type|
+// must be specified (not CHANGE_TYPE_NONE).
+storage::WatcherManager::ChangeType ParseChangeType(
+    const api::file_system_provider::ChangeType& change_type) {
+  switch (change_type) {
+    case api::file_system_provider::CHANGE_TYPE_CHANGED:
+      return storage::WatcherManager::CHANGED;
+    case api::file_system_provider::CHANGE_TYPE_DELETED:
+      return storage::WatcherManager::DELETED;
+    default:
+      break;
+  }
+  NOTREACHED();
+  return storage::WatcherManager::CHANGED;
+}
+
+// Convert the change from the IDL type to a native type. The reason IDL types
+// are not used is since they are imperfect, eg. paths are stored as strings.
+ProvidedFileSystemObserver::Change ParseChange(
+    const api::file_system_provider::Change& change) {
+  ProvidedFileSystemObserver::Change result;
+  result.entry_path = base::FilePath::FromUTF8Unsafe(change.entry_path);
+  result.change_type = ParseChangeType(change.change_type);
+  return result;
+}
+
+// Converts a list of child changes from the IDL type to a native type.
+std::unique_ptr<ProvidedFileSystemObserver::Changes> ParseChanges(
+    const std::vector<api::file_system_provider::Change>& changes) {
+  std::unique_ptr<ProvidedFileSystemObserver::Changes> results(
+      new ProvidedFileSystemObserver::Changes);
+  for (const auto& change : changes) {
+    results->push_back(ParseChange(change));
+  }
+  return results;
+}
+
+// Fills the IDL's FileSystemInfo with FSP's ProvidedFileSystemInfo and
+// Watchers.
+void FillFileSystemInfo(const ProvidedFileSystemInfo& file_system_info,
+                        const Watchers& watchers,
+                        const OpenedFiles& opened_files,
+                        api::file_system_provider::FileSystemInfo* output) {
+  using api::file_system_provider::Watcher;
+  using api::file_system_provider::OpenedFile;
+
+  output->file_system_id = file_system_info.file_system_id();
+  output->display_name = file_system_info.display_name();
+  output->writable = file_system_info.writable();
+  output->opened_files_limit = file_system_info.opened_files_limit();
+
+  for (const auto& watcher : watchers) {
+    Watcher watcher_item;
+    watcher_item.entry_path = watcher.second.entry_path.value();
+    watcher_item.recursive = watcher.second.recursive;
+    if (!watcher.second.last_tag.empty())
+      watcher_item.last_tag.reset(new std::string(watcher.second.last_tag));
+    output->watchers.push_back(std::move(watcher_item));
+  }
+
+  for (const auto& opened_file : opened_files) {
+    OpenedFile opened_file_item;
+    opened_file_item.open_request_id = opened_file.first;
+    opened_file_item.file_path = opened_file.second.file_path.value();
+    switch (opened_file.second.mode) {
+      case chromeos::file_system_provider::OPEN_FILE_MODE_READ:
+        opened_file_item.mode =
+            extensions::api::file_system_provider::OPEN_FILE_MODE_READ;
+        break;
+      case chromeos::file_system_provider::OPEN_FILE_MODE_WRITE:
+        opened_file_item.mode =
+            extensions::api::file_system_provider::OPEN_FILE_MODE_WRITE;
+        break;
+    }
+    output->opened_files.push_back(std::move(opened_file_item));
+  }
+}
+
+}  // namespace
+
+ExtensionFunction::ResponseAction FileSystemProviderMountFunction::Run() {
+  using api::file_system_provider::Mount::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  // It's an error if the file system Id is empty.
+  if (params->options.file_system_id.empty()) {
+    return RespondNow(
+        Error(FileErrorToString(base::File::FILE_ERROR_INVALID_OPERATION)));
+  }
+
+  // It's an error if the display name is empty.
+  if (params->options.display_name.empty()) {
+    return RespondNow(
+        Error(FileErrorToString(base::File::FILE_ERROR_INVALID_OPERATION)));
+  }
+
+  // If the opened files limit is set, then it must be larger or equal than 0.
+  if (params->options.opened_files_limit.get() &&
+      *params->options.opened_files_limit.get() < 0) {
+    return RespondNow(
+        Error(FileErrorToString(base::File::FILE_ERROR_INVALID_OPERATION)));
+  }
+
+  Service* const service =
+      Service::Get(Profile::FromBrowserContext(browser_context()));
+  DCHECK(service);
+
+  MountOptions options;
+  options.file_system_id = params->options.file_system_id;
+  options.display_name = params->options.display_name;
+  options.writable = params->options.writable != nullptr;
+  options.opened_files_limit = params->options.opened_files_limit.get()
+                                   ? *params->options.opened_files_limit.get()
+                                   : 0;
+  options.supports_notify_tag = params->options.supports_notify_tag != nullptr;
+  options.persistent = params->options.persistent.get()
+                           ? *params->options.persistent.get()
+                           : true;
+
+  const base::File::Error result = service->MountFileSystem(
+      ProviderId::CreateFromExtensionId(extension_id()), options);
+  if (result != base::File::FILE_OK)
+    return RespondNow(Error(FileErrorToString(result)));
+
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction FileSystemProviderUnmountFunction::Run() {
+  using api::file_system_provider::Unmount::Params;
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  Service* const service =
+      Service::Get(Profile::FromBrowserContext(browser_context()));
+  DCHECK(service);
+
+  const base::File::Error result = service->UnmountFileSystem(
+      ProviderId::CreateFromExtensionId(extension_id()),
+      params->options.file_system_id, Service::UNMOUNT_REASON_USER);
+  if (result != base::File::FILE_OK)
+    return RespondNow(Error(FileErrorToString(result)));
+
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction FileSystemProviderGetAllFunction::Run() {
+  using api::file_system_provider::FileSystemInfo;
+  Service* const service =
+      Service::Get(Profile::FromBrowserContext(browser_context()));
+  DCHECK(service);
+
+  ProviderId provider_id = ProviderId::CreateFromExtensionId(extension_id());
+  const std::vector<ProvidedFileSystemInfo> file_systems =
+      service->GetProvidedFileSystemInfoList(provider_id);
+
+  std::vector<FileSystemInfo> items;
+
+  for (const auto& file_system_info : file_systems) {
+    FileSystemInfo item;
+
+    chromeos::file_system_provider::ProvidedFileSystemInterface* const
+        file_system = service->GetProvidedFileSystem(
+            file_system_info.provider_id(), file_system_info.file_system_id());
+
+    DCHECK(file_system);
+
+    FillFileSystemInfo(
+        file_system_info,
+        file_system_info.watchable() ? *file_system->GetWatchers() : Watchers(),
+        file_system->GetOpenedFiles(), &item);
+
+    items.push_back(std::move(item));
+  }
+
+  return RespondNow(
+      ArgumentList(api::file_system_provider::GetAll::Results::Create(items)));
+}
+
+ExtensionFunction::ResponseAction FileSystemProviderGetFunction::Run() {
+  using api::file_system_provider::Get::Params;
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  using api::file_system_provider::FileSystemInfo;
+  Service* const service =
+      Service::Get(Profile::FromBrowserContext(browser_context()));
+  DCHECK(service);
+
+  chromeos::file_system_provider::ProvidedFileSystemInterface* const
+      file_system = service->GetProvidedFileSystem(
+          ProviderId::CreateFromExtensionId(extension_id()),
+          params->file_system_id);
+
+  if (!file_system) {
+    return RespondNow(
+        Error(FileErrorToString(base::File::FILE_ERROR_NOT_FOUND)));
+  }
+
+  FileSystemInfo file_system_info;
+  FillFileSystemInfo(file_system->GetFileSystemInfo(),
+                     file_system->GetFileSystemInfo().watchable()
+                         ? *file_system->GetWatchers()
+                         : Watchers(),
+                     file_system->GetOpenedFiles(), &file_system_info);
+  return RespondNow(ArgumentList(
+      api::file_system_provider::Get::Results::Create(file_system_info)));
+}
+
+bool FileSystemProviderNotifyFunction::RunAsync() {
+  using api::file_system_provider::Notify::Params;
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  Service* const service = Service::Get(GetProfile());
+  DCHECK(service);
+
+  ProvidedFileSystemInterface* const file_system =
+      service->GetProvidedFileSystem(
+          ProviderId::CreateFromExtensionId(extension_id()),
+          params->options.file_system_id);
+  if (!file_system) {
+    SetError(FileErrorToString(base::File::FILE_ERROR_NOT_FOUND));
+    return false;
+  }
+
+  file_system->Notify(
+      base::FilePath::FromUTF8Unsafe(params->options.observed_path),
+      params->options.recursive, ParseChangeType(params->options.change_type),
+      params->options.changes.get()
+          ? ParseChanges(*params->options.changes.get())
+          : base::WrapUnique(new ProvidedFileSystemObserver::Changes),
+      params->options.tag.get() ? *params->options.tag.get() : "",
+      base::Bind(&FileSystemProviderNotifyFunction::OnNotifyCompleted, this));
+
+  return true;
+}
+
+void FileSystemProviderNotifyFunction::OnNotifyCompleted(
+    base::File::Error result) {
+  if (result != base::File::FILE_OK) {
+    SetError(FileErrorToString(result));
+    SendResponse(false);
+    return;
+  }
+
+  SendResponse(true);
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalUnmountRequestedSuccessFunction::Run() {
+  using api::file_system_provider_internal::UnmountRequestedSuccess::Params;
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  return FulfillRequest(
+      RequestValue::CreateForUnmountSuccess(std::move(params)),
+      false /* has_more */);
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalGetMetadataRequestedSuccessFunction::Run() {
+  using api::file_system_provider_internal::GetMetadataRequestedSuccess::Params;
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  return FulfillRequest(
+      RequestValue::CreateForGetMetadataSuccess(std::move(params)),
+      false /* has_more */);
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalGetActionsRequestedSuccessFunction::Run() {
+  using api::file_system_provider_internal::GetActionsRequestedSuccess::Params;
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  return FulfillRequest(
+      RequestValue::CreateForGetActionsSuccess(std::move(params)),
+      false /* has_more */);
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalReadDirectoryRequestedSuccessFunction::Run() {
+  using api::file_system_provider_internal::ReadDirectoryRequestedSuccess::
+      Params;
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const bool has_more = params->has_more;
+  return FulfillRequest(
+      RequestValue::CreateForReadDirectorySuccess(std::move(params)), has_more);
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalReadFileRequestedSuccessFunction::Run() {
+  TRACE_EVENT0("file_system_provider", "ReadFileRequestedSuccess");
+  using api::file_system_provider_internal::ReadFileRequestedSuccess::Params;
+
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const bool has_more = params->has_more;
+  return FulfillRequest(
+      RequestValue::CreateForReadFileSuccess(std::move(params)), has_more);
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalOperationRequestedSuccessFunction::Run() {
+  using api::file_system_provider_internal::OperationRequestedSuccess::Params;
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  return FulfillRequest(
+      std::unique_ptr<RequestValue>(
+          RequestValue::CreateForOperationSuccess(std::move(params))),
+      false /* has_more */);
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalOperationRequestedErrorFunction::Run() {
+  using api::file_system_provider_internal::OperationRequestedError::Params;
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  if (params->error == api::file_system_provider::PROVIDER_ERROR_OK) {
+    // It's incorrect to pass OK as an error code.
+    return ValidationFailure(this);
+  }
+
+  const base::File::Error error = ProviderErrorToFileError(params->error);
+  return RejectRequest(RequestValue::CreateForOperationError(std::move(params)),
+                       error);
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_system_provider/file_system_provider_api.h b/chrome/browser/extensions/api/file_system_provider/file_system_provider_api.h
new file mode 100644
index 0000000000000..f57e7158d5540
--- /dev/null
+++ b/chrome/browser/extensions/api/file_system_provider/file_system_provider_api.h
@@ -0,0 +1,152 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_FILE_SYSTEM_PROVIDER_FILE_SYSTEM_PROVIDER_API_H_
+#define CHROME_BROWSER_EXTENSIONS_FILE_SYSTEM_PROVIDER_FILE_SYSTEM_PROVIDER_API_H_
+
+#include "chrome/browser/extensions/api/file_system_provider/provider_function.h"
+#include "chrome/browser/extensions/chrome_extension_function.h"
+
+namespace extensions {
+
+class FileSystemProviderMountFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.mount",
+                             FILESYSTEMPROVIDER_MOUNT)
+
+ protected:
+  ~FileSystemProviderMountFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderUnmountFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.unmount",
+                             FILESYSTEMPROVIDER_UNMOUNT)
+
+ protected:
+  ~FileSystemProviderUnmountFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderGetAllFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.getAll",
+                             FILESYSTEMPROVIDER_GETALL)
+
+ protected:
+  ~FileSystemProviderGetAllFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderGetFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.get", FILESYSTEMPROVIDER_GET)
+
+ protected:
+  ~FileSystemProviderGetFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderNotifyFunction : public ChromeAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.notify",
+                             FILESYSTEMPROVIDER_NOTIFY)
+
+ protected:
+  ~FileSystemProviderNotifyFunction() override {}
+  bool RunAsync() override;
+
+ private:
+  // Called when notifying is completed.
+  void OnNotifyCompleted(base::File::Error result);
+};
+
+class FileSystemProviderInternalUnmountRequestedSuccessFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.unmountRequestedSuccess",
+      FILESYSTEMPROVIDERINTERNAL_UNMOUNTREQUESTEDSUCCESS)
+
+ protected:
+  ~FileSystemProviderInternalUnmountRequestedSuccessFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderInternalGetMetadataRequestedSuccessFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.getMetadataRequestedSuccess",
+      FILESYSTEMPROVIDERINTERNAL_GETMETADATAREQUESTEDSUCCESS)
+
+ protected:
+  ~FileSystemProviderInternalGetMetadataRequestedSuccessFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderInternalGetActionsRequestedSuccessFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.getActionsRequestedSuccess",
+      FILESYSTEMPROVIDERINTERNAL_GETACTIONSREQUESTEDSUCCESS)
+
+ protected:
+  ~FileSystemProviderInternalGetActionsRequestedSuccessFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderInternalReadDirectoryRequestedSuccessFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.readDirectoryRequestedSuccess",
+      FILESYSTEMPROVIDERINTERNAL_READDIRECTORYREQUESTEDSUCCESS)
+
+ protected:
+  ~FileSystemProviderInternalReadDirectoryRequestedSuccessFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderInternalReadFileRequestedSuccessFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.readFileRequestedSuccess",
+      FILESYSTEMPROVIDERINTERNAL_READFILEREQUESTEDSUCCESS)
+
+ protected:
+  ~FileSystemProviderInternalReadFileRequestedSuccessFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderInternalOperationRequestedSuccessFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.operationRequestedSuccess",
+      FILESYSTEMPROVIDERINTERNAL_OPERATIONREQUESTEDSUCCESS)
+
+ protected:
+  ~FileSystemProviderInternalOperationRequestedSuccessFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderInternalOperationRequestedErrorFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.operationRequestedError",
+      FILESYSTEMPROVIDERINTERNAL_OPERATIONREQUESTEDERROR)
+
+ protected:
+  ~FileSystemProviderInternalOperationRequestedErrorFunction() override {}
+  ResponseAction Run() override;
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_FILE_SYSTEM_PROVIDER_FILE_SYSTEM_PROVIDER_API_H_
diff --git a/chrome/browser/extensions/api/file_system_provider/file_system_provider_apitest.cc b/chrome/browser/extensions/api/file_system_provider/file_system_provider_apitest.cc
new file mode 100644
index 0000000000000..9ba4c1b5c9ce2
--- /dev/null
+++ b/chrome/browser/extensions/api/file_system_provider/file_system_provider_apitest.cc
@@ -0,0 +1,303 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <memory>
+#include <utility>
+
+#include "base/files/file.h"
+#include "base/macros.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "base/time/time.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/chromeos/file_system_provider/notification_manager_interface.h"
+#include "chrome/browser/chromeos/file_system_provider/observer.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_info.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_interface.h"
+#include "chrome/browser/chromeos/file_system_provider/request_manager.h"
+#include "chrome/browser/chromeos/file_system_provider/request_value.h"
+#include "chrome/browser/chromeos/file_system_provider/service.h"
+#include "chrome/browser/extensions/extension_apitest.h"
+#include "chrome/browser/notifications/notification_display_service_tester.h"
+#include "ui/message_center/public/cpp/notification.h"
+#include "ui/message_center/public/cpp/notification_delegate.h"
+
+namespace extensions {
+namespace {
+
+using chromeos::file_system_provider::MountContext;
+using chromeos::file_system_provider::NotificationManagerInterface;
+using chromeos::file_system_provider::Observer;
+using chromeos::file_system_provider::ProvidedFileSystemInterface;
+using chromeos::file_system_provider::ProvidedFileSystemInfo;
+using chromeos::file_system_provider::RequestManager;
+using chromeos::file_system_provider::RequestType;
+using chromeos::file_system_provider::RequestValue;
+using chromeos::file_system_provider::Service;
+
+// Clicks the default button on the notification as soon as request timeouts
+// and a unresponsiveness notification is shown.
+class NotificationButtonClicker : public RequestManager::Observer {
+ public:
+  explicit NotificationButtonClicker(
+      const ProvidedFileSystemInfo& file_system_info)
+      : file_system_info_(file_system_info) {}
+  ~NotificationButtonClicker() override {}
+
+  // RequestManager::Observer overrides.
+  void OnRequestCreated(int request_id, RequestType type) override {}
+  void OnRequestDestroyed(int request_id) override {}
+  void OnRequestExecuted(int request_id) override {}
+  void OnRequestFulfilled(int request_id,
+                          const RequestValue& result,
+                          bool has_more) override {}
+  void OnRequestRejected(int request_id,
+                         const RequestValue& result,
+                         base::File::Error error) override {}
+  void OnRequestTimeouted(int request_id) override {
+    // Call asynchronously so the notification is setup is completed.
+    base::ThreadTaskRunnerHandle::Get()->PostTask(
+        FROM_HERE, base::BindOnce(&NotificationButtonClicker::ClickButton,
+                                  base::Unretained(this)));
+  }
+
+ private:
+  void ClickButton() {
+    base::Optional<message_center::Notification> notification =
+        NotificationDisplayServiceTester::Get()->GetNotification(
+            file_system_info_.mount_path().value());
+    if (notification)
+      notification->delegate()->Click(0, base::nullopt);
+  }
+
+  ProvidedFileSystemInfo file_system_info_;
+
+  DISALLOW_COPY_AND_ASSIGN(NotificationButtonClicker);
+};
+
+// Simulates clicking on the unresponsive notification's abort button. Also,
+// sets the timeout delay to 0 ms, so the notification is shown faster.
+class AbortOnUnresponsivePerformer : public Observer {
+ public:
+  explicit AbortOnUnresponsivePerformer(Profile* profile)
+      : service_(Service::Get(profile)) {
+    DCHECK(profile);
+    DCHECK(service_);
+    service_->AddObserver(this);
+  }
+
+  ~AbortOnUnresponsivePerformer() override { service_->RemoveObserver(this); }
+
+  // Observer overrides.
+  void OnProvidedFileSystemMount(const ProvidedFileSystemInfo& file_system_info,
+                                 MountContext context,
+                                 base::File::Error error) override {
+    if (error != base::File::FILE_OK)
+      return;
+
+    ProvidedFileSystemInterface* const file_system =
+        service_->GetProvidedFileSystem(file_system_info.provider_id(),
+                                        file_system_info.file_system_id());
+    DCHECK(file_system);
+    file_system->GetRequestManager()->SetTimeoutForTesting(base::TimeDelta());
+
+    std::unique_ptr<NotificationButtonClicker> clicker(
+        new NotificationButtonClicker(file_system->GetFileSystemInfo()));
+
+    file_system->GetRequestManager()->AddObserver(clicker.get());
+    clickers_.push_back(std::move(clicker));
+  }
+
+  void OnProvidedFileSystemUnmount(
+      const ProvidedFileSystemInfo& file_system_info,
+      base::File::Error error) override {}
+
+ private:
+  Service* service_;  // Not owned.
+  std::vector<std::unique_ptr<NotificationButtonClicker>> clickers_;
+
+  DISALLOW_COPY_AND_ASSIGN(AbortOnUnresponsivePerformer);
+};
+
+}  // namespace
+
+class FileSystemProviderApiTest : public ExtensionApiTest {
+ public:
+  FileSystemProviderApiTest() {}
+
+  // Loads a helper testing extension.
+  void SetUpOnMainThread() override {
+    ExtensionApiTest::SetUpOnMainThread();
+    const extensions::Extension* extension = LoadExtensionWithFlags(
+        test_data_dir_.AppendASCII("file_system_provider/test_util"),
+        kFlagEnableIncognito);
+    ASSERT_TRUE(extension);
+
+    display_service_ = std::make_unique<NotificationDisplayServiceTester>(
+        browser()->profile());
+  }
+
+  std::unique_ptr<NotificationDisplayServiceTester> display_service_;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(FileSystemProviderApiTest);
+};
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Mount) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/mount",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Unmount) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/unmount",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, GetAll) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/get_all",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, GetMetadata) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/get_metadata",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, ReadDirectory) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/read_directory",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, ReadFile) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/read_file",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, BigFile) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/big_file",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Evil) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/evil",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, MimeType) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/mime_type",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, CreateDirectory) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags(
+      "file_system_provider/create_directory", kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, DeleteEntry) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/delete_entry",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, CreateFile) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/create_file",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, CopyEntry) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/copy_entry",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, MoveEntry) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/move_entry",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Truncate) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/truncate",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, WriteFile) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/write_file",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Extension) {
+  ASSERT_TRUE(RunComponentExtensionTest("file_system_provider/extension"))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Thumbnail) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/thumbnail",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, AddWatcher) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/add_watcher",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, RemoveWatcher) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/remove_watcher",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Notify) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/notify",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Configure) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/configure",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, GetActions) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/get_actions",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, ExecuteAction) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/execute_action",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Unresponsive_Extension) {
+  AbortOnUnresponsivePerformer performer(browser()->profile());
+  ASSERT_TRUE(
+      RunComponentExtensionTest("file_system_provider/unresponsive_extension"))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Unresponsive_App) {
+  AbortOnUnresponsivePerformer performer(browser()->profile());
+  ASSERT_TRUE(RunPlatformAppTestWithFlags(
+      "file_system_provider/unresponsive_app", kFlagLoadAsComponent))
+      << message_;
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_system_provider/provider_function.cc b/chrome/browser/extensions/api/file_system_provider/provider_function.cc
new file mode 100644
index 0000000000000..8c7451c155e7c
--- /dev/null
+++ b/chrome/browser/extensions/api/file_system_provider/provider_function.cc
@@ -0,0 +1,176 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <utility>
+
+#include "chrome/browser/extensions/api/file_system_provider/file_system_provider_api.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_interface.h"
+#include "chrome/browser/chromeos/file_system_provider/request_manager.h"
+#include "chrome/browser/chromeos/file_system_provider/request_value.h"
+#include "chrome/browser/chromeos/file_system_provider/service.h"
+#include "chrome/common/extensions/api/file_system_provider_internal.h"
+
+using chromeos::file_system_provider::ProvidedFileSystemInterface;
+using chromeos::file_system_provider::ProviderId;
+using chromeos::file_system_provider::RequestManager;
+using chromeos::file_system_provider::RequestValue;
+using chromeos::file_system_provider::Service;
+
+namespace {
+
+// Converts a base::File::Error into the IDL error format.
+extensions::api::file_system_provider::ProviderError FileErrorToProviderError(
+    base::File::Error error) {
+  switch (error) {
+    case base::File::FILE_OK:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_OK;
+    case base::File::FILE_ERROR_FAILED:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_FAILED;
+    case base::File::FILE_ERROR_IN_USE:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_IN_USE;
+    case base::File::FILE_ERROR_EXISTS:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_EXISTS;
+    case base::File::FILE_ERROR_NOT_FOUND:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_NOT_FOUND;
+    case base::File::FILE_ERROR_ACCESS_DENIED:
+      return extensions::api::file_system_provider::
+          PROVIDER_ERROR_ACCESS_DENIED;
+    case base::File::FILE_ERROR_TOO_MANY_OPENED:
+      return extensions::api::file_system_provider::
+          PROVIDER_ERROR_TOO_MANY_OPENED;
+    case base::File::FILE_ERROR_NO_MEMORY:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_NO_MEMORY;
+    case base::File::FILE_ERROR_NO_SPACE:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_NO_SPACE;
+    case base::File::FILE_ERROR_NOT_A_DIRECTORY:
+      return extensions::api::file_system_provider::
+          PROVIDER_ERROR_NOT_A_DIRECTORY;
+    case base::File::FILE_ERROR_INVALID_OPERATION:
+      return extensions::api::file_system_provider::
+          PROVIDER_ERROR_INVALID_OPERATION;
+    case base::File::FILE_ERROR_SECURITY:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_SECURITY;
+    case base::File::FILE_ERROR_ABORT:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_ABORT;
+    case base::File::FILE_ERROR_NOT_A_FILE:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_NOT_A_FILE;
+    case base::File::FILE_ERROR_NOT_EMPTY:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_NOT_EMPTY;
+    case base::File::FILE_ERROR_INVALID_URL:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_INVALID_URL;
+    case base::File::FILE_ERROR_IO:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_IO;
+    case base::File::FILE_ERROR_MAX:
+      NOTREACHED();
+  }
+
+  return extensions::api::file_system_provider::PROVIDER_ERROR_FAILED;
+}
+
+}  // namespace
+
+namespace extensions {
+
+base::File::Error ProviderErrorToFileError(
+    api::file_system_provider::ProviderError error) {
+  switch (error) {
+    case api::file_system_provider::PROVIDER_ERROR_OK:
+      return base::File::FILE_OK;
+    case api::file_system_provider::PROVIDER_ERROR_FAILED:
+      return base::File::FILE_ERROR_FAILED;
+    case api::file_system_provider::PROVIDER_ERROR_IN_USE:
+      return base::File::FILE_ERROR_IN_USE;
+    case api::file_system_provider::PROVIDER_ERROR_EXISTS:
+      return base::File::FILE_ERROR_EXISTS;
+    case api::file_system_provider::PROVIDER_ERROR_NOT_FOUND:
+      return base::File::FILE_ERROR_NOT_FOUND;
+    case api::file_system_provider::PROVIDER_ERROR_ACCESS_DENIED:
+      return base::File::FILE_ERROR_ACCESS_DENIED;
+    case api::file_system_provider::PROVIDER_ERROR_TOO_MANY_OPENED:
+      return base::File::FILE_ERROR_TOO_MANY_OPENED;
+    case api::file_system_provider::PROVIDER_ERROR_NO_MEMORY:
+      return base::File::FILE_ERROR_NO_MEMORY;
+    case api::file_system_provider::PROVIDER_ERROR_NO_SPACE:
+      return base::File::FILE_ERROR_NO_SPACE;
+    case api::file_system_provider::PROVIDER_ERROR_NOT_A_DIRECTORY:
+      return base::File::FILE_ERROR_NOT_A_DIRECTORY;
+    case api::file_system_provider::PROVIDER_ERROR_INVALID_OPERATION:
+      return base::File::FILE_ERROR_INVALID_OPERATION;
+    case api::file_system_provider::PROVIDER_ERROR_SECURITY:
+      return base::File::FILE_ERROR_SECURITY;
+    case api::file_system_provider::PROVIDER_ERROR_ABORT:
+      return base::File::FILE_ERROR_ABORT;
+    case api::file_system_provider::PROVIDER_ERROR_NOT_A_FILE:
+      return base::File::FILE_ERROR_NOT_A_FILE;
+    case api::file_system_provider::PROVIDER_ERROR_NOT_EMPTY:
+      return base::File::FILE_ERROR_NOT_EMPTY;
+    case api::file_system_provider::PROVIDER_ERROR_INVALID_URL:
+      return base::File::FILE_ERROR_INVALID_URL;
+    case api::file_system_provider::PROVIDER_ERROR_IO:
+      return base::File::FILE_ERROR_IO;
+    case api::file_system_provider::PROVIDER_ERROR_NONE:
+      NOTREACHED();
+  }
+
+  return base::File::FILE_ERROR_FAILED;
+}
+
+std::string FileErrorToString(base::File::Error error) {
+  return extensions::api::file_system_provider::ToString(
+      FileErrorToProviderError(error));
+}
+
+FileSystemProviderInternalFunction::FileSystemProviderInternalFunction()
+    : request_id_(0), request_manager_(NULL) {
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalFunction::RejectRequest(
+    std::unique_ptr<chromeos::file_system_provider::RequestValue> value,
+    base::File::Error error) {
+  const base::File::Error result =
+      request_manager_->RejectRequest(request_id_, std::move(value), error);
+  if (result != base::File::FILE_OK)
+    return RespondNow(Error(FileErrorToString(result)));
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalFunction::FulfillRequest(
+    std::unique_ptr<RequestValue> value,
+    bool has_more) {
+  const base::File::Error result =
+      request_manager_->FulfillRequest(request_id_, std::move(value), has_more);
+  if (result != base::File::FILE_OK)
+    return RespondNow(Error(FileErrorToString(result)));
+  return RespondNow(NoArguments());
+}
+
+bool FileSystemProviderInternalFunction::PreRunValidation(std::string* error) {
+  if (!UIThreadExtensionFunction::PreRunValidation(error))
+    return false;
+
+  std::string file_system_id;
+
+  EXTENSION_FUNCTION_PRERUN_VALIDATE(args_->GetString(0, &file_system_id));
+  EXTENSION_FUNCTION_PRERUN_VALIDATE(args_->GetInteger(1, &request_id_));
+
+  Service* service = Service::Get(browser_context());
+  if (!service) {
+    *error = "File system provider service not found.";
+    return false;
+  }
+
+  ProvidedFileSystemInterface* file_system = service->GetProvidedFileSystem(
+      ProviderId::CreateFromExtensionId(extension_id()), file_system_id);
+  if (!file_system) {
+    *error = FileErrorToString(base::File::FILE_ERROR_NOT_FOUND);
+    return false;
+  }
+
+  request_manager_ = file_system->GetRequestManager();
+  return true;
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_system_provider/provider_function.h b/chrome/browser/extensions/api/file_system_provider/provider_function.h
new file mode 100644
index 0000000000000..7c3f6bdf4480b
--- /dev/null
+++ b/chrome/browser/extensions/api/file_system_provider/provider_function.h
@@ -0,0 +1,79 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_FILE_SYSTEM_PROVIDER_PROVIDER_FUNCTION_H_
+#define CHROME_BROWSER_EXTENSIONS_FILE_SYSTEM_PROVIDER_PROVIDER_FUNCTION_H_
+
+#include <memory>
+#include <string>
+
+#include "base/files/file.h"
+#include "chrome/browser/extensions/chrome_extension_function.h"
+#include "chrome/common/extensions/api/file_system_provider.h"
+
+namespace chromeos {
+namespace file_system_provider {
+
+class RequestManager;
+class RequestValue;
+
+}  // namespace file_system_provider
+}  // namespace chromeos
+
+namespace extensions {
+
+// Error names from
+// http://www.w3.org/TR/file-system-api/#errors-and-exceptions
+extern const char kNotFoundErrorName[];
+extern const char kSecurityErrorName[];
+
+// Error messages.
+extern const char kEmptyNameErrorMessage[];
+extern const char kEmptyIdErrorMessage[];
+extern const char kMountFailedErrorMessage[];
+extern const char kUnmountFailedErrorMessage[];
+extern const char kResponseFailedErrorMessage[];
+
+// Creates an identifier from |error|. For FILE_OK, an empty string is returned.
+// These values are passed to JavaScript as lastError.message value.
+std::string FileErrorToString(base::File::Error error);
+
+// Converts ProviderError to base::File::Error. This could be redundant, if it
+// was possible to create DOMError instances in Javascript easily.
+base::File::Error ProviderErrorToFileError(
+    api::file_system_provider::ProviderError error);
+
+// Base class for internal API functions handling request results, either
+// a success or a failure.
+class FileSystemProviderInternalFunction : public UIThreadExtensionFunction {
+ public:
+  FileSystemProviderInternalFunction();
+
+ protected:
+  ~FileSystemProviderInternalFunction() override {}
+
+  // Rejects the request and returns a response for this API function.
+  ResponseAction RejectRequest(
+      std::unique_ptr<chromeos::file_system_provider::RequestValue> value,
+      base::File::Error error);
+
+  // Fulfills the request with parsed arguments of this API function
+  // encapsulated as a RequestValue instance and returns a response.
+  // If |has_more| is set to true, then the function will be called again for
+  // this request.
+  ResponseAction FulfillRequest(
+      std::unique_ptr<chromeos::file_system_provider::RequestValue> value,
+      bool has_more);
+
+ private:
+  // Guarantees |request_id_| and |request_manager_| are valid.
+  bool PreRunValidation(std::string* error) override;
+
+  int request_id_;
+  chromeos::file_system_provider::RequestManager* request_manager_;
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_FILE_SYSTEM_PROVIDER_PROVIDER_FUNCTION_H_

From 5c6566bea4b12cdd1ded69b2550ade21d6b3603b Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Mon, 27 Aug 2018 11:21:17 +0900
Subject: [PATCH 23/32] Make file manager path to updated common path

It updated file manager build path to updated path under
chrome/browser/, not chrome/browser/chromeos/
---
 chrome/browser/BUILD.gn                       |  71 ++++++++-
 .../browser/chrome_content_browser_client.cc  |   6 +-
 chrome/browser/chromeos/BUILD.gn              | 135 +++---------------
 ...nt_file_system_async_file_util_unittest.cc |   2 +-
 ...arc_content_file_system_backend_delegate.h |   2 +-
 .../arc_content_file_system_url_util.cc       |   2 +-
 ...c_content_file_system_url_util_unittest.cc |   2 +-
 .../arc_documents_provider_backend_delegate.h |   2 +-
 .../arc/fileapi/arc_file_system_bridge.cc     |   4 +-
 .../chromeos/crostini/crostini_manager.cc     |   4 +-
 .../drive/drive_integration_service.cc        |   2 +-
 .../chromeos/drive/file_task_executor.h       |   2 +-
 .../drivefs_file_system_backend_delegate.h    |   2 +-
 .../fileapi/file_system_backend_delegate.h    |   2 +-
 .../chromeos/extensions/wallpaper_api.cc      |   2 +-
 .../extensions/wallpaper_private_api.cc       |   2 +-
 .../fileapi/backend_delegate.h                |   2 +-
 .../buffering_file_stream_reader_unittest.cc  |   2 +-
 .../chromeos/login/kiosk_browsertest.cc       |   2 +-
 chrome/browser/chromeos/note_taking_helper.cc |   2 +-
 .../chromeos/note_taking_helper_unittest.cc   |   2 +-
 chrome/browser/download/download_prefs.cc     |   2 +-
 chrome/browser/exo_parts.cc                   |   7 +-
 chrome/browser/extensions/BUILD.gn            |  37 +++++
 ...on_native_file_system_delegate_chromeos.cc |   2 +-
 .../chrome_file_system_delegate.cc            |   2 +-
 .../api/file_system/consent_provider.cc       |   4 +-
 .../file_system/consent_provider_unittest.cc  |   2 +-
 .../file_system_apitest_chromeos.cc           |   2 +-
 .../request_file_system_notification.cc       |   2 +-
 .../image_writer_private/operation_manager.cc |   2 +-
 ...able_storage_provider_chromeos_unittest.cc |   2 +-
 .../webstore_widget_private_api.cc            |   2 +-
 ...browser_context_keyed_service_factories.cc |   2 +-
 chrome/browser/extensions/extension_util.cc   |   2 +-
 chrome/browser/file_select_helper.cc          |   2 +-
 chrome/browser/platform_util_chromeos.cc      |   2 +-
 chrome/browser/platform_util_unittest.cc      |   6 +-
 chrome/browser/profiles/profile_io_data.cc    |   2 +-
 .../zip_archiver/test/zip_archiver_jstest.cc  |   2 +-
 chrome/browser/translate/translate_service.cc |   2 +-
 .../translate/translate_service_unittest.cc   |   2 +-
 .../ui/app_list/app_list_syncable_service.cc  |   2 +-
 .../ui/ash/chrome_new_window_client.cc        |   2 +-
 .../ui/ash/chrome_screenshot_grabber.cc       |   2 +-
 chrome/browser/ui/browser.cc                  |   2 +-
 .../ui/views/select_file_dialog_extension.cc  |   8 +-
 ...elect_file_dialog_extension_browsertest.cc |   2 +-
 .../ui/webui/chromeos/drive_internals_ui.cc   |   2 +-
 .../webui/net_internals/net_internals_ui.cc   |   2 +-
 .../chromeos/device_storage_handler.cc        |   2 +-
 .../ui/webui/settings/downloads_handler.cc    |   2 +-
 .../api/file_browser_handler_internal.json    |   2 +-
 .../extensions/api/file_manager_private.idl   |   2 +-
 .../api/file_manager_private_internal.idl     |   2 +-
 .../extensions/api/file_system_provider.idl   |   8 +-
 .../api/file_system_provider_internal.idl     |   2 +-
 chrome/test/BUILD.gn                          |  42 +++---
 58 files changed, 214 insertions(+), 210 deletions(-)

diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
index 53fc8c723b21a..3ba619cd7ff2b 100644
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -3038,6 +3038,67 @@ jumbo_split_static_library("browser") {
       "download/notification/download_notification_manager.h",
       "feedback/feedback_util_chromeos.cc",
       "feedback/feedback_util_chromeos.h",
+      "file_manager/app_id.h",
+      "file_manager/arc_file_tasks.cc",
+      "file_manager/arc_file_tasks.h",
+      "file_manager/crostini_file_tasks.cc",
+      "file_manager/crostini_file_tasks.h",
+      "file_manager/file_browser_handlers.cc",
+      "file_manager/file_browser_handlers.h",
+      "file_manager/file_tasks.cc",
+      "file_manager/file_tasks.h",
+      "file_manager/file_watcher.cc",
+      "file_manager/file_watcher.h",
+      "file_manager/fileapi_util.cc",
+      "file_manager/fileapi_util.h",
+      "file_manager/filesystem_api_util.cc",
+      "file_manager/filesystem_api_util.h",
+      "file_manager/open_util.cc",
+      "file_manager/open_util.h",
+      "file_manager/open_with_browser.cc",
+      "file_manager/open_with_browser.h",
+      "file_manager/path_util.cc",
+      "file_manager/path_util.h",
+      "file_manager/select_file_dialog_util.cc",
+      "file_manager/select_file_dialog_util.h",
+      "file_manager/snapshot_manager.cc",
+      "file_manager/snapshot_manager.h",
+      "file_manager/url_util.cc",
+      "file_manager/url_util.h",
+      "file_manager/volume_manager.cc",
+      "file_manager/volume_manager.h",
+      "file_manager/volume_manager_factory.cc",
+      "file_manager/volume_manager_factory.h",
+      "file_manager/volume_manager_observer.h",
+      "fileapi/external_file_protocol_handler.cc",
+      "fileapi/external_file_protocol_handler.h",
+      "fileapi/external_file_url_request_job.cc",
+      "fileapi/external_file_url_request_job.h",
+      "fileapi/external_file_url_util.cc",
+      "fileapi/external_file_url_util.h",
+      "fileapi/file_access_permissions.cc",
+      "fileapi/file_access_permissions.h",
+      "fileapi/file_system_backend.cc",
+      "fileapi/file_system_backend.h",
+      "fileapi/file_system_backend_delegate.h",
+      "fileapi/mtp_file_system_backend_delegate.cc",
+      "fileapi/mtp_file_system_backend_delegate.h",
+      "fileapi/mtp_watcher_manager.cc",
+      "fileapi/mtp_watcher_manager.h",
+      "fileapi/recent_arc_media_source.cc",
+      "fileapi/recent_arc_media_source.h",
+      "fileapi/recent_download_source.cc",
+      "fileapi/recent_download_source.h",
+      "fileapi/recent_drive_source.cc",
+      "fileapi/recent_drive_source.h",
+      "fileapi/recent_file.cc",
+      "fileapi/recent_file.h",
+      "fileapi/recent_model.cc",
+      "fileapi/recent_model.h",
+      "fileapi/recent_model_factory.cc",
+      "fileapi/recent_model_factory.h",
+      "fileapi/recent_source.cc",
+      "fileapi/recent_source.h",
       "media/chromeos_login_media_access_handler.cc",
       "media/chromeos_login_media_access_handler.h",
       "media/public_session_media_access_handler.cc",
@@ -3104,6 +3165,7 @@ jumbo_split_static_library("browser") {
       "//services/ui/public/cpp/input_devices:input_device_controller",
       "//services/ui/ws2:lib",
       "//services/ws/public/mojom",
+      "//ui/file_manager",
       "//ui/ozone",
     ]
     allow_circular_includes_from += [ "//chrome/browser/chromeos" ]
@@ -5031,8 +5093,6 @@ static_library("test_support") {
       "chromeos/app_mode/fake_cws.h",
       "chromeos/arc/extensions/fake_arc_support.cc",
       "chromeos/arc/extensions/fake_arc_support.h",
-      "chromeos/file_manager/fake_disk_mount_manager.cc",
-      "chromeos/file_manager/fake_disk_mount_manager.h",
       "chromeos/input_method/mock_candidate_window_controller.cc",
       "chromeos/input_method/mock_candidate_window_controller.h",
       "chromeos/input_method/mock_input_method_engine.cc",
@@ -5075,9 +5135,14 @@ static_library("test_support") {
       "chromeos/settings/device_settings_test_helper.h",
       "chromeos/settings/stub_install_attributes.cc",
       "chromeos/settings/stub_install_attributes.h",
+      "file_manager/fake_disk_mount_manager.cc",
+      "file_manager/fake_disk_mount_manager.h",
     ]
     configs += [ "//build/config/linux/dbus" ]
-    deps += [ "//chromeos:test_support" ]
+    deps += [
+      "//chromeos:test_support",
+      "//ui/file_manager/file_manager/test:create_test_main"
+    ]
   }
 
   if (is_mac && !mac_views_browser) {
diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
index 6d029466f0d4d..b691b9a3c6009 100644
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -317,10 +317,7 @@
 #include "chrome/browser/chromeos/chrome_service_name.h"
 #include "chrome/browser/chromeos/drive/fileapi/drivefs_file_system_backend_delegate.h"
 #include "chrome/browser/chromeos/drive/fileapi/file_system_backend_delegate.h"
-#include "chrome/browser/chromeos/file_manager/app_id.h"
 #include "chrome/browser/chromeos/file_system_provider/fileapi/backend_delegate.h"
-#include "chrome/browser/chromeos/fileapi/file_system_backend.h"
-#include "chrome/browser/chromeos/fileapi/mtp_file_system_backend_delegate.h"
 #include "chrome/browser/chromeos/login/signin/merge_session_navigation_throttle.h"
 #include "chrome/browser/chromeos/login/signin/merge_session_throttling_utils.h"
 #include "chrome/browser/chromeos/login/signin_partition_manager.h"
@@ -328,6 +325,9 @@
 #include "chrome/browser/chromeos/policy/browser_policy_connector_chromeos.h"
 #include "chrome/browser/chromeos/profiles/profile_helper.h"
 #include "chrome/browser/chromeos/system/input_device_settings.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/fileapi/file_system_backend.h"
+#include "chrome/browser/fileapi/mtp_file_system_backend_delegate.h"
 #include "chrome/browser/ui/ash/chrome_browser_main_extra_parts_ash.h"
 #include "chrome/browser/ui/ash/tablet_mode_client.h"
 #include "chrome/browser/ui/browser_dialogs.h"
diff --git a/chrome/browser/chromeos/BUILD.gn b/chrome/browser/chromeos/BUILD.gn
index 41d9e544c7a6f..21bf0b69d1236 100644
--- a/chrome/browser/chromeos/BUILD.gn
+++ b/chrome/browser/chromeos/BUILD.gn
@@ -225,7 +225,6 @@ source_set("chromeos") {
     "//ui/events/blink",
     "//ui/events/devices",
     "//ui/events/platform",
-    "//ui/file_manager",
     "//ui/keyboard",
     "//ui/keyboard:mojom",
     "//ui/message_center",
@@ -694,38 +693,6 @@ source_set("chromeos") {
     "external_metrics.h",
     "external_protocol_dialog.cc",
     "external_protocol_dialog.h",
-    "file_manager/app_id.h",
-    "file_manager/arc_file_tasks.cc",
-    "file_manager/arc_file_tasks.h",
-    "file_manager/crostini_file_tasks.cc",
-    "file_manager/crostini_file_tasks.h",
-    "file_manager/file_browser_handlers.cc",
-    "file_manager/file_browser_handlers.h",
-    "file_manager/file_tasks.cc",
-    "file_manager/file_tasks.h",
-    "file_manager/file_watcher.cc",
-    "file_manager/file_watcher.h",
-    "file_manager/fileapi_util.cc",
-    "file_manager/fileapi_util.h",
-    "file_manager/filesystem_api_util.cc",
-    "file_manager/filesystem_api_util.h",
-    "file_manager/open_util.cc",
-    "file_manager/open_util.h",
-    "file_manager/open_with_browser.cc",
-    "file_manager/open_with_browser.h",
-    "file_manager/path_util.cc",
-    "file_manager/path_util.h",
-    "file_manager/select_file_dialog_util.cc",
-    "file_manager/select_file_dialog_util.h",
-    "file_manager/snapshot_manager.cc",
-    "file_manager/snapshot_manager.h",
-    "file_manager/url_util.cc",
-    "file_manager/url_util.h",
-    "file_manager/volume_manager.cc",
-    "file_manager/volume_manager.h",
-    "file_manager/volume_manager_factory.cc",
-    "file_manager/volume_manager_factory.h",
-    "file_manager/volume_manager_observer.h",
     "file_system_provider/abort_callback.h",
     "file_system_provider/extension_provider.cc",
     "file_system_provider/extension_provider.h",
@@ -820,35 +787,6 @@ source_set("chromeos") {
     "file_system_provider/throttled_file_system.h",
     "file_system_provider/watcher.cc",
     "file_system_provider/watcher.h",
-    "fileapi/external_file_protocol_handler.cc",
-    "fileapi/external_file_protocol_handler.h",
-    "fileapi/external_file_url_request_job.cc",
-    "fileapi/external_file_url_request_job.h",
-    "fileapi/external_file_url_util.cc",
-    "fileapi/external_file_url_util.h",
-    "fileapi/file_access_permissions.cc",
-    "fileapi/file_access_permissions.h",
-    "fileapi/file_system_backend.cc",
-    "fileapi/file_system_backend.h",
-    "fileapi/file_system_backend_delegate.h",
-    "fileapi/mtp_file_system_backend_delegate.cc",
-    "fileapi/mtp_file_system_backend_delegate.h",
-    "fileapi/mtp_watcher_manager.cc",
-    "fileapi/mtp_watcher_manager.h",
-    "fileapi/recent_arc_media_source.cc",
-    "fileapi/recent_arc_media_source.h",
-    "fileapi/recent_download_source.cc",
-    "fileapi/recent_download_source.h",
-    "fileapi/recent_drive_source.cc",
-    "fileapi/recent_drive_source.h",
-    "fileapi/recent_file.cc",
-    "fileapi/recent_file.h",
-    "fileapi/recent_model.cc",
-    "fileapi/recent_model.h",
-    "fileapi/recent_model_factory.cc",
-    "fileapi/recent_model_factory.h",
-    "fileapi/recent_source.cc",
-    "fileapi/recent_source.h",
     "first_run/drive_first_run_controller.cc",
     "first_run/drive_first_run_controller.h",
     "first_run/first_run.cc",
@@ -1809,43 +1747,6 @@ source_set("chromeos") {
     "extensions/backdrop_wallpaper_handlers/backdrop_wallpaper_handlers.h",
     "extensions/echo_private_api.cc",
     "extensions/echo_private_api.h",
-    "extensions/file_manager/device_event_router.cc",
-    "extensions/file_manager/device_event_router.h",
-    "extensions/file_manager/drivefs_event_router.cc",
-    "extensions/file_manager/drivefs_event_router.h",
-    "extensions/file_manager/event_router.cc",
-    "extensions/file_manager/event_router.h",
-    "extensions/file_manager/event_router_factory.cc",
-    "extensions/file_manager/event_router_factory.h",
-    "extensions/file_manager/file_browser_handler_api.cc",
-    "extensions/file_manager/file_browser_handler_api.h",
-    "extensions/file_manager/file_manager_private_api_functions.h",
-    "extensions/file_manager/file_stream_md5_digester.cc",
-    "extensions/file_manager/file_stream_md5_digester.h",
-    "extensions/file_manager/job_event_router.cc",
-    "extensions/file_manager/job_event_router.h",
-    "extensions/file_manager/private_api_base.cc",
-    "extensions/file_manager/private_api_base.h",
-    "extensions/file_manager/private_api_dialog.cc",
-    "extensions/file_manager/private_api_dialog.h",
-    "extensions/file_manager/private_api_drive.cc",
-    "extensions/file_manager/private_api_drive.h",
-    "extensions/file_manager/private_api_file_system.cc",
-    "extensions/file_manager/private_api_file_system.h",
-    "extensions/file_manager/private_api_misc.cc",
-    "extensions/file_manager/private_api_misc.h",
-    "extensions/file_manager/private_api_mount.cc",
-    "extensions/file_manager/private_api_mount.h",
-    "extensions/file_manager/private_api_strings.cc",
-    "extensions/file_manager/private_api_strings.h",
-    "extensions/file_manager/private_api_tasks.cc",
-    "extensions/file_manager/private_api_tasks.h",
-    "extensions/file_manager/private_api_util.cc",
-    "extensions/file_manager/private_api_util.h",
-    "extensions/file_system_provider/file_system_provider_api.cc",
-    "extensions/file_system_provider/file_system_provider_api.h",
-    "extensions/file_system_provider/provider_function.cc",
-    "extensions/file_system_provider/provider_function.h",
     "extensions/first_run_private_api.cc",
     "extensions/first_run_private_api.h",
     "extensions/input_method_api.cc",
@@ -2056,9 +1957,9 @@ source_set("unit_tests") {
     "extensions/device_local_account_management_policy_provider_unittest.cc",
     "extensions/extension_tab_util_delegate_chromeos_unittest.cc",
     "extensions/external_cache_impl_unittest.cc",
-    "extensions/file_manager/device_event_router_unittest.cc",
-    "extensions/file_manager/drivefs_event_router_unittest.cc",
-    "extensions/file_manager/job_event_router_unittest.cc",
+    "../extensions/api/file_manager/device_event_router_unittest.cc",
+    "../extensions/api/file_manager/drivefs_event_router_unittest.cc",
+    "../extensions/api/file_manager/job_event_router_unittest.cc",
     "extensions/gfx_utils_unittest.cc",
     "extensions/permissions_updater_delegate_chromeos_unittest.cc",
     "extensions/public_session_permission_helper_unittest.cc",
@@ -2066,13 +1967,13 @@ source_set("unit_tests") {
     "extensions/signin_screen_policy_provider_unittest.cc",
     "extensions/wallpaper_private_api_unittest.cc",
     "external_metrics_unittest.cc",
-    "file_manager/file_tasks_unittest.cc",
-    "file_manager/file_watcher_unittest.cc",
-    "file_manager/fileapi_util_unittest.cc",
-    "file_manager/mount_test_util.cc",
-    "file_manager/path_util_unittest.cc",
-    "file_manager/url_util_unittest.cc",
-    "file_manager/volume_manager_unittest.cc",
+    "../file_manager/file_tasks_unittest.cc",
+    "../file_manager/file_watcher_unittest.cc",
+    "../file_manager/fileapi_util_unittest.cc",
+    "../file_manager/mount_test_util.cc",
+    "../file_manager/path_util_unittest.cc",
+    "../file_manager/url_util_unittest.cc",
+    "../file_manager/volume_manager_unittest.cc",
     "file_system_provider/fake_extension_provider.cc",
     "file_system_provider/fake_extension_provider.h",
     "file_system_provider/fake_provided_file_system.cc",
@@ -2115,14 +2016,14 @@ source_set("unit_tests") {
     "file_system_provider/scoped_file_opener_unittest.cc",
     "file_system_provider/service_unittest.cc",
     "file_system_provider/throttled_file_system_unittest.cc",
-    "fileapi/external_file_url_request_job_unittest.cc",
-    "fileapi/external_file_url_util_unittest.cc",
-    "fileapi/file_access_permissions_unittest.cc",
-    "fileapi/file_system_backend_unittest.cc",
-    "fileapi/recent_arc_media_source_unittest.cc",
-    "fileapi/recent_download_source_unittest.cc",
-    "fileapi/recent_model_unittest.cc",
-    "fileapi/test/fake_recent_source.cc",
+    "../fileapi/external_file_url_request_job_unittest.cc",
+    "../fileapi/external_file_url_util_unittest.cc",
+    "../fileapi/file_access_permissions_unittest.cc",
+    "../fileapi/file_system_backend_unittest.cc",
+    "../fileapi/recent_arc_media_source_unittest.cc",
+    "../fileapi/recent_download_source_unittest.cc",
+    "../fileapi/recent_model_unittest.cc",
+    "../fileapi/test/fake_recent_source.cc",
     "hats/hats_finch_helper_unittest.cc",
     "hats/hats_notification_controller_unittest.cc",
     "input_method/browser_state_monitor_unittest.cc",
diff --git a/chrome/browser/chromeos/arc/fileapi/arc_content_file_system_async_file_util_unittest.cc b/chrome/browser/chromeos/arc/fileapi/arc_content_file_system_async_file_util_unittest.cc
index d80a74f2b0ac9..64eec7a32e57f 100644
--- a/chrome/browser/chromeos/arc/fileapi/arc_content_file_system_async_file_util_unittest.cc
+++ b/chrome/browser/chromeos/arc/fileapi/arc_content_file_system_async_file_util_unittest.cc
@@ -13,7 +13,7 @@
 #include "chrome/browser/chromeos/arc/fileapi/arc_content_file_system_async_file_util.h"
 #include "chrome/browser/chromeos/arc/fileapi/arc_content_file_system_url_util.h"
 #include "chrome/browser/chromeos/arc/fileapi/arc_file_system_operation_runner.h"
-#include "chrome/browser/chromeos/fileapi/external_file_url_util.h"
+#include "chrome/browser/fileapi/external_file_url_util.h"
 #include "chrome/test/base/testing_profile.h"
 #include "components/arc/arc_bridge_service.h"
 #include "components/arc/arc_service_manager.h"
diff --git a/chrome/browser/chromeos/arc/fileapi/arc_content_file_system_backend_delegate.h b/chrome/browser/chromeos/arc/fileapi/arc_content_file_system_backend_delegate.h
index 66a6503dd3929..fce767ab8ed72 100644
--- a/chrome/browser/chromeos/arc/fileapi/arc_content_file_system_backend_delegate.h
+++ b/chrome/browser/chromeos/arc/fileapi/arc_content_file_system_backend_delegate.h
@@ -8,7 +8,7 @@
 #include <memory>
 
 #include "base/macros.h"
-#include "chrome/browser/chromeos/fileapi/file_system_backend_delegate.h"
+#include "chrome/browser/fileapi/file_system_backend_delegate.h"
 
 namespace arc {
 
diff --git a/chrome/browser/chromeos/arc/fileapi/arc_content_file_system_url_util.cc b/chrome/browser/chromeos/arc/fileapi/arc_content_file_system_url_util.cc
index c0a9a8c3c5e98..aed595a36d053 100644
--- a/chrome/browser/chromeos/arc/fileapi/arc_content_file_system_url_util.cc
+++ b/chrome/browser/chromeos/arc/fileapi/arc_content_file_system_url_util.cc
@@ -5,7 +5,7 @@
 #include "chrome/browser/chromeos/arc/fileapi/arc_content_file_system_url_util.h"
 
 #include "base/files/file_path.h"
-#include "chrome/browser/chromeos/fileapi/external_file_url_util.h"
+#include "chrome/browser/fileapi/external_file_url_util.h"
 #include "net/base/escape.h"
 #include "storage/browser/fileapi/file_system_url.h"
 
diff --git a/chrome/browser/chromeos/arc/fileapi/arc_content_file_system_url_util_unittest.cc b/chrome/browser/chromeos/arc/fileapi/arc_content_file_system_url_util_unittest.cc
index e58c0f567a698..ec3f86ee56fd3 100644
--- a/chrome/browser/chromeos/arc/fileapi/arc_content_file_system_url_util_unittest.cc
+++ b/chrome/browser/chromeos/arc/fileapi/arc_content_file_system_url_util_unittest.cc
@@ -4,7 +4,7 @@
 
 #include "base/strings/utf_string_conversions.h"
 #include "chrome/browser/chromeos/arc/fileapi/arc_content_file_system_url_util.h"
-#include "chrome/browser/chromeos/fileapi/external_file_url_util.h"
+#include "chrome/browser/fileapi/external_file_url_util.h"
 #include "content/public/common/url_constants.h"
 #include "storage/browser/fileapi/file_system_url.h"
 #include "testing/gtest/include/gtest/gtest.h"
diff --git a/chrome/browser/chromeos/arc/fileapi/arc_documents_provider_backend_delegate.h b/chrome/browser/chromeos/arc/fileapi/arc_documents_provider_backend_delegate.h
index 667c39749a4eb..259731454693e 100644
--- a/chrome/browser/chromeos/arc/fileapi/arc_documents_provider_backend_delegate.h
+++ b/chrome/browser/chromeos/arc/fileapi/arc_documents_provider_backend_delegate.h
@@ -11,7 +11,7 @@
 #include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_async_file_util.h"
 #include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_root_map.h"
 #include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_watcher_manager.h"
-#include "chrome/browser/chromeos/fileapi/file_system_backend_delegate.h"
+#include "chrome/browser/fileapi/file_system_backend_delegate.h"
 
 namespace arc {
 
diff --git a/chrome/browser/chromeos/arc/fileapi/arc_file_system_bridge.cc b/chrome/browser/chromeos/arc/fileapi/arc_file_system_bridge.cc
index 9f9ab3dcc762c..3c929cf903d50 100644
--- a/chrome/browser/chromeos/arc/fileapi/arc_file_system_bridge.cc
+++ b/chrome/browser/chromeos/arc/fileapi/arc_file_system_bridge.cc
@@ -10,8 +10,8 @@
 #include "base/memory/singleton.h"
 #include "chrome/browser/chromeos/arc/fileapi/chrome_content_provider_url_util.h"
 #include "chrome/browser/chromeos/arc/fileapi/file_stream_forwarder.h"
-#include "chrome/browser/chromeos/file_manager/fileapi_util.h"
-#include "chrome/browser/chromeos/fileapi/external_file_url_util.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/fileapi/external_file_url_util.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chromeos/dbus/dbus_thread_manager.h"
 #include "chromeos/dbus/virtual_file_provider_client.h"
diff --git a/chrome/browser/chromeos/crostini/crostini_manager.cc b/chrome/browser/chromeos/crostini/crostini_manager.cc
index 4177cfba04445..db347040bb323 100644
--- a/chrome/browser/chromeos/crostini/crostini_manager.cc
+++ b/chrome/browser/chromeos/crostini/crostini_manager.cc
@@ -16,8 +16,8 @@
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/chromeos/crostini/crostini_remover.h"
 #include "chrome/browser/chromeos/crostini/crostini_util.h"
-#include "chrome/browser/chromeos/file_manager/path_util.h"
-#include "chrome/browser/chromeos/file_manager/volume_manager.h"
+#include "chrome/browser/file_manager/path_util.h"
+#include "chrome/browser/file_manager/volume_manager.h"
 #include "chrome/browser/chromeos/profiles/profile_helper.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/profiles/profile_manager.h"
diff --git a/chrome/browser/chromeos/drive/drive_integration_service.cc b/chrome/browser/chromeos/drive/drive_integration_service.cc
index 1e07e24d76a77..ff56078939701 100644
--- a/chrome/browser/chromeos/drive/drive_integration_service.cc
+++ b/chrome/browser/chromeos/drive/drive_integration_service.cc
@@ -22,13 +22,13 @@
 #include "chrome/browser/chromeos/drive/debug_info_collector.h"
 #include "chrome/browser/chromeos/drive/download_handler.h"
 #include "chrome/browser/chromeos/drive/file_system_util.h"
-#include "chrome/browser/chromeos/file_manager/path_util.h"
 #include "chrome/browser/chromeos/profiles/profile_helper.h"
 #include "chrome/browser/chromeos/profiles/profile_util.h"
 #include "chrome/browser/download/download_core_service_factory.h"
 #include "chrome/browser/download/download_prefs.h"
 #include "chrome/browser/drive/drive_notification_manager_factory.h"
 #include "chrome/browser/net/system_network_context_manager.h"
+#include "chrome/browser/file_manager/path_util.h"
 #include "chrome/browser/profiles/incognito_helpers.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/signin/profile_oauth2_token_service_factory.h"
diff --git a/chrome/browser/chromeos/drive/file_task_executor.h b/chrome/browser/chromeos/drive/file_task_executor.h
index 1868b7cb1db46..d716404a9efaf 100644
--- a/chrome/browser/chromeos/drive/file_task_executor.h
+++ b/chrome/browser/chromeos/drive/file_task_executor.h
@@ -10,7 +10,7 @@
 
 #include "base/callback.h"
 #include "base/memory/weak_ptr.h"
-#include "chrome/browser/chromeos/file_manager/file_tasks.h"
+#include "chrome/browser/file_manager/file_tasks.h"
 #include "components/drive/file_errors.h"
 #include "google_apis/drive/drive_api_error_codes.h"
 
diff --git a/chrome/browser/chromeos/drive/fileapi/drivefs_file_system_backend_delegate.h b/chrome/browser/chromeos/drive/fileapi/drivefs_file_system_backend_delegate.h
index ac3b249b7c437..6f5e85f90255c 100644
--- a/chrome/browser/chromeos/drive/fileapi/drivefs_file_system_backend_delegate.h
+++ b/chrome/browser/chromeos/drive/fileapi/drivefs_file_system_backend_delegate.h
@@ -10,7 +10,7 @@
 #include <memory>
 
 #include "base/macros.h"
-#include "chrome/browser/chromeos/fileapi/file_system_backend_delegate.h"
+#include "chrome/browser/fileapi/file_system_backend_delegate.h"
 
 namespace storage {
 class AsyncFileUtil;
diff --git a/chrome/browser/chromeos/drive/fileapi/file_system_backend_delegate.h b/chrome/browser/chromeos/drive/fileapi/file_system_backend_delegate.h
index 6ac4027e6a168..bcbdf074f227d 100644
--- a/chrome/browser/chromeos/drive/fileapi/file_system_backend_delegate.h
+++ b/chrome/browser/chromeos/drive/fileapi/file_system_backend_delegate.h
@@ -10,7 +10,7 @@
 #include <memory>
 
 #include "base/macros.h"
-#include "chrome/browser/chromeos/fileapi/file_system_backend_delegate.h"
+#include "chrome/browser/fileapi/file_system_backend_delegate.h"
 
 namespace storage {
 class AsyncFileUtil;
diff --git a/chrome/browser/chromeos/extensions/wallpaper_api.cc b/chrome/browser/chromeos/extensions/wallpaper_api.cc
index 544179b9f06b5..95d5242fde228 100644
--- a/chrome/browser/chromeos/extensions/wallpaper_api.cc
+++ b/chrome/browser/chromeos/extensions/wallpaper_api.cc
@@ -18,8 +18,8 @@
 #include "base/values.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/chromeos/extensions/wallpaper_private_api.h"
-#include "chrome/browser/chromeos/file_manager/app_id.h"
 #include "chrome/browser/chromeos/profiles/profile_helper.h"
+#include "chrome/browser/file_manager/app_id.h"
 #include "chrome/browser/net/system_network_context_manager.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/ui/ash/wallpaper_controller_client.h"
diff --git a/chrome/browser/chromeos/extensions/wallpaper_private_api.cc b/chrome/browser/chromeos/extensions/wallpaper_private_api.cc
index 4472ac90202f4..4199c4e87cb4b 100644
--- a/chrome/browser/chromeos/extensions/wallpaper_private_api.cc
+++ b/chrome/browser/chromeos/extensions/wallpaper_private_api.cc
@@ -25,8 +25,8 @@
 #include "base/values.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/chromeos/extensions/backdrop_wallpaper_handlers/backdrop_wallpaper_handlers.h"
-#include "chrome/browser/chromeos/file_manager/path_util.h"
 #include "chrome/browser/chromeos/profiles/profile_helper.h"
+#include "chrome/browser/file_manager/path_util.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/sync/profile_sync_service_factory.h"
 #include "chrome/browser/ui/ash/wallpaper_controller_client.h"
diff --git a/chrome/browser/chromeos/file_system_provider/fileapi/backend_delegate.h b/chrome/browser/chromeos/file_system_provider/fileapi/backend_delegate.h
index 151acfbc69f85..3b7ee895883dd 100644
--- a/chrome/browser/chromeos/file_system_provider/fileapi/backend_delegate.h
+++ b/chrome/browser/chromeos/file_system_provider/fileapi/backend_delegate.h
@@ -11,7 +11,7 @@
 
 #include "base/files/file_util.h"
 #include "base/macros.h"
-#include "chrome/browser/chromeos/fileapi/file_system_backend_delegate.h"
+#include "chrome/browser/fileapi/file_system_backend_delegate.h"
 
 namespace storage {
 class AsyncFileUtil;
diff --git a/chrome/browser/chromeos/file_system_provider/fileapi/buffering_file_stream_reader_unittest.cc b/chrome/browser/chromeos/file_system_provider/fileapi/buffering_file_stream_reader_unittest.cc
index 10c1c8e59930b..e0cfd718ac0d2 100644
--- a/chrome/browser/chromeos/file_system_provider/fileapi/buffering_file_stream_reader_unittest.cc
+++ b/chrome/browser/chromeos/file_system_provider/fileapi/buffering_file_stream_reader_unittest.cc
@@ -15,7 +15,7 @@
 #include "base/memory/ref_counted.h"
 #include "base/run_loop.h"
 #include "base/threading/thread_task_runner_handle.h"
-#include "chrome/browser/chromeos/fileapi/file_system_backend.h"
+#include "chrome/browser/fileapi/file_system_backend.h"
 #include "content/public/test/test_browser_thread_bundle.h"
 #include "net/base/io_buffer.h"
 #include "net/base/net_errors.h"
diff --git a/chrome/browser/chromeos/login/kiosk_browsertest.cc b/chrome/browser/chromeos/login/kiosk_browsertest.cc
index 5bc35d9fc9b1d..90194e4febfce 100644
--- a/chrome/browser/chromeos/login/kiosk_browsertest.cc
+++ b/chrome/browser/chromeos/login/kiosk_browsertest.cc
@@ -21,7 +21,6 @@
 #include "chrome/browser/chromeos/app_mode/fake_cws.h"
 #include "chrome/browser/chromeos/app_mode/kiosk_app_launch_error.h"
 #include "chrome/browser/chromeos/app_mode/kiosk_app_manager.h"
-#include "chrome/browser/chromeos/file_manager/fake_disk_mount_manager.h"
 #include "chrome/browser/chromeos/login/app_launch_controller.h"
 #include "chrome/browser/chromeos/login/startup_utils.h"
 #include "chrome/browser/chromeos/login/test/oobe_base_test.h"
@@ -40,6 +39,7 @@
 #include "chrome/browser/chromeos/settings/scoped_cros_settings_test_helper.h"
 #include "chrome/browser/extensions/browsertest_util.h"
 #include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/file_manager/fake_disk_mount_manager.h"
 #include "chrome/browser/profiles/profile_impl.h"
 #include "chrome/browser/profiles/profile_manager.h"
 #include "chrome/browser/profiles/profiles_state.h"
diff --git a/chrome/browser/chromeos/note_taking_helper.cc b/chrome/browser/chromeos/note_taking_helper.cc
index 574ca89aa1855..45ae646dd105b 100644
--- a/chrome/browser/chromeos/note_taking_helper.cc
+++ b/chrome/browser/chromeos/note_taking_helper.cc
@@ -20,9 +20,9 @@
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/chrome_notification_types.h"
 #include "chrome/browser/chromeos/arc/arc_util.h"
-#include "chrome/browser/chromeos/file_manager/path_util.h"
 #include "chrome/browser/chromeos/lock_screen_apps/state_controller.h"
 #include "chrome/browser/chromeos/note_taking_controller_client.h"
+#include "chrome/browser/file_manager/path_util.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/profiles/profile_manager.h"
 #include "chrome/common/pref_names.h"
diff --git a/chrome/browser/chromeos/note_taking_helper_unittest.cc b/chrome/browser/chromeos/note_taking_helper_unittest.cc
index 6d0cdddc685b6..e68f70d11a149 100644
--- a/chrome/browser/chromeos/note_taking_helper_unittest.cc
+++ b/chrome/browser/chromeos/note_taking_helper_unittest.cc
@@ -17,10 +17,10 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/test/metrics/histogram_tester.h"
 #include "chrome/browser/chrome_notification_types.h"
-#include "chrome/browser/chromeos/file_manager/path_util.h"
 #include "chrome/browser/chromeos/note_taking_controller_client.h"
 #include "chrome/browser/extensions/extension_service.h"
 #include "chrome/browser/extensions/test_extension_system.h"
+#include "chrome/browser/file_manager/path_util.h"
 #include "chrome/browser/prefs/browser_prefs.h"
 #include "chrome/browser/ui/app_list/arc/arc_app_test.h"
 #include "chrome/common/pref_names.h"
diff --git a/chrome/browser/download/download_prefs.cc b/chrome/browser/download/download_prefs.cc
index 24b096ffc5d47..cb505da2125cc 100644
--- a/chrome/browser/download/download_prefs.cc
+++ b/chrome/browser/download/download_prefs.cc
@@ -44,7 +44,7 @@
 #if defined(OS_CHROMEOS)
 #include "chrome/browser/chromeos/drive/drive_integration_service.h"
 #include "chrome/browser/chromeos/drive/file_system_util.h"
-#include "chrome/browser/chromeos/file_manager/path_util.h"
+#include "chrome/browser/file_manager/path_util.h"
 #include "chromeos/dbus/cros_disks_client.h"
 #endif
 
diff --git a/chrome/browser/exo_parts.cc b/chrome/browser/exo_parts.cc
index 6029e489c8e31..724f5978fe5a3 100644
--- a/chrome/browser/exo_parts.cc
+++ b/chrome/browser/exo_parts.cc
@@ -11,10 +11,11 @@
 #include "base/command_line.h"
 #include "base/macros.h"
 #include "base/memory/ptr_util.h"
-#include "chrome/browser/chromeos/file_manager/app_id.h"
-#include "chrome/browser/chromeos/file_manager/fileapi_util.h"
-#include "chrome/browser/chromeos/file_manager/path_util.h"
 #include "chrome/browser/chromeos/profiles/profile_helper.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/path_util.h"
+#include "chrome/browser/ui/ash/ash_util.h"
 #include "chrome/common/chrome_switches.h"
 #include "components/exo/file_helper.h"
 #include "components/user_manager/user_manager.h"
diff --git a/chrome/browser/extensions/BUILD.gn b/chrome/browser/extensions/BUILD.gn
index ea57b69658060..adc169a240563 100644
--- a/chrome/browser/extensions/BUILD.gn
+++ b/chrome/browser/extensions/BUILD.gn
@@ -941,10 +941,47 @@ jumbo_static_library("extensions") {
       "api/enterprise_platform_keys/enterprise_platform_keys_api.h",
       "api/enterprise_platform_keys_private/enterprise_platform_keys_private_api.cc",
       "api/enterprise_platform_keys_private/enterprise_platform_keys_private_api.h",
+      "api/file_manager/device_event_router.cc",
+      "api/file_manager/device_event_router.h",
+      "api/file_manager/drivefs_event_router.cc",
+      "api/file_manager/drivefs_event_router.h",
+      "api/file_manager/event_router.cc",
+      "api/file_manager/event_router.h",
+      "api/file_manager/event_router_factory.cc",
+      "api/file_manager/event_router_factory.h",
+      "api/file_manager/file_browser_handler_api.cc",
+      "api/file_manager/file_browser_handler_api.h",
+      "api/file_manager/file_manager_private_api_functions.h",
+      "api/file_manager/file_stream_md5_digester.cc",
+      "api/file_manager/file_stream_md5_digester.h",
+      "api/file_manager/job_event_router.cc",
+      "api/file_manager/job_event_router.h",
+      "api/file_manager/private_api_base.cc",
+      "api/file_manager/private_api_base.h",
+      "api/file_manager/private_api_dialog.cc",
+      "api/file_manager/private_api_dialog.h",
+      "api/file_manager/private_api_drive.cc",
+      "api/file_manager/private_api_drive.h",
+      "api/file_manager/private_api_file_system.cc",
+      "api/file_manager/private_api_file_system.h",
+      "api/file_manager/private_api_misc.cc",
+      "api/file_manager/private_api_misc.h",
+      "api/file_manager/private_api_mount.cc",
+      "api/file_manager/private_api_mount.h",
+      "api/file_manager/private_api_strings.cc",
+      "api/file_manager/private_api_strings.h",
+      "api/file_manager/private_api_tasks.cc",
+      "api/file_manager/private_api_tasks.h",
+      "api/file_manager/private_api_util.cc",
+      "api/file_manager/private_api_util.h",
       "api/file_system/consent_provider.cc",
       "api/file_system/consent_provider.h",
       "api/file_system/request_file_system_notification.cc",
       "api/file_system/request_file_system_notification.h",
+      "api/file_system_provider/file_system_provider_api.cc",
+      "api/file_system_provider/file_system_provider_api.h",
+      "api/file_system_provider/provider_function.cc",
+      "api/file_system_provider/provider_function.h",
       "api/input_ime/input_ime_api.cc",
       "api/input_ime/input_ime_api.h",
       "api/input_ime/input_ime_api_chromeos.cc",
diff --git a/chrome/browser/extensions/api/file_handlers/non_native_file_system_delegate_chromeos.cc b/chrome/browser/extensions/api/file_handlers/non_native_file_system_delegate_chromeos.cc
index dfbcd313c47f8..0ffb2a3dae4fb 100644
--- a/chrome/browser/extensions/api/file_handlers/non_native_file_system_delegate_chromeos.cc
+++ b/chrome/browser/extensions/api/file_handlers/non_native_file_system_delegate_chromeos.cc
@@ -4,7 +4,7 @@
 
 #include "chrome/browser/extensions/api/file_handlers/non_native_file_system_delegate_chromeos.h"
 
-#include "chrome/browser/chromeos/file_manager/filesystem_api_util.h"
+#include "chrome/browser/file_manager/filesystem_api_util.h"
 #include "chrome/browser/profiles/profile.h"
 #include "content/public/browser/browser_context.h"
 
diff --git a/chrome/browser/extensions/api/file_system/chrome_file_system_delegate.cc b/chrome/browser/extensions/api/file_system/chrome_file_system_delegate.cc
index 0c631b3bc98de..e2db9cd71c515 100644
--- a/chrome/browser/extensions/api/file_system/chrome_file_system_delegate.cc
+++ b/chrome/browser/extensions/api/file_system/chrome_file_system_delegate.cc
@@ -48,8 +48,8 @@
 #endif
 
 #if defined(OS_CHROMEOS)
-#include "chrome/browser/chromeos/file_manager/volume_manager.h"
 #include "chrome/browser/extensions/api/file_system/consent_provider.h"
+#include "chrome/browser/file_manager/volume_manager.h"
 #include "extensions/browser/event_router.h"
 #include "extensions/browser/extension_registry.h"
 #include "extensions/common/constants.h"
diff --git a/chrome/browser/extensions/api/file_system/consent_provider.cc b/chrome/browser/extensions/api/file_system/consent_provider.cc
index f024101b05c15..698cbab114675 100644
--- a/chrome/browser/extensions/api/file_system/consent_provider.cc
+++ b/chrome/browser/extensions/api/file_system/consent_provider.cc
@@ -11,9 +11,9 @@
 #include "base/logging.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "chrome/browser/chromeos/app_mode/kiosk_app_manager.h"
-#include "chrome/browser/chromeos/file_manager/app_id.h"
-#include "chrome/browser/chromeos/file_manager/volume_manager.h"
 #include "chrome/browser/extensions/api/file_system/request_file_system_notification.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/volume_manager.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/ui/views/extensions/request_file_system_dialog_view.h"
 #include "components/user_manager/user_manager.h"
diff --git a/chrome/browser/extensions/api/file_system/consent_provider_unittest.cc b/chrome/browser/extensions/api/file_system/consent_provider_unittest.cc
index e5c4f100360b8..a811b2f375cd5 100644
--- a/chrome/browser/extensions/api/file_system/consent_provider_unittest.cc
+++ b/chrome/browser/extensions/api/file_system/consent_provider_unittest.cc
@@ -12,8 +12,8 @@
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 #include "base/run_loop.h"
-#include "chrome/browser/chromeos/file_manager/volume_manager.h"
 #include "chrome/browser/chromeos/login/users/fake_chrome_user_manager.h"
+#include "chrome/browser/file_manager/volume_manager.h"
 #include "chrome/test/base/testing_browser_process.h"
 #include "components/prefs/testing_pref_service.h"
 #include "components/user_manager/scoped_user_manager.h"
diff --git a/chrome/browser/extensions/api/file_system/file_system_apitest_chromeos.cc b/chrome/browser/extensions/api/file_system/file_system_apitest_chromeos.cc
index a1706c7cf1c8f..5a36855fe7cd7 100644
--- a/chrome/browser/extensions/api/file_system/file_system_apitest_chromeos.cc
+++ b/chrome/browser/extensions/api/file_system/file_system_apitest_chromeos.cc
@@ -13,11 +13,11 @@
 #include "chrome/browser/apps/platform_apps/app_browsertest_util.h"
 #include "chrome/browser/chromeos/drive/drive_integration_service.h"
 #include "chrome/browser/chromeos/drive/file_system_util.h"
-#include "chrome/browser/chromeos/file_manager/volume_manager.h"
 #include "chrome/browser/chromeos/login/users/fake_chrome_user_manager.h"
 #include "chrome/browser/chromeos/profiles/profile_helper.h"
 #include "chrome/browser/extensions/api/file_system/consent_provider.h"
 #include "chrome/browser/extensions/component_loader.h"
+#include "chrome/browser/file_manager/volume_manager.h"
 #include "chrome/common/chrome_paths.h"
 #include "components/drive/chromeos/file_system_interface.h"
 #include "components/drive/service/fake_drive_service.h"
diff --git a/chrome/browser/extensions/api/file_system/request_file_system_notification.cc b/chrome/browser/extensions/api/file_system/request_file_system_notification.cc
index 0815a0b59075f..10765f93c8140 100644
--- a/chrome/browser/extensions/api/file_system/request_file_system_notification.cc
+++ b/chrome/browser/extensions/api/file_system/request_file_system_notification.cc
@@ -12,8 +12,8 @@
 #include "base/strings/string16.h"
 #include "base/strings/utf_string_conversions.h"
 #include "chrome/browser/browser_process.h"
-#include "chrome/browser/chromeos/file_manager/volume_manager.h"
 #include "chrome/browser/extensions/chrome_app_icon_loader.h"
+#include "chrome/browser/file_manager/volume_manager.h"
 #include "chrome/browser/notifications/notification_display_service.h"
 #include "chrome/browser/ui/app_icon_loader.h"
 #include "chrome/grit/generated_resources.h"
diff --git a/chrome/browser/extensions/api/image_writer_private/operation_manager.cc b/chrome/browser/extensions/api/image_writer_private/operation_manager.cc
index 037e29ae33852..5e186852f45af 100644
--- a/chrome/browser/extensions/api/image_writer_private/operation_manager.cc
+++ b/chrome/browser/extensions/api/image_writer_private/operation_manager.cc
@@ -28,7 +28,7 @@
 #include "services/service_manager/public/cpp/connector.h"
 
 #if defined(OS_CHROMEOS)
-#include "chrome/browser/chromeos/file_manager/path_util.h"
+#include "chrome/browser/file_manager/path_util.h"
 #endif
 
 namespace image_writer_api = extensions::api::image_writer_private;
diff --git a/chrome/browser/extensions/api/image_writer_private/removable_storage_provider_chromeos_unittest.cc b/chrome/browser/extensions/api/image_writer_private/removable_storage_provider_chromeos_unittest.cc
index bbbea6ddf8b18..6f46fbfebddf3 100644
--- a/chrome/browser/extensions/api/image_writer_private/removable_storage_provider_chromeos_unittest.cc
+++ b/chrome/browser/extensions/api/image_writer_private/removable_storage_provider_chromeos_unittest.cc
@@ -7,8 +7,8 @@
 #include "base/bind.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_task_environment.h"
-#include "chrome/browser/extensions/api/image_writer_private/removable_storage_provider.h"
 #include "chromeos/disks/mock_disk_mount_manager.h"
+#include "chrome/browser/extensions/api/image_writer_private/removable_storage_provider.h"
 #include "content/public/test/test_browser_thread_bundle.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
diff --git a/chrome/browser/extensions/api/webstore_widget_private/webstore_widget_private_api.cc b/chrome/browser/extensions/api/webstore_widget_private/webstore_widget_private_api.cc
index f8f5aa30cb9dd..49c764dde954c 100644
--- a/chrome/browser/extensions/api/webstore_widget_private/webstore_widget_private_api.cc
+++ b/chrome/browser/extensions/api/webstore_widget_private/webstore_widget_private_api.cc
@@ -9,8 +9,8 @@
 
 #include "base/values.h"
 #include "chrome/browser/browser_process.h"
-#include "chrome/browser/chromeos/file_manager/app_id.h"
 #include "chrome/browser/extensions/api/webstore_widget_private/app_installer.h"
+#include "chrome/browser/file_manager/app_id.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/common/extensions/api/webstore_widget_private.h"
 #include "chrome/grit/generated_resources.h"
diff --git a/chrome/browser/extensions/browser_context_keyed_service_factories.cc b/chrome/browser/extensions/browser_context_keyed_service_factories.cc
index ff3c53bce7076..1edec6c65d7a5 100644
--- a/chrome/browser/extensions/browser_context_keyed_service_factories.cc
+++ b/chrome/browser/extensions/browser_context_keyed_service_factories.cc
@@ -53,9 +53,9 @@
 
 #if defined(OS_CHROMEOS)
 #include "chrome/browser/chromeos/extensions/arc_apps_private_api.h"
-#include "chrome/browser/chromeos/extensions/file_manager/event_router_factory.h"
 #include "chrome/browser/chromeos/extensions/input_method_api.h"
 #include "chrome/browser/chromeos/extensions/media_player_api.h"
+#include "chrome/browser/extensions/api/file_manager/event_router_factory.h"
 #include "chrome/browser/extensions/api/input_ime/input_ime_api.h"
 #include "chrome/browser/extensions/api/screenlock_private/screenlock_private_api.h"
 #elif defined(OS_LINUX) || defined(OS_WIN)
diff --git a/chrome/browser/extensions/extension_util.cc b/chrome/browser/extensions/extension_util.cc
index 6354931738e79..6cb74a47cbf5d 100644
--- a/chrome/browser/extensions/extension_util.cc
+++ b/chrome/browser/extensions/extension_util.cc
@@ -44,7 +44,7 @@
 #include "url/gurl.h"
 
 #if defined(OS_CHROMEOS)
-#include "chrome/browser/chromeos/file_manager/app_id.h"
+#include "chrome/browser/file_manager/app_id.h"
 #endif
 
 namespace extensions {
diff --git a/chrome/browser/file_select_helper.cc b/chrome/browser/file_select_helper.cc
index c3cacbad338a9..5683fc6263e2b 100644
--- a/chrome/browser/file_select_helper.cc
+++ b/chrome/browser/file_select_helper.cc
@@ -42,7 +42,7 @@
 #include "ui/shell_dialogs/selected_file_info.h"
 
 #if defined(OS_CHROMEOS)
-#include "chrome/browser/chromeos/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
 #include "content/public/browser/site_instance.h"
 #endif
 
diff --git a/chrome/browser/platform_util_chromeos.cc b/chrome/browser/platform_util_chromeos.cc
index 700049c4c86a3..8571a45f2019c 100644
--- a/chrome/browser/platform_util_chromeos.cc
+++ b/chrome/browser/platform_util_chromeos.cc
@@ -6,7 +6,7 @@
 
 #include "base/bind.h"
 #include "base/files/file_path.h"
-#include "chrome/browser/chromeos/file_manager/open_util.h"
+#include "chrome/browser/file_manager/open_util.h"
 #include "chrome/browser/platform_util_internal.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_finder.h"
diff --git a/chrome/browser/platform_util_unittest.cc b/chrome/browser/platform_util_unittest.cc
index 528c97dbcfaad..b285866260562 100644
--- a/chrome/browser/platform_util_unittest.cc
+++ b/chrome/browser/platform_util_unittest.cc
@@ -20,9 +20,9 @@
 #include "base/json/json_string_value_serializer.h"
 #include "base/values.h"
 #include "chrome/browser/chrome_content_browser_client.h"
-#include "chrome/browser/chromeos/file_manager/app_id.h"
-#include "chrome/browser/chromeos/fileapi/file_system_backend.h"
-#include "chrome/browser/chromeos/fileapi/file_system_backend_delegate.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/fileapi/file_system_backend.h"
+#include "chrome/browser/fileapi/file_system_backend_delegate.h"
 #include "chrome/browser/extensions/extension_special_storage_policy.h"
 #include "chrome/test/base/browser_with_test_window_test.h"
 #include "content/public/browser/browser_context.h"
diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index b6ba476cbf1fc..048a8dbcd2a03 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -130,7 +130,6 @@
 #include "chrome/browser/chromeos/certificate_provider/certificate_provider.h"
 #include "chrome/browser/chromeos/certificate_provider/certificate_provider_service.h"
 #include "chrome/browser/chromeos/certificate_provider/certificate_provider_service_factory.h"
-#include "chrome/browser/chromeos/fileapi/external_file_protocol_handler.h"
 #include "chrome/browser/chromeos/login/startup_utils.h"
 #include "chrome/browser/chromeos/net/cert_verify_proc_chromeos.h"
 #include "chrome/browser/chromeos/net/client_cert_filter_chromeos.h"
@@ -140,6 +139,7 @@
 #include "chrome/browser/chromeos/policy/policy_cert_verifier.h"
 #include "chrome/browser/chromeos/profiles/profile_helper.h"
 #include "chrome/browser/chromeos/settings/cros_settings.h"
+#include "chrome/browser/fileapi/external_file_protocol_handler.h"
 #include "chrome/browser/net/nss_context.h"
 #include "chromeos/chromeos_switches.h"
 #include "chromeos/dbus/cryptohome_client.h"
diff --git a/chrome/browser/resources/chromeos/zip_archiver/test/zip_archiver_jstest.cc b/chrome/browser/resources/chromeos/zip_archiver/test/zip_archiver_jstest.cc
index ece1a279d9966..7d1ec4cf872b5 100644
--- a/chrome/browser/resources/chromeos/zip_archiver/test/zip_archiver_jstest.cc
+++ b/chrome/browser/resources/chromeos/zip_archiver/test/zip_archiver_jstest.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "chrome/browser/chromeos/file_manager/file_manager_jstest_base.h"
+#include "chrome/browser/file_manager/file_manager_jstest_base.h"
 
 class ZipArchiverJsTest : public FileManagerJsTestBase {
  protected:
diff --git a/chrome/browser/translate/translate_service.cc b/chrome/browser/translate/translate_service.cc
index 14be91b661919..084bb870aaaac 100644
--- a/chrome/browser/translate/translate_service.cc
+++ b/chrome/browser/translate/translate_service.cc
@@ -24,7 +24,7 @@
 #include "url/gurl.h"
 
 #if defined(OS_CHROMEOS)
-#include "chrome/browser/chromeos/file_manager/app_id.h"
+#include "chrome/browser/file_manager/app_id.h"
 #include "extensions/common/constants.h"
 #endif
 
diff --git a/chrome/browser/translate/translate_service_unittest.cc b/chrome/browser/translate/translate_service_unittest.cc
index 99c79b53711d0..c9b8cf8698cf7 100644
--- a/chrome/browser/translate/translate_service_unittest.cc
+++ b/chrome/browser/translate/translate_service_unittest.cc
@@ -15,7 +15,7 @@
 #include "url/gurl.h"
 
 #if defined(OS_CHROMEOS)
-#include "chrome/browser/chromeos/file_manager/app_id.h"
+#include "chrome/browser/file_manager/app_id.h"
 #include "extensions/common/constants.h"
 #endif
 
diff --git a/chrome/browser/ui/app_list/app_list_syncable_service.cc b/chrome/browser/ui/app_list/app_list_syncable_service.cc
index a1c4a0500f993..b06858e794c7d 100644
--- a/chrome/browser/ui/app_list/app_list_syncable_service.cc
+++ b/chrome/browser/ui/app_list/app_list_syncable_service.cc
@@ -17,9 +17,9 @@
 #include "build/build_config.h"
 #include "chrome/browser/chromeos/arc/arc_util.h"
 #include "chrome/browser/chromeos/crostini/crostini_util.h"
-#include "chrome/browser/chromeos/file_manager/app_id.h"
 #include "chrome/browser/chromeos/genius_app/app_id.h"
 #include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/file_manager/app_id.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/ui/app_list/app_list_client_impl.h"
 #include "chrome/browser/ui/app_list/app_list_model_updater.h"
diff --git a/chrome/browser/ui/ash/chrome_new_window_client.cc b/chrome/browser/ui/ash/chrome_new_window_client.cc
index 5e526479795f5..52d5a5bf65086 100644
--- a/chrome/browser/ui/ash/chrome_new_window_client.cc
+++ b/chrome/browser/ui/ash/chrome_new_window_client.cc
@@ -10,7 +10,7 @@
 #include "base/macros.h"
 #include "chrome/browser/chromeos/arc/arc_web_contents_data.h"
 #include "chrome/browser/chromeos/arc/fileapi/arc_content_file_system_url_util.h"
-#include "chrome/browser/chromeos/file_manager/app_id.h"
+#include "chrome/browser/file_manager/app_id.h"
 #include "chrome/browser/extensions/api/terminal/terminal_extension_helper.h"
 #include "chrome/browser/extensions/extension_service.h"
 #include "chrome/browser/extensions/extension_util.h"
diff --git a/chrome/browser/ui/ash/chrome_screenshot_grabber.cc b/chrome/browser/ui/ash/chrome_screenshot_grabber.cc
index c0056e4ff15e5..4f43b8cc9029c 100644
--- a/chrome/browser/ui/ash/chrome_screenshot_grabber.cc
+++ b/chrome/browser/ui/ash/chrome_screenshot_grabber.cc
@@ -28,9 +28,9 @@
 #include "build/build_config.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/chromeos/drive/file_system_util.h"
-#include "chrome/browser/chromeos/file_manager/open_util.h"
 #include "chrome/browser/chromeos/note_taking_helper.h"
 #include "chrome/browser/download/download_prefs.h"
+#include "chrome/browser/file_manager/open_util.h"
 #include "chrome/browser/notifications/notification_display_service.h"
 #include "chrome/browser/platform_util.h"
 #include "chrome/browser/profiles/profile.h"
diff --git a/chrome/browser/ui/browser.cc b/chrome/browser/ui/browser.cc
index 46f438211f43a..2dd1199844714 100644
--- a/chrome/browser/ui/browser.cc
+++ b/chrome/browser/ui/browser.cc
@@ -234,7 +234,7 @@
 #endif  // OS_WIN
 
 #if defined(OS_CHROMEOS)
-#include "chrome/browser/chromeos/fileapi/external_file_url_util.h"
+#include "chrome/browser/fileapi/external_file_url_util.h"
 #include "chrome/browser/ui/settings_window_manager_chromeos.h"
 #endif
 
diff --git a/chrome/browser/ui/views/select_file_dialog_extension.cc b/chrome/browser/ui/views/select_file_dialog_extension.cc
index 60efdab806f42..0f3aac219fad4 100644
--- a/chrome/browser/ui/views/select_file_dialog_extension.cc
+++ b/chrome/browser/ui/views/select_file_dialog_extension.cc
@@ -14,13 +14,13 @@
 #include "base/threading/thread_task_runner_handle.h"
 #include "chrome/browser/app_mode/app_mode_utils.h"
 #include "chrome/browser/apps/platform_apps/app_window_registry_util.h"
-#include "chrome/browser/chromeos/file_manager/app_id.h"
-#include "chrome/browser/chromeos/file_manager/fileapi_util.h"
-#include "chrome/browser/chromeos/file_manager/select_file_dialog_util.h"
-#include "chrome/browser/chromeos/file_manager/url_util.h"
 #include "chrome/browser/chromeos/login/ui/login_web_dialog.h"
 #include "chrome/browser/extensions/extension_service.h"
 #include "chrome/browser/extensions/extension_view_host.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/select_file_dialog_util.h"
+#include "chrome/browser/file_manager/url_util.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/profiles/profile_manager.h"
 #include "chrome/browser/sessions/session_tab_helper.h"
diff --git a/chrome/browser/ui/views/select_file_dialog_extension_browsertest.cc b/chrome/browser/ui/views/select_file_dialog_extension_browsertest.cc
index 1191156280522..11d7582a0fb17 100644
--- a/chrome/browser/ui/views/select_file_dialog_extension_browsertest.cc
+++ b/chrome/browser/ui/views/select_file_dialog_extension_browsertest.cc
@@ -14,9 +14,9 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/threading/platform_thread.h"
 #include "build/build_config.h"
-#include "chrome/browser/chromeos/file_manager/volume_manager.h"
 #include "chrome/browser/extensions/component_loader.h"
 #include "chrome/browser/extensions/extension_browsertest.h"
+#include "chrome/browser/file_manager/volume_manager.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_navigator.h"
diff --git a/chrome/browser/ui/webui/chromeos/drive_internals_ui.cc b/chrome/browser/ui/webui/chromeos/drive_internals_ui.cc
index 13c32f05652ee..662f616025c39 100644
--- a/chrome/browser/ui/webui/chromeos/drive_internals_ui.cc
+++ b/chrome/browser/ui/webui/chromeos/drive_internals_ui.cc
@@ -26,8 +26,8 @@
 #include "chrome/browser/chromeos/drive/debug_info_collector.h"
 #include "chrome/browser/chromeos/drive/drive_integration_service.h"
 #include "chrome/browser/chromeos/drive/file_system_util.h"
-#include "chrome/browser/chromeos/file_manager/path_util.h"
 #include "chrome/browser/drive/drive_notification_manager_factory.h"
+#include "chrome/browser/file_manager/path_util.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/common/pref_names.h"
 #include "chrome/common/url_constants.h"
diff --git a/chrome/browser/ui/webui/net_internals/net_internals_ui.cc b/chrome/browser/ui/webui/net_internals/net_internals_ui.cc
index 76652731b9269..716b2abdfa38f 100644
--- a/chrome/browser/ui/webui/net_internals/net_internals_ui.cc
+++ b/chrome/browser/ui/webui/net_internals/net_internals_ui.cc
@@ -75,9 +75,9 @@
 #include "services/network/expect_ct_reporter.h"
 
 #if defined(OS_CHROMEOS)
-#include "chrome/browser/chromeos/file_manager/filesystem_api_util.h"
 #include "chrome/browser/chromeos/profiles/profile_helper.h"
 #include "chrome/browser/chromeos/system_logs/debug_log_writer.h"
+#include "chrome/browser/file_manager/filesystem_api_util.h"
 #include "chrome/browser/net/nss_context.h"
 #include "chromeos/dbus/dbus_thread_manager.h"
 #include "chromeos/dbus/debug_daemon_client.h"
diff --git a/chrome/browser/ui/webui/settings/chromeos/device_storage_handler.cc b/chrome/browser/ui/webui/settings/chromeos/device_storage_handler.cc
index cf29c54876531..cf4ebbacb6b23 100644
--- a/chrome/browser/ui/webui/settings/chromeos/device_storage_handler.cc
+++ b/chrome/browser/ui/webui/settings/chromeos/device_storage_handler.cc
@@ -27,7 +27,7 @@
 #include "chrome/browser/chromeos/crostini/crostini_manager.h"
 #include "chrome/browser/chromeos/crostini/crostini_util.h"
 #include "chrome/browser/chromeos/drive/file_system_util.h"
-#include "chrome/browser/chromeos/file_manager/path_util.h"
+#include "chrome/browser/file_manager/path_util.h"
 #include "chrome/browser/platform_util.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/grit/generated_resources.h"
diff --git a/chrome/browser/ui/webui/settings/downloads_handler.cc b/chrome/browser/ui/webui/settings/downloads_handler.cc
index 61d21286ab990..8754759148d7f 100644
--- a/chrome/browser/ui/webui/settings/downloads_handler.cc
+++ b/chrome/browser/ui/webui/settings/downloads_handler.cc
@@ -19,7 +19,7 @@
 #include "ui/base/l10n/l10n_util.h"
 
 #if defined(OS_CHROMEOS)
-#include "chrome/browser/chromeos/file_manager/path_util.h"
+#include "chrome/browser/file_manager/path_util.h"
 #endif
 
 using base::UserMetricsAction;
diff --git a/chrome/common/extensions/api/file_browser_handler_internal.json b/chrome/common/extensions/api/file_browser_handler_internal.json
index b3023e4eaad9a..2a8fed6581a41 100644
--- a/chrome/common/extensions/api/file_browser_handler_internal.json
+++ b/chrome/common/extensions/api/file_browser_handler_internal.json
@@ -6,7 +6,7 @@
   {
     "namespace": "fileBrowserHandlerInternal",
     "compiler_options": {
-      "implemented_in": "chrome/browser/chromeos/extensions/file_manager/file_browser_handler_api.h"
+      "implemented_in": "chrome/browser/extensions/api/file_manager/file_browser_handler_api.h"
     },
     "description": "none",
     "types": [
diff --git a/chrome/common/extensions/api/file_manager_private.idl b/chrome/common/extensions/api/file_manager_private.idl
index 1b0e015e11fa5..eeb5a8279f08f 100644
--- a/chrome/common/extensions/api/file_manager_private.idl
+++ b/chrome/common/extensions/api/file_manager_private.idl
@@ -5,7 +5,7 @@
 // fileManagerPrivate API.
 // This is a private API used by the file browser of ChromeOS.
 [platforms=("chromeos"),
- implemented_in="chrome/browser/chromeos/extensions/file_manager/file_manager_private_api_functions.h"]
+ implemented_in="chrome/browser/extensions/api/file_manager/file_manager_private_api_functions.h"]
 namespace fileManagerPrivate {
 // Type of the mounted volume.
 enum VolumeType { drive, downloads, removable, archive, provided, mtp,
diff --git a/chrome/common/extensions/api/file_manager_private_internal.idl b/chrome/common/extensions/api/file_manager_private_internal.idl
index 5a53b4561bde6..0a936477b7ce6 100644
--- a/chrome/common/extensions/api/file_manager_private_internal.idl
+++ b/chrome/common/extensions/api/file_manager_private_internal.idl
@@ -4,7 +4,7 @@
 
 // Internal, used by fileManagerPrivate's custom bindings.
 [platforms=("chromeos"),
- implemented_in="chrome/browser/chromeos/extensions/file_manager/file_manager_private_api_functions.h"]
+ implemented_in="chrome/browser/extensions/api/file_manager/file_manager_private_api_functions.h"]
 namespace fileManagerPrivateInternal {
   // Entry information that renderers need to create an Entry instance.
   dictionary EntryDescription {
diff --git a/chrome/common/extensions/api/file_system_provider.idl b/chrome/common/extensions/api/file_system_provider.idl
index 59eacf0586404..dd125d10c03c2 100644
--- a/chrome/common/extensions/api/file_system_provider.idl
+++ b/chrome/common/extensions/api/file_system_provider.idl
@@ -4,7 +4,7 @@
 
 // Use the <code>chrome.fileSystemProvider</code> API to create file systems,
 // that can be accessible from the file manager on Chrome OS.
-[implemented_in="chrome/browser/chromeos/extensions/file_system_provider/file_system_provider_api.h"]
+[implemented_in="chrome/browser/extensions/api/file_system_provider/file_system_provider_api.h"]
 namespace fileSystemProvider {
   // Error codes used by providing extensions in response to requests as well
   // as in case of errors when calling methods of the API. For success,
@@ -110,7 +110,7 @@ namespace fileSystemProvider {
     // The identifier of the file system.
     DOMString fileSystemId;
 
-    // A human-readable name for the file system. 
+    // A human-readable name for the file system.
     DOMString displayName;
 
     // Whether the file system supports operations which may change contents
@@ -138,7 +138,7 @@ namespace fileSystemProvider {
     // extension.
     DOMString fileSystemId;
 
-    // A human-readable name for the file system. 
+    // A human-readable name for the file system.
     DOMString displayName;
 
     // Whether the file system supports operations which may change contents
@@ -224,7 +224,7 @@ namespace fileSystemProvider {
     // The unique identifier of this request.
     long requestId;
 
-    // The path of the directory which contents are requested. 
+    // The path of the directory which contents are requested.
     DOMString directoryPath;
 
     // Set to <code>true</code> if <code>is_directory</code> value is requested.
diff --git a/chrome/common/extensions/api/file_system_provider_internal.idl b/chrome/common/extensions/api/file_system_provider_internal.idl
index df9250269e962..171f02f2a9e6a 100644
--- a/chrome/common/extensions/api/file_system_provider_internal.idl
+++ b/chrome/common/extensions/api/file_system_provider_internal.idl
@@ -4,7 +4,7 @@
 
 // Internal, used by fileSystemProvider's custom bindings. These functions are
 // called when events' callbacks are invoked.
-[implemented_in="chrome/browser/chromeos/extensions/file_system_provider/file_system_provider_api.h",
+[implemented_in="chrome/browser/extensions/api/file_system_provider/file_system_provider_api.h",
  nodoc]
 namespace fileSystemProviderInternal {
   interface Functions {
diff --git a/chrome/test/BUILD.gn b/chrome/test/BUILD.gn
index 29b8e326fe3c6..47804454340ad 100644
--- a/chrome/test/BUILD.gn
+++ b/chrome/test/BUILD.gn
@@ -1617,33 +1617,12 @@ test("browser_tests") {
         "../browser/chromeos/extensions/default_keyboard_extension_browser_test.cc",
         "../browser/chromeos/extensions/default_keyboard_extension_browser_test.h",
         "../browser/chromeos/extensions/echo_private_apitest.cc",
-        "../browser/chromeos/extensions/file_manager/file_browser_handler_api_test.cc",
-        "../browser/chromeos/extensions/file_manager/file_manager_private_apitest.cc",
-        "../browser/chromeos/extensions/file_system_provider/file_system_provider_apitest.cc",
         "../browser/chromeos/extensions/info_private_apitest.cc",
         "../browser/chromeos/extensions/input_method_apitest_chromeos.cc",
         "../browser/chromeos/extensions/users_private/users_private_apitest.cc",
         "../browser/chromeos/extensions/wallpaper_apitest.cc",
         "../browser/chromeos/extensions/wallpaper_manager_browsertest.cc",
         "../browser/chromeos/extensions/wallpaper_private_apitest.cc",
-        "../browser/chromeos/file_manager/audio_player_browsertest.cc",
-        "../browser/chromeos/file_manager/external_filesystem_apitest.cc",
-        "../browser/chromeos/file_manager/file_manager_browsertest.cc",
-        "../browser/chromeos/file_manager/file_manager_browsertest_base.cc",
-        "../browser/chromeos/file_manager/file_manager_browsertest_base.h",
-        "../browser/chromeos/file_manager/file_manager_jstest.cc",
-        "../browser/chromeos/file_manager/file_manager_jstest_base.cc",
-        "../browser/chromeos/file_manager/file_manager_jstest_base.h",
-        "../browser/chromeos/file_manager/file_manager_test_util.cc",
-        "../browser/chromeos/file_manager/file_manager_test_util.h",
-        "../browser/chromeos/file_manager/file_manager_uitest.cc",
-        "../browser/chromeos/file_manager/file_tasks_browsertest.cc",
-        "../browser/chromeos/file_manager/gallery_browsertest.cc",
-        "../browser/chromeos/file_manager/gallery_jstest.cc",
-        "../browser/chromeos/file_manager/image_loader_jstest.cc",
-        "../browser/chromeos/file_manager/mount_test_util.cc",
-        "../browser/chromeos/file_manager/mount_test_util.h",
-        "../browser/chromeos/file_manager/video_player_browsertest.cc",
         "../browser/chromeos/first_run/chromeos_first_run_browsertest.cc",
         "../browser/chromeos/first_run/drive_first_run_browsertest.cc",
         "../browser/chromeos/first_run/goodies_displayer_browsertest.cc",
@@ -1758,11 +1737,32 @@ test("browser_tests") {
         "../browser/chromeos/system/tray_accessibility_browsertest.cc",
         "../browser/drive/drive_notification_manager_factory_browsertest.cc",
         "../browser/extensions/api/certificate_provider/certificate_provider_apitest.cc",
+        "../browser/extensions/api/file_manager/file_browser_handler_api_test.cc",
+        "../browser/extensions/api/file_manager/file_manager_private_apitest.cc",
+        "../browser/extensions/api/file_system_provider/file_system_provider_apitest.cc",
         "../browser/extensions/api/networking_private/networking_private_apitest.cc",
         "../browser/extensions/api/networking_private/networking_private_chromeos_apitest.cc",
         "../browser/extensions/api/screenlock_private/screenlock_private_apitest.cc",
         "../browser/extensions/api/vpn_provider/vpn_provider_apitest.cc",
         "../browser/extensions/chromeos_component_extensions_browsertest.cc",
+        "../browser/file_manager/audio_player_browsertest.cc",
+        "../browser/file_manager/external_filesystem_apitest.cc",
+        "../browser/file_manager/file_manager_browsertest.cc",
+        "../browser/file_manager/file_manager_browsertest_base.cc",
+        "../browser/file_manager/file_manager_browsertest_base.h",
+        "../browser/file_manager/file_manager_jstest.cc",
+        "../browser/file_manager/file_manager_jstest_base.cc",
+        "../browser/file_manager/file_manager_jstest_base.h",
+        "../browser/file_manager/file_manager_test_util.cc",
+        "../browser/file_manager/file_manager_test_util.h",
+        "../browser/file_manager/file_manager_uitest.cc",
+        "../browser/file_manager/file_tasks_browsertest.cc",
+        "../browser/file_manager/gallery_browsertest.cc",
+        "../browser/file_manager/gallery_jstest.cc",
+        "../browser/file_manager/image_loader_jstest.cc",
+        "../browser/file_manager/mount_test_util.cc",
+        "../browser/file_manager/mount_test_util.h",
+        "../browser/file_manager/video_player_browsertest.cc",
         "../browser/notifications/chrome_ash_message_center_client_browsertest.cc",
         "../browser/notifications/notification_platform_bridge_chromeos_browsertest.cc",
         "../browser/resources/chromeos/zip_archiver/test/zip_archiver_jstest.cc",

From db363010a66ecd28998379c4d4479bcd0f5f8f07 Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Tue, 14 Aug 2018 20:41:22 +0900
Subject: [PATCH 24/32] Add platform folder to chrome/browser/file_manager

As file_manager has many features specific to ChromeOs,
it adds platform folder to handle it separately.

It's still not included for building.
---
 .../file_manager/chromeos/volume_manager.cc   | 1200 +++++++++++++++++
 .../file_manager/chromeos/volume_manager.h    |  400 ++++++
 .../file_manager/linux/volume_manager.cc      |  183 +++
 .../file_manager/linux/volume_manager.h       |  194 +++
 4 files changed, 1977 insertions(+)
 create mode 100644 chrome/browser/file_manager/chromeos/volume_manager.cc
 create mode 100644 chrome/browser/file_manager/chromeos/volume_manager.h
 create mode 100644 chrome/browser/file_manager/linux/volume_manager.cc
 create mode 100644 chrome/browser/file_manager/linux/volume_manager.h

diff --git a/chrome/browser/file_manager/chromeos/volume_manager.cc b/chrome/browser/file_manager/chromeos/volume_manager.cc
new file mode 100644
index 0000000000000..211cecfe5195a
--- /dev/null
+++ b/chrome/browser/file_manager/chromeos/volume_manager.cc
@@ -0,0 +1,1200 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/chromeos/volume_manager.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <utility>
+
+#include "base/bind.h"
+#include "base/command_line.h"
+#include "base/feature_list.h"
+#include "base/files/file_path.h"
+#include "base/logging.h"
+#include "base/memory/weak_ptr.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/chromeos/arc/arc_util.h"
+#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_util.h"
+#include "chrome/browser/chromeos/arc/fileapi/arc_media_view_util.h"
+#include "chrome/browser/chromeos/crostini/crostini_manager.h"
+#include "chrome/browser/chromeos/crostini/crostini_util.h"
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_info.h"
+#include "chrome/browser/chromeos/profiles/profile_helper.h"
+#include "chrome/browser/file_manager/path_util.h"
+#include "chrome/browser/file_manager/snapshot_manager.h"
+#include "chrome/browser/file_manager/volume_manager_factory.h"
+#include "chrome/browser/file_manager/volume_manager_observer.h"
+#include "chrome/browser/media_galleries/fileapi/mtp_device_map_service.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/common/pref_names.h"
+#include "chromeos/chromeos_switches.h"
+#include "chromeos/disks/disk.h"
+#include "chromeos/disks/disk_mount_manager.h"
+#include "components/drive/chromeos/file_system_interface.h"
+#include "components/prefs/pref_service.h"
+#include "components/storage_monitor/storage_monitor.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/browser_thread.h"
+#include "services/device/public/mojom/mtp_manager.mojom.h"
+#include "storage/browser/fileapi/external_mount_points.h"
+
+namespace file_manager {
+namespace {
+
+const uint32_t kAccessCapabilityReadWrite = 0;
+const uint32_t kFilesystemTypeGenericHierarchical = 2;
+const char kFileManagerMTPMountNamePrefix[] = "fileman-mtp-";
+const char kMtpVolumeIdPrefix[] = "mtp:";
+const char kRootPath[] = "/";
+const char kAndroidFilesMountPointName[] = "android_files";
+
+// Registers |path| as the "Downloads" folder to the FileSystem API backend.
+// If another folder is already mounted. It revokes and overrides the old one.
+bool RegisterDownloadsMountPoint(Profile* profile, const base::FilePath& path) {
+  // Although we show only profile's own "Downloads" folder in the Files app,
+  // in the backend we need to mount all profile's download directory globally.
+  // Otherwise, the Files app cannot support cross-profile file copies, etc.
+  // For this reason, we need to register to the global GetSystemInstance().
+  const std::string mount_point_name =
+      file_manager::util::GetDownloadsMountPointName(profile);
+  storage::ExternalMountPoints* const mount_points =
+      storage::ExternalMountPoints::GetSystemInstance();
+
+  // In some tests we want to override existing Downloads mount point, so we
+  // first revoke the existing mount point (if any).
+  mount_points->RevokeFileSystem(mount_point_name);
+  return mount_points->RegisterFileSystem(mount_point_name,
+                                          storage::kFileSystemTypeNativeLocal,
+                                          storage::FileSystemMountOption(),
+                                          path);
+}
+
+// Returns true if the "Play files" root should be shown based on the current
+// flag settings (chrome://flags/#android-files-in-files-app).
+bool IsShowAndroidFilesEnabled() {
+  return !base::CommandLine::ForCurrentProcess()->HasSwitch(
+      chromeos::switches::kHideAndroidFilesInFilesApp);
+}
+
+// Registers a mount point for Android files to ExternalMountPoints.
+bool RegisterAndroidFilesMountPoint() {
+  storage::ExternalMountPoints* const mount_points =
+      storage::ExternalMountPoints::GetSystemInstance();
+  return mount_points->RegisterFileSystem(
+      kAndroidFilesMountPointName, storage::kFileSystemTypeNativeLocal,
+      storage::FileSystemMountOption(),
+      base::FilePath(util::kAndroidFilesPath));
+}
+
+// Finds the path register as the "Downloads" folder to FileSystem API backend.
+// Returns false if it is not registered.
+bool FindDownloadsMountPointPath(Profile* profile, base::FilePath* path) {
+  const std::string mount_point_name =
+      util::GetDownloadsMountPointName(profile);
+  storage::ExternalMountPoints* const mount_points =
+      storage::ExternalMountPoints::GetSystemInstance();
+
+  return mount_points->GetRegisteredPath(mount_point_name, path);
+}
+
+VolumeType MountTypeToVolumeType(chromeos::MountType type) {
+  switch (type) {
+    case chromeos::MOUNT_TYPE_INVALID:
+      // We don't expect this value, but list here, so that when any value
+      // is added to the enum definition but this is not edited, the compiler
+      // warns it.
+      break;
+    case chromeos::MOUNT_TYPE_DEVICE:
+      return VOLUME_TYPE_REMOVABLE_DISK_PARTITION;
+    case chromeos::MOUNT_TYPE_ARCHIVE:
+      return VOLUME_TYPE_MOUNTED_ARCHIVE_FILE;
+    case chromeos::MOUNT_TYPE_NETWORK_STORAGE:
+      // Network storage mounts are handled by their mounters so
+      // MOUNT_TYPE_NETWORK_STORAGE should never need to be handled here.
+      break;
+  }
+
+  NOTREACHED();
+  return VOLUME_TYPE_DOWNLOADS_DIRECTORY;
+}
+
+// Returns a string representation of the given volume type.
+std::string VolumeTypeToString(VolumeType type) {
+  switch (type) {
+    case VOLUME_TYPE_GOOGLE_DRIVE:
+      return "drive";
+    case VOLUME_TYPE_DOWNLOADS_DIRECTORY:
+      return "downloads";
+    case VOLUME_TYPE_REMOVABLE_DISK_PARTITION:
+      return "removable";
+    case VOLUME_TYPE_MOUNTED_ARCHIVE_FILE:
+      return "archive";
+    case VOLUME_TYPE_PROVIDED:
+      return "provided";
+    case VOLUME_TYPE_MTP:
+      return "mtp";
+    case VOLUME_TYPE_MEDIA_VIEW:
+      return "media_view";
+    case VOLUME_TYPE_ANDROID_FILES:
+      return "android_files";
+    case VOLUME_TYPE_TESTING:
+      return "testing";
+    case VOLUME_TYPE_CROSTINI:
+      return "crostini";
+    case NUM_VOLUME_TYPE:
+      break;
+  }
+  NOTREACHED();
+  return "";
+}
+
+// Generates a unique volume ID for the given volume info.
+std::string GenerateVolumeId(const Volume& volume) {
+  // For the same volume type, base names are unique, as mount points are
+  // flat for the same volume type.
+  return (VolumeTypeToString(volume.type()) + ":" +
+          volume.mount_path().BaseName().AsUTF8Unsafe());
+}
+
+std::string GetMountPointNameForMediaStorage(
+    const storage_monitor::StorageInfo& info) {
+  std::string name(kFileManagerMTPMountNamePrefix);
+  name += info.device_id();
+  return name;
+}
+
+chromeos::MountAccessMode GetExternalStorageAccessMode(const Profile* profile) {
+  return profile->GetPrefs()->GetBoolean(prefs::kExternalStorageReadOnly)
+             ? chromeos::MOUNT_ACCESS_MODE_READ_ONLY
+             : chromeos::MOUNT_ACCESS_MODE_READ_WRITE;
+}
+
+}  // namespace
+
+Volume::Volume()
+    : source_(SOURCE_FILE),
+      type_(VOLUME_TYPE_GOOGLE_DRIVE),
+      device_type_(chromeos::DEVICE_TYPE_UNKNOWN),
+      mount_condition_(chromeos::disks::MOUNT_CONDITION_NONE),
+      mount_context_(MOUNT_CONTEXT_UNKNOWN),
+      is_parent_(false),
+      is_read_only_(false),
+      is_read_only_removable_device_(false),
+      has_media_(false),
+      configurable_(false),
+      watchable_(false) {
+}
+
+Volume::~Volume() = default;
+
+// static
+std::unique_ptr<Volume> Volume::CreateForDrive(
+    const base::FilePath& drive_path) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->type_ = VOLUME_TYPE_GOOGLE_DRIVE;
+  volume->device_type_ = chromeos::DEVICE_TYPE_UNKNOWN;
+  volume->source_path_ = drive_path;
+  volume->source_ = SOURCE_NETWORK;
+  volume->mount_path_ = drive_path;
+  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
+  volume->volume_id_ = GenerateVolumeId(*volume);
+  volume->watchable_ = true;
+  return volume;
+}
+
+// static
+std::unique_ptr<Volume> Volume::CreateForDownloads(
+    const base::FilePath& downloads_path) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->type_ = VOLUME_TYPE_DOWNLOADS_DIRECTORY;
+  volume->device_type_ = chromeos::DEVICE_TYPE_UNKNOWN;
+  // Keep source_path empty.
+  volume->source_ = SOURCE_SYSTEM;
+  volume->mount_path_ = downloads_path;
+  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
+  volume->volume_id_ = GenerateVolumeId(*volume);
+  volume->watchable_ = true;
+  return volume;
+}
+
+// static
+std::unique_ptr<Volume> Volume::CreateForRemovable(
+    const chromeos::disks::DiskMountManager::MountPointInfo& mount_point,
+    const chromeos::disks::Disk* disk) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->type_ = MountTypeToVolumeType(mount_point.mount_type);
+  volume->source_path_ = base::FilePath(mount_point.source_path);
+  volume->source_ = mount_point.mount_type == chromeos::MOUNT_TYPE_ARCHIVE
+                        ? SOURCE_FILE
+                        : SOURCE_DEVICE;
+  volume->mount_path_ = base::FilePath(mount_point.mount_path);
+  volume->mount_condition_ = mount_point.mount_condition;
+
+  if (disk) {
+    volume->file_system_type_ = disk->file_system_type();
+    volume->volume_label_ = disk->device_label();
+    volume->device_type_ = disk->device_type();
+    volume->system_path_prefix_ = base::FilePath(disk->system_path_prefix());
+    volume->is_parent_ = disk->is_parent();
+    volume->is_read_only_ = disk->is_read_only();
+    volume->is_read_only_removable_device_ = disk->is_read_only_hardware();
+    volume->has_media_ = disk->has_media();
+  } else {
+    volume->volume_label_ = volume->mount_path().BaseName().AsUTF8Unsafe();
+    volume->device_type_ = chromeos::DEVICE_TYPE_UNKNOWN;
+    volume->is_read_only_ =
+        (mount_point.mount_type == chromeos::MOUNT_TYPE_ARCHIVE);
+  }
+  volume->volume_id_ = GenerateVolumeId(*volume);
+  volume->watchable_ = true;
+  return volume;
+}
+
+// static
+std::unique_ptr<Volume> Volume::CreateForProvidedFileSystem(
+    const chromeos::file_system_provider::ProvidedFileSystemInfo&
+        file_system_info,
+    MountContext mount_context) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->file_system_id_ = file_system_info.file_system_id();
+  volume->provider_id_ = file_system_info.provider_id();
+  switch (file_system_info.source()) {
+    case extensions::SOURCE_FILE:
+      volume->source_ = SOURCE_FILE;
+      break;
+    case extensions::SOURCE_DEVICE:
+      volume->source_ = SOURCE_DEVICE;
+      break;
+    case extensions::SOURCE_NETWORK:
+      volume->source_ = SOURCE_NETWORK;
+      break;
+  }
+  volume->volume_label_ = file_system_info.display_name();
+  volume->type_ = VOLUME_TYPE_PROVIDED;
+  volume->mount_path_ = file_system_info.mount_path();
+  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
+  volume->mount_context_ = mount_context;
+  volume->is_parent_ = true;
+  volume->is_read_only_ = !file_system_info.writable();
+  volume->configurable_ = file_system_info.configurable();
+  volume->watchable_ = file_system_info.watchable();
+  volume->volume_id_ = GenerateVolumeId(*volume);
+  volume->icon_set_ = file_system_info.icon_set();
+  return volume;
+}
+
+// static
+std::unique_ptr<Volume> Volume::CreateForMTP(const base::FilePath& mount_path,
+                                             const std::string& label,
+                                             bool read_only) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->type_ = VOLUME_TYPE_MTP;
+  volume->mount_path_ = mount_path;
+  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
+  volume->is_parent_ = true;
+  volume->is_read_only_ = read_only;
+  volume->volume_id_ = kMtpVolumeIdPrefix + label;
+  volume->volume_label_ = label;
+  volume->source_path_ = mount_path;
+  volume->source_ = SOURCE_DEVICE;
+  volume->device_type_ = chromeos::DEVICE_TYPE_MOBILE;
+  return volume;
+}
+
+// static
+std::unique_ptr<Volume> Volume::CreateForMediaView(
+    const std::string& root_document_id) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->type_ = VOLUME_TYPE_MEDIA_VIEW;
+  volume->device_type_ = chromeos::DEVICE_TYPE_UNKNOWN;
+  volume->source_ = SOURCE_SYSTEM;
+  volume->mount_path_ = arc::GetDocumentsProviderMountPath(
+      arc::kMediaDocumentsProviderAuthority, root_document_id);
+  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
+  volume->volume_label_ = root_document_id;
+  volume->is_read_only_ = true;
+  volume->watchable_ = false;
+  volume->volume_id_ = arc::GetMediaViewVolumeId(root_document_id);
+  return volume;
+}
+
+// static
+std::unique_ptr<Volume> Volume::CreateForSshfsCrostini(
+    const base::FilePath& sshfs_mount_path) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->type_ = VOLUME_TYPE_CROSTINI;
+  volume->device_type_ = chromeos::DEVICE_TYPE_UNKNOWN;
+  // Keep source_path empty.
+  volume->source_ = SOURCE_SYSTEM;
+  volume->mount_path_ = sshfs_mount_path;
+  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
+  volume->volume_id_ = GenerateVolumeId(*volume);
+  volume->watchable_ = false;
+  return volume;
+}
+
+// static
+std::unique_ptr<Volume> Volume::CreateForAndroidFiles() {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->type_ = VOLUME_TYPE_ANDROID_FILES;
+  volume->device_type_ = chromeos::DEVICE_TYPE_UNKNOWN;
+  // Keep source_path empty.
+  volume->source_ = SOURCE_SYSTEM;
+  volume->mount_path_ = base::FilePath(util::kAndroidFilesPath);
+  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
+  volume->volume_id_ = GenerateVolumeId(*volume);
+  volume->watchable_ = true;
+  return volume;
+}
+
+// static
+std::unique_ptr<Volume> Volume::CreateForTesting(
+    const base::FilePath& path,
+    VolumeType volume_type,
+    chromeos::DeviceType device_type,
+    bool read_only) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->type_ = volume_type;
+  volume->device_type_ = device_type;
+  // Keep source_path empty.
+  volume->source_ = SOURCE_DEVICE;
+  volume->mount_path_ = path;
+  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
+  volume->is_read_only_ = read_only;
+  volume->volume_id_ = GenerateVolumeId(*volume);
+  return volume;
+}
+
+// static
+std::unique_ptr<Volume> Volume::CreateForTesting(
+    const base::FilePath& device_path,
+    const base::FilePath& mount_path) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->system_path_prefix_ = device_path;
+  volume->mount_path_ = mount_path;
+  return volume;
+}
+
+VolumeManager::VolumeManager(
+    Profile* profile,
+    drive::DriveIntegrationService* drive_integration_service,
+    chromeos::PowerManagerClient* power_manager_client,
+    chromeos::disks::DiskMountManager* disk_mount_manager,
+    chromeos::file_system_provider::Service* file_system_provider_service,
+    const GetMtpStorageInfoCallback& get_mtp_storage_info_callback)
+    : profile_(profile),
+      drive_integration_service_(drive_integration_service),
+      disk_mount_manager_(disk_mount_manager),
+      file_system_provider_service_(file_system_provider_service),
+      get_mtp_storage_info_callback_(get_mtp_storage_info_callback),
+      snapshot_manager_(new SnapshotManager(profile_)),
+      weak_ptr_factory_(this) {
+  DCHECK(disk_mount_manager);
+}
+
+VolumeManager::~VolumeManager() = default;
+
+VolumeManager* VolumeManager::Get(content::BrowserContext* context) {
+  return VolumeManagerFactory::Get(context);
+}
+
+void VolumeManager::Initialize() {
+  // If in the Sign in profile pr the lock screen app profile, skip mounting
+  // and listening for mount events.
+  if (chromeos::ProfileHelper::IsSigninProfile(profile_) ||
+      chromeos::ProfileHelper::IsLockScreenAppProfile(profile_)) {
+    return;
+  }
+
+  // Register 'Downloads' folder for the profile to the file system.
+  const base::FilePath downloads =
+      file_manager::util::GetDownloadsFolderForProfile(profile_);
+  const bool success = RegisterDownloadsMountPoint(profile_, downloads);
+  DCHECK(success);
+
+  DoMountEvent(chromeos::MOUNT_ERROR_NONE,
+               Volume::CreateForDownloads(downloads));
+
+  // Subscribe to DriveIntegrationService.
+  drive_integration_service_->AddObserver(this);
+  if (drive_integration_service_->IsMounted()) {
+    DoMountEvent(chromeos::MOUNT_ERROR_NONE,
+                 Volume::CreateForDrive(GetDriveMountPointPath()));
+  }
+
+  // Subscribe to DiskMountManager.
+  disk_mount_manager_->AddObserver(this);
+  disk_mount_manager_->EnsureMountInfoRefreshed(
+      base::Bind(&VolumeManager::OnDiskMountManagerRefreshed,
+                 weak_ptr_factory_.GetWeakPtr()),
+      false /* force */);
+
+  // Subscribe to FileSystemProviderService and register currently mounted
+  // volumes for the profile.
+  if (file_system_provider_service_) {
+    using chromeos::file_system_provider::ProvidedFileSystemInfo;
+    file_system_provider_service_->AddObserver(this);
+
+    std::vector<ProvidedFileSystemInfo> file_system_info_list =
+        file_system_provider_service_->GetProvidedFileSystemInfoList();
+    for (size_t i = 0; i < file_system_info_list.size(); ++i) {
+      std::unique_ptr<Volume> volume = Volume::CreateForProvidedFileSystem(
+          file_system_info_list[i], MOUNT_CONTEXT_AUTO);
+      DoMountEvent(chromeos::MOUNT_ERROR_NONE, std::move(volume));
+    }
+  }
+
+  // Subscribe to Profile Preference change.
+  pref_change_registrar_.Init(profile_->GetPrefs());
+  pref_change_registrar_.Add(
+      prefs::kExternalStorageDisabled,
+      base::Bind(&VolumeManager::OnExternalStorageDisabledChanged,
+                 weak_ptr_factory_.GetWeakPtr()));
+  pref_change_registrar_.Add(
+      prefs::kExternalStorageReadOnly,
+      base::Bind(&VolumeManager::OnExternalStorageReadOnlyChanged,
+                 weak_ptr_factory_.GetWeakPtr()));
+
+  // Subscribe to storage monitor for MTP notifications.
+  if (storage_monitor::StorageMonitor::GetInstance()) {
+    storage_monitor::StorageMonitor::GetInstance()->EnsureInitialized(
+        base::Bind(&VolumeManager::OnStorageMonitorInitialized,
+                   weak_ptr_factory_.GetWeakPtr()));
+  }
+
+  // Subscribe to ARC file system events.
+  if (base::FeatureList::IsEnabled(arc::kMediaViewFeature) &&
+      arc::IsArcAllowedForProfile(profile_)) {
+    // Registers a mount point for Android files only when the flag is enabled.
+    if (IsShowAndroidFilesEnabled())
+      RegisterAndroidFilesMountPoint();
+
+    arc::ArcSessionManager::Get()->AddObserver(this);
+    OnArcPlayStoreEnabledChanged(
+        arc::IsArcPlayStoreEnabledForProfile(profile_));
+  }
+}
+
+void VolumeManager::Shutdown() {
+  weak_ptr_factory_.InvalidateWeakPtrs();
+
+  snapshot_manager_.reset();
+  pref_change_registrar_.RemoveAll();
+  disk_mount_manager_->RemoveObserver(this);
+  if (storage_monitor::StorageMonitor::GetInstance())
+    storage_monitor::StorageMonitor::GetInstance()->RemoveObserver(this);
+
+  if (drive_integration_service_)
+    drive_integration_service_->RemoveObserver(this);
+
+  if (file_system_provider_service_)
+    file_system_provider_service_->RemoveObserver(this);
+
+  // Unsubscribe from ARC file system events.
+  if (base::FeatureList::IsEnabled(arc::kMediaViewFeature) &&
+      arc::IsArcAllowedForProfile(profile_)) {
+    auto* session_manager = arc::ArcSessionManager::Get();
+    // TODO(crbug.com/672829): We need nullptr check here because
+    // ArcSessionManager may or may not be alive at this point.
+    if (session_manager)
+      session_manager->RemoveObserver(this);
+  }
+}
+
+void VolumeManager::AddObserver(VolumeManagerObserver* observer) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DCHECK(observer);
+  observers_.AddObserver(observer);
+}
+
+void VolumeManager::RemoveObserver(VolumeManagerObserver* observer) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DCHECK(observer);
+  observers_.RemoveObserver(observer);
+}
+
+std::vector<base::WeakPtr<Volume>> VolumeManager::GetVolumeList() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  std::vector<base::WeakPtr<Volume>> result;
+  result.reserve(mounted_volumes_.size());
+  for (const auto& pair : mounted_volumes_) {
+    result.push_back(pair.second->AsWeakPtr());
+  }
+  return result;
+}
+
+base::WeakPtr<Volume> VolumeManager::FindVolumeById(
+    const std::string& volume_id) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  const auto it = mounted_volumes_.find(volume_id);
+  if (it != mounted_volumes_.end())
+    return it->second->AsWeakPtr();
+  return base::WeakPtr<Volume>();
+}
+
+void VolumeManager::AddSshfsCrostiniVolume(
+    const base::FilePath& sshfs_mount_path) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  std::unique_ptr<Volume> volume =
+      Volume::CreateForSshfsCrostini(sshfs_mount_path);
+  // Ignore if volume already exists.
+  if (mounted_volumes_.find(volume->volume_id()) != mounted_volumes_.end())
+    return;
+  DoMountEvent(chromeos::MOUNT_ERROR_NONE, std::move(volume));
+
+  // Listen for crostini container shutdown and remove volume.
+  crostini::CrostiniManager::GetInstance()->AddShutdownContainerCallback(
+      profile_, kCrostiniDefaultVmName, kCrostiniDefaultContainerName,
+      base::BindOnce(&VolumeManager::RemoveSshfsCrostiniVolume,
+                     weak_ptr_factory_.GetWeakPtr(), sshfs_mount_path));
+}
+
+void VolumeManager::RemoveSshfsCrostiniVolume(
+    const base::FilePath& sshfs_mount_path) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
+                 *Volume::CreateForSshfsCrostini(sshfs_mount_path));
+  disk_mount_manager_->UnmountPath(
+      sshfs_mount_path.value(), chromeos::UNMOUNT_OPTIONS_NONE,
+      chromeos::disks::DiskMountManager::UnmountPathCallback());
+}
+
+bool VolumeManager::RegisterDownloadsDirectoryForTesting(
+    const base::FilePath& path) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  base::FilePath old_path;
+  if (FindDownloadsMountPointPath(profile_, &old_path)) {
+    DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
+                   *Volume::CreateForDownloads(old_path));
+  }
+
+  bool success = RegisterDownloadsMountPoint(profile_, path);
+  DoMountEvent(
+      success ? chromeos::MOUNT_ERROR_NONE : chromeos::MOUNT_ERROR_INVALID_PATH,
+      Volume::CreateForDownloads(path));
+  return success;
+}
+
+bool VolumeManager::RegisterCrostiniDirectoryForTesting(
+    const base::FilePath& path) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  bool success =
+      storage::ExternalMountPoints::GetSystemInstance()->RegisterFileSystem(
+          file_manager::util::GetCrostiniMountPointName(profile_),
+          storage::kFileSystemTypeNativeLocal, storage::FileSystemMountOption(),
+          path);
+  DoMountEvent(
+      success ? chromeos::MOUNT_ERROR_NONE : chromeos::MOUNT_ERROR_INVALID_PATH,
+      Volume::CreateForSshfsCrostini(path));
+  return true;
+}
+
+void VolumeManager::AddVolumeForTesting(const base::FilePath& path,
+                                        VolumeType volume_type,
+                                        chromeos::DeviceType device_type,
+                                        bool read_only) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DoMountEvent(
+      chromeos::MOUNT_ERROR_NONE,
+      Volume::CreateForTesting(path, volume_type, device_type, read_only));
+}
+
+void VolumeManager::AddVolumeForTesting(std::unique_ptr<Volume> volume) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DoMountEvent(chromeos::MOUNT_ERROR_NONE, std::move(volume));
+}
+
+void VolumeManager::OnFileSystemMounted() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  // Raise mount event.
+  // We can pass chromeos::MOUNT_ERROR_NONE even when authentication is failed
+  // or network is unreachable. These two errors will be handled later.
+  DoMountEvent(chromeos::MOUNT_ERROR_NONE,
+               Volume::CreateForDrive(GetDriveMountPointPath()));
+}
+
+void VolumeManager::OnFileSystemBeingUnmounted() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
+                 *Volume::CreateForDrive(GetDriveMountPointPath()));
+}
+
+void VolumeManager::OnAutoMountableDiskEvent(
+    chromeos::disks::DiskMountManager::DiskEvent event,
+    const chromeos::disks::Disk& disk) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  // Disregard hidden devices.
+  if (disk.is_hidden())
+    return;
+
+  switch (event) {
+    case chromeos::disks::DiskMountManager::DISK_ADDED:
+    case chromeos::disks::DiskMountManager::DISK_CHANGED: {
+      if (disk.device_path().empty()) {
+        DVLOG(1) << "Empty system path for " << disk.device_path();
+        return;
+      }
+
+      bool mounting = false;
+      if (disk.mount_path().empty() && disk.has_media() &&
+          !profile_->GetPrefs()->GetBoolean(prefs::kExternalStorageDisabled)) {
+        // TODO(crbug.com/774890): Remove |mount_label| when the issue gets
+        // resolved. Currently we suggest a mount point name, because in case
+        // when disk's name contains '#', content will not load in Files App.
+        std::string mount_label = disk.device_label();
+        std::replace(mount_label.begin(), mount_label.end(), '#', '_');
+
+        // If disk is not mounted yet and it has media and there is no policy
+        // forbidding external storage, give it a try.
+        // Initiate disk mount operation. MountPath auto-detects the filesystem
+        // format if the second argument is empty. The third argument (mount
+        // label) is not used in a disk mount operation.
+        disk_mount_manager_->MountPath(disk.device_path(), std::string(),
+                                       mount_label, {},
+                                       chromeos::MOUNT_TYPE_DEVICE,
+                                       GetExternalStorageAccessMode(profile_));
+        mounting = true;
+      }
+
+      // Notify to observers.
+      for (auto& observer : observers_)
+        observer.OnDiskAdded(disk, mounting);
+      return;
+    }
+
+    case chromeos::disks::DiskMountManager::DISK_REMOVED:
+      // If the disk is already mounted, unmount it.
+      if (!disk.mount_path().empty()) {
+        disk_mount_manager_->UnmountPath(
+            disk.mount_path(), chromeos::UNMOUNT_OPTIONS_LAZY,
+            chromeos::disks::DiskMountManager::UnmountPathCallback());
+      }
+
+      // Notify to observers.
+      for (auto& observer : observers_)
+        observer.OnDiskRemoved(disk);
+      return;
+  }
+  NOTREACHED();
+}
+
+void VolumeManager::OnDeviceEvent(
+    chromeos::disks::DiskMountManager::DeviceEvent event,
+    const std::string& device_path) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  DVLOG(1) << "OnDeviceEvent: " << event << ", " << device_path;
+  switch (event) {
+    case chromeos::disks::DiskMountManager::DEVICE_ADDED:
+      for (auto& observer : observers_)
+        observer.OnDeviceAdded(device_path);
+      return;
+    case chromeos::disks::DiskMountManager::DEVICE_REMOVED: {
+      for (auto& observer : observers_)
+        observer.OnDeviceRemoved(device_path);
+      return;
+    }
+    case chromeos::disks::DiskMountManager::DEVICE_SCANNED:
+      DVLOG(1) << "Ignore SCANNED event: " << device_path;
+      return;
+  }
+  NOTREACHED();
+}
+
+void VolumeManager::OnMountEvent(
+    chromeos::disks::DiskMountManager::MountEvent event,
+    chromeos::MountError error_code,
+    const chromeos::disks::DiskMountManager::MountPointInfo& mount_info) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  switch (mount_info.mount_type) {
+    case chromeos::MOUNT_TYPE_ARCHIVE: {
+      // If the file is not mounted now, tell it to drive file system so that
+      // it can handle file caching correctly.
+      // Note that drive file system knows if the file is managed by drive file
+      // system or not, so here we report all paths.
+      if ((event == chromeos::disks::DiskMountManager::MOUNTING &&
+           error_code != chromeos::MOUNT_ERROR_NONE) ||
+          (event == chromeos::disks::DiskMountManager::UNMOUNTING &&
+           error_code == chromeos::MOUNT_ERROR_NONE)) {
+        drive::FileSystemInterface* const file_system =
+            drive::util::GetFileSystemByProfile(profile_);
+        if (file_system) {
+          file_system->MarkCacheFileAsUnmounted(
+              base::FilePath(mount_info.source_path), base::DoNothing());
+        }
+      }
+      FALLTHROUGH;
+    }
+    case chromeos::MOUNT_TYPE_DEVICE: {
+      // Notify a mounting/unmounting event to observers.
+      const chromeos::disks::Disk* const disk =
+          disk_mount_manager_->FindDiskBySourcePath(mount_info.source_path);
+      std::unique_ptr<Volume> volume =
+          Volume::CreateForRemovable(mount_info, disk);
+      switch (event) {
+        case chromeos::disks::DiskMountManager::MOUNTING: {
+          DoMountEvent(error_code, std::move(volume));
+          return;
+        }
+        case chromeos::disks::DiskMountManager::UNMOUNTING:
+          DoUnmountEvent(error_code, *volume);
+          return;
+      }
+      NOTREACHED();
+    }
+
+    // Network storage is responsible for doing its own mounting.
+    case chromeos::MOUNT_TYPE_NETWORK_STORAGE: {
+      break;
+    }
+
+    case chromeos::MOUNT_TYPE_INVALID: {
+      NOTREACHED();
+      break;
+    }
+  }
+}
+
+void VolumeManager::OnFormatEvent(
+    chromeos::disks::DiskMountManager::FormatEvent event,
+    chromeos::FormatError error_code,
+    const std::string& device_path) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DVLOG(1) << "OnDeviceEvent: " << event << ", " << error_code
+           << ", " << device_path;
+
+  switch (event) {
+    case chromeos::disks::DiskMountManager::FORMAT_STARTED:
+      for (auto& observer : observers_) {
+        observer.OnFormatStarted(device_path,
+                                 error_code == chromeos::FORMAT_ERROR_NONE);
+      }
+      return;
+    case chromeos::disks::DiskMountManager::FORMAT_COMPLETED:
+      if (error_code == chromeos::FORMAT_ERROR_NONE) {
+        // If format is completed successfully, try to mount the device.
+        // MountPath auto-detects filesystem format if second argument is
+        // empty. The third argument (mount label) is not used in a disk mount
+        // operation.
+        disk_mount_manager_->MountPath(device_path, std::string(),
+                                       std::string(), {},
+                                       chromeos::MOUNT_TYPE_DEVICE,
+                                       GetExternalStorageAccessMode(profile_));
+      }
+
+      for (auto& observer : observers_) {
+        observer.OnFormatCompleted(device_path,
+                                   error_code == chromeos::FORMAT_ERROR_NONE);
+      }
+
+      return;
+  }
+  NOTREACHED();
+}
+
+void VolumeManager::OnRenameEvent(
+    chromeos::disks::DiskMountManager::RenameEvent event,
+    chromeos::RenameError error_code,
+    const std::string& device_path) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DVLOG(1) << "OnDeviceEvent: " << event << ", " << error_code << ", "
+           << device_path;
+
+  switch (event) {
+    case chromeos::disks::DiskMountManager::RENAME_STARTED:
+      for (auto& observer : observers_) {
+        observer.OnRenameStarted(device_path,
+                                 error_code == chromeos::RENAME_ERROR_NONE);
+      }
+      return;
+    case chromeos::disks::DiskMountManager::RENAME_COMPLETED:
+      // Find previous mount point label if it exists
+      std::string mount_label = "";
+      auto disk_map_iter = disk_mount_manager_->disks().find(device_path);
+      if (disk_map_iter != disk_mount_manager_->disks().end() &&
+          !disk_map_iter->second->base_mount_path().empty()) {
+        mount_label = base::FilePath(disk_map_iter->second->base_mount_path())
+                          .BaseName()
+                          .AsUTF8Unsafe();
+      }
+
+      // Try to mount the device. MountPath auto-detects filesystem format if
+      // second argument is empty. Third argument is a mount point name of the
+      // disk when it was first time mounted (to preserve mount point regardless
+      // of the volume name).
+      disk_mount_manager_->MountPath(device_path, std::string(), mount_label,
+                                     {}, chromeos::MOUNT_TYPE_DEVICE,
+                                     GetExternalStorageAccessMode(profile_));
+
+      bool successfully_renamed = error_code == chromeos::RENAME_ERROR_NONE;
+      for (auto& observer : observers_)
+        observer.OnRenameCompleted(device_path, successfully_renamed);
+
+      return;
+  }
+  NOTREACHED();
+}
+
+void VolumeManager::OnProvidedFileSystemMount(
+    const chromeos::file_system_provider::ProvidedFileSystemInfo&
+        file_system_info,
+    chromeos::file_system_provider::MountContext context,
+    base::File::Error error) {
+  MountContext volume_context = MOUNT_CONTEXT_UNKNOWN;
+  switch (context) {
+    case chromeos::file_system_provider::MOUNT_CONTEXT_USER:
+      volume_context = MOUNT_CONTEXT_USER;
+      break;
+    case chromeos::file_system_provider::MOUNT_CONTEXT_RESTORE:
+      volume_context = MOUNT_CONTEXT_AUTO;
+      break;
+  }
+
+  std::unique_ptr<Volume> volume =
+      Volume::CreateForProvidedFileSystem(file_system_info, volume_context);
+
+  // TODO(mtomasz): Introduce own type, and avoid using MountError internally,
+  // since it is related to cros disks only.
+  chromeos::MountError mount_error;
+  switch (error) {
+    case base::File::FILE_OK:
+      mount_error = chromeos::MOUNT_ERROR_NONE;
+      break;
+    case base::File::FILE_ERROR_EXISTS:
+      mount_error = chromeos::MOUNT_ERROR_PATH_ALREADY_MOUNTED;
+      break;
+    default:
+      mount_error = chromeos::MOUNT_ERROR_UNKNOWN;
+      break;
+  }
+
+  DoMountEvent(mount_error, std::move(volume));
+}
+
+void VolumeManager::OnProvidedFileSystemUnmount(
+    const chromeos::file_system_provider::ProvidedFileSystemInfo&
+        file_system_info,
+    base::File::Error error) {
+  // TODO(mtomasz): Introduce own type, and avoid using MountError internally,
+  // since it is related to cros disks only.
+  const chromeos::MountError mount_error = error == base::File::FILE_OK
+                                               ? chromeos::MOUNT_ERROR_NONE
+                                               : chromeos::MOUNT_ERROR_UNKNOWN;
+  std::unique_ptr<Volume> volume = Volume::CreateForProvidedFileSystem(
+      file_system_info, MOUNT_CONTEXT_UNKNOWN);
+  DoUnmountEvent(mount_error, *volume);
+}
+
+void VolumeManager::OnExternalStorageDisabledChangedUnmountCallback(
+    chromeos::MountError error_code) {
+  if (disk_mount_manager_->mount_points().empty())
+    return;
+  // Repeat until unmount all paths
+  const std::string& mount_path =
+      disk_mount_manager_->mount_points().begin()->second.mount_path;
+  disk_mount_manager_->UnmountPath(
+      mount_path, chromeos::UNMOUNT_OPTIONS_NONE,
+      base::Bind(
+          &VolumeManager::OnExternalStorageDisabledChangedUnmountCallback,
+          weak_ptr_factory_.GetWeakPtr()));
+}
+
+void VolumeManager::OnArcPlayStoreEnabledChanged(bool enabled) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DCHECK(base::FeatureList::IsEnabled(arc::kMediaViewFeature));
+  DCHECK(arc::IsArcAllowedForProfile(profile_));
+
+  if (enabled == arc_volumes_mounted_)
+    return;
+
+  if (enabled) {
+    DoMountEvent(chromeos::MOUNT_ERROR_NONE,
+                 Volume::CreateForMediaView(arc::kImagesRootDocumentId));
+    DoMountEvent(chromeos::MOUNT_ERROR_NONE,
+                 Volume::CreateForMediaView(arc::kVideosRootDocumentId));
+    DoMountEvent(chromeos::MOUNT_ERROR_NONE,
+                 Volume::CreateForMediaView(arc::kAudioRootDocumentId));
+    if (IsShowAndroidFilesEnabled())
+      DoMountEvent(chromeos::MOUNT_ERROR_NONE, Volume::CreateForAndroidFiles());
+  } else {
+    DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
+                   *Volume::CreateForMediaView(arc::kImagesRootDocumentId));
+    DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
+                   *Volume::CreateForMediaView(arc::kVideosRootDocumentId));
+    DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
+                   *Volume::CreateForMediaView(arc::kAudioRootDocumentId));
+    if (IsShowAndroidFilesEnabled()) {
+      DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
+                     *Volume::CreateForAndroidFiles());
+    }
+  }
+
+  arc_volumes_mounted_ = enabled;
+}
+
+void VolumeManager::OnExternalStorageDisabledChanged() {
+  // If the policy just got disabled we have to unmount every device currently
+  // mounted. The opposite is fine - we can let the user re-plug their device to
+  // make it available.
+  if (profile_->GetPrefs()->GetBoolean(prefs::kExternalStorageDisabled)) {
+    // We do not iterate on mount_points directly, because mount_points can
+    // be changed by UnmountPath().
+    // TODO(hidehiko): Is it necessary to unmount mounted archives, too, here?
+    if (disk_mount_manager_->mount_points().empty())
+      return;
+    const std::string& mount_path =
+        disk_mount_manager_->mount_points().begin()->second.mount_path;
+    disk_mount_manager_->UnmountPath(
+        mount_path, chromeos::UNMOUNT_OPTIONS_NONE,
+        base::Bind(
+            &VolumeManager::OnExternalStorageDisabledChangedUnmountCallback,
+            weak_ptr_factory_.GetWeakPtr()));
+  }
+}
+
+void VolumeManager::OnExternalStorageReadOnlyChanged() {
+  disk_mount_manager_->RemountAllRemovableDrives(
+      GetExternalStorageAccessMode(profile_));
+}
+
+void VolumeManager::OnRemovableStorageAttached(
+    const storage_monitor::StorageInfo& info) {
+  if (!storage_monitor::StorageInfo::IsMTPDevice(info.device_id()))
+    return;
+  if (profile_->GetPrefs()->GetBoolean(prefs::kExternalStorageDisabled))
+    return;
+
+  // Resolve mtp storage name and get MtpStorageInfo.
+  std::string storage_name;
+  base::RemoveChars(info.location(), kRootPath, &storage_name);
+  DCHECK(!storage_name.empty());
+  if (get_mtp_storage_info_callback_.is_null()) {
+    storage_monitor::StorageMonitor::GetInstance()
+        ->media_transfer_protocol_manager()
+        ->GetStorageInfo(storage_name,
+                         base::BindOnce(&VolumeManager::DoAttachMtpStorage,
+                                        weak_ptr_factory_.GetWeakPtr(), info));
+  } else {
+    get_mtp_storage_info_callback_.Run(
+        storage_name, base::BindOnce(&VolumeManager::DoAttachMtpStorage,
+                                     weak_ptr_factory_.GetWeakPtr(), info));
+  }
+}
+
+void VolumeManager::DoAttachMtpStorage(
+    const storage_monitor::StorageInfo& info,
+    device::mojom::MtpStorageInfoPtr mtp_storage_info) {
+  if (!mtp_storage_info) {
+    // |mtp_storage_info| can be null. e.g. As OnRemovableStorageAttached and
+    // DoAttachMtpStorage are called asynchronously, there can be a race
+    // condition where the storage has been already removed in
+    // MediaTransferProtocolManager at the time when this method is called.
+    return;
+  }
+
+  // Mtp write is enabled only when the device is writable, supports generic
+  // hierarchical file system, and writing to external storage devices is not
+  // prohibited by the preference.
+  const bool read_only =
+      base::CommandLine::ForCurrentProcess()->HasSwitch(
+          chromeos::switches::kDisableMtpWriteSupport) ||
+      mtp_storage_info->access_capability != kAccessCapabilityReadWrite ||
+      mtp_storage_info->filesystem_type !=
+          kFilesystemTypeGenericHierarchical ||
+      GetExternalStorageAccessMode(profile_) ==
+          chromeos::MOUNT_ACCESS_MODE_READ_ONLY;
+
+  const base::FilePath path = base::FilePath::FromUTF8Unsafe(info.location());
+  const std::string fsid = GetMountPointNameForMediaStorage(info);
+  const std::string base_name = base::UTF16ToUTF8(info.model_name());
+
+  // Assign a fresh volume ID based on the volume name.
+  std::string label = base_name;
+  for (int i = 2; mounted_volumes_.count(kMtpVolumeIdPrefix + label); ++i)
+    label = base_name + base::StringPrintf(" (%d)", i);
+
+  bool result =
+      storage::ExternalMountPoints::GetSystemInstance()->RegisterFileSystem(
+          fsid, storage::kFileSystemTypeDeviceMediaAsFileStorage,
+          storage::FileSystemMountOption(), path);
+  DCHECK(result);
+
+  content::BrowserThread::PostTask(
+      content::BrowserThread::IO, FROM_HERE,
+      base::BindOnce(&MTPDeviceMapService::RegisterMTPFileSystem,
+                     base::Unretained(MTPDeviceMapService::GetInstance()),
+                     info.location(), fsid, read_only));
+
+  std::unique_ptr<Volume> volume = Volume::CreateForMTP(path, label, read_only);
+  DoMountEvent(chromeos::MOUNT_ERROR_NONE, std::move(volume));
+}
+
+void VolumeManager::OnRemovableStorageDetached(
+    const storage_monitor::StorageInfo& info) {
+  if (!storage_monitor::StorageInfo::IsMTPDevice(info.device_id()))
+    return;
+
+  for (const auto& mounted_volume : mounted_volumes_) {
+    if (mounted_volume.second->source_path().value() == info.location()) {
+      DoUnmountEvent(chromeos::MOUNT_ERROR_NONE, *mounted_volume.second.get());
+
+      const std::string fsid = GetMountPointNameForMediaStorage(info);
+      storage::ExternalMountPoints::GetSystemInstance()->RevokeFileSystem(fsid);
+      content::BrowserThread::PostTask(
+          content::BrowserThread::IO, FROM_HERE,
+          base::BindOnce(&MTPDeviceMapService::RevokeMTPFileSystem,
+                         base::Unretained(MTPDeviceMapService::GetInstance()),
+                         fsid));
+      return;
+    }
+  }
+}
+
+void VolumeManager::OnDiskMountManagerRefreshed(bool success) {
+  if (!success) {
+    LOG(ERROR) << "Failed to refresh disk mount manager";
+    return;
+  }
+
+  std::vector<std::unique_ptr<Volume>> archives;
+
+  const chromeos::disks::DiskMountManager::MountPointMap& mount_points =
+      disk_mount_manager_->mount_points();
+  for (const auto& mount_point : mount_points) {
+    switch (mount_point.second.mount_type) {
+      case chromeos::MOUNT_TYPE_ARCHIVE: {
+        // Archives are mounted after other types of volume. See below.
+        archives.push_back(
+            Volume::CreateForRemovable(mount_point.second, nullptr));
+        break;
+      }
+      case chromeos::MOUNT_TYPE_DEVICE: {
+        DoMountEvent(
+            chromeos::MOUNT_ERROR_NONE,
+            Volume::CreateForRemovable(
+                mount_point.second, disk_mount_manager_->FindDiskBySourcePath(
+                                        mount_point.second.source_path)));
+        break;
+      }
+      case chromeos::MOUNT_TYPE_NETWORK_STORAGE: {
+        break;
+      }
+      case chromeos::MOUNT_TYPE_INVALID: {
+        NOTREACHED();
+      }
+    }
+  }
+
+  // We mount archives only if they are opened from currently mounted volumes.
+  // To check the condition correctly in DoMountEvent, we care about the order.
+  std::vector<bool> done(archives.size(), false);
+  for (size_t i = 0; i < archives.size(); ++i) {
+    if (done[i])
+      continue;
+
+    std::vector<std::unique_ptr<Volume>> chain;
+    // done[x] = true means archives[x] is null and that volume is in |chain|.
+    done[i] = true;
+    chain.push_back(std::move(archives[i]));
+
+    // If archives[i]'s source_path is in another archive, mount it first.
+    for (size_t parent = i + 1; parent < archives.size(); ++parent) {
+      if (!done[parent] &&
+          archives[parent]->mount_path().IsParent(
+              chain.back()->source_path())) {
+        // done[parent] started false, so archives[parent] is non-null.
+        done[parent] = true;
+        chain.push_back(std::move(archives[parent]));
+        parent = i + 1;  // Search archives[parent]'s parent from the beginning.
+      }
+    }
+
+    // Mount from the tail of chain.
+    for (size_t i = chain.size(); i > 0; --i) {
+      DoMountEvent(chromeos::MOUNT_ERROR_NONE, std::move(chain[i - 1]));
+    }
+  }
+}
+
+void VolumeManager::OnStorageMonitorInitialized() {
+  std::vector<storage_monitor::StorageInfo> storages =
+      storage_monitor::StorageMonitor::GetInstance()->GetAllAvailableStorages();
+  for (size_t i = 0; i < storages.size(); ++i)
+    OnRemovableStorageAttached(storages[i]);
+  storage_monitor::StorageMonitor::GetInstance()->AddObserver(this);
+}
+
+void VolumeManager::DoMountEvent(chromeos::MountError error_code,
+                                 std::unique_ptr<Volume> volume) {
+  // Archive files are mounted globally in system. We however don't want to show
+  // archives from profile-specific folders (Drive/Downloads) of other users in
+  // multi-profile session. To this end, we filter out archives not on the
+  // volumes already mounted on this VolumeManager instance.
+  if (volume->type() == VOLUME_TYPE_MOUNTED_ARCHIVE_FILE) {
+    // Source may be in Drive cache folder under the current profile directory.
+    bool from_current_profile =
+        profile_->GetPath().IsParent(volume->source_path());
+    for (const auto& mounted_volume : mounted_volumes_) {
+      if (mounted_volume.second->mount_path().IsParent(volume->source_path())) {
+        from_current_profile = true;
+        break;
+      }
+    }
+    if (!from_current_profile)
+      return;
+  }
+
+  // Filter out removable disks if forbidden by policy for this profile.
+  if (volume->type() == VOLUME_TYPE_REMOVABLE_DISK_PARTITION &&
+      profile_->GetPrefs()->GetBoolean(prefs::kExternalStorageDisabled)) {
+    return;
+  }
+
+  Volume* raw_volume = volume.get();
+  if (error_code == chromeos::MOUNT_ERROR_NONE || volume->mount_condition()) {
+    mounted_volumes_[volume->volume_id()] = std::move(volume);
+    UMA_HISTOGRAM_ENUMERATION("FileBrowser.VolumeType", raw_volume->type(),
+                              NUM_VOLUME_TYPE);
+  }
+
+  for (auto& observer : observers_)
+    observer.OnVolumeMounted(error_code, *raw_volume);
+}
+
+void VolumeManager::DoUnmountEvent(chromeos::MountError error_code,
+                                   const Volume& volume) {
+  auto iter = mounted_volumes_.find(volume.volume_id());
+  if (iter == mounted_volumes_.end())
+    return;
+  std::unique_ptr<Volume> volume_ref;
+  if (error_code == chromeos::MOUNT_ERROR_NONE) {
+    // It is important to hold a reference to the removed Volume from
+    // |mounted_volumes_|, because OnVolumeMounted() will access it.
+    volume_ref = std::move(iter->second);
+    mounted_volumes_.erase(iter);
+  }
+
+  for (auto& observer : observers_)
+    observer.OnVolumeUnmounted(error_code, volume);
+}
+
+base::FilePath VolumeManager::GetDriveMountPointPath() const {
+  return drive_integration_service_->GetMountPointPath();
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/chromeos/volume_manager.h b/chrome/browser/file_manager/chromeos/volume_manager.h
new file mode 100644
index 0000000000000..d3a0f0df8ec29
--- /dev/null
+++ b/chrome/browser/file_manager/chromeos/volume_manager.h
@@ -0,0 +1,400 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_CHROMEOS_VOLUME_MANAGER_H_
+#define CHROME_BROWSER_FILE_MANAGER_CHROMEOS_VOLUME_MANAGER_H_
+
+#include <map>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/callback.h"
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/observer_list.h"
+#include "chrome/browser/chromeos/arc/arc_session_manager.h"
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/chromeos/file_system_provider/icon_set.h"
+#include "chrome/browser/chromeos/file_system_provider/observer.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_info.h"
+#include "chrome/browser/chromeos/file_system_provider/service.h"
+#include "chromeos/dbus/cros_disks_client.h"
+#include "chromeos/disks/disk_mount_manager.h"
+#include "components/keyed_service/core/keyed_service.h"
+#include "components/prefs/pref_change_registrar.h"
+#include "components/storage_monitor/removable_storage_observer.h"
+#include "services/device/public/mojom/mtp_manager.mojom.h"
+
+class Profile;
+
+namespace chromeos {
+class PowerManagerClient;
+
+namespace disks {
+class Disk;
+}  // namespace disks
+
+}  // namespace chromeos
+
+namespace content {
+class BrowserContext;
+}  // namespace content
+
+namespace file_manager {
+
+class SnapshotManager;
+class VolumeManagerObserver;
+
+// Identifiers for volume types managed by Chrome OS file manager.
+enum VolumeType {
+  VOLUME_TYPE_TESTING = -1,  // Used only in tests.
+  VOLUME_TYPE_GOOGLE_DRIVE = 0,
+  VOLUME_TYPE_DOWNLOADS_DIRECTORY,
+  VOLUME_TYPE_REMOVABLE_DISK_PARTITION,
+  VOLUME_TYPE_MOUNTED_ARCHIVE_FILE,
+  VOLUME_TYPE_PROVIDED,  // File system provided by the FileSystemProvider API.
+  VOLUME_TYPE_MTP,
+  VOLUME_TYPE_MEDIA_VIEW,
+  VOLUME_TYPE_CROSTINI,
+  VOLUME_TYPE_ANDROID_FILES,
+  // The enum values must be kept in sync with FileManagerVolumeType in
+  // tools/metrics/histograms/histograms.xml. Since enums for histograms are
+  // append-only (for keeping the number consistent across versions), new values
+  // for this enum also has to be always appended at the end (i.e., here).
+  NUM_VOLUME_TYPE,
+};
+
+// Says how was the mount performed, whether due to user interaction, or
+// automatic. User interaction includes both hardware (pluggins a USB stick)
+// or software (mounting a ZIP archive) interaction.
+enum MountContext {
+  MOUNT_CONTEXT_USER,
+  MOUNT_CONTEXT_AUTO,
+  MOUNT_CONTEXT_UNKNOWN
+};
+
+// Source of a volume's data.
+enum Source { SOURCE_FILE, SOURCE_DEVICE, SOURCE_NETWORK, SOURCE_SYSTEM };
+
+// Represents a volume (mount point) in the volume manager. Validity of the data
+// is guaranteed by the weak pointer. Simply saying, the weak pointer should be
+// valid as long as the volume is mounted.
+class Volume : public base::SupportsWeakPtr<Volume> {
+ public:
+  ~Volume();
+
+  // Factory static methods for different volume types.
+  static std::unique_ptr<Volume> CreateForDrive(
+      const base::FilePath& drive_path);
+  static std::unique_ptr<Volume> CreateForDownloads(
+      const base::FilePath& downloads_path);
+  static std::unique_ptr<Volume> CreateForRemovable(
+      const chromeos::disks::DiskMountManager::MountPointInfo& mount_point,
+      const chromeos::disks::Disk* disk);
+  static std::unique_ptr<Volume> CreateForProvidedFileSystem(
+      const chromeos::file_system_provider::ProvidedFileSystemInfo&
+          file_system_info,
+      MountContext mount_context);
+  static std::unique_ptr<Volume> CreateForMTP(const base::FilePath& mount_path,
+                                              const std::string& label,
+                                              bool read_only);
+  static std::unique_ptr<Volume> CreateForMediaView(
+      const std::string& root_document_id);
+  static std::unique_ptr<Volume> CreateForSshfsCrostini(
+      const base::FilePath& crostini_path);
+  static std::unique_ptr<Volume> CreateForAndroidFiles();
+  static std::unique_ptr<Volume> CreateForTesting(
+      const base::FilePath& path,
+      VolumeType volume_type,
+      chromeos::DeviceType device_type,
+      bool read_only);
+  static std::unique_ptr<Volume> CreateForTesting(
+      const base::FilePath& device_path,
+      const base::FilePath& mount_path);
+
+  // Getters for all members. See below for details.
+  const std::string& volume_id() const { return volume_id_; }
+  const std::string& file_system_id() const { return file_system_id_; }
+  const chromeos::file_system_provider::ProviderId& provider_id() const {
+    return provider_id_;
+  }
+  Source source() const { return source_; }
+  VolumeType type() const { return type_; }
+  chromeos::DeviceType device_type() const { return device_type_; }
+  const base::FilePath& source_path() const { return source_path_; }
+  const base::FilePath& mount_path() const { return mount_path_; }
+  chromeos::disks::MountCondition mount_condition() const {
+    return mount_condition_;
+  }
+  MountContext mount_context() const { return mount_context_; }
+  const base::FilePath& system_path_prefix() const {
+    return system_path_prefix_;
+  }
+  const std::string& volume_label() const { return volume_label_; }
+  bool is_parent() const { return is_parent_; }
+  // Whether the applications can write to the volume. True if not writable.
+  // For example, when write access to external storage is restricted by the
+  // policy (ExternalStorageReadOnly), is_read_only() will be true even when
+  // is_read_only_removable_device() is false.
+  bool is_read_only() const { return is_read_only_; }
+  // Whether the device is write-protected by hardware. This field is valid
+  // only when device_type is VOLUME_TYPE_REMOVABLE_DISK_PARTITION and
+  // source is SOURCE_DEVICE.
+  // When this value is true, is_read_only() is also true.
+  bool is_read_only_removable_device() const {
+    return is_read_only_removable_device_;
+  }
+  bool has_media() const { return has_media_; }
+  bool configurable() const { return configurable_; }
+  bool watchable() const { return watchable_; }
+  const std::string& file_system_type() const { return file_system_type_; }
+  const chromeos::file_system_provider::IconSet& icon_set() const {
+    return icon_set_;
+  }
+
+ private:
+  Volume();
+
+  // The ID of the volume.
+  std::string volume_id_;
+
+  // The ID for provided file systems. If other type, then empty string. Unique
+  // per providing extension or native provider.
+  std::string file_system_id_;
+
+  // The ID of an extension or native provider providing the file system. If
+  // other type, then equal to a ProviderId of the type INVALID.
+  chromeos::file_system_provider::ProviderId provider_id_;
+
+  // The source of the volume's data.
+  Source source_;
+
+  // The type of mounted volume.
+  VolumeType type_;
+
+  // The type of device. (e.g. USB, SD card, DVD etc.)
+  chromeos::DeviceType device_type_;
+
+  // The source path of the volume.
+  // E.g.:
+  // - /home/chronos/user/Downloads/zipfile_path.zip
+  base::FilePath source_path_;
+
+  // The mount path of the volume.
+  // E.g.:
+  // - /home/chronos/user/Downloads
+  // - /media/removable/usb1
+  // - /media/archive/zip1
+  base::FilePath mount_path_;
+
+  // The mounting condition. See the enum for the details.
+  chromeos::disks::MountCondition mount_condition_;
+
+  // The context of the mount. Whether mounting was performed due to a user
+  // interaction or not.
+  MountContext mount_context_;
+
+  // Path of the system device this device's block is a part of.
+  // (e.g. /sys/devices/pci0000:00/.../8:0:0:0/)
+  base::FilePath system_path_prefix_;
+
+  // Label for the volume if the volume is either removable or a provided
+  // file system. In case of removables, if disk is a parent, then its label,
+  // else parents label (e.g. "TransMemory").
+  std::string volume_label_;
+
+  // Is the device is a parent device (i.e. sdb rather than sdb1).
+  bool is_parent_;
+
+  // True if the volume is not writable by applications.
+  bool is_read_only_;
+
+  // True if the volume is made read_only due to its hardware.
+  // This implies is_read_only_.
+  bool is_read_only_removable_device_;
+
+  // True if the volume contains media.
+  bool has_media_;
+
+  // True if the volume is configurable.
+  bool configurable_;
+
+  // True if the volume notifies about changes via file/directory watchers.
+  bool watchable_;
+
+  // Identifier for the file system type
+  std::string file_system_type_;
+
+  // Volume icon set.
+  chromeos::file_system_provider::IconSet icon_set_;
+
+  DISALLOW_COPY_AND_ASSIGN(Volume);
+};
+
+// Manages Volumes for file manager. Example of Volumes:
+// - Drive File System.
+// - Downloads directory.
+// - Removable disks (volume will be created for each partition, not only one
+//   for a device).
+// - Mounted zip archives.
+// - Linux/Crostini file system.
+// - Android/Arc++ file system.
+// - File System Providers.
+class VolumeManager : public KeyedService,
+                      public arc::ArcSessionManager::Observer,
+                      public drive::DriveIntegrationServiceObserver,
+                      public chromeos::disks::DiskMountManager::Observer,
+                      public chromeos::file_system_provider::Observer,
+                      public storage_monitor::RemovableStorageObserver {
+ public:
+  // An alternate to device::mojom::MtpManager::GetStorageInfo.
+  // Used for injecting fake MTP manager for testing in VolumeManagerTest.
+  using GetMtpStorageInfoCallback = base::RepeatingCallback<void(
+      const std::string&,
+      device::mojom::MtpManager::GetStorageInfoCallback)>;
+
+  VolumeManager(
+      Profile* profile,
+      drive::DriveIntegrationService* drive_integration_service,
+      chromeos::PowerManagerClient* power_manager_client,
+      chromeos::disks::DiskMountManager* disk_mount_manager,
+      chromeos::file_system_provider::Service* file_system_provider_service,
+      const GetMtpStorageInfoCallback& get_mtp_storage_info_callback);
+  ~VolumeManager() override;
+
+  // Returns the instance corresponding to the |context|.
+  static VolumeManager* Get(content::BrowserContext* context);
+
+  // Initializes this instance.
+  void Initialize();
+
+  // Disposes this instance.
+  void Shutdown() override;
+
+  // Adds an observer.
+  void AddObserver(VolumeManagerObserver* observer);
+
+  // Removes the observer.
+  void RemoveObserver(VolumeManagerObserver* observer);
+
+  // Returns the information about all volumes currently mounted. The returned
+  // weak pointers are valid as long as the volumes are mounted.
+  std::vector<base::WeakPtr<Volume>> GetVolumeList();
+
+  // Finds Volume for the given volume ID. If found, then the returned weak
+  // pointer is valid. It is invalidated as soon as the volume is removed from
+  // the volume manager.
+  base::WeakPtr<Volume> FindVolumeById(const std::string& volume_id);
+
+  // Add sshfs crostini volume mounted at specified path.
+  void AddSshfsCrostiniVolume(const base::FilePath& sshfs_mount_path);
+
+  // Removes specified sshfs crostini mount.
+  void RemoveSshfsCrostiniVolume(const base::FilePath& sshfs_mount_path);
+
+  // For testing purpose, registers a native local file system pointing to
+  // |path| with DOWNLOADS type, and adds its volume info.
+  bool RegisterDownloadsDirectoryForTesting(const base::FilePath& path);
+
+  // For testing purpose, registers a native local file system pointing to
+  // |path| with CROSTINI type, and adds its volume info.
+  bool RegisterCrostiniDirectoryForTesting(const base::FilePath& path);
+
+  // For testing purpose, adds a volume info pointing to |path|, with TESTING
+  // type. Assumes that the mount point is already registered.
+  void AddVolumeForTesting(const base::FilePath& path,
+                           VolumeType volume_type,
+                           chromeos::DeviceType device_type,
+                           bool read_only);
+
+  // For testing purpose, adds the volume info to the volume manager.
+  void AddVolumeForTesting(std::unique_ptr<Volume> volume);
+
+  // drive::DriveIntegrationServiceObserver overrides.
+  void OnFileSystemMounted() override;
+  void OnFileSystemBeingUnmounted() override;
+
+  // chromeos::disks::DiskMountManager::Observer overrides.
+  void OnAutoMountableDiskEvent(
+      chromeos::disks::DiskMountManager::DiskEvent event,
+      const chromeos::disks::Disk& disk) override;
+  void OnDeviceEvent(chromeos::disks::DiskMountManager::DeviceEvent event,
+                     const std::string& device_path) override;
+  void OnMountEvent(chromeos::disks::DiskMountManager::MountEvent event,
+                    chromeos::MountError error_code,
+                    const chromeos::disks::DiskMountManager::MountPointInfo&
+                        mount_info) override;
+  void OnFormatEvent(chromeos::disks::DiskMountManager::FormatEvent event,
+                     chromeos::FormatError error_code,
+                     const std::string& device_path) override;
+  void OnRenameEvent(chromeos::disks::DiskMountManager::RenameEvent event,
+                     chromeos::RenameError error_code,
+                     const std::string& device_path) override;
+
+  // chromeos::file_system_provider::Observer overrides.
+  void OnProvidedFileSystemMount(
+      const chromeos::file_system_provider::ProvidedFileSystemInfo&
+          file_system_info,
+      chromeos::file_system_provider::MountContext context,
+      base::File::Error error) override;
+  void OnProvidedFileSystemUnmount(
+      const chromeos::file_system_provider::ProvidedFileSystemInfo&
+          file_system_info,
+      base::File::Error error) override;
+
+  // arc::ArcSessionManager::Observer overrides.
+  void OnArcPlayStoreEnabledChanged(bool enabled) override;
+
+  // Called on change to kExternalStorageDisabled pref.
+  void OnExternalStorageDisabledChanged();
+
+  // Called on change to kExternalStorageReadOnly pref.
+  void OnExternalStorageReadOnlyChanged();
+
+  // RemovableStorageObserver overrides.
+  void OnRemovableStorageAttached(
+      const storage_monitor::StorageInfo& info) override;
+  void OnRemovableStorageDetached(
+      const storage_monitor::StorageInfo& info) override;
+
+  SnapshotManager* snapshot_manager() { return snapshot_manager_.get(); }
+
+ private:
+  void OnDiskMountManagerRefreshed(bool success);
+  void OnStorageMonitorInitialized();
+  void DoAttachMtpStorage(const storage_monitor::StorageInfo& info,
+                          device::mojom::MtpStorageInfoPtr mtp_storage_info);
+  void DoMountEvent(chromeos::MountError error_code,
+                    std::unique_ptr<Volume> volume);
+  void DoUnmountEvent(chromeos::MountError error_code, const Volume& volume);
+  void OnExternalStorageDisabledChangedUnmountCallback(
+      chromeos::MountError error_code);
+
+  // Returns the path of the mount point for drive.
+  base::FilePath GetDriveMountPointPath() const;
+
+  Profile* profile_;
+  drive::DriveIntegrationService* drive_integration_service_;  // Not owned.
+  chromeos::disks::DiskMountManager* disk_mount_manager_;      // Not owned.
+  PrefChangeRegistrar pref_change_registrar_;
+  base::ObserverList<VolumeManagerObserver>::Unchecked observers_;
+  chromeos::file_system_provider::Service*
+      file_system_provider_service_;  // Not owned by this class.
+  GetMtpStorageInfoCallback get_mtp_storage_info_callback_;
+  std::map<std::string, std::unique_ptr<Volume>> mounted_volumes_;
+  std::unique_ptr<SnapshotManager> snapshot_manager_;
+  bool arc_volumes_mounted_ = false;
+
+  // Note: This should remain the last member so it'll be destroyed and
+  // invalidate its weak pointers before any other members are destroyed.
+  base::WeakPtrFactory<VolumeManager> weak_ptr_factory_;
+  DISALLOW_COPY_AND_ASSIGN(VolumeManager);
+};
+
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_CHROMEOS_VOLUME_MANAGER_H_
diff --git a/chrome/browser/file_manager/linux/volume_manager.cc b/chrome/browser/file_manager/linux/volume_manager.cc
new file mode 100644
index 0000000000000..147e98cdfac58
--- /dev/null
+++ b/chrome/browser/file_manager/linux/volume_manager.cc
@@ -0,0 +1,183 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/file_manager/linux/volume_manager.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include "base/bind.h"
+#include "base/command_line.h"
+#include "base/feature_list.h"
+#include "base/files/file_path.h"
+#include "base/logging.h"
+#include "base/memory/weak_ptr.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/file_manager/path_util.h"
+#include "chrome/browser/file_manager/snapshot_manager.h"
+#include "chrome/browser/file_manager/volume_manager_factory.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/common/pref_names.h"
+#include "components/prefs/pref_service.h"
+#include "components/storage_monitor/storage_monitor.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/browser_thread.h"
+#include "storage/browser/fileapi/external_mount_points.h"
+
+namespace file_manager {
+namespace {
+
+// Registers |path| as the "Downloads" folder to the FileSystem API backend.
+// If another folder is already mounted. It revokes and overrides the old one.
+bool RegisterDownloadsMountPoint(Profile* profile, const base::FilePath& path) {
+  // Although we show only profile's own "Downloads" folder in the Files app,
+  // in the backend we need to mount all profile's download directory globally.
+  // Otherwise, the Files app cannot support cross-profile file copies, etc.
+  // For this reason, we need to register to the global GetSystemInstance().
+  const std::string mount_point_name =
+      file_manager::util::GetDownloadsMountPointName(profile);
+  storage::ExternalMountPoints* const mount_points =
+      storage::ExternalMountPoints::GetSystemInstance();
+
+  // In some tests we want to override existing Downloads mount point, so we
+  // first revoke the existing mount point (if any).
+  mount_points->RevokeFileSystem(mount_point_name);
+  return mount_points->RegisterFileSystem(mount_point_name,
+                                          storage::kFileSystemTypeNativeLocal,
+                                          storage::FileSystemMountOption(),
+                                          path);
+}
+
+// Returns a string representation of the given volume type.
+std::string VolumeTypeToString(VolumeType type) {
+  switch (type) {
+    case VOLUME_TYPE_GOOGLE_DRIVE:
+      return "drive";
+    case VOLUME_TYPE_DOWNLOADS_DIRECTORY:
+      return "downloads";
+    case VOLUME_TYPE_REMOVABLE_DISK_PARTITION:
+      return "removable";
+    case VOLUME_TYPE_MOUNTED_ARCHIVE_FILE:
+      return "archive";
+    case VOLUME_TYPE_PROVIDED:
+      return "provided";
+    case VOLUME_TYPE_MTP:
+      return "mtp";
+    case VOLUME_TYPE_MEDIA_VIEW:
+      return "media_view";
+    case VOLUME_TYPE_ANDROID_FILES:
+      return "android_files";
+    case VOLUME_TYPE_TESTING:
+      return "testing";
+    case VOLUME_TYPE_CROSTINI:
+      return "crostini";
+    case NUM_VOLUME_TYPE:
+      break;
+  }
+  NOTREACHED();
+  return "";
+}
+
+// Generates a unique volume ID for the given volume info.
+std::string GenerateVolumeId(const Volume& volume) {
+  // For the same volume type, base names are unique, as mount points are
+  // flat for the same volume type.
+  return (VolumeTypeToString(volume.type()) + ":" +
+          volume.mount_path().BaseName().AsUTF8Unsafe());
+}
+
+}  // namespace
+
+Volume::Volume()
+    : source_(SOURCE_FILE),
+      type_(VOLUME_TYPE_GOOGLE_DRIVE),
+      is_parent_(false),
+      is_read_only_(false),
+      is_read_only_removable_device_(false),
+      has_media_(false),
+      configurable_(false),
+      watchable_(false) {
+}
+
+Volume::~Volume() = default;
+
+// static
+std::unique_ptr<Volume> Volume::CreateForDownloads(
+    const base::FilePath& downloads_path) {
+  std::unique_ptr<Volume> volume(new Volume());
+  volume->type_ = VOLUME_TYPE_DOWNLOADS_DIRECTORY;
+  // Keep source_path empty.
+  volume->source_ = SOURCE_SYSTEM;
+  volume->mount_path_ = downloads_path;
+  volume->volume_id_ = GenerateVolumeId(*volume);
+  volume->watchable_ = true;
+  return volume;
+}
+
+VolumeManager::VolumeManager(Profile* profile)
+    : profile_(profile),
+      snapshot_manager_(new SnapshotManager(profile_)),
+      weak_ptr_factory_(this) {}
+
+VolumeManager::~VolumeManager() = default;
+
+VolumeManager* VolumeManager::Get(content::BrowserContext* context) {
+  return VolumeManagerFactory::Get(context);
+}
+
+void VolumeManager::Initialize() {
+  // Register 'Downloads' folder for the profile to the file system.
+  const base::FilePath downloads =
+      file_manager::util::GetDownloadsFolderForProfile(profile_);
+  const bool success = RegisterDownloadsMountPoint(profile_, downloads);
+  DCHECK(success);
+  AddVolume(Volume::CreateForDownloads(downloads));
+}
+
+void VolumeManager::Shutdown() {
+  weak_ptr_factory_.InvalidateWeakPtrs();
+
+  snapshot_manager_.reset();
+}
+
+std::vector<base::WeakPtr<Volume>> VolumeManager::GetVolumeList() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  std::vector<base::WeakPtr<Volume>> result;
+  result.reserve(mounted_volumes_.size());
+  for (const auto& pair : mounted_volumes_) {
+    result.push_back(pair.second->AsWeakPtr());
+  }
+  return result;
+}
+
+base::WeakPtr<Volume> VolumeManager::FindVolumeById(
+    const std::string& volume_id) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  const auto it = mounted_volumes_.find(volume_id);
+  if (it != mounted_volumes_.end())
+    return it->second->AsWeakPtr();
+  return base::WeakPtr<Volume>();
+}
+
+void VolumeManager::AddVolume(std::unique_ptr<Volume> volume) {
+  mounted_volumes_[volume->volume_id()] = std::move(volume);
+}
+
+void VolumeManager::RemoveVolume(const Volume& volume) {
+  auto iter = mounted_volumes_.find(volume.volume_id());
+  if (iter == mounted_volumes_.end())
+    return;
+  std::unique_ptr<Volume> volume_ref;
+  // It is important to hold a reference to the removed Volume from
+  // |mounted_volumes_|, because OnVolumeMounted() will access it.
+  volume_ref = std::move(iter->second);
+  mounted_volumes_.erase(iter);
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/file_manager/linux/volume_manager.h b/chrome/browser/file_manager/linux/volume_manager.h
new file mode 100644
index 0000000000000..ec8e37529d198
--- /dev/null
+++ b/chrome/browser/file_manager/linux/volume_manager.h
@@ -0,0 +1,194 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_FILE_MANAGER_LINUX_VOLUME_MANAGER_H_
+#define CHROME_BROWSER_FILE_MANAGER_LINUX_VOLUME_MANAGER_H_
+
+#include <map>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/callback.h"
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/observer_list.h"
+#include "components/keyed_service/core/keyed_service.h"
+#include "components/prefs/pref_change_registrar.h"
+
+class Profile;
+
+namespace content {
+class BrowserContext;
+}  // namespace content
+
+namespace file_manager {
+
+class SnapshotManager;
+
+// Identifiers for volume types managed by Chrome OS file manager.
+enum VolumeType {
+  VOLUME_TYPE_TESTING = -1,  // Used only in tests.
+  VOLUME_TYPE_GOOGLE_DRIVE = 0,
+  VOLUME_TYPE_DOWNLOADS_DIRECTORY,
+  VOLUME_TYPE_REMOVABLE_DISK_PARTITION,
+  VOLUME_TYPE_MOUNTED_ARCHIVE_FILE,
+  VOLUME_TYPE_PROVIDED,  // File system provided by the FileSystemProvider API.
+  VOLUME_TYPE_MTP,
+  VOLUME_TYPE_MEDIA_VIEW,
+  VOLUME_TYPE_CROSTINI,
+  VOLUME_TYPE_ANDROID_FILES,
+  // The enum values must be kept in sync with FileManagerVolumeType in
+  // tools/metrics/histograms/histograms.xml. Since enums for histograms are
+  // append-only (for keeping the number consistent across versions), new values
+  // for this enum also has to be always appended at the end (i.e., here).
+  NUM_VOLUME_TYPE,
+};
+
+// Source of a volume's data.
+enum Source { SOURCE_FILE, SOURCE_DEVICE, SOURCE_NETWORK, SOURCE_SYSTEM };
+
+// Represents a volume (mount point) in the volume manager. Validity of the data
+// is guaranteed by the weak pointer. Simply saying, the weak pointer should be
+// valid as long as the volume is mounted.
+class Volume : public base::SupportsWeakPtr<Volume> {
+ public:
+  ~Volume();
+
+  static std::unique_ptr<Volume> CreateForDownloads(
+      const base::FilePath& downloads_path);
+
+  // Getters for all members. See below for details.
+  const std::string& volume_id() const { return volume_id_; }
+  Source source() const { return source_; }
+  VolumeType type() const { return type_; }
+  const base::FilePath& source_path() const { return source_path_; }
+  const base::FilePath& mount_path() const { return mount_path_; }
+  const base::FilePath& system_path_prefix() const {
+    return system_path_prefix_;
+  }
+  const std::string& volume_label() const { return volume_label_; }
+  bool is_parent() const { return is_parent_; }
+  // Whether the applications can write to the volume. True if not writable.
+  // For example, when write access to external storage is restricted by the
+  // policy (ExternalStorageReadOnly), is_read_only() will be true even when
+  // is_read_only_removable_device() is false.
+  bool is_read_only() const { return is_read_only_; }
+  // Whether the device is write-protected by hardware. This field is valid
+  // only when device_type is VOLUME_TYPE_REMOVABLE_DISK_PARTITION and
+  // source is SOURCE_DEVICE.
+  // When this value is true, is_read_only() is also true.
+  bool is_read_only_removable_device() const {
+    return is_read_only_removable_device_;
+  }
+  bool has_media() const { return has_media_; }
+  bool configurable() const { return configurable_; }
+  bool watchable() const { return watchable_; }
+  const std::string& file_system_type() const { return file_system_type_; }
+
+ private:
+  Volume();
+
+  // The ID of the volume.
+  std::string volume_id_;
+
+  // The source of the volume's data.
+  Source source_;
+
+  // The type of mounted volume.
+  VolumeType type_;
+
+  // The source path of the volume.
+  // E.g.:
+  // - /home/chronos/user/Downloads/zipfile_path.zip
+  base::FilePath source_path_;
+
+  // The mount path of the volume.
+  // E.g.:
+  // - /home/chronos/user/Downloads
+  // - /media/removable/usb1
+  // - /media/archive/zip1
+  base::FilePath mount_path_;
+
+  // Path of the system device this device's block is a part of.
+  // (e.g. /sys/devices/pci0000:00/.../8:0:0:0/)
+  base::FilePath system_path_prefix_;
+
+  // Label for the volume if the volume is either removable or a provided
+  // file system. In case of removables, if disk is a parent, then its label,
+  // else parents label (e.g. "TransMemory").
+  std::string volume_label_;
+
+  // Is the device is a parent device (i.e. sdb rather than sdb1).
+  bool is_parent_;
+
+  // True if the volume is not writable by applications.
+  bool is_read_only_;
+
+  // True if the volume is made read_only due to its hardware.
+  // This implies is_read_only_.
+  bool is_read_only_removable_device_;
+
+  // True if the volume contains media.
+  bool has_media_;
+
+  // True if the volume is configurable.
+  bool configurable_;
+
+  // True if the volume notifies about changes via file/directory watchers.
+  bool watchable_;
+
+  // Identifier for the file system type
+  std::string file_system_type_;
+
+  DISALLOW_COPY_AND_ASSIGN(Volume);
+};
+
+// Manages Volumes for file manager. Example of Volumes:
+// - Downloads directory.
+class VolumeManager : public KeyedService {
+ public:
+  VolumeManager(Profile* profile);
+  ~VolumeManager() override;
+
+  // Returns the instance corresponding to the |context|.
+  static VolumeManager* Get(content::BrowserContext* context);
+
+  // Initializes this instance.
+  void Initialize();
+
+  // Disposes this instance.
+  void Shutdown() override;
+
+  // Returns the information about all volumes currently mounted. The returned
+  // weak pointers are valid as long as the volumes are mounted.
+  std::vector<base::WeakPtr<Volume>> GetVolumeList();
+
+  // Finds Volume for the given volume ID. If found, then the returned weak
+  // pointer is valid. It is invalidated as soon as the volume is removed from
+  // the volume manager.
+  base::WeakPtr<Volume> FindVolumeById(const std::string& volume_id);
+
+
+  SnapshotManager* snapshot_manager() { return snapshot_manager_.get(); }
+
+ private:
+  void AddVolume(std::unique_ptr<Volume> volume);
+  void RemoveVolume(const Volume& volume);
+
+  Profile* profile_;
+  std::map<std::string, std::unique_ptr<Volume>> mounted_volumes_;
+  std::unique_ptr<SnapshotManager> snapshot_manager_;
+
+  // Note: This should remain the last member so it'll be destroyed and
+  // invalidate its weak pointers before any other members are destroyed.
+  base::WeakPtrFactory<VolumeManager> weak_ptr_factory_;
+  DISALLOW_COPY_AND_ASSIGN(VolumeManager);
+};
+
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_FILE_MANAGER_LINUX_VOLUME_MANAGER_H_

From 0a4c88119587ac5a20d4c7a65fa0641e9b44482d Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Tue, 14 Aug 2018 20:36:24 +0900
Subject: [PATCH 25/32] Add platform folder to
 chrome/browser/extensions/api/file_system_provider/

As it has many features specific to ChromeOs,
this patch adds platform folder to handle it separately.

It's still not included for building.
---
 .../chromeos/file_system_provider_api.cc      | 372 ++++++++++++++++++
 .../chromeos/file_system_provider_api.h       | 152 +++++++
 .../chromeos/file_system_provider_apitest.cc  | 303 ++++++++++++++
 .../chromeos/provider_function.cc             | 176 +++++++++
 .../chromeos/provider_function.h              |  79 ++++
 .../file_system_provider_api.h                | 156 +-------
 .../linux/file_system_provider_api.cc         |  76 ++++
 .../linux/file_system_provider_api.h          | 152 +++++++
 .../linux/provider_function.cc                |  20 +
 .../linux/provider_function.h                 |  33 ++
 10 files changed, 1372 insertions(+), 147 deletions(-)
 create mode 100644 chrome/browser/extensions/api/file_system_provider/chromeos/file_system_provider_api.cc
 create mode 100644 chrome/browser/extensions/api/file_system_provider/chromeos/file_system_provider_api.h
 create mode 100644 chrome/browser/extensions/api/file_system_provider/chromeos/file_system_provider_apitest.cc
 create mode 100644 chrome/browser/extensions/api/file_system_provider/chromeos/provider_function.cc
 create mode 100644 chrome/browser/extensions/api/file_system_provider/chromeos/provider_function.h
 create mode 100644 chrome/browser/extensions/api/file_system_provider/linux/file_system_provider_api.cc
 create mode 100644 chrome/browser/extensions/api/file_system_provider/linux/file_system_provider_api.h
 create mode 100644 chrome/browser/extensions/api/file_system_provider/linux/provider_function.cc
 create mode 100644 chrome/browser/extensions/api/file_system_provider/linux/provider_function.h

diff --git a/chrome/browser/extensions/api/file_system_provider/chromeos/file_system_provider_api.cc b/chrome/browser/extensions/api/file_system_provider/chromeos/file_system_provider_api.cc
new file mode 100644
index 0000000000000..00c3b9e9ab919
--- /dev/null
+++ b/chrome/browser/extensions/api/file_system_provider/chromeos/file_system_provider_api.cc
@@ -0,0 +1,372 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_system_provider/chromeos/file_system_provider_api.h"
+
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/memory/ptr_util.h"
+#include "base/trace_event/trace_event.h"
+#include "base/values.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_info.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_interface.h"
+#include "chrome/browser/chromeos/file_system_provider/request_manager.h"
+#include "chrome/browser/chromeos/file_system_provider/request_value.h"
+#include "chrome/browser/chromeos/file_system_provider/service.h"
+#include "chrome/common/extensions/api/file_system_provider.h"
+#include "chrome/common/extensions/api/file_system_provider_internal.h"
+#include "storage/browser/fileapi/watcher_manager.h"
+
+using chromeos::file_system_provider::MountOptions;
+using chromeos::file_system_provider::OpenedFiles;
+using chromeos::file_system_provider::ProvidedFileSystemInfo;
+using chromeos::file_system_provider::ProvidedFileSystemInterface;
+using chromeos::file_system_provider::ProvidedFileSystemObserver;
+using chromeos::file_system_provider::ProviderId;
+using chromeos::file_system_provider::RequestValue;
+using chromeos::file_system_provider::Service;
+using chromeos::file_system_provider::Watchers;
+
+namespace extensions {
+namespace {
+
+// Converts the change type from the IDL type to a native type. |changed_type|
+// must be specified (not CHANGE_TYPE_NONE).
+storage::WatcherManager::ChangeType ParseChangeType(
+    const api::file_system_provider::ChangeType& change_type) {
+  switch (change_type) {
+    case api::file_system_provider::CHANGE_TYPE_CHANGED:
+      return storage::WatcherManager::CHANGED;
+    case api::file_system_provider::CHANGE_TYPE_DELETED:
+      return storage::WatcherManager::DELETED;
+    default:
+      break;
+  }
+  NOTREACHED();
+  return storage::WatcherManager::CHANGED;
+}
+
+// Convert the change from the IDL type to a native type. The reason IDL types
+// are not used is since they are imperfect, eg. paths are stored as strings.
+ProvidedFileSystemObserver::Change ParseChange(
+    const api::file_system_provider::Change& change) {
+  ProvidedFileSystemObserver::Change result;
+  result.entry_path = base::FilePath::FromUTF8Unsafe(change.entry_path);
+  result.change_type = ParseChangeType(change.change_type);
+  return result;
+}
+
+// Converts a list of child changes from the IDL type to a native type.
+std::unique_ptr<ProvidedFileSystemObserver::Changes> ParseChanges(
+    const std::vector<api::file_system_provider::Change>& changes) {
+  std::unique_ptr<ProvidedFileSystemObserver::Changes> results(
+      new ProvidedFileSystemObserver::Changes);
+  for (const auto& change : changes) {
+    results->push_back(ParseChange(change));
+  }
+  return results;
+}
+
+// Fills the IDL's FileSystemInfo with FSP's ProvidedFileSystemInfo and
+// Watchers.
+void FillFileSystemInfo(const ProvidedFileSystemInfo& file_system_info,
+                        const Watchers& watchers,
+                        const OpenedFiles& opened_files,
+                        api::file_system_provider::FileSystemInfo* output) {
+  using api::file_system_provider::Watcher;
+  using api::file_system_provider::OpenedFile;
+
+  output->file_system_id = file_system_info.file_system_id();
+  output->display_name = file_system_info.display_name();
+  output->writable = file_system_info.writable();
+  output->opened_files_limit = file_system_info.opened_files_limit();
+
+  for (const auto& watcher : watchers) {
+    Watcher watcher_item;
+    watcher_item.entry_path = watcher.second.entry_path.value();
+    watcher_item.recursive = watcher.second.recursive;
+    if (!watcher.second.last_tag.empty())
+      watcher_item.last_tag.reset(new std::string(watcher.second.last_tag));
+    output->watchers.push_back(std::move(watcher_item));
+  }
+
+  for (const auto& opened_file : opened_files) {
+    OpenedFile opened_file_item;
+    opened_file_item.open_request_id = opened_file.first;
+    opened_file_item.file_path = opened_file.second.file_path.value();
+    switch (opened_file.second.mode) {
+      case chromeos::file_system_provider::OPEN_FILE_MODE_READ:
+        opened_file_item.mode =
+            extensions::api::file_system_provider::OPEN_FILE_MODE_READ;
+        break;
+      case chromeos::file_system_provider::OPEN_FILE_MODE_WRITE:
+        opened_file_item.mode =
+            extensions::api::file_system_provider::OPEN_FILE_MODE_WRITE;
+        break;
+    }
+    output->opened_files.push_back(std::move(opened_file_item));
+  }
+}
+
+}  // namespace
+
+ExtensionFunction::ResponseAction FileSystemProviderMountFunction::Run() {
+  using api::file_system_provider::Mount::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  // It's an error if the file system Id is empty.
+  if (params->options.file_system_id.empty()) {
+    return RespondNow(
+        Error(FileErrorToString(base::File::FILE_ERROR_INVALID_OPERATION)));
+  }
+
+  // It's an error if the display name is empty.
+  if (params->options.display_name.empty()) {
+    return RespondNow(
+        Error(FileErrorToString(base::File::FILE_ERROR_INVALID_OPERATION)));
+  }
+
+  // If the opened files limit is set, then it must be larger or equal than 0.
+  if (params->options.opened_files_limit.get() &&
+      *params->options.opened_files_limit.get() < 0) {
+    return RespondNow(
+        Error(FileErrorToString(base::File::FILE_ERROR_INVALID_OPERATION)));
+  }
+
+  Service* const service =
+      Service::Get(Profile::FromBrowserContext(browser_context()));
+  DCHECK(service);
+
+  MountOptions options;
+  options.file_system_id = params->options.file_system_id;
+  options.display_name = params->options.display_name;
+  options.writable = params->options.writable != nullptr;
+  options.opened_files_limit = params->options.opened_files_limit.get()
+                                   ? *params->options.opened_files_limit.get()
+                                   : 0;
+  options.supports_notify_tag = params->options.supports_notify_tag != nullptr;
+  options.persistent = params->options.persistent.get()
+                           ? *params->options.persistent.get()
+                           : true;
+
+  const base::File::Error result = service->MountFileSystem(
+      ProviderId::CreateFromExtensionId(extension_id()), options);
+  if (result != base::File::FILE_OK)
+    return RespondNow(Error(FileErrorToString(result)));
+
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction FileSystemProviderUnmountFunction::Run() {
+  using api::file_system_provider::Unmount::Params;
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  Service* const service =
+      Service::Get(Profile::FromBrowserContext(browser_context()));
+  DCHECK(service);
+
+  const base::File::Error result = service->UnmountFileSystem(
+      ProviderId::CreateFromExtensionId(extension_id()),
+      params->options.file_system_id, Service::UNMOUNT_REASON_USER);
+  if (result != base::File::FILE_OK)
+    return RespondNow(Error(FileErrorToString(result)));
+
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction FileSystemProviderGetAllFunction::Run() {
+  using api::file_system_provider::FileSystemInfo;
+  Service* const service =
+      Service::Get(Profile::FromBrowserContext(browser_context()));
+  DCHECK(service);
+
+  ProviderId provider_id = ProviderId::CreateFromExtensionId(extension_id());
+  const std::vector<ProvidedFileSystemInfo> file_systems =
+      service->GetProvidedFileSystemInfoList(provider_id);
+
+  std::vector<FileSystemInfo> items;
+
+  for (const auto& file_system_info : file_systems) {
+    FileSystemInfo item;
+
+    chromeos::file_system_provider::ProvidedFileSystemInterface* const
+        file_system = service->GetProvidedFileSystem(
+            file_system_info.provider_id(), file_system_info.file_system_id());
+
+    DCHECK(file_system);
+
+    FillFileSystemInfo(
+        file_system_info,
+        file_system_info.watchable() ? *file_system->GetWatchers() : Watchers(),
+        file_system->GetOpenedFiles(), &item);
+
+    items.push_back(std::move(item));
+  }
+
+  return RespondNow(
+      ArgumentList(api::file_system_provider::GetAll::Results::Create(items)));
+}
+
+ExtensionFunction::ResponseAction FileSystemProviderGetFunction::Run() {
+  using api::file_system_provider::Get::Params;
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  using api::file_system_provider::FileSystemInfo;
+  Service* const service =
+      Service::Get(Profile::FromBrowserContext(browser_context()));
+  DCHECK(service);
+
+  chromeos::file_system_provider::ProvidedFileSystemInterface* const
+      file_system = service->GetProvidedFileSystem(
+          ProviderId::CreateFromExtensionId(extension_id()),
+          params->file_system_id);
+
+  if (!file_system) {
+    return RespondNow(
+        Error(FileErrorToString(base::File::FILE_ERROR_NOT_FOUND)));
+  }
+
+  FileSystemInfo file_system_info;
+  FillFileSystemInfo(file_system->GetFileSystemInfo(),
+                     file_system->GetFileSystemInfo().watchable()
+                         ? *file_system->GetWatchers()
+                         : Watchers(),
+                     file_system->GetOpenedFiles(), &file_system_info);
+  return RespondNow(ArgumentList(
+      api::file_system_provider::Get::Results::Create(file_system_info)));
+}
+
+bool FileSystemProviderNotifyFunction::RunAsync() {
+  using api::file_system_provider::Notify::Params;
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  Service* const service = Service::Get(GetProfile());
+  DCHECK(service);
+
+  ProvidedFileSystemInterface* const file_system =
+      service->GetProvidedFileSystem(
+          ProviderId::CreateFromExtensionId(extension_id()),
+          params->options.file_system_id);
+  if (!file_system) {
+    SetError(FileErrorToString(base::File::FILE_ERROR_NOT_FOUND));
+    return false;
+  }
+
+  file_system->Notify(
+      base::FilePath::FromUTF8Unsafe(params->options.observed_path),
+      params->options.recursive, ParseChangeType(params->options.change_type),
+      params->options.changes.get()
+          ? ParseChanges(*params->options.changes.get())
+          : base::WrapUnique(new ProvidedFileSystemObserver::Changes),
+      params->options.tag.get() ? *params->options.tag.get() : "",
+      base::Bind(&FileSystemProviderNotifyFunction::OnNotifyCompleted, this));
+
+  return true;
+}
+
+void FileSystemProviderNotifyFunction::OnNotifyCompleted(
+    base::File::Error result) {
+  if (result != base::File::FILE_OK) {
+    SetError(FileErrorToString(result));
+    SendResponse(false);
+    return;
+  }
+
+  SendResponse(true);
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalUnmountRequestedSuccessFunction::Run() {
+  using api::file_system_provider_internal::UnmountRequestedSuccess::Params;
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  return FulfillRequest(
+      RequestValue::CreateForUnmountSuccess(std::move(params)),
+      false /* has_more */);
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalGetMetadataRequestedSuccessFunction::Run() {
+  using api::file_system_provider_internal::GetMetadataRequestedSuccess::Params;
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  return FulfillRequest(
+      RequestValue::CreateForGetMetadataSuccess(std::move(params)),
+      false /* has_more */);
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalGetActionsRequestedSuccessFunction::Run() {
+  using api::file_system_provider_internal::GetActionsRequestedSuccess::Params;
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  return FulfillRequest(
+      RequestValue::CreateForGetActionsSuccess(std::move(params)),
+      false /* has_more */);
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalReadDirectoryRequestedSuccessFunction::Run() {
+  using api::file_system_provider_internal::ReadDirectoryRequestedSuccess::
+      Params;
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const bool has_more = params->has_more;
+  return FulfillRequest(
+      RequestValue::CreateForReadDirectorySuccess(std::move(params)), has_more);
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalReadFileRequestedSuccessFunction::Run() {
+  TRACE_EVENT0("file_system_provider", "ReadFileRequestedSuccess");
+  using api::file_system_provider_internal::ReadFileRequestedSuccess::Params;
+
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const bool has_more = params->has_more;
+  return FulfillRequest(
+      RequestValue::CreateForReadFileSuccess(std::move(params)), has_more);
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalOperationRequestedSuccessFunction::Run() {
+  using api::file_system_provider_internal::OperationRequestedSuccess::Params;
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  return FulfillRequest(
+      std::unique_ptr<RequestValue>(
+          RequestValue::CreateForOperationSuccess(std::move(params))),
+      false /* has_more */);
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalOperationRequestedErrorFunction::Run() {
+  using api::file_system_provider_internal::OperationRequestedError::Params;
+  std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  if (params->error == api::file_system_provider::PROVIDER_ERROR_OK) {
+    // It's incorrect to pass OK as an error code.
+    return ValidationFailure(this);
+  }
+
+  const base::File::Error error = ProviderErrorToFileError(params->error);
+  return RejectRequest(RequestValue::CreateForOperationError(std::move(params)),
+                       error);
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_system_provider/chromeos/file_system_provider_api.h b/chrome/browser/extensions/api/file_system_provider/chromeos/file_system_provider_api.h
new file mode 100644
index 0000000000000..39294c59111cf
--- /dev/null
+++ b/chrome/browser/extensions/api/file_system_provider/chromeos/file_system_provider_api.h
@@ -0,0 +1,152 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_SYSTEM_PROVIDER_CHROMEOS_FILE_SYSTEM_PROVIDER_API_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_SYSTEM_PROVIDER_CHROMEOS_FILE_SYSTEM_PROVIDER_API_H_
+
+#include "chrome/browser/extensions/api/file_system_provider/chromeos/provider_function.h"
+#include "chrome/browser/extensions/chrome_extension_function.h"
+
+namespace extensions {
+
+class FileSystemProviderMountFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.mount",
+                             FILESYSTEMPROVIDER_MOUNT)
+
+ protected:
+  ~FileSystemProviderMountFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderUnmountFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.unmount",
+                             FILESYSTEMPROVIDER_UNMOUNT)
+
+ protected:
+  ~FileSystemProviderUnmountFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderGetAllFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.getAll",
+                             FILESYSTEMPROVIDER_GETALL)
+
+ protected:
+  ~FileSystemProviderGetAllFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderGetFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.get", FILESYSTEMPROVIDER_GET)
+
+ protected:
+  ~FileSystemProviderGetFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderNotifyFunction : public ChromeAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.notify",
+                             FILESYSTEMPROVIDER_NOTIFY)
+
+ protected:
+  ~FileSystemProviderNotifyFunction() override {}
+  bool RunAsync() override;
+
+ private:
+  // Called when notifying is completed.
+  void OnNotifyCompleted(base::File::Error result);
+};
+
+class FileSystemProviderInternalUnmountRequestedSuccessFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.unmountRequestedSuccess",
+      FILESYSTEMPROVIDERINTERNAL_UNMOUNTREQUESTEDSUCCESS)
+
+ protected:
+  ~FileSystemProviderInternalUnmountRequestedSuccessFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderInternalGetMetadataRequestedSuccessFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.getMetadataRequestedSuccess",
+      FILESYSTEMPROVIDERINTERNAL_GETMETADATAREQUESTEDSUCCESS)
+
+ protected:
+  ~FileSystemProviderInternalGetMetadataRequestedSuccessFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderInternalGetActionsRequestedSuccessFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.getActionsRequestedSuccess",
+      FILESYSTEMPROVIDERINTERNAL_GETACTIONSREQUESTEDSUCCESS)
+
+ protected:
+  ~FileSystemProviderInternalGetActionsRequestedSuccessFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderInternalReadDirectoryRequestedSuccessFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.readDirectoryRequestedSuccess",
+      FILESYSTEMPROVIDERINTERNAL_READDIRECTORYREQUESTEDSUCCESS)
+
+ protected:
+  ~FileSystemProviderInternalReadDirectoryRequestedSuccessFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderInternalReadFileRequestedSuccessFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.readFileRequestedSuccess",
+      FILESYSTEMPROVIDERINTERNAL_READFILEREQUESTEDSUCCESS)
+
+ protected:
+  ~FileSystemProviderInternalReadFileRequestedSuccessFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderInternalOperationRequestedSuccessFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.operationRequestedSuccess",
+      FILESYSTEMPROVIDERINTERNAL_OPERATIONREQUESTEDSUCCESS)
+
+ protected:
+  ~FileSystemProviderInternalOperationRequestedSuccessFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderInternalOperationRequestedErrorFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.operationRequestedError",
+      FILESYSTEMPROVIDERINTERNAL_OPERATIONREQUESTEDERROR)
+
+ protected:
+  ~FileSystemProviderInternalOperationRequestedErrorFunction() override {}
+  ResponseAction Run() override;
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_SYSTEM_PROVIDER_CHROMEOS_FILE_SYSTEM_PROVIDER_API_H_
diff --git a/chrome/browser/extensions/api/file_system_provider/chromeos/file_system_provider_apitest.cc b/chrome/browser/extensions/api/file_system_provider/chromeos/file_system_provider_apitest.cc
new file mode 100644
index 0000000000000..9ba4c1b5c9ce2
--- /dev/null
+++ b/chrome/browser/extensions/api/file_system_provider/chromeos/file_system_provider_apitest.cc
@@ -0,0 +1,303 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <memory>
+#include <utility>
+
+#include "base/files/file.h"
+#include "base/macros.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "base/time/time.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/chromeos/file_system_provider/notification_manager_interface.h"
+#include "chrome/browser/chromeos/file_system_provider/observer.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_info.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_interface.h"
+#include "chrome/browser/chromeos/file_system_provider/request_manager.h"
+#include "chrome/browser/chromeos/file_system_provider/request_value.h"
+#include "chrome/browser/chromeos/file_system_provider/service.h"
+#include "chrome/browser/extensions/extension_apitest.h"
+#include "chrome/browser/notifications/notification_display_service_tester.h"
+#include "ui/message_center/public/cpp/notification.h"
+#include "ui/message_center/public/cpp/notification_delegate.h"
+
+namespace extensions {
+namespace {
+
+using chromeos::file_system_provider::MountContext;
+using chromeos::file_system_provider::NotificationManagerInterface;
+using chromeos::file_system_provider::Observer;
+using chromeos::file_system_provider::ProvidedFileSystemInterface;
+using chromeos::file_system_provider::ProvidedFileSystemInfo;
+using chromeos::file_system_provider::RequestManager;
+using chromeos::file_system_provider::RequestType;
+using chromeos::file_system_provider::RequestValue;
+using chromeos::file_system_provider::Service;
+
+// Clicks the default button on the notification as soon as request timeouts
+// and a unresponsiveness notification is shown.
+class NotificationButtonClicker : public RequestManager::Observer {
+ public:
+  explicit NotificationButtonClicker(
+      const ProvidedFileSystemInfo& file_system_info)
+      : file_system_info_(file_system_info) {}
+  ~NotificationButtonClicker() override {}
+
+  // RequestManager::Observer overrides.
+  void OnRequestCreated(int request_id, RequestType type) override {}
+  void OnRequestDestroyed(int request_id) override {}
+  void OnRequestExecuted(int request_id) override {}
+  void OnRequestFulfilled(int request_id,
+                          const RequestValue& result,
+                          bool has_more) override {}
+  void OnRequestRejected(int request_id,
+                         const RequestValue& result,
+                         base::File::Error error) override {}
+  void OnRequestTimeouted(int request_id) override {
+    // Call asynchronously so the notification is setup is completed.
+    base::ThreadTaskRunnerHandle::Get()->PostTask(
+        FROM_HERE, base::BindOnce(&NotificationButtonClicker::ClickButton,
+                                  base::Unretained(this)));
+  }
+
+ private:
+  void ClickButton() {
+    base::Optional<message_center::Notification> notification =
+        NotificationDisplayServiceTester::Get()->GetNotification(
+            file_system_info_.mount_path().value());
+    if (notification)
+      notification->delegate()->Click(0, base::nullopt);
+  }
+
+  ProvidedFileSystemInfo file_system_info_;
+
+  DISALLOW_COPY_AND_ASSIGN(NotificationButtonClicker);
+};
+
+// Simulates clicking on the unresponsive notification's abort button. Also,
+// sets the timeout delay to 0 ms, so the notification is shown faster.
+class AbortOnUnresponsivePerformer : public Observer {
+ public:
+  explicit AbortOnUnresponsivePerformer(Profile* profile)
+      : service_(Service::Get(profile)) {
+    DCHECK(profile);
+    DCHECK(service_);
+    service_->AddObserver(this);
+  }
+
+  ~AbortOnUnresponsivePerformer() override { service_->RemoveObserver(this); }
+
+  // Observer overrides.
+  void OnProvidedFileSystemMount(const ProvidedFileSystemInfo& file_system_info,
+                                 MountContext context,
+                                 base::File::Error error) override {
+    if (error != base::File::FILE_OK)
+      return;
+
+    ProvidedFileSystemInterface* const file_system =
+        service_->GetProvidedFileSystem(file_system_info.provider_id(),
+                                        file_system_info.file_system_id());
+    DCHECK(file_system);
+    file_system->GetRequestManager()->SetTimeoutForTesting(base::TimeDelta());
+
+    std::unique_ptr<NotificationButtonClicker> clicker(
+        new NotificationButtonClicker(file_system->GetFileSystemInfo()));
+
+    file_system->GetRequestManager()->AddObserver(clicker.get());
+    clickers_.push_back(std::move(clicker));
+  }
+
+  void OnProvidedFileSystemUnmount(
+      const ProvidedFileSystemInfo& file_system_info,
+      base::File::Error error) override {}
+
+ private:
+  Service* service_;  // Not owned.
+  std::vector<std::unique_ptr<NotificationButtonClicker>> clickers_;
+
+  DISALLOW_COPY_AND_ASSIGN(AbortOnUnresponsivePerformer);
+};
+
+}  // namespace
+
+class FileSystemProviderApiTest : public ExtensionApiTest {
+ public:
+  FileSystemProviderApiTest() {}
+
+  // Loads a helper testing extension.
+  void SetUpOnMainThread() override {
+    ExtensionApiTest::SetUpOnMainThread();
+    const extensions::Extension* extension = LoadExtensionWithFlags(
+        test_data_dir_.AppendASCII("file_system_provider/test_util"),
+        kFlagEnableIncognito);
+    ASSERT_TRUE(extension);
+
+    display_service_ = std::make_unique<NotificationDisplayServiceTester>(
+        browser()->profile());
+  }
+
+  std::unique_ptr<NotificationDisplayServiceTester> display_service_;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(FileSystemProviderApiTest);
+};
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Mount) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/mount",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Unmount) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/unmount",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, GetAll) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/get_all",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, GetMetadata) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/get_metadata",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, ReadDirectory) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/read_directory",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, ReadFile) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/read_file",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, BigFile) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/big_file",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Evil) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/evil",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, MimeType) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/mime_type",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, CreateDirectory) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags(
+      "file_system_provider/create_directory", kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, DeleteEntry) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/delete_entry",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, CreateFile) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/create_file",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, CopyEntry) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/copy_entry",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, MoveEntry) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/move_entry",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Truncate) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/truncate",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, WriteFile) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/write_file",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Extension) {
+  ASSERT_TRUE(RunComponentExtensionTest("file_system_provider/extension"))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Thumbnail) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/thumbnail",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, AddWatcher) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/add_watcher",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, RemoveWatcher) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/remove_watcher",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Notify) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/notify",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Configure) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/configure",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, GetActions) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/get_actions",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, ExecuteAction) {
+  ASSERT_TRUE(RunPlatformAppTestWithFlags("file_system_provider/execute_action",
+                                          kFlagLoadAsComponent))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Unresponsive_Extension) {
+  AbortOnUnresponsivePerformer performer(browser()->profile());
+  ASSERT_TRUE(
+      RunComponentExtensionTest("file_system_provider/unresponsive_extension"))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_F(FileSystemProviderApiTest, Unresponsive_App) {
+  AbortOnUnresponsivePerformer performer(browser()->profile());
+  ASSERT_TRUE(RunPlatformAppTestWithFlags(
+      "file_system_provider/unresponsive_app", kFlagLoadAsComponent))
+      << message_;
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_system_provider/chromeos/provider_function.cc b/chrome/browser/extensions/api/file_system_provider/chromeos/provider_function.cc
new file mode 100644
index 0000000000000..ff6866a46f126
--- /dev/null
+++ b/chrome/browser/extensions/api/file_system_provider/chromeos/provider_function.cc
@@ -0,0 +1,176 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <utility>
+
+#include "chrome/browser/extensions/api/file_system_provider/chromeos/file_system_provider_api.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_interface.h"
+#include "chrome/browser/chromeos/file_system_provider/request_manager.h"
+#include "chrome/browser/chromeos/file_system_provider/request_value.h"
+#include "chrome/browser/chromeos/file_system_provider/service.h"
+#include "chrome/common/extensions/api/file_system_provider_internal.h"
+
+using chromeos::file_system_provider::ProvidedFileSystemInterface;
+using chromeos::file_system_provider::ProviderId;
+using chromeos::file_system_provider::RequestManager;
+using chromeos::file_system_provider::RequestValue;
+using chromeos::file_system_provider::Service;
+
+namespace {
+
+// Converts a base::File::Error into the IDL error format.
+extensions::api::file_system_provider::ProviderError FileErrorToProviderError(
+    base::File::Error error) {
+  switch (error) {
+    case base::File::FILE_OK:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_OK;
+    case base::File::FILE_ERROR_FAILED:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_FAILED;
+    case base::File::FILE_ERROR_IN_USE:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_IN_USE;
+    case base::File::FILE_ERROR_EXISTS:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_EXISTS;
+    case base::File::FILE_ERROR_NOT_FOUND:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_NOT_FOUND;
+    case base::File::FILE_ERROR_ACCESS_DENIED:
+      return extensions::api::file_system_provider::
+          PROVIDER_ERROR_ACCESS_DENIED;
+    case base::File::FILE_ERROR_TOO_MANY_OPENED:
+      return extensions::api::file_system_provider::
+          PROVIDER_ERROR_TOO_MANY_OPENED;
+    case base::File::FILE_ERROR_NO_MEMORY:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_NO_MEMORY;
+    case base::File::FILE_ERROR_NO_SPACE:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_NO_SPACE;
+    case base::File::FILE_ERROR_NOT_A_DIRECTORY:
+      return extensions::api::file_system_provider::
+          PROVIDER_ERROR_NOT_A_DIRECTORY;
+    case base::File::FILE_ERROR_INVALID_OPERATION:
+      return extensions::api::file_system_provider::
+          PROVIDER_ERROR_INVALID_OPERATION;
+    case base::File::FILE_ERROR_SECURITY:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_SECURITY;
+    case base::File::FILE_ERROR_ABORT:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_ABORT;
+    case base::File::FILE_ERROR_NOT_A_FILE:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_NOT_A_FILE;
+    case base::File::FILE_ERROR_NOT_EMPTY:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_NOT_EMPTY;
+    case base::File::FILE_ERROR_INVALID_URL:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_INVALID_URL;
+    case base::File::FILE_ERROR_IO:
+      return extensions::api::file_system_provider::PROVIDER_ERROR_IO;
+    case base::File::FILE_ERROR_MAX:
+      NOTREACHED();
+  }
+
+  return extensions::api::file_system_provider::PROVIDER_ERROR_FAILED;
+}
+
+}  // namespace
+
+namespace extensions {
+
+base::File::Error ProviderErrorToFileError(
+    api::file_system_provider::ProviderError error) {
+  switch (error) {
+    case api::file_system_provider::PROVIDER_ERROR_OK:
+      return base::File::FILE_OK;
+    case api::file_system_provider::PROVIDER_ERROR_FAILED:
+      return base::File::FILE_ERROR_FAILED;
+    case api::file_system_provider::PROVIDER_ERROR_IN_USE:
+      return base::File::FILE_ERROR_IN_USE;
+    case api::file_system_provider::PROVIDER_ERROR_EXISTS:
+      return base::File::FILE_ERROR_EXISTS;
+    case api::file_system_provider::PROVIDER_ERROR_NOT_FOUND:
+      return base::File::FILE_ERROR_NOT_FOUND;
+    case api::file_system_provider::PROVIDER_ERROR_ACCESS_DENIED:
+      return base::File::FILE_ERROR_ACCESS_DENIED;
+    case api::file_system_provider::PROVIDER_ERROR_TOO_MANY_OPENED:
+      return base::File::FILE_ERROR_TOO_MANY_OPENED;
+    case api::file_system_provider::PROVIDER_ERROR_NO_MEMORY:
+      return base::File::FILE_ERROR_NO_MEMORY;
+    case api::file_system_provider::PROVIDER_ERROR_NO_SPACE:
+      return base::File::FILE_ERROR_NO_SPACE;
+    case api::file_system_provider::PROVIDER_ERROR_NOT_A_DIRECTORY:
+      return base::File::FILE_ERROR_NOT_A_DIRECTORY;
+    case api::file_system_provider::PROVIDER_ERROR_INVALID_OPERATION:
+      return base::File::FILE_ERROR_INVALID_OPERATION;
+    case api::file_system_provider::PROVIDER_ERROR_SECURITY:
+      return base::File::FILE_ERROR_SECURITY;
+    case api::file_system_provider::PROVIDER_ERROR_ABORT:
+      return base::File::FILE_ERROR_ABORT;
+    case api::file_system_provider::PROVIDER_ERROR_NOT_A_FILE:
+      return base::File::FILE_ERROR_NOT_A_FILE;
+    case api::file_system_provider::PROVIDER_ERROR_NOT_EMPTY:
+      return base::File::FILE_ERROR_NOT_EMPTY;
+    case api::file_system_provider::PROVIDER_ERROR_INVALID_URL:
+      return base::File::FILE_ERROR_INVALID_URL;
+    case api::file_system_provider::PROVIDER_ERROR_IO:
+      return base::File::FILE_ERROR_IO;
+    case api::file_system_provider::PROVIDER_ERROR_NONE:
+      NOTREACHED();
+  }
+
+  return base::File::FILE_ERROR_FAILED;
+}
+
+std::string FileErrorToString(base::File::Error error) {
+  return extensions::api::file_system_provider::ToString(
+      FileErrorToProviderError(error));
+}
+
+FileSystemProviderInternalFunction::FileSystemProviderInternalFunction()
+    : request_id_(0), request_manager_(NULL) {
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalFunction::RejectRequest(
+    std::unique_ptr<chromeos::file_system_provider::RequestValue> value,
+    base::File::Error error) {
+  const base::File::Error result =
+      request_manager_->RejectRequest(request_id_, std::move(value), error);
+  if (result != base::File::FILE_OK)
+    return RespondNow(Error(FileErrorToString(result)));
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalFunction::FulfillRequest(
+    std::unique_ptr<RequestValue> value,
+    bool has_more) {
+  const base::File::Error result =
+      request_manager_->FulfillRequest(request_id_, std::move(value), has_more);
+  if (result != base::File::FILE_OK)
+    return RespondNow(Error(FileErrorToString(result)));
+  return RespondNow(NoArguments());
+}
+
+bool FileSystemProviderInternalFunction::PreRunValidation(std::string* error) {
+  if (!UIThreadExtensionFunction::PreRunValidation(error))
+    return false;
+
+  std::string file_system_id;
+
+  EXTENSION_FUNCTION_PRERUN_VALIDATE(args_->GetString(0, &file_system_id));
+  EXTENSION_FUNCTION_PRERUN_VALIDATE(args_->GetInteger(1, &request_id_));
+
+  Service* service = Service::Get(browser_context());
+  if (!service) {
+    *error = "File system provider service not found.";
+    return false;
+  }
+
+  ProvidedFileSystemInterface* file_system = service->GetProvidedFileSystem(
+      ProviderId::CreateFromExtensionId(extension_id()), file_system_id);
+  if (!file_system) {
+    *error = FileErrorToString(base::File::FILE_ERROR_NOT_FOUND);
+    return false;
+  }
+
+  request_manager_ = file_system->GetRequestManager();
+  return true;
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_system_provider/chromeos/provider_function.h b/chrome/browser/extensions/api/file_system_provider/chromeos/provider_function.h
new file mode 100644
index 0000000000000..426714ea78b1f
--- /dev/null
+++ b/chrome/browser/extensions/api/file_system_provider/chromeos/provider_function.h
@@ -0,0 +1,79 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_SYSTEM_PROVIDER_CHROMEOS_PROVIDER_FUNCTION_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_SYSTEM_PROVIDER_CHROMEOS_PROVIDER_FUNCTION_H_
+
+#include <memory>
+#include <string>
+
+#include "base/files/file.h"
+#include "chrome/browser/extensions/chrome_extension_function.h"
+#include "chrome/common/extensions/api/file_system_provider.h"
+
+namespace chromeos {
+namespace file_system_provider {
+
+class RequestManager;
+class RequestValue;
+
+}  // namespace file_system_provider
+}  // namespace chromeos
+
+namespace extensions {
+
+// Error names from
+// http://www.w3.org/TR/file-system-api/#errors-and-exceptions
+extern const char kNotFoundErrorName[];
+extern const char kSecurityErrorName[];
+
+// Error messages.
+extern const char kEmptyNameErrorMessage[];
+extern const char kEmptyIdErrorMessage[];
+extern const char kMountFailedErrorMessage[];
+extern const char kUnmountFailedErrorMessage[];
+extern const char kResponseFailedErrorMessage[];
+
+// Creates an identifier from |error|. For FILE_OK, an empty string is returned.
+// These values are passed to JavaScript as lastError.message value.
+std::string FileErrorToString(base::File::Error error);
+
+// Converts ProviderError to base::File::Error. This could be redundant, if it
+// was possible to create DOMError instances in Javascript easily.
+base::File::Error ProviderErrorToFileError(
+    api::file_system_provider::ProviderError error);
+
+// Base class for internal API functions handling request results, either
+// a success or a failure.
+class FileSystemProviderInternalFunction : public UIThreadExtensionFunction {
+ public:
+  FileSystemProviderInternalFunction();
+
+ protected:
+  ~FileSystemProviderInternalFunction() override {}
+
+  // Rejects the request and returns a response for this API function.
+  ResponseAction RejectRequest(
+      std::unique_ptr<chromeos::file_system_provider::RequestValue> value,
+      base::File::Error error);
+
+  // Fulfills the request with parsed arguments of this API function
+  // encapsulated as a RequestValue instance and returns a response.
+  // If |has_more| is set to true, then the function will be called again for
+  // this request.
+  ResponseAction FulfillRequest(
+      std::unique_ptr<chromeos::file_system_provider::RequestValue> value,
+      bool has_more);
+
+ private:
+  // Guarantees |request_id_| and |request_manager_| are valid.
+  bool PreRunValidation(std::string* error) override;
+
+  int request_id_;
+  chromeos::file_system_provider::RequestManager* request_manager_;
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_SYSTEM_PROVIDER_CHROMEOS_PROVIDER_FUNCTION_H_
diff --git a/chrome/browser/extensions/api/file_system_provider/file_system_provider_api.h b/chrome/browser/extensions/api/file_system_provider/file_system_provider_api.h
index f57e7158d5540..9c2d960e666f0 100644
--- a/chrome/browser/extensions/api/file_system_provider/file_system_provider_api.h
+++ b/chrome/browser/extensions/api/file_system_provider/file_system_provider_api.h
@@ -1,152 +1,14 @@
-// Copyright 2013 The Chromium Authors. All rights reserved.
+// Copyright 2018 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef CHROME_BROWSER_EXTENSIONS_FILE_SYSTEM_PROVIDER_FILE_SYSTEM_PROVIDER_API_H_
-#define CHROME_BROWSER_EXTENSIONS_FILE_SYSTEM_PROVIDER_FILE_SYSTEM_PROVIDER_API_H_
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_SYSTEM_PROVIDER_FILE_SYSTEM_PROVIDER_API_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_SYSTEM_PROVIDER_FILE_SYSTEM_PROVIDER_API_H_
 
-#include "chrome/browser/extensions/api/file_system_provider/provider_function.h"
-#include "chrome/browser/extensions/chrome_extension_function.h"
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/extensions/api/file_system_provider/chromeos/file_system_provider_api.h"
+#else
+#include "chrome/browser/extensions/api/file_system_provider/linux/file_system_provider_api.h"
+#endif
 
-namespace extensions {
-
-class FileSystemProviderMountFunction : public UIThreadExtensionFunction {
- public:
-  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.mount",
-                             FILESYSTEMPROVIDER_MOUNT)
-
- protected:
-  ~FileSystemProviderMountFunction() override {}
-  ResponseAction Run() override;
-};
-
-class FileSystemProviderUnmountFunction : public UIThreadExtensionFunction {
- public:
-  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.unmount",
-                             FILESYSTEMPROVIDER_UNMOUNT)
-
- protected:
-  ~FileSystemProviderUnmountFunction() override {}
-  ResponseAction Run() override;
-};
-
-class FileSystemProviderGetAllFunction : public UIThreadExtensionFunction {
- public:
-  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.getAll",
-                             FILESYSTEMPROVIDER_GETALL)
-
- protected:
-  ~FileSystemProviderGetAllFunction() override {}
-  ResponseAction Run() override;
-};
-
-class FileSystemProviderGetFunction : public UIThreadExtensionFunction {
- public:
-  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.get", FILESYSTEMPROVIDER_GET)
-
- protected:
-  ~FileSystemProviderGetFunction() override {}
-  ResponseAction Run() override;
-};
-
-class FileSystemProviderNotifyFunction : public ChromeAsyncExtensionFunction {
- public:
-  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.notify",
-                             FILESYSTEMPROVIDER_NOTIFY)
-
- protected:
-  ~FileSystemProviderNotifyFunction() override {}
-  bool RunAsync() override;
-
- private:
-  // Called when notifying is completed.
-  void OnNotifyCompleted(base::File::Error result);
-};
-
-class FileSystemProviderInternalUnmountRequestedSuccessFunction
-    : public FileSystemProviderInternalFunction {
- public:
-  DECLARE_EXTENSION_FUNCTION(
-      "fileSystemProviderInternal.unmountRequestedSuccess",
-      FILESYSTEMPROVIDERINTERNAL_UNMOUNTREQUESTEDSUCCESS)
-
- protected:
-  ~FileSystemProviderInternalUnmountRequestedSuccessFunction() override {}
-  ResponseAction Run() override;
-};
-
-class FileSystemProviderInternalGetMetadataRequestedSuccessFunction
-    : public FileSystemProviderInternalFunction {
- public:
-  DECLARE_EXTENSION_FUNCTION(
-      "fileSystemProviderInternal.getMetadataRequestedSuccess",
-      FILESYSTEMPROVIDERINTERNAL_GETMETADATAREQUESTEDSUCCESS)
-
- protected:
-  ~FileSystemProviderInternalGetMetadataRequestedSuccessFunction() override {}
-  ResponseAction Run() override;
-};
-
-class FileSystemProviderInternalGetActionsRequestedSuccessFunction
-    : public FileSystemProviderInternalFunction {
- public:
-  DECLARE_EXTENSION_FUNCTION(
-      "fileSystemProviderInternal.getActionsRequestedSuccess",
-      FILESYSTEMPROVIDERINTERNAL_GETACTIONSREQUESTEDSUCCESS)
-
- protected:
-  ~FileSystemProviderInternalGetActionsRequestedSuccessFunction() override {}
-  ResponseAction Run() override;
-};
-
-class FileSystemProviderInternalReadDirectoryRequestedSuccessFunction
-    : public FileSystemProviderInternalFunction {
- public:
-  DECLARE_EXTENSION_FUNCTION(
-      "fileSystemProviderInternal.readDirectoryRequestedSuccess",
-      FILESYSTEMPROVIDERINTERNAL_READDIRECTORYREQUESTEDSUCCESS)
-
- protected:
-  ~FileSystemProviderInternalReadDirectoryRequestedSuccessFunction() override {}
-  ResponseAction Run() override;
-};
-
-class FileSystemProviderInternalReadFileRequestedSuccessFunction
-    : public FileSystemProviderInternalFunction {
- public:
-  DECLARE_EXTENSION_FUNCTION(
-      "fileSystemProviderInternal.readFileRequestedSuccess",
-      FILESYSTEMPROVIDERINTERNAL_READFILEREQUESTEDSUCCESS)
-
- protected:
-  ~FileSystemProviderInternalReadFileRequestedSuccessFunction() override {}
-  ResponseAction Run() override;
-};
-
-class FileSystemProviderInternalOperationRequestedSuccessFunction
-    : public FileSystemProviderInternalFunction {
- public:
-  DECLARE_EXTENSION_FUNCTION(
-      "fileSystemProviderInternal.operationRequestedSuccess",
-      FILESYSTEMPROVIDERINTERNAL_OPERATIONREQUESTEDSUCCESS)
-
- protected:
-  ~FileSystemProviderInternalOperationRequestedSuccessFunction() override {}
-  ResponseAction Run() override;
-};
-
-class FileSystemProviderInternalOperationRequestedErrorFunction
-    : public FileSystemProviderInternalFunction {
- public:
-  DECLARE_EXTENSION_FUNCTION(
-      "fileSystemProviderInternal.operationRequestedError",
-      FILESYSTEMPROVIDERINTERNAL_OPERATIONREQUESTEDERROR)
-
- protected:
-  ~FileSystemProviderInternalOperationRequestedErrorFunction() override {}
-  ResponseAction Run() override;
-};
-
-}  // namespace extensions
-
-#endif  // CHROME_BROWSER_EXTENSIONS_FILE_SYSTEM_PROVIDER_FILE_SYSTEM_PROVIDER_API_H_
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_SYSTEM_PROVIDER_FILE_SYSTEM_PROVIDER_API_H_
diff --git a/chrome/browser/extensions/api/file_system_provider/linux/file_system_provider_api.cc b/chrome/browser/extensions/api/file_system_provider/linux/file_system_provider_api.cc
new file mode 100644
index 0000000000000..862023dbb9780
--- /dev/null
+++ b/chrome/browser/extensions/api/file_system_provider/linux/file_system_provider_api.cc
@@ -0,0 +1,76 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_system_provider/linux/file_system_provider_api.h"
+
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/memory/ptr_util.h"
+#include "base/trace_event/trace_event.h"
+#include "base/values.h"
+#include "chrome/common/extensions/api/file_system_provider.h"
+#include "chrome/common/extensions/api/file_system_provider_internal.h"
+
+namespace extensions {
+
+ExtensionFunction::ResponseAction FileSystemProviderMountFunction::Run() {
+  return RespondNow(Error("Not supported"));
+}
+
+ExtensionFunction::ResponseAction FileSystemProviderUnmountFunction::Run() {
+  return RespondNow(Error("Not supported"));
+}
+
+ExtensionFunction::ResponseAction FileSystemProviderGetAllFunction::Run() {
+  return RespondNow(Error("Not supported"));
+}
+
+ExtensionFunction::ResponseAction FileSystemProviderGetFunction::Run() {
+  return RespondNow(Error("Not supported"));
+}
+
+bool FileSystemProviderNotifyFunction::RunAsync() {
+  SetError("Not supported");
+  return false;
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalUnmountRequestedSuccessFunction::Run() {
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalGetMetadataRequestedSuccessFunction::Run() {
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalGetActionsRequestedSuccessFunction::Run() {
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalReadDirectoryRequestedSuccessFunction::Run() {
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalReadFileRequestedSuccessFunction::Run() {
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalOperationRequestedSuccessFunction::Run() {
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+FileSystemProviderInternalOperationRequestedErrorFunction::Run() {
+  return RespondNow(NoArguments());
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_system_provider/linux/file_system_provider_api.h b/chrome/browser/extensions/api/file_system_provider/linux/file_system_provider_api.h
new file mode 100644
index 0000000000000..af37aff29e531
--- /dev/null
+++ b/chrome/browser/extensions/api/file_system_provider/linux/file_system_provider_api.h
@@ -0,0 +1,152 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_SYSTEM_PROVIDER_LINUX_FILE_SYSTEM_PROVIDER_API_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_SYSTEM_PROVIDER_LINUX_FILE_SYSTEM_PROVIDER_API_H_
+
+#include "chrome/browser/extensions/api/file_system_provider/linux/provider_function.h"
+#include "chrome/browser/extensions/chrome_extension_function.h"
+
+namespace extensions {
+
+class FileSystemProviderMountFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.mount",
+                             FILESYSTEMPROVIDER_MOUNT)
+
+ protected:
+  ~FileSystemProviderMountFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderUnmountFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.unmount",
+                             FILESYSTEMPROVIDER_UNMOUNT)
+
+ protected:
+  ~FileSystemProviderUnmountFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderGetAllFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.getAll",
+                             FILESYSTEMPROVIDER_GETALL)
+
+ protected:
+  ~FileSystemProviderGetAllFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderGetFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.get", FILESYSTEMPROVIDER_GET)
+
+ protected:
+  ~FileSystemProviderGetFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderNotifyFunction : public ChromeAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileSystemProvider.notify",
+                             FILESYSTEMPROVIDER_NOTIFY)
+
+ protected:
+  ~FileSystemProviderNotifyFunction() override {}
+  bool RunAsync() override;
+
+ private:
+  // Called when notifying is completed.
+  void OnNotifyCompleted(base::File::Error result);
+};
+
+class FileSystemProviderInternalUnmountRequestedSuccessFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.unmountRequestedSuccess",
+      FILESYSTEMPROVIDERINTERNAL_UNMOUNTREQUESTEDSUCCESS)
+
+ protected:
+  ~FileSystemProviderInternalUnmountRequestedSuccessFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderInternalGetMetadataRequestedSuccessFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.getMetadataRequestedSuccess",
+      FILESYSTEMPROVIDERINTERNAL_GETMETADATAREQUESTEDSUCCESS)
+
+ protected:
+  ~FileSystemProviderInternalGetMetadataRequestedSuccessFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderInternalGetActionsRequestedSuccessFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.getActionsRequestedSuccess",
+      FILESYSTEMPROVIDERINTERNAL_GETACTIONSREQUESTEDSUCCESS)
+
+ protected:
+  ~FileSystemProviderInternalGetActionsRequestedSuccessFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderInternalReadDirectoryRequestedSuccessFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.readDirectoryRequestedSuccess",
+      FILESYSTEMPROVIDERINTERNAL_READDIRECTORYREQUESTEDSUCCESS)
+
+ protected:
+  ~FileSystemProviderInternalReadDirectoryRequestedSuccessFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderInternalReadFileRequestedSuccessFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.readFileRequestedSuccess",
+      FILESYSTEMPROVIDERINTERNAL_READFILEREQUESTEDSUCCESS)
+
+ protected:
+  ~FileSystemProviderInternalReadFileRequestedSuccessFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderInternalOperationRequestedSuccessFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.operationRequestedSuccess",
+      FILESYSTEMPROVIDERINTERNAL_OPERATIONREQUESTEDSUCCESS)
+
+ protected:
+  ~FileSystemProviderInternalOperationRequestedSuccessFunction() override {}
+  ResponseAction Run() override;
+};
+
+class FileSystemProviderInternalOperationRequestedErrorFunction
+    : public FileSystemProviderInternalFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileSystemProviderInternal.operationRequestedError",
+      FILESYSTEMPROVIDERINTERNAL_OPERATIONREQUESTEDERROR)
+
+ protected:
+  ~FileSystemProviderInternalOperationRequestedErrorFunction() override {}
+  ResponseAction Run() override;
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_SYSTEM_PROVIDER_LINUX_FILE_SYSTEM_PROVIDER_API_H_
diff --git a/chrome/browser/extensions/api/file_system_provider/linux/provider_function.cc b/chrome/browser/extensions/api/file_system_provider/linux/provider_function.cc
new file mode 100644
index 0000000000000..4da7e76b12d59
--- /dev/null
+++ b/chrome/browser/extensions/api/file_system_provider/linux/provider_function.cc
@@ -0,0 +1,20 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <utility>
+
+#include "chrome/browser/extensions/api/file_system_provider/linux/file_system_provider_api.h"
+#include "chrome/common/extensions/api/file_system_provider_internal.h"
+
+
+namespace extensions {
+
+FileSystemProviderInternalFunction::FileSystemProviderInternalFunction() {}
+
+bool FileSystemProviderInternalFunction::PreRunValidation(std::string* error) {
+  *error = "File system provider service not found.";
+  return false;
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_system_provider/linux/provider_function.h b/chrome/browser/extensions/api/file_system_provider/linux/provider_function.h
new file mode 100644
index 0000000000000..f17547b8831c5
--- /dev/null
+++ b/chrome/browser/extensions/api/file_system_provider/linux/provider_function.h
@@ -0,0 +1,33 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_SYSTEM_PROVIDER_LINUX_PROVIDER_FUNCTION_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_SYSTEM_PROVIDER_LINUX_PROVIDER_FUNCTION_H_
+
+#include <memory>
+#include <string>
+
+#include "base/files/file.h"
+#include "chrome/browser/extensions/chrome_extension_function.h"
+#include "chrome/common/extensions/api/file_system_provider.h"
+
+namespace extensions {
+
+// Base class for internal API functions handling request results, either
+// a success or a failure.
+class FileSystemProviderInternalFunction : public UIThreadExtensionFunction {
+ public:
+  FileSystemProviderInternalFunction();
+
+ protected:
+  ~FileSystemProviderInternalFunction() override {}
+
+ private:
+  // Guarantees |request_id_| and |request_manager_| are valid.
+  bool PreRunValidation(std::string* error) override;
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_SYSTEM_PROVIDER_LINUX_PROVIDER_FUNCTION_H_

From 5ee925d1b2b8cfa83af65586da984c51ceddc95f Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Tue, 14 Aug 2018 20:32:50 +0900
Subject: [PATCH 26/32] Add platform folder to
 chrome/browser/extensions/api/file_manager/

As it has many features specific to ChromeOs,
this patch adds platform folder to handle it separately.

It's still not included for building.
---
 chrome/browser/extensions/BUILD.gn            |   20 +-
 .../api/file_manager/chromeos/event_router.cc | 1095 ++++++++++++
 .../api/file_manager/chromeos/event_router.h  |  237 +++
 .../chromeos/private_api_drive.cc             | 1565 +++++++++++++++++
 .../file_manager/chromeos/private_api_drive.h |  286 +++
 .../chromeos/private_api_file_system.cc       | 1076 ++++++++++++
 .../chromeos/private_api_file_system.h        |  400 +++++
 .../file_manager/chromeos/private_api_misc.cc |  910 ++++++++++
 .../file_manager/chromeos/private_api_misc.h  |  382 ++++
 .../chromeos/private_api_mount.cc             |  391 ++++
 .../file_manager/chromeos/private_api_mount.h |  114 ++
 .../api/file_manager/linux/event_router.cc    |  513 ++++++
 .../api/file_manager/linux/event_router.h     |  147 ++
 .../file_manager/linux/private_api_drive.cc   |  175 ++
 .../file_manager/linux/private_api_drive.h    |  207 +++
 .../linux/private_api_file_system.cc          |  853 +++++++++
 .../linux/private_api_file_system.h           |  375 ++++
 .../file_manager/linux/private_api_misc.cc    |  361 ++++
 .../api/file_manager/linux/private_api_misc.h |  343 ++++
 .../file_manager/linux/private_api_mount.cc   |   62 +
 .../file_manager/linux/private_api_mount.h    |   75 +
 21 files changed, 9577 insertions(+), 10 deletions(-)
 create mode 100644 chrome/browser/extensions/api/file_manager/chromeos/event_router.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/chromeos/event_router.h
 create mode 100644 chrome/browser/extensions/api/file_manager/chromeos/private_api_drive.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/chromeos/private_api_drive.h
 create mode 100644 chrome/browser/extensions/api/file_manager/chromeos/private_api_file_system.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/chromeos/private_api_file_system.h
 create mode 100644 chrome/browser/extensions/api/file_manager/chromeos/private_api_misc.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/chromeos/private_api_misc.h
 create mode 100644 chrome/browser/extensions/api/file_manager/chromeos/private_api_mount.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/chromeos/private_api_mount.h
 create mode 100644 chrome/browser/extensions/api/file_manager/linux/event_router.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/linux/event_router.h
 create mode 100644 chrome/browser/extensions/api/file_manager/linux/private_api_drive.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/linux/private_api_drive.h
 create mode 100644 chrome/browser/extensions/api/file_manager/linux/private_api_file_system.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/linux/private_api_file_system.h
 create mode 100644 chrome/browser/extensions/api/file_manager/linux/private_api_misc.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/linux/private_api_misc.h
 create mode 100644 chrome/browser/extensions/api/file_manager/linux/private_api_mount.cc
 create mode 100644 chrome/browser/extensions/api/file_manager/linux/private_api_mount.h

diff --git a/chrome/browser/extensions/BUILD.gn b/chrome/browser/extensions/BUILD.gn
index adc169a240563..a2073aff3527f 100644
--- a/chrome/browser/extensions/BUILD.gn
+++ b/chrome/browser/extensions/BUILD.gn
@@ -945,8 +945,8 @@ jumbo_static_library("extensions") {
       "api/file_manager/device_event_router.h",
       "api/file_manager/drivefs_event_router.cc",
       "api/file_manager/drivefs_event_router.h",
-      "api/file_manager/event_router.cc",
-      "api/file_manager/event_router.h",
+      "api/file_manager/chromeos/event_router.cc",
+      "api/file_manager/chromeos/event_router.h",
       "api/file_manager/event_router_factory.cc",
       "api/file_manager/event_router_factory.h",
       "api/file_manager/file_browser_handler_api.cc",
@@ -960,14 +960,14 @@ jumbo_static_library("extensions") {
       "api/file_manager/private_api_base.h",
       "api/file_manager/private_api_dialog.cc",
       "api/file_manager/private_api_dialog.h",
-      "api/file_manager/private_api_drive.cc",
-      "api/file_manager/private_api_drive.h",
-      "api/file_manager/private_api_file_system.cc",
-      "api/file_manager/private_api_file_system.h",
-      "api/file_manager/private_api_misc.cc",
-      "api/file_manager/private_api_misc.h",
-      "api/file_manager/private_api_mount.cc",
-      "api/file_manager/private_api_mount.h",
+      "api/file_manager/chromeos/private_api_drive.cc",
+      "api/file_manager/chromeos/private_api_drive.h",
+      "api/file_manager/chromeos/private_api_file_system.cc",
+      "api/file_manager/chromeos/private_api_file_system.h",
+      "api/file_manager/chromeos/private_api_misc.cc",
+      "api/file_manager/chromeos/private_api_misc.h",
+      "api/file_manager/chromeos/private_api_mount.cc",
+      "api/file_manager/chromeos/private_api_mount.h",
       "api/file_manager/private_api_strings.cc",
       "api/file_manager/private_api_strings.h",
       "api/file_manager/private_api_tasks.cc",
diff --git a/chrome/browser/extensions/api/file_manager/chromeos/event_router.cc b/chrome/browser/extensions/api/file_manager/chromeos/event_router.cc
new file mode 100644
index 0000000000000..7187fc5636f09
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/chromeos/event_router.cc
@@ -0,0 +1,1095 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/chromeos/event_router.h"
+
+#include <stddef.h>
+
+#include <memory>
+#include <set>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/command_line.h"
+#include "base/files/file_util.h"
+#include "base/macros.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "base/values.h"
+#include "chrome/browser/app_mode/app_mode_utils.h"
+#include "chrome/browser/chromeos/arc/arc_util.h"
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/open_util.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/browser/chromeos/login/lock/screen_locker.h"
+#include "chrome/browser/chromeos/login/ui/login_display_host.h"
+#include "chrome/browser/extensions/api/file_system/chrome_file_system_delegate.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/extensions/extension_util.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/common/chrome_switches.h"
+#include "chrome/common/pref_names.h"
+#include "chromeos/components/drivefs/drivefs_host.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
+#include "chromeos/disks/disk.h"
+#include "chromeos/login/login_state.h"
+#include "chromeos/network/network_handler.h"
+#include "chromeos/network/network_state_handler.h"
+#include "components/arc/intent_helper/arc_intent_helper_bridge.h"
+#include "components/drive/chromeos/file_system_interface.h"
+#include "components/drive/drive_pref_names.h"
+#include "components/drive/file_change.h"
+#include "components/drive/service/drive_service_interface.h"
+#include "components/prefs/pref_change_registrar.h"
+#include "components/prefs/pref_service.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/storage_partition.h"
+#include "extensions/browser/event_router.h"
+#include "extensions/browser/extension_host.h"
+#include "extensions/browser/extension_prefs.h"
+#include "storage/common/fileapi/file_system_types.h"
+#include "storage/common/fileapi/file_system_util.h"
+
+using chromeos::disks::Disk;
+using chromeos::disks::DiskMountManager;
+using chromeos::NetworkHandler;
+using content::BrowserThread;
+using drive::DriveIntegrationService;
+using drive::DriveIntegrationServiceFactory;
+using file_manager::util::EntryDefinition;
+using file_manager::util::FileDefinition;
+
+namespace file_manager_private = extensions::api::file_manager_private;
+
+namespace file_manager {
+namespace {
+
+// Frequency of sending onFileTransferUpdated.
+const int64_t kProgressEventFrequencyInMilliseconds = 1000;
+
+// Maximim size of detailed change info on directory change event. If the size
+// exceeds the maximum size, the detailed info is omitted and the force refresh
+// is kicked.
+const size_t kDirectoryChangeEventMaxDetailInfoSize = 1000;
+
+// This time(millisecond) is used for confirm following event exists.
+const int64_t kFileTransferEventDelayTimeInMilliseconds = 300;
+
+// Checks if the Recovery Tool is running. This is a temporary solution.
+// TODO(mtomasz): Replace with crbug.com/341902 solution.
+bool IsRecoveryToolRunning(Profile* profile) {
+  extensions::ExtensionPrefs* extension_prefs =
+      extensions::ExtensionPrefs::Get(profile);
+  if (!extension_prefs)
+    return false;
+
+  const std::string kRecoveryToolIds[] = {
+      "kkebgepbbgbcmghedmmdfcbdcodlkngh",  // Recovery tool staging
+      "jndclpdbaamdhonoechobihbbiimdgai"   // Recovery tool prod
+  };
+
+  for (size_t i = 0; i < arraysize(kRecoveryToolIds); ++i) {
+    const std::string extension_id = kRecoveryToolIds[i];
+    if (extension_prefs->IsExtensionRunning(extension_id))
+      return true;
+  }
+
+  return false;
+}
+
+// Sends an event named |event_name| with arguments |event_args| to extensions.
+void BroadcastEvent(Profile* profile,
+                    extensions::events::HistogramValue histogram_value,
+                    const std::string& event_name,
+                    std::unique_ptr<base::ListValue> event_args) {
+  extensions::EventRouter::Get(profile)->BroadcastEvent(
+      std::make_unique<extensions::Event>(histogram_value, event_name,
+                                          std::move(event_args)));
+}
+
+// Sends an event named |event_name| with arguments |event_args| to an extension
+// of |extention_id|.
+void DispatchEventToExtension(
+    Profile* profile,
+    const std::string& extension_id,
+    extensions::events::HistogramValue histogram_value,
+    const std::string& event_name,
+    std::unique_ptr<base::ListValue> event_args) {
+  extensions::EventRouter::Get(profile)->DispatchEventToExtension(
+      extension_id, std::make_unique<extensions::Event>(
+                        histogram_value, event_name, std::move(event_args)));
+}
+
+file_manager_private::MountCompletedStatus
+MountErrorToMountCompletedStatus(chromeos::MountError error) {
+  switch (error) {
+    case chromeos::MOUNT_ERROR_NONE:
+      return file_manager_private::MOUNT_COMPLETED_STATUS_SUCCESS;
+    case chromeos::MOUNT_ERROR_UNKNOWN:
+      return file_manager_private::MOUNT_COMPLETED_STATUS_ERROR_UNKNOWN;
+    case chromeos::MOUNT_ERROR_INTERNAL:
+      return file_manager_private::MOUNT_COMPLETED_STATUS_ERROR_INTERNAL;
+    case chromeos::MOUNT_ERROR_INVALID_ARGUMENT:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_INVALID_ARGUMENT;
+    case chromeos::MOUNT_ERROR_INVALID_PATH:
+      return file_manager_private::MOUNT_COMPLETED_STATUS_ERROR_INVALID_PATH;
+    case chromeos::MOUNT_ERROR_PATH_ALREADY_MOUNTED:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_PATH_ALREADY_MOUNTED;
+    case chromeos::MOUNT_ERROR_PATH_NOT_MOUNTED:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_PATH_NOT_MOUNTED;
+    case chromeos::MOUNT_ERROR_DIRECTORY_CREATION_FAILED:
+      return file_manager_private
+          ::MOUNT_COMPLETED_STATUS_ERROR_DIRECTORY_CREATION_FAILED;
+    case chromeos::MOUNT_ERROR_INVALID_MOUNT_OPTIONS:
+      return file_manager_private
+          ::MOUNT_COMPLETED_STATUS_ERROR_INVALID_MOUNT_OPTIONS;
+    case chromeos::MOUNT_ERROR_INVALID_UNMOUNT_OPTIONS:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_INVALID_UNMOUNT_OPTIONS;
+    case chromeos::MOUNT_ERROR_INSUFFICIENT_PERMISSIONS:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_INSUFFICIENT_PERMISSIONS;
+    case chromeos::MOUNT_ERROR_MOUNT_PROGRAM_NOT_FOUND:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_MOUNT_PROGRAM_NOT_FOUND;
+    case chromeos::MOUNT_ERROR_MOUNT_PROGRAM_FAILED:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_MOUNT_PROGRAM_FAILED;
+    case chromeos::MOUNT_ERROR_INVALID_DEVICE_PATH:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_INVALID_DEVICE_PATH;
+    case chromeos::MOUNT_ERROR_UNKNOWN_FILESYSTEM:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_UNKNOWN_FILESYSTEM;
+    case chromeos::MOUNT_ERROR_UNSUPPORTED_FILESYSTEM:
+      return file_manager_private::
+          MOUNT_COMPLETED_STATUS_ERROR_UNSUPPORTED_FILESYSTEM;
+    case chromeos::MOUNT_ERROR_INVALID_ARCHIVE:
+      return file_manager_private::MOUNT_COMPLETED_STATUS_ERROR_INVALID_ARCHIVE;
+    // Not a real error.
+    case chromeos::MOUNT_ERROR_COUNT:
+      NOTREACHED();
+  }
+  NOTREACHED();
+  return file_manager_private::MOUNT_COMPLETED_STATUS_NONE;
+}
+
+file_manager_private::CopyProgressStatusType
+CopyProgressTypeToCopyProgressStatusType(
+    storage::FileSystemOperation::CopyProgressType type) {
+  switch (type) {
+    case storage::FileSystemOperation::BEGIN_COPY_ENTRY:
+      return file_manager_private::COPY_PROGRESS_STATUS_TYPE_BEGIN_COPY_ENTRY;
+    case storage::FileSystemOperation::END_COPY_ENTRY:
+      return file_manager_private::COPY_PROGRESS_STATUS_TYPE_END_COPY_ENTRY;
+    case storage::FileSystemOperation::PROGRESS:
+      return file_manager_private::COPY_PROGRESS_STATUS_TYPE_PROGRESS;
+    case storage::FileSystemOperation::ERROR_COPY_ENTRY:
+      return file_manager_private::COPY_PROGRESS_STATUS_TYPE_ERROR;
+  }
+  NOTREACHED();
+  return file_manager_private::COPY_PROGRESS_STATUS_TYPE_NONE;
+}
+
+file_manager_private::ChangeType ConvertChangeTypeFromDriveToApi(
+    drive::FileChange::ChangeType type) {
+  switch (type) {
+    case drive::FileChange::CHANGE_TYPE_ADD_OR_UPDATE:
+      return file_manager_private::CHANGE_TYPE_ADD_OR_UPDATE;
+    case drive::FileChange::CHANGE_TYPE_DELETE:
+      return file_manager_private::CHANGE_TYPE_DELETE;
+  }
+  NOTREACHED();
+  return file_manager_private::CHANGE_TYPE_ADD_OR_UPDATE;
+}
+
+std::string FileErrorToErrorName(base::File::Error error_code) {
+  namespace js = extensions::api::file_manager_private;
+  switch (error_code) {
+    case base::File::FILE_ERROR_NOT_FOUND:
+      return "NotFoundError";
+    case base::File::FILE_ERROR_INVALID_OPERATION:
+    case base::File::FILE_ERROR_EXISTS:
+    case base::File::FILE_ERROR_NOT_EMPTY:
+      return "InvalidModificationError";
+    case base::File::FILE_ERROR_NOT_A_DIRECTORY:
+    case base::File::FILE_ERROR_NOT_A_FILE:
+      return "TypeMismatchError";
+    case base::File::FILE_ERROR_ACCESS_DENIED:
+      return "NoModificationAllowedError";
+    case base::File::FILE_ERROR_FAILED:
+      return "InvalidStateError";
+    case base::File::FILE_ERROR_ABORT:
+      return "AbortError";
+    case base::File::FILE_ERROR_SECURITY:
+      return "SecurityError";
+    case base::File::FILE_ERROR_NO_SPACE:
+      return "QuotaExceededError";
+    case base::File::FILE_ERROR_INVALID_URL:
+      return "EncodingError";
+    default:
+      return "InvalidModificationError";
+  }
+}
+
+// Checks if we should send a progress event or not according to the
+// |last_time| of sending an event. If |always| is true, the function always
+// returns true. If the function returns true, the function also updates
+// |last_time|.
+bool ShouldSendProgressEvent(bool always, base::Time* last_time) {
+  const base::Time now = base::Time::Now();
+  const int64_t delta = (now - *last_time).InMilliseconds();
+  // delta < 0 may rarely happen if system clock is synced and rewinded.
+  // To be conservative, we don't skip in that case.
+  if (!always && 0 <= delta && delta < kProgressEventFrequencyInMilliseconds) {
+    return false;
+  } else {
+    *last_time = now;
+    return true;
+  }
+}
+
+// Obtains whether the Files app should handle the volume or not.
+bool ShouldShowNotificationForVolume(
+    Profile* profile,
+    const DeviceEventRouter& device_event_router,
+    const Volume& volume) {
+  if (volume.type() != VOLUME_TYPE_MTP &&
+      volume.type() != VOLUME_TYPE_REMOVABLE_DISK_PARTITION) {
+    return false;
+  }
+
+  if (device_event_router.is_resuming() || device_event_router.is_starting_up())
+    return false;
+
+  // Do not attempt to open File Manager while the login is in progress or
+  // the screen is locked or running in kiosk app mode and make sure the file
+  // manager is opened only for the active user.
+  if (chromeos::LoginDisplayHost::default_host() ||
+      chromeos::ScreenLocker::default_screen_locker() ||
+      chrome::IsRunningInForcedAppMode() ||
+      profile != ProfileManager::GetActiveUserProfile()) {
+    return false;
+  }
+
+  // Do not pop-up the File Manager, if the recovery tool is running.
+  if (IsRecoveryToolRunning(profile))
+    return false;
+
+  // If the disable-default-apps flag is on, the Files app is not opened
+  // automatically on device mount not to obstruct the manual test.
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kDisableDefaultApps)) {
+    return false;
+  }
+
+  // We suppress notifications about HP Elite USB-C Dock's internal storage.
+  // chrome-os-partner:58309.
+  // TODO(fukino): Remove this workaround when the root cause is fixed.
+  if (volume.type() == VOLUME_TYPE_REMOVABLE_DISK_PARTITION) {
+    const Disk* disk = DiskMountManager::GetInstance()->FindDiskBySourcePath(
+        volume.source_path().AsUTF8Unsafe());
+    if (disk && disk->vendor_id() == "0ea0" && disk->product_id() == "2272")
+      return false;
+  }
+
+  return true;
+}
+
+// Sub-part of the event router for handling device events.
+class DeviceEventRouterImpl : public DeviceEventRouter {
+ public:
+  explicit DeviceEventRouterImpl(Profile* profile) : profile_(profile) {}
+
+  // DeviceEventRouter overrides.
+  void OnDeviceEvent(file_manager_private::DeviceEventType type,
+                     const std::string& device_path) override {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    file_manager_private::DeviceEvent event;
+    event.type = type;
+    event.device_path = device_path;
+
+    BroadcastEvent(profile_,
+                   extensions::events::FILE_MANAGER_PRIVATE_ON_DEVICE_CHANGED,
+                   file_manager_private::OnDeviceChanged::kEventName,
+                   file_manager_private::OnDeviceChanged::Create(event));
+  }
+
+  // DeviceEventRouter overrides.
+  bool IsExternalStorageDisabled() override {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+    return profile_->GetPrefs()->GetBoolean(prefs::kExternalStorageDisabled);
+  }
+
+ private:
+  Profile* const profile_;
+
+  DISALLOW_COPY_AND_ASSIGN(DeviceEventRouterImpl);
+};
+
+class JobEventRouterImpl : public JobEventRouter {
+ public:
+  explicit JobEventRouterImpl(Profile* profile)
+      : JobEventRouter(base::TimeDelta::FromMilliseconds(
+            kFileTransferEventDelayTimeInMilliseconds)),
+        profile_(profile) {}
+
+ protected:
+  std::set<std::string> GetFileTransfersUpdateEventListenerExtensionIds()
+      override {
+    const extensions::EventListenerMap::ListenerList& listeners =
+        extensions::EventRouter::Get(profile_)
+            ->listeners()
+            .GetEventListenersByName(
+                file_manager_private::OnFileTransfersUpdated::kEventName);
+
+    std::set<std::string> extension_ids;
+
+    for (const auto& listener : listeners) {
+      extension_ids.insert(listener->extension_id());
+    }
+
+    return extension_ids;
+  }
+
+  GURL ConvertDrivePathToFileSystemUrl(
+      const base::FilePath& file_path,
+      const std::string& extension_id) override {
+    return file_manager::util::ConvertDrivePathToFileSystemUrl(
+        profile_, file_path, extension_id);
+  }
+
+  void DispatchEventToExtension(
+      const std::string& extension_id,
+      extensions::events::HistogramValue histogram_value,
+      const std::string& event_name,
+      std::unique_ptr<base::ListValue> event_args) override {
+    ::file_manager::DispatchEventToExtension(profile_, extension_id,
+                                             histogram_value, event_name,
+                                             std::move(event_args));
+  }
+
+ private:
+  Profile* const profile_;
+
+  DISALLOW_COPY_AND_ASSIGN(JobEventRouterImpl);
+};
+
+class DriveFsEventRouterImpl : public DriveFsEventRouter {
+ public:
+  explicit DriveFsEventRouterImpl(Profile* profile) : profile_(profile) {}
+
+ private:
+  std::set<std::string> GetEventListenerExtensionIds(
+      const std::string& event_name) override {
+    const extensions::EventListenerMap::ListenerList& listeners =
+        extensions::EventRouter::Get(profile_)
+            ->listeners()
+            .GetEventListenersByName(event_name);
+
+    std::set<std::string> extension_ids;
+
+    for (const auto& listener : listeners) {
+      extension_ids.insert(listener->extension_id());
+    }
+
+    return extension_ids;
+  }
+
+  GURL ConvertDrivePathToFileSystemUrl(
+      const base::FilePath& file_path,
+      const std::string& extension_id) override {
+    GURL url;
+    file_manager::util::ConvertAbsoluteFilePathToFileSystemUrl(
+        profile_,
+        base::FilePath(DriveIntegrationServiceFactory::FindForProfile(profile_)
+                           ->GetMountPointPath()
+                           .value() +
+                       file_path.value()),
+        extension_id, &url);
+    return url;
+  }
+
+  std::string GetDriveFileSystemName() override {
+    return DriveIntegrationServiceFactory::FindForProfile(profile_)
+        ->GetMountPointPath()
+        .BaseName()
+        .value();
+  }
+
+  void DispatchEventToExtension(
+      const std::string& extension_id,
+      extensions::events::HistogramValue histogram_value,
+      const std::string& event_name,
+      std::unique_ptr<base::ListValue> event_args) override {
+    extensions::EventRouter::Get(profile_)->DispatchEventToExtension(
+        extension_id, std::make_unique<extensions::Event>(
+                          histogram_value, event_name, std::move(event_args)));
+  }
+
+  Profile* const profile_;
+
+  DISALLOW_COPY_AND_ASSIGN(DriveFsEventRouterImpl);
+};
+
+}  // namespace
+
+EventRouter::EventRouter(Profile* profile)
+    : pref_change_registrar_(std::make_unique<PrefChangeRegistrar>()),
+      profile_(profile),
+      device_event_router_(std::make_unique<DeviceEventRouterImpl>(profile)),
+      job_event_router_(std::make_unique<JobEventRouterImpl>(profile)),
+      drivefs_event_router_(std::make_unique<DriveFsEventRouterImpl>(profile)),
+      dispatch_directory_change_event_impl_(
+          base::Bind(&EventRouter::DispatchDirectoryChangeEventImpl,
+                     base::Unretained(this))),
+      weak_factory_(this) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  ObserveEvents();
+}
+
+EventRouter::~EventRouter() = default;
+
+void EventRouter::OnIntentFiltersUpdated() {
+  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
+  BroadcastEvent(profile_,
+                 extensions::events::FILE_MANAGER_PRIVATE_ON_APPS_UPDATED,
+                 file_manager_private::OnAppsUpdated::kEventName,
+                 file_manager_private::OnAppsUpdated::Create());
+}
+
+void EventRouter::Shutdown() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  auto* intent_helper =
+      arc::ArcIntentHelperBridge::GetForBrowserContext(profile_);
+  if (intent_helper)
+    intent_helper->RemoveObserver(this);
+
+  chromeos::system::TimezoneSettings::GetInstance()->RemoveObserver(this);
+
+  DLOG_IF(WARNING, !file_watchers_.empty())
+      << "Not all file watchers are "
+      << "removed. This can happen when the Files app is open during shutdown.";
+  file_watchers_.clear();
+  if (!profile_) {
+    NOTREACHED();
+    return;
+  }
+
+  pref_change_registrar_->RemoveAll();
+
+  if (NetworkHandler::IsInitialized()) {
+    NetworkHandler::Get()->network_state_handler()->RemoveObserver(this,
+                                                                   FROM_HERE);
+  }
+
+  DriveIntegrationService* const integration_service =
+      DriveIntegrationServiceFactory::FindForProfile(profile_);
+  if (integration_service) {
+    if (integration_service->GetDriveFsHost()) {
+      integration_service->GetDriveFsHost()->RemoveObserver(
+          drivefs_event_router_.get());
+    } else {
+      integration_service->file_system()->RemoveObserver(this);
+      integration_service->drive_service()->RemoveObserver(this);
+      integration_service->job_list()->RemoveObserver(job_event_router_.get());
+    }
+  }
+
+  VolumeManager* const volume_manager = VolumeManager::Get(profile_);
+  if (volume_manager) {
+    volume_manager->RemoveObserver(this);
+    volume_manager->RemoveObserver(device_event_router_.get());
+  }
+
+  chromeos::PowerManagerClient* const power_manager_client =
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
+  power_manager_client->RemoveObserver(device_event_router_.get());
+
+  profile_ = nullptr;
+}
+
+void EventRouter::ObserveEvents() {
+  if (!profile_) {
+    NOTREACHED();
+    return;
+  }
+  if (!chromeos::LoginState::IsInitialized() ||
+      !chromeos::LoginState::Get()->IsUserLoggedIn()) {
+    return;
+  }
+
+  // Ignore device events for the first few seconds.
+  device_event_router_->Startup();
+
+  // VolumeManager's construction triggers DriveIntegrationService's
+  // construction, so it is necessary to call VolumeManager's Get before
+  // accessing DriveIntegrationService.
+  VolumeManager* const volume_manager = VolumeManager::Get(profile_);
+  if (volume_manager) {
+    volume_manager->AddObserver(this);
+    volume_manager->AddObserver(device_event_router_.get());
+  }
+
+  chromeos::PowerManagerClient* const power_manager_client =
+      chromeos::DBusThreadManager::Get()->GetPowerManagerClient();
+  power_manager_client->AddObserver(device_event_router_.get());
+
+  DriveIntegrationService* const integration_service =
+      DriveIntegrationServiceFactory::FindForProfile(profile_);
+  if (integration_service) {
+    if (integration_service->GetDriveFsHost()) {
+      integration_service->GetDriveFsHost()->AddObserver(
+          drivefs_event_router_.get());
+    } else {
+      integration_service->drive_service()->AddObserver(this);
+      integration_service->file_system()->AddObserver(this);
+      integration_service->job_list()->AddObserver(job_event_router_.get());
+    }
+  }
+
+  if (NetworkHandler::IsInitialized()) {
+    NetworkHandler::Get()->network_state_handler()->AddObserver(this,
+                                                                FROM_HERE);
+  }
+
+  pref_change_registrar_->Init(profile_->GetPrefs());
+  base::Closure callback =
+      base::Bind(&EventRouter::OnFileManagerPrefsChanged,
+                 weak_factory_.GetWeakPtr());
+  pref_change_registrar_->Add(drive::prefs::kDisableDriveOverCellular,
+                              callback);
+  pref_change_registrar_->Add(drive::prefs::kDisableDriveHostedFiles, callback);
+  pref_change_registrar_->Add(drive::prefs::kDisableDrive, callback);
+  pref_change_registrar_->Add(prefs::kSearchSuggestEnabled, callback);
+  pref_change_registrar_->Add(prefs::kUse24HourClock, callback);
+
+  chromeos::system::TimezoneSettings::GetInstance()->AddObserver(this);
+
+  auto* intent_helper =
+      arc::ArcIntentHelperBridge::GetForBrowserContext(profile_);
+  if (intent_helper)
+    intent_helper->AddObserver(this);
+}
+
+// File watch setup routines.
+void EventRouter::AddFileWatch(const base::FilePath& local_path,
+                               const base::FilePath& virtual_path,
+                               const std::string& extension_id,
+                               const BoolCallback& callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(!callback.is_null());
+
+  base::FilePath watch_path = local_path;
+  bool is_on_drive = drive::util::IsUnderDriveMountPoint(watch_path);
+  // Tweak watch path for remote sources - we need to drop leading /special
+  // directory from there in order to be able to pair these events with
+  // their change notifications.
+  if (is_on_drive)
+    watch_path = drive::util::ExtractDrivePath(watch_path);
+
+  auto iter = file_watchers_.find(watch_path);
+  if (iter == file_watchers_.end()) {
+    std::unique_ptr<FileWatcher> watcher(new FileWatcher(virtual_path));
+    watcher->AddExtension(extension_id);
+
+    if (is_on_drive) {
+      // For Drive, file watching is done via OnDirectoryChanged().
+      base::ThreadTaskRunnerHandle::Get()->PostTask(
+          FROM_HERE, base::BindOnce(callback, true));
+    } else {
+      // For local files, start watching using FileWatcher.
+      watcher->WatchLocalFile(
+          watch_path,
+          base::Bind(&EventRouter::HandleFileWatchNotification,
+                     weak_factory_.GetWeakPtr(),
+                     static_cast<drive::FileChange*>(nullptr)),
+          callback);
+    }
+
+    file_watchers_[watch_path] = std::move(watcher);
+  } else {
+    iter->second->AddExtension(extension_id);
+    base::ThreadTaskRunnerHandle::Get()->PostTask(
+        FROM_HERE, base::BindOnce(callback, true));
+  }
+}
+
+void EventRouter::RemoveFileWatch(const base::FilePath& local_path,
+                                  const std::string& extension_id) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  base::FilePath watch_path = local_path;
+  // Tweak watch path for remote sources - we need to drop leading /special
+  // directory from there in order to be able to pair these events with
+  // their change notifications.
+  if (drive::util::IsUnderDriveMountPoint(watch_path)) {
+    watch_path = drive::util::ExtractDrivePath(watch_path);
+  }
+  auto iter = file_watchers_.find(watch_path);
+  if (iter == file_watchers_.end())
+    return;
+  // Remove the watcher if |watch_path| is no longer watched by any extensions.
+  iter->second->RemoveExtension(extension_id);
+  if (iter->second->GetExtensionIds().empty())
+    file_watchers_.erase(iter);
+}
+
+void EventRouter::OnCopyCompleted(int copy_id,
+                                  const GURL& source_url,
+                                  const GURL& destination_url,
+                                  base::File::Error error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  file_manager_private::CopyProgressStatus status;
+  if (error == base::File::FILE_OK) {
+    // Send success event.
+    status.type = file_manager_private::COPY_PROGRESS_STATUS_TYPE_SUCCESS;
+    status.source_url = std::make_unique<std::string>(source_url.spec());
+    status.destination_url =
+        std::make_unique<std::string>(destination_url.spec());
+  } else {
+    // Send error event.
+    status.type = file_manager_private::COPY_PROGRESS_STATUS_TYPE_ERROR;
+    status.error = std::make_unique<std::string>(FileErrorToErrorName(error));
+  }
+
+  BroadcastEvent(profile_,
+                 extensions::events::FILE_MANAGER_PRIVATE_ON_COPY_PROGRESS,
+                 file_manager_private::OnCopyProgress::kEventName,
+                 file_manager_private::OnCopyProgress::Create(copy_id, status));
+}
+
+void EventRouter::OnCopyProgress(
+    int copy_id,
+    storage::FileSystemOperation::CopyProgressType type,
+    const GURL& source_url,
+    const GURL& destination_url,
+    int64_t size) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  file_manager_private::CopyProgressStatus status;
+  status.type = CopyProgressTypeToCopyProgressStatusType(type);
+  status.source_url = std::make_unique<std::string>(source_url.spec());
+  if (type == storage::FileSystemOperation::END_COPY_ENTRY ||
+      type == storage::FileSystemOperation::ERROR_COPY_ENTRY)
+    status.destination_url =
+        std::make_unique<std::string>(destination_url.spec());
+  if (type == storage::FileSystemOperation::ERROR_COPY_ENTRY)
+    status.error = std::make_unique<std::string>(
+        FileErrorToErrorName(base::File::FILE_ERROR_FAILED));
+  if (type == storage::FileSystemOperation::PROGRESS)
+    status.size = std::make_unique<double>(size);
+
+  // Discard error progress since current JS code cannot handle this properly.
+  // TODO(yawano): Remove this after JS side is implemented correctly.
+  if (type == storage::FileSystemOperation::ERROR_COPY_ENTRY)
+    return;
+
+  // Should not skip events other than TYPE_PROGRESS.
+  const bool always =
+      status.type != file_manager_private::COPY_PROGRESS_STATUS_TYPE_PROGRESS;
+  if (!ShouldSendProgressEvent(always, &last_copy_progress_event_))
+    return;
+
+  BroadcastEvent(profile_,
+                 extensions::events::FILE_MANAGER_PRIVATE_ON_COPY_PROGRESS,
+                 file_manager_private::OnCopyProgress::kEventName,
+                 file_manager_private::OnCopyProgress::Create(copy_id, status));
+}
+
+void EventRouter::OnWatcherManagerNotification(
+    const storage::FileSystemURL& file_system_url,
+    const std::string& extension_id,
+    storage::WatcherManager::ChangeType /* change_type */) {
+  std::vector<std::string> extension_ids;
+  extension_ids.push_back(extension_id);
+
+  DispatchDirectoryChangeEvent(file_system_url.virtual_path(), nullptr,
+                               false /* error */, extension_ids);
+}
+
+void EventRouter::DefaultNetworkChanged(const chromeos::NetworkState* network) {
+  if (!profile_ || !extensions::EventRouter::Get(profile_)) {
+    NOTREACHED();
+    return;
+  }
+
+  BroadcastEvent(
+      profile_, extensions::events::
+                    FILE_MANAGER_PRIVATE_ON_DRIVE_CONNECTION_STATUS_CHANGED,
+      file_manager_private::OnDriveConnectionStatusChanged::kEventName,
+      file_manager_private::OnDriveConnectionStatusChanged::Create());
+}
+
+void EventRouter::TimezoneChanged(const icu::TimeZone& timezone) {
+  OnFileManagerPrefsChanged();
+}
+
+void EventRouter::OnFileManagerPrefsChanged() {
+  if (!profile_ || !extensions::EventRouter::Get(profile_)) {
+    NOTREACHED();
+    return;
+  }
+
+  BroadcastEvent(
+      profile_, extensions::events::FILE_MANAGER_PRIVATE_ON_PREFERENCES_CHANGED,
+      file_manager_private::OnPreferencesChanged::kEventName,
+      file_manager_private::OnPreferencesChanged::Create());
+}
+
+void EventRouter::OnDirectoryChanged(const base::FilePath& drive_path) {
+  HandleFileWatchNotification(nullptr, drive_path, false);
+}
+
+void EventRouter::OnFileChanged(const drive::FileChange& changed_files) {
+  // In this method, we convert changed_files to a map which can be handled by
+  // HandleFileWatchNotification.
+  //
+  // e.g.
+  // /a/b DIRECTORY:DELETE
+  //
+  // map[/a] = /a/b DIRECTORY:DELETE
+  // map[/a/b] = /a/b DIRECTORY:DELETE
+  //
+  // We used the key of map to match the watched directories of file watchers.
+  typedef std::map<base::FilePath, drive::FileChange> FileChangeMap;
+  typedef drive::FileChange::ChangeList::List FileChangeList;
+
+  FileChangeMap map;
+  const drive::FileChange::Map& changed_file_map = changed_files.map();
+  for (auto const& file_change_key_value : changed_file_map) {
+    // Check whether the FileChangeList contains directory deletion.
+    bool contains_directory_deletion = false;
+    const FileChangeList list = file_change_key_value.second.list();
+    for (drive::FileChange::Change const& change : list) {
+      if (change.IsDirectory() && change.IsDelete()) {
+        contains_directory_deletion = true;
+        break;
+      }
+    }
+
+    const base::FilePath& path = file_change_key_value.first;
+    map[path.DirName()].Update(path, file_change_key_value.second);
+
+    // For deletion of a directory, onFileChanged gets different changed_files.
+    // We solve the difference here.
+    //
+    // /a/b is watched, and /a is deleted from Drive (e.g. from Web).
+    // 1. /a/b DELETE:DIRECTORY
+    // 2. /a DELETE:DIRECTORY
+    //
+    // /a/b is watched, and /a is deleted from the Files app.
+    // 1. /a DELETE:DIRECTORY
+    if (contains_directory_deletion) {
+      // Expand the deleted directory path with watched paths.
+      for (auto file_watchers_it = file_watchers_.lower_bound(path);
+           file_watchers_it != file_watchers_.end(); ++file_watchers_it) {
+        if (path == file_watchers_it->first ||
+            path.IsParent(file_watchers_it->first)) {
+          map[file_watchers_it->first].Update(
+              file_watchers_it->first,
+              drive::FileChange::FileType::FILE_TYPE_DIRECTORY,
+              drive::FileChange::ChangeType::CHANGE_TYPE_DELETE);
+        }
+      }
+    }
+  }
+
+  for (auto const& file_change_key_value : map) {
+    HandleFileWatchNotification(&(file_change_key_value.second),
+                                file_change_key_value.first, false);
+  }
+}
+
+void EventRouter::OnDriveSyncError(drive::file_system::DriveSyncErrorType type,
+                                   const base::FilePath& drive_path) {
+  file_manager_private::DriveSyncErrorEvent event;
+  switch (type) {
+    case drive::file_system::DRIVE_SYNC_ERROR_DELETE_WITHOUT_PERMISSION:
+      event.type =
+          file_manager_private::DRIVE_SYNC_ERROR_TYPE_DELETE_WITHOUT_PERMISSION;
+      break;
+    case drive::file_system::DRIVE_SYNC_ERROR_SERVICE_UNAVAILABLE:
+      event.type =
+          file_manager_private::DRIVE_SYNC_ERROR_TYPE_SERVICE_UNAVAILABLE;
+      break;
+    case drive::file_system::DRIVE_SYNC_ERROR_NO_SERVER_SPACE:
+      event.type = file_manager_private::DRIVE_SYNC_ERROR_TYPE_NO_SERVER_SPACE;
+      break;
+    case drive::file_system::DRIVE_SYNC_ERROR_MISC:
+      event.type =
+          file_manager_private::DRIVE_SYNC_ERROR_TYPE_MISC;
+      break;
+  }
+  event.file_url = util::ConvertDrivePathToFileSystemUrl(
+      profile_, drive_path, kFileManagerAppId).spec();
+  BroadcastEvent(profile_,
+                 extensions::events::FILE_MANAGER_PRIVATE_ON_DRIVE_SYNC_ERROR,
+                 file_manager_private::OnDriveSyncError::kEventName,
+                 file_manager_private::OnDriveSyncError::Create(event));
+}
+
+void EventRouter::OnRefreshTokenInvalid() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  // Raise a DriveConnectionStatusChanged event to notify the status offline.
+  BroadcastEvent(
+      profile_, extensions::events::
+                    FILE_MANAGER_PRIVATE_ON_DRIVE_CONNECTION_STATUS_CHANGED,
+      file_manager_private::OnDriveConnectionStatusChanged::kEventName,
+      file_manager_private::OnDriveConnectionStatusChanged::Create());
+}
+
+void EventRouter::OnReadyToSendRequests() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  // Raise a DriveConnectionStatusChanged event to notify the status online.
+  BroadcastEvent(
+      profile_, extensions::events::
+                    FILE_MANAGER_PRIVATE_ON_DRIVE_CONNECTION_STATUS_CHANGED,
+      file_manager_private::OnDriveConnectionStatusChanged::kEventName,
+      file_manager_private::OnDriveConnectionStatusChanged::Create());
+}
+
+void EventRouter::HandleFileWatchNotification(const drive::FileChange* list,
+                                              const base::FilePath& local_path,
+                                              bool got_error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  auto iter = file_watchers_.find(local_path);
+  if (iter == file_watchers_.end()) {
+    return;
+  }
+
+  if (list && list->size() > kDirectoryChangeEventMaxDetailInfoSize) {
+    // Removes the detailed information, if the list size is more than
+    // kDirectoryChangeEventMaxDetailInfoSize, since passing large list
+    // and processing it may cause more itme.
+    // This will be invoked full-refresh in the Files app.
+    list = nullptr;
+  }
+
+  DispatchDirectoryChangeEvent(iter->second->virtual_path(),
+                               list,
+                               got_error,
+                               iter->second->GetExtensionIds());
+}
+
+void EventRouter::DispatchDirectoryChangeEvent(
+    const base::FilePath& virtual_path,
+    const drive::FileChange* list,
+    bool got_error,
+    const std::vector<std::string>& extension_ids) {
+  dispatch_directory_change_event_impl_.Run(virtual_path, list, got_error,
+                                            extension_ids);
+}
+
+void EventRouter::DispatchDirectoryChangeEventImpl(
+    const base::FilePath& virtual_path,
+    const drive::FileChange* list,
+    bool got_error,
+    const std::vector<std::string>& extension_ids) {
+  if (!profile_) {
+    NOTREACHED();
+    return;
+  }
+  linked_ptr<drive::FileChange> changes;
+  if (list)
+    changes.reset(new drive::FileChange(*list));  // Copy
+
+  for (size_t i = 0; i < extension_ids.size(); ++i) {
+    std::string* extension_id = new std::string(extension_ids[i]);
+
+    FileDefinition file_definition;
+    file_definition.virtual_path = virtual_path;
+    // TODO(mtomasz): Add support for watching files in File System Provider
+    // API.
+    file_definition.is_directory = true;
+
+    file_manager::util::ConvertFileDefinitionToEntryDefinition(
+        profile_,
+        *extension_id,
+        file_definition,
+        base::Bind(
+            &EventRouter::DispatchDirectoryChangeEventWithEntryDefinition,
+            weak_factory_.GetWeakPtr(),
+            changes,
+            base::Owned(extension_id),
+            got_error));
+  }
+}
+
+void EventRouter::DispatchDirectoryChangeEventWithEntryDefinition(
+    const linked_ptr<drive::FileChange> list,
+    const std::string* extension_id,
+    bool watcher_error,
+    const EntryDefinition& entry_definition) {
+  // TODO(mtomasz): Add support for watching files in File System Provider API.
+  if (entry_definition.error != base::File::FILE_OK ||
+      !entry_definition.is_directory) {
+    DVLOG(1) << "Unable to dispatch event because resolving the directory "
+             << "entry definition failed.";
+    return;
+  }
+
+  file_manager_private::FileWatchEvent event;
+  event.event_type = watcher_error
+      ? file_manager_private::FILE_WATCH_EVENT_TYPE_ERROR
+      : file_manager_private::FILE_WATCH_EVENT_TYPE_CHANGED;
+
+  // Detailed information is available.
+  if (list.get()) {
+    event.changed_files =
+        std::make_unique<std::vector<file_manager_private::FileChange>>();
+
+    if (list->map().empty())
+      return;
+
+    for (drive::FileChange::Map::const_iterator it = list->map().begin();
+         it != list->map().end();
+         it++) {
+      file_manager_private::FileChange change_list;
+
+      GURL url = util::ConvertDrivePathToFileSystemUrl(
+          profile_, it->first, *extension_id);
+      change_list.url = url.spec();
+
+      for (drive::FileChange::ChangeList::List::const_iterator change =
+               it->second.list().begin();
+           change != it->second.list().end();
+           change++) {
+        change_list.changes.push_back(
+            ConvertChangeTypeFromDriveToApi(change->change()));
+      }
+
+      event.changed_files->push_back(std::move(change_list));
+    }
+  }
+
+  event.entry.additional_properties.SetString(
+      "fileSystemName", entry_definition.file_system_name);
+  event.entry.additional_properties.SetString(
+      "fileSystemRoot", entry_definition.file_system_root_url);
+  event.entry.additional_properties.SetString(
+      "fileFullPath", "/" + entry_definition.full_path.value());
+  event.entry.additional_properties.SetBoolean("fileIsDirectory",
+                                               entry_definition.is_directory);
+
+  DispatchEventToExtension(
+      profile_, *extension_id,
+      extensions::events::FILE_MANAGER_PRIVATE_ON_DIRECTORY_CHANGED,
+      file_manager_private::OnDirectoryChanged::kEventName,
+      file_manager_private::OnDirectoryChanged::Create(event));
+}
+
+void EventRouter::OnDiskAdded(const Disk& disk, bool mounting) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // Do nothing.
+}
+
+void EventRouter::OnDiskRemoved(const Disk& disk) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // Do nothing.
+}
+
+void EventRouter::OnDeviceAdded(const std::string& device_path) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // Do nothing.
+}
+
+void EventRouter::OnDeviceRemoved(const std::string& device_path) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // Do nothing.
+}
+
+void EventRouter::OnVolumeMounted(chromeos::MountError error_code,
+                                  const Volume& volume) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // profile_ is NULL if ShutdownOnUIThread() is called earlier. This can
+  // happen at shutdown. This should be removed after removing Drive mounting
+  // code in addMount. (addMount -> OnFileSystemMounted -> OnVolumeMounted is
+  // the only path to come here after Shutdown is called).
+  if (!profile_)
+    return;
+
+  DispatchMountCompletedEvent(
+      file_manager_private::MOUNT_COMPLETED_EVENT_TYPE_MOUNT, error_code,
+      volume);
+
+  // TODO(mtomasz): Move VolumeManager and part of the event router outside of
+  // file_manager, so there is no dependency between File System API and the
+  // file_manager code.
+  extensions::file_system_api::DispatchVolumeListChangeEvent(profile_);
+}
+
+void EventRouter::OnVolumeUnmounted(chromeos::MountError error_code,
+                                    const Volume& volume) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DispatchMountCompletedEvent(
+      file_manager_private::MOUNT_COMPLETED_EVENT_TYPE_UNMOUNT, error_code,
+      volume);
+}
+
+void EventRouter::DispatchMountCompletedEvent(
+    file_manager_private::MountCompletedEventType event_type,
+    chromeos::MountError error,
+    const Volume& volume) {
+  // Build an event object.
+  file_manager_private::MountCompletedEvent event;
+  event.event_type = event_type;
+  event.status = MountErrorToMountCompletedStatus(error);
+  util::VolumeToVolumeMetadata(profile_, volume, &event.volume_metadata);
+  event.should_notify =
+      ShouldShowNotificationForVolume(profile_, *device_event_router_, volume);
+  BroadcastEvent(profile_,
+                 extensions::events::FILE_MANAGER_PRIVATE_ON_MOUNT_COMPLETED,
+                 file_manager_private::OnMountCompleted::kEventName,
+                 file_manager_private::OnMountCompleted::Create(event));
+}
+
+void EventRouter::OnFormatStarted(const std::string& device_path,
+                                  bool success) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // Do nothing.
+}
+
+void EventRouter::OnFormatCompleted(const std::string& device_path,
+                                    bool success) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // Do nothing.
+}
+
+void EventRouter::OnRenameStarted(const std::string& device_path,
+                                  bool success) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // Do nothing.
+}
+
+void EventRouter::OnRenameCompleted(const std::string& device_path,
+                                    bool success) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // Do nothing.
+}
+
+void EventRouter::SetDispatchDirectoryChangeEventImplForTesting(
+    const DispatchDirectoryChangeEventImplCallback& callback) {
+  dispatch_directory_change_event_impl_ = callback;
+}
+
+base::WeakPtr<EventRouter> EventRouter::GetWeakPtr() {
+  return weak_factory_.GetWeakPtr();
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/extensions/api/file_manager/chromeos/event_router.h b/chrome/browser/extensions/api/file_manager/chromeos/event_router.h
new file mode 100644
index 0000000000000..a0b3c4eeec693
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/chromeos/event_router.h
@@ -0,0 +1,237 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_CHROMEOS_EVENT_ROUTER_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_CHROMEOS_EVENT_ROUTER_H_
+
+#include <stdint.h>
+
+#include <map>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/compiler_specific.h"
+#include "base/files/file_path_watcher.h"
+#include "base/macros.h"
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/extensions/api/file_manager/device_event_router.h"
+#include "chrome/browser/extensions/api/file_manager/drivefs_event_router.h"
+#include "chrome/browser/extensions/api/file_manager/job_event_router.h"
+#include "chrome/browser/file_manager/file_watcher.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/browser/file_manager/volume_manager_observer.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "chromeos/disks/disk_mount_manager.h"
+#include "chromeos/network/network_state_handler_observer.h"
+#include "chromeos/settings/timezone_settings.h"
+#include "components/arc/arc_service_manager.h"
+#include "components/arc/intent_helper/arc_intent_helper_observer.h"
+#include "components/drive/chromeos/file_system_observer.h"
+#include "components/drive/chromeos/sync_client.h"
+#include "components/drive/service/drive_service_interface.h"
+#include "components/keyed_service/core/keyed_service.h"
+#include "storage/browser/fileapi/file_system_operation.h"
+
+class PrefChangeRegistrar;
+class Profile;
+
+using file_manager::util::EntryDefinition;
+
+namespace chromeos {
+class NetworkState;
+}
+
+namespace drive {
+class FileChange;
+}
+
+namespace file_manager {
+
+// Monitors changes in disk mounts, network connection state and preferences
+// affecting File Manager. Dispatches appropriate File Browser events.
+class EventRouter : public KeyedService,
+                    public chromeos::NetworkStateHandlerObserver,
+                    public chromeos::system::TimezoneSettings::Observer,
+                    public drive::FileSystemObserver,
+                    public drive::DriveServiceObserver,
+                    public VolumeManagerObserver,
+                    public arc::ArcIntentHelperObserver {
+ public:
+  typedef base::Callback<void(const base::FilePath& virtual_path,
+                              const drive::FileChange* list,
+                              bool got_error,
+                              const std::vector<std::string>& extension_ids)>
+      DispatchDirectoryChangeEventImplCallback;
+
+  explicit EventRouter(Profile* profile);
+  ~EventRouter() override;
+
+  // arc::ArcIntentHelperObserver overrides.
+  void OnIntentFiltersUpdated() override;
+
+  // KeyedService overrides.
+  void Shutdown() override;
+
+  typedef base::Callback<void(bool success)> BoolCallback;
+
+  // Adds a file watch at |local_path|, associated with |virtual_path|, for
+  // an extension with |extension_id|.
+  //
+  // |callback| will be called with true on success, or false on failure.
+  // |callback| must not be null.
+  //
+  // Obsolete. Used as fallback for files which backends do not implement the
+  // storage::WatcherManager interface.
+  void AddFileWatch(const base::FilePath& local_path,
+                    const base::FilePath& virtual_path,
+                    const std::string& extension_id,
+                    const BoolCallback& callback);
+
+  // Removes a file watch at |local_path| for an extension with |extension_id|.
+  //
+  // Obsolete. Used as fallback for files which backends do not implement the
+  // storage::WatcherManager interface.
+  void RemoveFileWatch(const base::FilePath& local_path,
+                       const std::string& extension_id);
+
+  // Called when a copy task is completed.
+  void OnCopyCompleted(
+      int copy_id, const GURL& source_url, const GURL& destination_url,
+      base::File::Error error);
+
+  // Called when a copy task progress is updated.
+  void OnCopyProgress(int copy_id,
+                      storage::FileSystemOperation::CopyProgressType type,
+                      const GURL& source_url,
+                      const GURL& destination_url,
+                      int64_t size);
+
+  // Called when a notification from a watcher manager arrives.
+  void OnWatcherManagerNotification(
+      const storage::FileSystemURL& file_system_url,
+      const std::string& extension_id,
+      storage::WatcherManager::ChangeType change_type);
+
+  // chromeos::NetworkStateHandlerObserver overrides.
+  void DefaultNetworkChanged(const chromeos::NetworkState* network) override;
+
+  // chromeos::system::TimezoneSettings::Observer overrides.
+  void TimezoneChanged(const icu::TimeZone& timezone) override;
+
+  // drive::DriveServiceObserver overrides.
+  void OnRefreshTokenInvalid() override;
+  void OnReadyToSendRequests() override;
+
+  // drive::FileSystemObserver overrides.
+  void OnDirectoryChanged(const base::FilePath& drive_path) override;
+  void OnFileChanged(const drive::FileChange& changed_files) override;
+  void OnDriveSyncError(drive::file_system::DriveSyncErrorType type,
+                        const base::FilePath& drive_path) override;
+
+  // VolumeManagerObserver overrides.
+  void OnDiskAdded(const chromeos::disks::Disk& disk, bool mounting) override;
+  void OnDiskRemoved(const chromeos::disks::Disk& disk) override;
+  void OnDeviceAdded(const std::string& device_path) override;
+  void OnDeviceRemoved(const std::string& device_path) override;
+  void OnVolumeMounted(chromeos::MountError error_code,
+                       const Volume& volume) override;
+  void OnVolumeUnmounted(chromeos::MountError error_code,
+                         const Volume& volume) override;
+  void OnFormatStarted(const std::string& device_path, bool success) override;
+  void OnFormatCompleted(const std::string& device_path, bool success) override;
+  void OnRenameStarted(const std::string& device_path, bool success) override;
+  void OnRenameCompleted(const std::string& device_path, bool success) override;
+  // Set custom dispatch directory change event implementation for testing.
+  void SetDispatchDirectoryChangeEventImplForTesting(
+      const DispatchDirectoryChangeEventImplCallback& callback);
+
+  // Returns a weak pointer for the event router.
+  base::WeakPtr<EventRouter> GetWeakPtr();
+
+ private:
+  // Starts observing file system change events.
+  void ObserveEvents();
+
+  // Called when prefs related to file manager change.
+  void OnFileManagerPrefsChanged();
+
+  // Process file watch notifications.
+  void HandleFileWatchNotification(const drive::FileChange* list,
+                                   const base::FilePath& path,
+                                   bool got_error);
+
+  // Sends directory change event.
+  void DispatchDirectoryChangeEvent(
+      const base::FilePath& path,
+      const drive::FileChange* list,
+      bool got_error,
+      const std::vector<std::string>& extension_ids);
+
+  // Default implementation of DispatchDirectoryChangeEvent.
+  void DispatchDirectoryChangeEventImpl(
+      const base::FilePath& path,
+      const drive::FileChange* list,
+      bool got_error,
+      const std::vector<std::string>& extension_ids);
+
+  // Sends directory change event, after converting the file definition to entry
+  // definition.
+  void DispatchDirectoryChangeEventWithEntryDefinition(
+      const linked_ptr<drive::FileChange> list,
+      const std::string* extension_id,
+      bool watcher_error,
+      const EntryDefinition& entry_definition);
+
+  // Dispatches the mount completed event.
+  void DispatchMountCompletedEvent(
+      extensions::api::file_manager_private::MountCompletedEventType event_type,
+      chromeos::MountError error,
+      const Volume& volume);
+
+  // If needed, opens a file manager window for the removable device mounted at
+  // |mount_path|. Disk.mount_path() is empty, since it is being filled out
+  // after calling notifying observers by DiskMountManager.
+  void ShowRemovableDeviceInFileManager(VolumeType type,
+                                        const base::FilePath& mount_path);
+
+  // Sends onFileTransferUpdate event right now if |immediate| is set. Otherwise
+  // it refrains from sending for a short while, and after that it sends the
+  // most recently scheduled event once.
+  // The delay is for waiting subsequent 'added' events to come after the first
+  // one when multiple tasks are added. This way, we can avoid frequent UI
+  // update caused by differences between singular and plural cases.
+  void ScheduleDriveFileTransferEvent(const drive::JobInfo& job_info,
+                                      const std::string& status,
+                                      bool immediate);
+
+  // Sends the most recently scheduled onFileTransferUpdated event to
+  // extensions.
+  // This is used for implementing ScheduledDriveFileTransferEvent().
+  void SendDriveFileTransferEvent();
+
+  base::Time last_copy_progress_event_;
+
+  std::map<base::FilePath, std::unique_ptr<FileWatcher>> file_watchers_;
+  std::unique_ptr<PrefChangeRegistrar> pref_change_registrar_;
+  Profile* profile_;
+
+  std::unique_ptr<DeviceEventRouter> device_event_router_;
+  std::unique_ptr<JobEventRouter> job_event_router_;
+  std::unique_ptr<DriveFsEventRouter> drivefs_event_router_;
+
+  DispatchDirectoryChangeEventImplCallback
+      dispatch_directory_change_event_impl_;
+
+  // Note: This should remain the last member so it'll be destroyed and
+  // invalidate the weak pointers before any other members are destroyed.
+  base::WeakPtrFactory<EventRouter> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(EventRouter);
+};
+
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_CHROMEOS_EVENT_ROUTER_H_
diff --git a/chrome/browser/extensions/api/file_manager/chromeos/private_api_drive.cc b/chrome/browser/extensions/api/file_manager/chromeos/private_api_drive.cc
new file mode 100644
index 0000000000000..4d0f7ce764aa4
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/chromeos/private_api_drive.cc
@@ -0,0 +1,1565 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/chromeos/private_api_drive.h"
+
+#include <map>
+#include <memory>
+#include <set>
+#include <utility>
+
+#include "base/base64.h"
+#include "base/command_line.h"
+#include "base/memory/ptr_util.h"
+#include "base/strings/strcat.h"
+#include "base/task/post_task.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/chromeos/file_system_provider/mount_path_util.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_interface.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+#include "chrome/browser/file_manager/file_tasks.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/url_util.h"
+#include "chrome/browser/fileapi/external_file_url_util.h"
+#include "chrome/browser/fileapi/file_system_backend.h"
+#include "chrome/browser/chromeos/profiles/profile_helper.h"
+#include "chrome/browser/net/system_network_context_manager.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/browser/signin/profile_oauth2_token_service_factory.h"
+#include "chrome/browser/signin/signin_manager_factory.h"
+#include "chrome/common/extensions/api/file_manager_private_internal.h"
+#include "chromeos/chromeos_switches.h"
+#include "chromeos/network/network_handler.h"
+#include "chromeos/network/network_state_handler.h"
+#include "components/drive/drive_app_registry.h"
+#include "components/drive/event_logger.h"
+#include "components/signin/core/browser/profile_oauth2_token_service.h"
+#include "components/signin/core/browser/signin_manager.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/storage_partition.h"
+#include "google_apis/drive/auth_service.h"
+#include "google_apis/drive/drive_api_url_generator.h"
+#include "google_apis/drive/drive_switches.h"
+#include "mojo/public/cpp/bindings/callback_helpers.h"
+#include "services/network/public/cpp/shared_url_loader_factory.h"
+#include "storage/common/fileapi/file_system_info.h"
+#include "storage/common/fileapi/file_system_util.h"
+#include "url/gurl.h"
+
+using content::BrowserThread;
+
+using chromeos::file_system_provider::EntryMetadata;
+using chromeos::file_system_provider::ProvidedFileSystemInterface;
+using chromeos::file_system_provider::util::FileSystemURLParser;
+using extensions::api::file_manager_private::EntryProperties;
+using extensions::api::file_manager_private::EntryPropertyName;
+using file_manager::util::EntryDefinition;
+using file_manager::util::EntryDefinitionCallback;
+using file_manager::util::EntryDefinitionList;
+using file_manager::util::EntryDefinitionListCallback;
+using file_manager::util::FileDefinition;
+using file_manager::util::FileDefinitionList;
+using google_apis::DriveApiUrlGenerator;
+
+namespace extensions {
+namespace {
+
+// List of connection types of drive.
+// Keep this in sync with the DriveConnectionType in common/js/util.js.
+const char kDriveConnectionTypeOffline[] = "offline";
+const char kDriveConnectionTypeMetered[] = "metered";
+const char kDriveConnectionTypeOnline[] = "online";
+
+// List of reasons of kDriveConnectionType*.
+// Keep this in sync with the DriveConnectionReason in common/js/util.js.
+const char kDriveConnectionReasonNotReady[] = "not_ready";
+const char kDriveConnectionReasonNoNetwork[] = "no_network";
+const char kDriveConnectionReasonNoService[] = "no_service";
+
+// Maximum dimension of thumbnail in file manager. File manager shows 180x180
+// thumbnail. Given that we support hdpi devices, maximum dimension is 360.
+const int kFileManagerMaximumThumbnailDimension = 360;
+
+std::unique_ptr<std::string> GetShareUrlFromAlternateUrl(
+    const GURL& alternate_url) {
+  // Set |share_url| to a modified version of |alternate_url| that opens the
+  // sharing dialog for files and folders (add ?userstoinvite="" to the URL).
+  // TODO(sashab): Add an endpoint to the Drive API that generates this URL,
+  // instead of manually modifying it here.
+  GURL::Replacements replacements;
+  std::string new_query =
+      (alternate_url.has_query() ? alternate_url.query() + "&" : "") +
+      "userstoinvite=%22%22";
+  replacements.SetQueryStr(new_query);
+
+  return std::make_unique<std::string>(
+      alternate_url.ReplaceComponents(replacements).spec());
+}
+
+// Copies properties from |entry_proto| to |properties|. |shared_with_me| is
+// given from the running profile.
+void FillEntryPropertiesValueForDrive(const drive::ResourceEntry& entry_proto,
+                                      bool shared_with_me,
+                                      EntryProperties* properties) {
+  properties->shared_with_me = std::make_unique<bool>(shared_with_me);
+  properties->shared = std::make_unique<bool>(entry_proto.shared());
+  properties->starred = std::make_unique<bool>(entry_proto.starred());
+
+  const drive::PlatformFileInfoProto& file_info = entry_proto.file_info();
+  properties->size = std::make_unique<double>(file_info.size());
+  properties->modification_time = std::make_unique<double>(
+      base::Time::FromInternalValue(file_info.last_modified()).ToJsTime());
+  properties->modification_by_me_time = std::make_unique<double>(
+      base::Time::FromInternalValue(entry_proto.last_modified_by_me())
+          .ToJsTime());
+
+  if (entry_proto.has_alternate_url()) {
+    properties->alternate_url =
+        std::make_unique<std::string>(entry_proto.alternate_url());
+    properties->share_url =
+        GetShareUrlFromAlternateUrl(GURL(entry_proto.alternate_url()));
+  }
+
+  if (entry_proto.has_file_specific_info()) {
+    const drive::FileSpecificInfo& file_specific_info =
+        entry_proto.file_specific_info();
+
+    if (!entry_proto.resource_id().empty()) {
+      DriveApiUrlGenerator url_generator(
+          (GURL(google_apis::DriveApiUrlGenerator::kBaseUrlForProduction)),
+          (GURL(google_apis::DriveApiUrlGenerator::
+                    kBaseThumbnailUrlForProduction)),
+          google_apis::GetTeamDrivesIntegrationSwitch());
+      properties->thumbnail_url = std::make_unique<std::string>(
+          url_generator
+              .GetThumbnailUrl(entry_proto.resource_id(), 500 /* width */,
+                               500 /* height */, false /* not cropped */)
+              .spec());
+      properties->cropped_thumbnail_url = std::make_unique<std::string>(
+          url_generator
+              .GetThumbnailUrl(
+                  entry_proto.resource_id(),
+                  kFileManagerMaximumThumbnailDimension /* width */,
+                  kFileManagerMaximumThumbnailDimension /* height */,
+                  true /* cropped */)
+              .spec());
+    }
+    if (file_specific_info.has_image_width()) {
+      properties->image_width =
+          std::make_unique<int>(file_specific_info.image_width());
+    }
+    if (file_specific_info.has_image_height()) {
+      properties->image_height =
+          std::make_unique<int>(file_specific_info.image_height());
+    }
+    if (file_specific_info.has_image_rotation()) {
+      properties->image_rotation =
+          std::make_unique<int>(file_specific_info.image_rotation());
+    }
+    properties->hosted =
+        std::make_unique<bool>(file_specific_info.is_hosted_document());
+    properties->content_mime_type =
+        std::make_unique<std::string>(file_specific_info.content_mime_type());
+    properties->pinned =
+        std::make_unique<bool>(file_specific_info.cache_state().is_pinned());
+    properties->dirty =
+        std::make_unique<bool>(file_specific_info.cache_state().is_dirty());
+    properties->present =
+        std::make_unique<bool>(file_specific_info.cache_state().is_present());
+
+    if (file_specific_info.cache_state().is_present()) {
+      properties->available_offline = std::make_unique<bool>(true);
+    } else if (file_specific_info.is_hosted_document() &&
+               file_specific_info.has_document_extension()) {
+      const std::string file_extension =
+          file_specific_info.document_extension();
+      // What's available offline? See the 'Web' column at:
+      // https://support.google.com/drive/answer/1628467
+      properties->available_offline = std::make_unique<bool>(
+          file_extension == ".gdoc" || file_extension == ".gdraw" ||
+          file_extension == ".gsheet" || file_extension == ".gslides");
+    } else {
+      properties->available_offline = std::make_unique<bool>(false);
+    }
+
+    properties->available_when_metered =
+        std::make_unique<bool>(file_specific_info.cache_state().is_present() ||
+                               file_specific_info.is_hosted_document());
+  }
+
+  if (entry_proto.has_capabilities_info()) {
+    const drive::CapabilitiesInfo& capabilities_info =
+        entry_proto.capabilities_info();
+
+    // Only set the |can_copy| capability for hosted documents; for other files,
+    // we must have read access, so |can_copy| is implicitly true.
+    bool can_copy = true;
+    if (entry_proto.has_file_specific_info() &&
+        entry_proto.file_specific_info().is_hosted_document() &&
+        capabilities_info.has_can_copy()) {
+      can_copy = capabilities_info.can_copy();
+    }
+    properties->can_copy = std::make_unique<bool>(can_copy);
+
+    properties->can_delete = std::make_unique<bool>(
+        capabilities_info.has_can_delete() ? capabilities_info.can_delete()
+                                           : true);
+    properties->can_rename = std::make_unique<bool>(
+        capabilities_info.has_can_rename() ? capabilities_info.can_rename()
+                                           : true);
+
+    // |can_add_children| defaults to true for directories, and false for files.
+    properties->can_add_children =
+        std::make_unique<bool>(capabilities_info.has_can_add_children()
+                                   ? capabilities_info.can_add_children()
+                                   : file_info.is_directory());
+
+    properties->can_share = std::make_unique<bool>(
+        capabilities_info.has_can_share() ? capabilities_info.can_share()
+                                          : true);
+  }
+}
+
+// Creates entry definition list for (metadata) search result info list.
+template <class T>
+void ConvertSearchResultInfoListToEntryDefinitionList(
+    Profile* profile,
+    const std::string& extension_id,
+    const std::vector<T>& search_result_info_list,
+    const EntryDefinitionListCallback& callback) {
+  FileDefinitionList file_definition_list;
+
+  for (size_t i = 0; i < search_result_info_list.size(); ++i) {
+    FileDefinition file_definition;
+    file_definition.virtual_path =
+        file_manager::util::ConvertDrivePathToRelativeFileSystemPath(
+            profile, extension_id, search_result_info_list.at(i).path);
+    file_definition.is_directory = search_result_info_list.at(i).is_directory;
+    file_definition_list.push_back(file_definition);
+  }
+
+  file_manager::util::ConvertFileDefinitionListToEntryDefinitionList(
+      profile,
+      extension_id,
+      file_definition_list,  // Safe, since copied internally.
+      callback);
+}
+
+class SingleEntryPropertiesGetterForDrive {
+ public:
+  typedef base::Callback<void(std::unique_ptr<EntryProperties> properties,
+                              base::File::Error error)>
+      ResultCallback;
+
+  // Creates an instance and starts the process.
+  static void Start(const base::FilePath local_path,
+                    const std::set<EntryPropertyName>& names,
+                    Profile* const profile,
+                    const ResultCallback& callback) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    SingleEntryPropertiesGetterForDrive* instance =
+        new SingleEntryPropertiesGetterForDrive(local_path, names, profile,
+                                                callback);
+    instance->StartProcess();
+
+    // The instance will be destroyed by itself.
+  }
+
+  virtual ~SingleEntryPropertiesGetterForDrive() = default;
+
+ private:
+  SingleEntryPropertiesGetterForDrive(
+      const base::FilePath local_path,
+      const std::set<EntryPropertyName>& /* names */,
+      Profile* const profile,
+      const ResultCallback& callback)
+      : callback_(callback),
+        local_path_(local_path),
+        running_profile_(profile),
+        properties_(new EntryProperties),
+        file_owner_profile_(nullptr),
+        weak_ptr_factory_(this) {
+    DCHECK(!callback_.is_null());
+    DCHECK(profile);
+  }
+
+  void StartProcess() {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    file_path_ = drive::util::ExtractDrivePath(local_path_);
+    file_owner_profile_ = drive::util::ExtractProfileFromPath(local_path_);
+
+    if (!file_owner_profile_ ||
+        !g_browser_process->profile_manager()->IsValidProfile(
+            file_owner_profile_)) {
+      CompleteGetEntryProperties(drive::FILE_ERROR_FAILED);
+      return;
+    }
+
+    // Start getting the file info.
+    drive::FileSystemInterface* const file_system =
+        drive::util::GetFileSystemByProfile(file_owner_profile_);
+    if (!file_system) {
+      // |file_system| is NULL if Drive is disabled or not mounted.
+      CompleteGetEntryProperties(drive::FILE_ERROR_FAILED);
+      return;
+    }
+
+    file_system->GetResourceEntry(
+        file_path_,
+        base::BindOnce(&SingleEntryPropertiesGetterForDrive::OnGetFileInfo,
+                       weak_ptr_factory_.GetWeakPtr()));
+  }
+
+  void OnGetFileInfo(drive::FileError error,
+                     std::unique_ptr<drive::ResourceEntry> entry) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    if (error != drive::FILE_ERROR_OK) {
+      CompleteGetEntryProperties(error);
+      return;
+    }
+
+    DCHECK(entry);
+    owner_resource_entry_.swap(entry);
+
+    if (running_profile_->IsSameProfile(file_owner_profile_)) {
+      StartParseFileInfo(owner_resource_entry_->shared_with_me());
+      return;
+    }
+
+    // If the running profile does not own the file, obtain the shared_with_me
+    // flag from the running profile's value.
+    drive::FileSystemInterface* const file_system =
+        drive::util::GetFileSystemByProfile(running_profile_);
+    if (!file_system) {
+      CompleteGetEntryProperties(drive::FILE_ERROR_FAILED);
+      return;
+    }
+    file_system->GetPathFromResourceId(
+        owner_resource_entry_->resource_id(),
+        base::Bind(&SingleEntryPropertiesGetterForDrive::OnGetRunningPath,
+                   weak_ptr_factory_.GetWeakPtr()));
+  }
+
+  void OnGetRunningPath(drive::FileError error,
+                        const base::FilePath& file_path) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    if (error != drive::FILE_ERROR_OK) {
+      // The running profile does not know the file.
+      StartParseFileInfo(false);
+      return;
+    }
+
+    drive::FileSystemInterface* const file_system =
+        drive::util::GetFileSystemByProfile(running_profile_);
+    if (!file_system) {
+      // The drive is disable for the running profile.
+      StartParseFileInfo(false);
+      return;
+    }
+
+    file_system->GetResourceEntry(
+        file_path,
+        base::BindOnce(&SingleEntryPropertiesGetterForDrive::OnGetShareInfo,
+                       weak_ptr_factory_.GetWeakPtr()));
+  }
+
+  void OnGetShareInfo(drive::FileError error,
+                      std::unique_ptr<drive::ResourceEntry> entry) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    if (error != drive::FILE_ERROR_OK) {
+      CompleteGetEntryProperties(error);
+      return;
+    }
+
+    DCHECK(entry.get());
+    StartParseFileInfo(entry->shared_with_me());
+  }
+
+  void StartParseFileInfo(bool shared_with_me) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    FillEntryPropertiesValueForDrive(
+        *owner_resource_entry_, shared_with_me, properties_.get());
+
+    drive::FileSystemInterface* const file_system =
+        drive::util::GetFileSystemByProfile(file_owner_profile_);
+    drive::DriveAppRegistry* const app_registry =
+        drive::util::GetDriveAppRegistryByProfile(file_owner_profile_);
+    if (!file_system || !app_registry) {
+      // |file_system| or |app_registry| is NULL if Drive is disabled.
+      CompleteGetEntryProperties(drive::FILE_ERROR_FAILED);
+      return;
+    }
+
+    // The properties meaningful for directories are already filled in
+    // FillEntryPropertiesValueForDrive().
+    if (!owner_resource_entry_->has_file_specific_info()) {
+      CompleteGetEntryProperties(drive::FILE_ERROR_OK);
+      return;
+    }
+
+    const drive::FileSpecificInfo& file_specific_info =
+        owner_resource_entry_->file_specific_info();
+
+    // Get drive WebApps that can accept this file. We just need to extract the
+    // doc icon for the drive app, which is set as default.
+    std::vector<drive::DriveAppInfo> drive_apps;
+    app_registry->GetAppsForFile(file_path_.Extension(),
+                                 file_specific_info.content_mime_type(),
+                                 &drive_apps);
+    if (!drive_apps.empty()) {
+      std::string default_task_id =
+          file_manager::file_tasks::GetDefaultTaskIdFromPrefs(
+              *file_owner_profile_->GetPrefs(),
+              file_specific_info.content_mime_type(),
+              file_path_.Extension());
+      file_manager::file_tasks::TaskDescriptor default_task;
+      file_manager::file_tasks::ParseTaskID(default_task_id, &default_task);
+      DCHECK(default_task_id.empty() || !default_task.app_id.empty());
+      for (size_t i = 0; i < drive_apps.size(); ++i) {
+        const drive::DriveAppInfo& app_info = drive_apps[i];
+        if (default_task.app_id == app_info.app_id) {
+          // The drive app is set as default. The Files app should use the doc
+          // icon.
+          const GURL doc_icon = drive::util::FindPreferredIcon(
+              app_info.document_icons, drive::util::kPreferredIconSize);
+          properties_->custom_icon_url =
+              std::make_unique<std::string>(doc_icon.spec());
+        }
+      }
+    }
+
+    CompleteGetEntryProperties(drive::FILE_ERROR_OK);
+  }
+
+  void CompleteGetEntryProperties(drive::FileError error) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+    DCHECK(!callback_.is_null());
+
+    callback_.Run(std::move(properties_),
+                  drive::FileErrorToBaseFileError(error));
+    BrowserThread::DeleteSoon(BrowserThread::UI, FROM_HERE, this);
+  }
+
+  // Given parameters.
+  const ResultCallback callback_;
+  const base::FilePath local_path_;
+  Profile* const running_profile_;
+
+  // Values used in the process.
+  std::unique_ptr<EntryProperties> properties_;
+  Profile* file_owner_profile_;
+  base::FilePath file_path_;
+  std::unique_ptr<drive::ResourceEntry> owner_resource_entry_;
+
+  base::WeakPtrFactory<SingleEntryPropertiesGetterForDrive> weak_ptr_factory_;
+};  // class SingleEntryPropertiesGetterForDrive
+
+class SingleEntryPropertiesGetterForFileSystemProvider {
+ public:
+  typedef base::Callback<void(std::unique_ptr<EntryProperties> properties,
+                              base::File::Error error)>
+      ResultCallback;
+
+  // Creates an instance and starts the process.
+  static void Start(const storage::FileSystemURL file_system_url,
+                    const std::set<EntryPropertyName>& names,
+                    const ResultCallback& callback) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    SingleEntryPropertiesGetterForFileSystemProvider* instance =
+        new SingleEntryPropertiesGetterForFileSystemProvider(file_system_url,
+                                                             names, callback);
+    instance->StartProcess();
+
+    // The instance will be destroyed by itself.
+  }
+
+  virtual ~SingleEntryPropertiesGetterForFileSystemProvider() = default;
+
+ private:
+  SingleEntryPropertiesGetterForFileSystemProvider(
+      const storage::FileSystemURL& file_system_url,
+      const std::set<EntryPropertyName>& names,
+      const ResultCallback& callback)
+      : callback_(callback),
+        file_system_url_(file_system_url),
+        names_(names),
+        properties_(new EntryProperties),
+        weak_ptr_factory_(this) {
+    DCHECK(!callback_.is_null());
+  }
+
+  void StartProcess() {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    FileSystemURLParser parser(file_system_url_);
+    if (!parser.Parse()) {
+      CompleteGetEntryProperties(base::File::FILE_ERROR_NOT_FOUND);
+      return;
+    }
+
+    ProvidedFileSystemInterface::MetadataFieldMask field_mask =
+        ProvidedFileSystemInterface::METADATA_FIELD_NONE;
+    if (names_.find(api::file_manager_private::ENTRY_PROPERTY_NAME_SIZE) !=
+        names_.end()) {
+      field_mask |= ProvidedFileSystemInterface::METADATA_FIELD_SIZE;
+    }
+    if (names_.find(
+            api::file_manager_private::ENTRY_PROPERTY_NAME_MODIFICATIONTIME) !=
+        names_.end()) {
+      field_mask |=
+          ProvidedFileSystemInterface::METADATA_FIELD_MODIFICATION_TIME;
+    }
+    if (names_.find(
+            api::file_manager_private::ENTRY_PROPERTY_NAME_CONTENTMIMETYPE) !=
+        names_.end()) {
+      field_mask |= ProvidedFileSystemInterface::METADATA_FIELD_MIME_TYPE;
+    }
+    if (names_.find(
+            api::file_manager_private::ENTRY_PROPERTY_NAME_THUMBNAILURL) !=
+        names_.end()) {
+      field_mask |= ProvidedFileSystemInterface::METADATA_FIELD_THUMBNAIL;
+    }
+
+    parser.file_system()->GetMetadata(
+        parser.file_path(), field_mask,
+        base::BindOnce(&SingleEntryPropertiesGetterForFileSystemProvider::
+                           OnGetMetadataCompleted,
+                       weak_ptr_factory_.GetWeakPtr()));
+  }
+
+  void OnGetMetadataCompleted(std::unique_ptr<EntryMetadata> metadata,
+                              base::File::Error result) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    if (result != base::File::FILE_OK) {
+      CompleteGetEntryProperties(result);
+      return;
+    }
+
+    if (names_.find(api::file_manager_private::ENTRY_PROPERTY_NAME_SIZE) !=
+        names_.end()) {
+      properties_->size = std::make_unique<double>(*metadata->size.get());
+    }
+
+    if (names_.find(
+            api::file_manager_private::ENTRY_PROPERTY_NAME_MODIFICATIONTIME) !=
+        names_.end()) {
+      properties_->modification_time =
+          std::make_unique<double>(metadata->modification_time->ToJsTime());
+    }
+
+    if (names_.find(
+            api::file_manager_private::ENTRY_PROPERTY_NAME_CONTENTMIMETYPE) !=
+            names_.end() &&
+        metadata->mime_type.get()) {
+      properties_->content_mime_type =
+          std::make_unique<std::string>(*metadata->mime_type);
+    }
+
+    if (names_.find(
+            api::file_manager_private::ENTRY_PROPERTY_NAME_THUMBNAILURL) !=
+            names_.end() &&
+        metadata->thumbnail.get()) {
+      properties_->thumbnail_url =
+          std::make_unique<std::string>(*metadata->thumbnail);
+    }
+
+    CompleteGetEntryProperties(base::File::FILE_OK);
+  }
+
+  void CompleteGetEntryProperties(base::File::Error result) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+    DCHECK(!callback_.is_null());
+
+    callback_.Run(std::move(properties_), result);
+    BrowserThread::DeleteSoon(BrowserThread::UI, FROM_HERE, this);
+  }
+
+  // Given parameters.
+  const ResultCallback callback_;
+  const storage::FileSystemURL file_system_url_;
+  const std::set<EntryPropertyName> names_;
+
+  // Values used in the process.
+  std::unique_ptr<EntryProperties> properties_;
+
+  base::WeakPtrFactory<SingleEntryPropertiesGetterForFileSystemProvider>
+      weak_ptr_factory_;
+};  // class SingleEntryPropertiesGetterForDrive
+
+class SingleEntryPropertiesGetterForDriveFs {
+ public:
+  using ResultCallback =
+      base::OnceCallback<void(std::unique_ptr<EntryProperties> properties,
+                              base::File::Error error)>;
+
+  // Creates an instance and starts the process.
+  static void Start(base::FilePath local_path,
+                    bool want_thumbnail,
+                    Profile* const profile,
+                    ResultCallback callback) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    SingleEntryPropertiesGetterForDriveFs* instance =
+        new SingleEntryPropertiesGetterForDriveFs(std::move(local_path),
+                                                  want_thumbnail, profile,
+                                                  std::move(callback));
+    instance->StartProcess();
+
+    // The instance will be destroyed by itself.
+  }
+
+ private:
+  SingleEntryPropertiesGetterForDriveFs(base::FilePath local_path,
+                                        bool want_thumbnail,
+                                        Profile* const profile,
+                                        ResultCallback callback)
+      : callback_(std::move(callback)),
+        local_path_(std::move(local_path)),
+        want_thumbnail_(want_thumbnail),
+        running_profile_(profile),
+        properties_(std::make_unique<EntryProperties>()),
+        weak_ptr_factory_(this) {
+    DCHECK(callback_);
+    DCHECK(profile);
+  }
+
+  void StartProcess() {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    drive::DriveIntegrationService* integration_service =
+        drive::DriveIntegrationServiceFactory::FindForProfile(running_profile_);
+    if (!integration_service || !integration_service->IsMounted()) {
+      CompleteGetEntryProperties(drive::FILE_ERROR_SERVICE_UNAVAILABLE);
+      return;
+    }
+    base::FilePath path;
+    if (!integration_service->GetRelativeDrivePath(local_path_, &path)) {
+      CompleteGetEntryProperties(drive::FILE_ERROR_INVALID_OPERATION);
+      return;
+    }
+
+    auto* drivefs_interface = integration_service->GetDriveFsInterface();
+    if (!drivefs_interface) {
+      CompleteGetEntryProperties(drive::FILE_ERROR_SERVICE_UNAVAILABLE);
+      return;
+    }
+
+    drivefs_interface->GetMetadata(
+        path, want_thumbnail_,
+        mojo::WrapCallbackWithDefaultInvokeIfNotRun(
+            base::BindOnce(
+                &SingleEntryPropertiesGetterForDriveFs::OnGetFileInfo,
+                weak_ptr_factory_.GetWeakPtr()),
+            drive::FILE_ERROR_SERVICE_UNAVAILABLE, nullptr));
+  }
+
+  void OnGetFileInfo(drive::FileError error,
+                     drivefs::mojom::FileMetadataPtr metadata) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+    if (!metadata) {
+      CompleteGetEntryProperties(error);
+      return;
+    }
+
+    properties_->size = std::make_unique<double>(metadata->size);
+    properties_->available_offline =
+        std::make_unique<bool>(metadata->available_offline);
+    properties_->present = std::make_unique<bool>(metadata->available_offline);
+    properties_->dirty = std::make_unique<bool>(metadata->dirty);
+    properties_->hosted = std::make_unique<bool>(
+        metadata->type == drivefs::mojom::FileMetadata::Type::kHosted);
+    properties_->present = std::make_unique<bool>(metadata->available_offline ||
+                                                  *properties_->hosted);
+    properties_->available_when_metered = std::make_unique<bool>(
+        metadata->available_offline || *properties_->hosted);
+    properties_->pinned = std::make_unique<bool>(metadata->pinned);
+    properties_->shared = std::make_unique<bool>(metadata->shared);
+    properties_->starred = std::make_unique<bool>(metadata->starred);
+
+    if (metadata->modification_time != base::Time()) {
+      properties_->modification_time =
+          std::make_unique<double>(metadata->modification_time.ToJsTime());
+    }
+    if (metadata->modification_by_me_time != base::Time()) {
+      properties_->modification_by_me_time = std::make_unique<double>(
+          metadata->modification_by_me_time.ToJsTime());
+    }
+    if (!metadata->content_mime_type.empty()) {
+      properties_->content_mime_type =
+          std::make_unique<std::string>(metadata->content_mime_type);
+    }
+    if (!metadata->custom_icon_url.empty()) {
+      properties_->custom_icon_url =
+          std::make_unique<std::string>(std::move(metadata->custom_icon_url));
+    }
+    if (!metadata->alternate_url.empty()) {
+      properties_->alternate_url =
+          std::make_unique<std::string>(std::move(metadata->alternate_url));
+      properties_->share_url =
+          GetShareUrlFromAlternateUrl(GURL(*properties_->alternate_url));
+    }
+    if (metadata->image_metadata) {
+      if (metadata->image_metadata->height) {
+        properties_->image_height =
+            std::make_unique<int32_t>(metadata->image_metadata->height);
+      }
+      if (metadata->image_metadata->width) {
+        properties_->image_width =
+            std::make_unique<int32_t>(metadata->image_metadata->width);
+      }
+      if (metadata->image_metadata->rotation) {
+        properties_->image_rotation =
+            std::make_unique<int32_t>(metadata->image_metadata->rotation);
+      }
+    }
+
+    properties_->can_delete =
+        std::make_unique<bool>(metadata->capabilities->can_delete);
+    properties_->can_rename =
+        std::make_unique<bool>(metadata->capabilities->can_rename);
+    properties_->can_add_children =
+        std::make_unique<bool>(metadata->capabilities->can_add_children);
+
+    // Only set the |can_copy| capability for hosted documents; for other files,
+    // we must have read access, so |can_copy| is implicitly true.
+    properties_->can_copy = std::make_unique<bool>(
+        !*properties_->hosted || metadata->capabilities->can_copy);
+    properties_->can_share =
+        std::make_unique<bool>(metadata->capabilities->can_share);
+
+    if (metadata->thumbnail) {
+      base::PostTaskAndReplyWithResult(
+          FROM_HERE,
+          base::BindOnce(&SingleEntryPropertiesGetterForDriveFs::
+                             MakeThumbnailDataUrlOnSequence,
+                         std::move(*metadata->thumbnail)),
+          base::BindOnce(
+              &SingleEntryPropertiesGetterForDriveFs::SetThumbnailAndComplete,
+              weak_ptr_factory_.GetWeakPtr()));
+      return;
+    }
+
+    CompleteGetEntryProperties(drive::FILE_ERROR_OK);
+  }
+
+  static std::string MakeThumbnailDataUrlOnSequence(
+      const std::vector<uint8_t>& png_data) {
+    std::string encoded;
+    base::Base64Encode(
+        base::StringPiece(reinterpret_cast<const char*>(png_data.data()),
+                          png_data.size()),
+        &encoded);
+    return base::StrCat({"data:image/png;base64,", encoded});
+  }
+
+  void SetThumbnailAndComplete(std::string thumbnail_data_url) {
+    properties_->thumbnail_url =
+        std::make_unique<std::string>(std::move(thumbnail_data_url));
+
+    CompleteGetEntryProperties(drive::FILE_ERROR_OK);
+  }
+
+  void CompleteGetEntryProperties(drive::FileError error) {
+    DCHECK_CURRENTLY_ON(BrowserThread::UI);
+    DCHECK(callback_);
+
+    std::move(callback_).Run(std::move(properties_),
+                             drive::FileErrorToBaseFileError(error));
+    BrowserThread::DeleteSoon(BrowserThread::UI, FROM_HERE, this);
+  }
+
+  // Given parameters.
+  ResultCallback callback_;
+  const base::FilePath local_path_;
+  const bool want_thumbnail_;
+  Profile* const running_profile_;
+
+  // Values used in the process.
+  std::unique_ptr<EntryProperties> properties_;
+
+  base::WeakPtrFactory<SingleEntryPropertiesGetterForDriveFs> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(SingleEntryPropertiesGetterForDriveFs);
+};
+
+}  // namespace
+
+FileManagerPrivateInternalGetEntryPropertiesFunction::
+    FileManagerPrivateInternalGetEntryPropertiesFunction()
+    : processed_count_(0) {
+}
+
+FileManagerPrivateInternalGetEntryPropertiesFunction::
+    ~FileManagerPrivateInternalGetEntryPropertiesFunction() = default;
+
+bool FileManagerPrivateInternalGetEntryPropertiesFunction::RunAsync() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  using api::file_manager_private_internal::GetEntryProperties::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  properties_list_.resize(params->urls.size());
+  const std::set<EntryPropertyName> names_as_set(params->names.begin(),
+                                                 params->names.end());
+  for (size_t i = 0; i < params->urls.size(); i++) {
+    const GURL url = GURL(params->urls[i]);
+    const storage::FileSystemURL file_system_url =
+        file_system_context->CrackURL(url);
+    switch (file_system_url.type()) {
+      case storage::kFileSystemTypeDrive:
+        SingleEntryPropertiesGetterForDrive::Start(
+            file_system_url.path(), names_as_set, GetProfile(),
+            base::Bind(&FileManagerPrivateInternalGetEntryPropertiesFunction::
+                           CompleteGetEntryProperties,
+                       this, i, file_system_url));
+        break;
+      case storage::kFileSystemTypeProvided:
+        SingleEntryPropertiesGetterForFileSystemProvider::Start(
+            file_system_url, names_as_set,
+            base::Bind(&FileManagerPrivateInternalGetEntryPropertiesFunction::
+                           CompleteGetEntryProperties,
+                       this, i, file_system_url));
+        break;
+      case storage::kFileSystemTypeDriveFs:
+        SingleEntryPropertiesGetterForDriveFs::Start(
+            file_system_url.path(),
+            names_as_set.count(
+                api::file_manager_private::ENTRY_PROPERTY_NAME_THUMBNAILURL),
+            GetProfile(),
+            base::BindOnce(
+                &FileManagerPrivateInternalGetEntryPropertiesFunction::
+                    CompleteGetEntryProperties,
+                this, i, file_system_url));
+        break;
+      default:
+        // TODO(yawano) Change this to support other voluems (e.g. local) ,and
+        // integrate fileManagerPrivate.getMimeType to this method.
+        LOG(ERROR) << "Not supported file system type.";
+        CompleteGetEntryProperties(i, file_system_url,
+                                   base::WrapUnique(new EntryProperties),
+                                   base::File::FILE_ERROR_INVALID_OPERATION);
+    }
+  }
+
+  return true;
+}
+
+void FileManagerPrivateInternalGetEntryPropertiesFunction::
+    CompleteGetEntryProperties(size_t index,
+                               const storage::FileSystemURL& url,
+                               std::unique_ptr<EntryProperties> properties,
+                               base::File::Error error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(0 <= processed_count_ && processed_count_ < properties_list_.size());
+
+  if (error == base::File::FILE_OK) {
+    properties->external_file_url = std::make_unique<std::string>(
+        chromeos::FileSystemURLToExternalFileURL(url).spec());
+  }
+  properties_list_[index] = std::move(*properties);
+
+  processed_count_++;
+  if (processed_count_ < properties_list_.size())
+    return;
+
+  results_ = extensions::api::file_manager_private_internal::
+      GetEntryProperties::Results::Create(properties_list_);
+  SendResponse(true);
+}
+
+bool FileManagerPrivateInternalPinDriveFileFunction::RunAsync() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  using extensions::api::file_manager_private_internal::PinDriveFile::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+  const GURL url = GURL(params->url);
+  const storage::FileSystemURL file_system_url =
+      file_system_context->CrackURL(url);
+
+  switch (file_system_url.type()) {
+    case storage::kFileSystemTypeDrive:
+      return RunAsyncForDrive(url, params->pin);
+
+    case storage::kFileSystemTypeDriveFs:
+      return RunAsyncForDriveFs(file_system_url, params->pin);
+
+    default:
+      return false;
+  }
+}
+
+bool FileManagerPrivateInternalPinDriveFileFunction::RunAsyncForDrive(
+    const GURL& url,
+    bool pin) {
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system)  // |file_system| is NULL if Drive is disabled.
+    return false;
+
+  const base::FilePath drive_path =
+      drive::util::ExtractDrivePath(file_manager::util::GetLocalPathFromURL(
+          render_frame_host(), GetProfile(), url));
+  if (pin) {
+    file_system->Pin(
+        drive_path,
+        base::Bind(
+            &FileManagerPrivateInternalPinDriveFileFunction::OnPinStateSet,
+            this));
+  } else {
+    file_system->Unpin(
+        drive_path,
+        base::Bind(
+            &FileManagerPrivateInternalPinDriveFileFunction::OnPinStateSet,
+            this));
+  }
+  return true;
+}
+
+bool FileManagerPrivateInternalPinDriveFileFunction::RunAsyncForDriveFs(
+    const storage::FileSystemURL& file_system_url,
+    bool pin) {
+  drive::DriveIntegrationService* integration_service =
+      drive::DriveIntegrationServiceFactory::FindForProfile(GetProfile());
+  base::FilePath path;
+  if (!integration_service || !integration_service->GetRelativeDrivePath(
+                                  file_system_url.path(), &path)) {
+    return false;
+  }
+
+  auto* drivefs_interface = integration_service->GetDriveFsInterface();
+  if (!drivefs_interface)
+    return false;
+
+  drivefs_interface->SetPinned(
+      path, pin,
+      mojo::WrapCallbackWithDefaultInvokeIfNotRun(
+          base::BindOnce(
+              &FileManagerPrivateInternalPinDriveFileFunction::OnPinStateSet,
+              this),
+          drive::FILE_ERROR_SERVICE_UNAVAILABLE));
+  return true;
+}
+void FileManagerPrivateInternalPinDriveFileFunction::OnPinStateSet(
+    drive::FileError error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (error == drive::FILE_ERROR_OK) {
+    SendResponse(true);
+  } else {
+    SetError(drive::FileErrorToString(error));
+    SendResponse(false);
+  }
+}
+
+bool FileManagerPrivateInternalEnsureFileDownloadedFunction::RunAsync() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  using extensions::api::file_manager_private_internal::EnsureFileDownloaded::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const base::FilePath drive_path =
+      drive::util::ExtractDrivePath(file_manager::util::GetLocalPathFromURL(
+          render_frame_host(), GetProfile(), GURL(params->url)));
+  if (drive_path.empty()) {
+    // Not under Drive. No need to fill the cache.
+    SendResponse(true);
+    return true;
+  }
+
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system)  // |file_system| is NULL if Drive is disabled.
+    return false;
+
+  file_system->GetFile(
+      drive_path,
+      base::BindOnce(&FileManagerPrivateInternalEnsureFileDownloadedFunction::
+                         OnDownloadFinished,
+                     this));
+  return true;
+}
+
+void FileManagerPrivateInternalEnsureFileDownloadedFunction::OnDownloadFinished(
+    drive::FileError error,
+    const base::FilePath& file_path,
+    std::unique_ptr<drive::ResourceEntry> entry) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (error == drive::FILE_ERROR_OK) {
+    SendResponse(true);
+  } else {
+    SetError(drive::FileErrorToString(error));
+    SendResponse(false);
+  }
+}
+
+bool FileManagerPrivateInternalCancelFileTransfersFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::CancelFileTransfers::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  drive::DriveIntegrationService* integration_service =
+      drive::DriveIntegrationServiceFactory::FindForProfile(GetProfile());
+  if (!integration_service || !integration_service->IsMounted())
+    return false;
+
+  drive::JobListInterface* const job_list = integration_service->job_list();
+  DCHECK(job_list);
+  const std::vector<drive::JobInfo> jobs = job_list->GetJobInfoList();
+
+  // Create the mapping from file path to job ID.
+  typedef std::map<base::FilePath, std::vector<drive::JobID>> PathToIdMap;
+  PathToIdMap path_to_id_map;
+  for (size_t i = 0; i < jobs.size(); ++i) {
+    if (drive::IsActiveFileTransferJobInfo(jobs[i]))
+      path_to_id_map[jobs[i].file_path].push_back(jobs[i].job_id);
+  }
+
+  for (size_t i = 0; i < params->urls.size(); ++i) {
+    base::FilePath file_path = file_manager::util::GetLocalPathFromURL(
+        render_frame_host(), GetProfile(), GURL(params->urls[i]));
+    if (file_path.empty())
+      continue;
+
+    file_path = drive::util::ExtractDrivePath(file_path);
+    DCHECK(file_path.empty());
+
+    // Cancel all the jobs for the file.
+    PathToIdMap::iterator it = path_to_id_map.find(file_path);
+    if (it != path_to_id_map.end()) {
+      for (size_t i = 0; i < it->second.size(); ++i)
+        job_list->CancelJob(it->second[i]);
+    }
+  }
+
+  SendResponse(true);
+  return true;
+}
+
+bool FileManagerPrivateSearchDriveFunction::RunAsync() {
+  using extensions::api::file_manager_private::SearchDrive::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system) {
+    // |file_system| is NULL if Drive is disabled.
+    return false;
+  }
+
+  file_system->Search(
+      params->search_params.query, GURL(params->search_params.next_feed),
+      base::Bind(&FileManagerPrivateSearchDriveFunction::OnSearch, this));
+  return true;
+}
+
+void FileManagerPrivateSearchDriveFunction::OnSearch(
+    drive::FileError error,
+    const GURL& next_link,
+    std::unique_ptr<SearchResultInfoList> results) {
+  if (error != drive::FILE_ERROR_OK) {
+    SendResponse(false);
+    return;
+  }
+
+  // Outlives the following conversion, since the pointer is bound to the
+  // callback.
+  DCHECK(results.get());
+  const SearchResultInfoList& results_ref = *results.get();
+
+  ConvertSearchResultInfoListToEntryDefinitionList(
+      GetProfile(),
+      extension_->id(),
+      results_ref,
+      base::Bind(&FileManagerPrivateSearchDriveFunction::OnEntryDefinitionList,
+                 this,
+                 next_link,
+                 base::Passed(&results)));
+}
+
+void FileManagerPrivateSearchDriveFunction::OnEntryDefinitionList(
+    const GURL& next_link,
+    std::unique_ptr<SearchResultInfoList> search_result_info_list,
+    std::unique_ptr<EntryDefinitionList> entry_definition_list) {
+  DCHECK_EQ(search_result_info_list->size(), entry_definition_list->size());
+  auto entries = std::make_unique<base::ListValue>();
+
+  // Convert Drive files to something File API stack can understand.
+  for (EntryDefinitionList::const_iterator it = entry_definition_list->begin();
+       it != entry_definition_list->end();
+       ++it) {
+    auto entry = std::make_unique<base::DictionaryValue>();
+    entry->SetString("fileSystemName", it->file_system_name);
+    entry->SetString("fileSystemRoot", it->file_system_root_url);
+    entry->SetString("fileFullPath", "/" + it->full_path.AsUTF8Unsafe());
+    entry->SetBoolean("fileIsDirectory", it->is_directory);
+    entries->Append(std::move(entry));
+  }
+
+  std::unique_ptr<base::DictionaryValue> result(new base::DictionaryValue());
+  result->Set("entries", std::move(entries));
+  result->SetString("nextFeed", next_link.spec());
+
+  SetResult(std::move(result));
+  SendResponse(true);
+}
+
+bool FileManagerPrivateSearchDriveMetadataFunction::RunAsync() {
+  using api::file_manager_private::SearchDriveMetadata::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  drive::EventLogger* logger = file_manager::util::GetLogger(GetProfile());
+  if (logger) {
+    logger->Log(
+        logging::LOG_INFO, "%s[%d] called. (types: '%s', maxResults: '%d')",
+        name(), request_id(),
+        api::file_manager_private::ToString(params->search_params.types),
+        params->search_params.max_results);
+  }
+  set_log_on_completion(true);
+
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system) {
+    // |file_system| is NULL if Drive is disabled.
+    return false;
+  }
+
+  int options = -1;
+  switch (params->search_params.types) {
+    case api::file_manager_private::SEARCH_TYPE_EXCLUDE_DIRECTORIES:
+      options = drive::SEARCH_METADATA_EXCLUDE_DIRECTORIES;
+      break;
+    case api::file_manager_private::SEARCH_TYPE_SHARED_WITH_ME:
+      options = drive::SEARCH_METADATA_SHARED_WITH_ME;
+      break;
+    case api::file_manager_private::SEARCH_TYPE_OFFLINE:
+      options = drive::SEARCH_METADATA_OFFLINE;
+      break;
+    case api::file_manager_private::SEARCH_TYPE_ALL:
+      options = drive::SEARCH_METADATA_ALL;
+      break;
+    case api::file_manager_private::SEARCH_TYPE_NONE:
+      break;
+  }
+  DCHECK_NE(options, -1);
+
+  file_system->SearchMetadata(
+      params->search_params.query, options, params->search_params.max_results,
+      drive::MetadataSearchOrder::LAST_ACCESSED,
+      base::Bind(
+          &FileManagerPrivateSearchDriveMetadataFunction::OnSearchMetadata,
+          this));
+  return true;
+}
+
+void FileManagerPrivateSearchDriveMetadataFunction::OnSearchMetadata(
+    drive::FileError error,
+    std::unique_ptr<drive::MetadataSearchResultVector> results) {
+  if (error != drive::FILE_ERROR_OK) {
+    SendResponse(false);
+    return;
+  }
+
+  // Outlives the following conversion, since the pointer is bound to the
+  // callback.
+  DCHECK(results.get());
+  const drive::MetadataSearchResultVector& results_ref = *results.get();
+
+  ConvertSearchResultInfoListToEntryDefinitionList(
+      GetProfile(),
+      extension_->id(),
+      results_ref,
+      base::Bind(
+          &FileManagerPrivateSearchDriveMetadataFunction::OnEntryDefinitionList,
+          this,
+          base::Passed(&results)));
+}
+
+void FileManagerPrivateSearchDriveMetadataFunction::OnEntryDefinitionList(
+    std::unique_ptr<drive::MetadataSearchResultVector> search_result_info_list,
+    std::unique_ptr<EntryDefinitionList> entry_definition_list) {
+  DCHECK_EQ(search_result_info_list->size(), entry_definition_list->size());
+  std::unique_ptr<base::ListValue> results_list(new base::ListValue());
+
+  // Convert Drive files to something File API stack can understand.  See
+  // file_browser_handler_custom_bindings.cc and
+  // file_manager_private_custom_bindings.js for how this is magically
+  // converted to a FileEntry.
+  for (size_t i = 0; i < entry_definition_list->size(); ++i) {
+    auto result_dict = std::make_unique<base::DictionaryValue>();
+
+    // FileEntry fields.
+    auto entry = std::make_unique<base::DictionaryValue>();
+    entry->SetString(
+        "fileSystemName", entry_definition_list->at(i).file_system_name);
+    entry->SetString(
+        "fileSystemRoot", entry_definition_list->at(i).file_system_root_url);
+    entry->SetString(
+        "fileFullPath",
+        "/" + entry_definition_list->at(i).full_path.AsUTF8Unsafe());
+    entry->SetBoolean("fileIsDirectory",
+                      entry_definition_list->at(i).is_directory);
+
+    result_dict->Set("entry", std::move(entry));
+    result_dict->SetString(
+        "highlightedBaseName",
+        search_result_info_list->at(i).highlighted_base_name);
+    results_list->Append(std::move(result_dict));
+  }
+
+  SetResult(std::move(results_list));
+  SendResponse(true);
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateGetDriveConnectionStateFunction::Run() {
+  api::file_manager_private::DriveConnectionState result;
+
+  switch (drive::util::GetDriveConnectionStatus(
+      Profile::FromBrowserContext(browser_context()))) {
+    case drive::util::DRIVE_DISCONNECTED_NOSERVICE:
+      result.type = kDriveConnectionTypeOffline;
+      result.reason =
+          std::make_unique<std::string>(kDriveConnectionReasonNoService);
+      break;
+    case drive::util::DRIVE_DISCONNECTED_NONETWORK:
+      result.type = kDriveConnectionTypeOffline;
+      result.reason =
+          std::make_unique<std::string>(kDriveConnectionReasonNoNetwork);
+      break;
+    case drive::util::DRIVE_DISCONNECTED_NOTREADY:
+      result.type = kDriveConnectionTypeOffline;
+      result.reason =
+          std::make_unique<std::string>(kDriveConnectionReasonNotReady);
+      break;
+    case drive::util::DRIVE_CONNECTED_METERED:
+      result.type = kDriveConnectionTypeMetered;
+      break;
+    case drive::util::DRIVE_CONNECTED:
+      result.type = kDriveConnectionTypeOnline;
+      break;
+  }
+
+  result.has_cellular_network_access =
+      chromeos::NetworkHandler::Get()
+          ->network_state_handler()
+          ->FirstNetworkByType(chromeos::NetworkTypePattern::Mobile());
+
+  drive::EventLogger* logger = file_manager::util::GetLogger(
+      Profile::FromBrowserContext(browser_context()));
+  if (logger)
+    logger->Log(logging::LOG_INFO, "%s succeeded.", name());
+  return RespondNow(ArgumentList(
+      api::file_manager_private::GetDriveConnectionState::Results::Create(
+          result)));
+}
+
+bool FileManagerPrivateRequestAccessTokenFunction::RunAsync() {
+  using extensions::api::file_manager_private::RequestAccessToken::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  drive::DriveServiceInterface* const drive_service =
+      drive::util::GetDriveServiceByProfile(GetProfile());
+
+  if (!drive_service) {
+    // DriveService is not available.
+    SetResult(std::make_unique<base::Value>(std::string()));
+    SendResponse(true);
+    return true;
+  }
+
+  // If refreshing is requested, then clear the token to refetch it.
+  if (params->refresh)
+    drive_service->ClearAccessToken();
+
+  // Retrieve the cached auth token (if available), otherwise the AuthService
+  // instance will try to refetch it.
+  drive_service->RequestAccessToken(
+      base::Bind(&FileManagerPrivateRequestAccessTokenFunction::
+                      OnAccessTokenFetched, this));
+  return true;
+}
+
+void FileManagerPrivateRequestAccessTokenFunction::OnAccessTokenFetched(
+    google_apis::DriveApiErrorCode code,
+    const std::string& access_token) {
+  SetResult(std::make_unique<base::Value>(access_token));
+  SendResponse(true);
+}
+
+bool FileManagerPrivateInternalGetShareUrlFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::GetShareUrl::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const base::FilePath path = file_manager::util::GetLocalPathFromURL(
+      render_frame_host(), GetProfile(), GURL(params->url));
+  DCHECK(drive::util::IsUnderDriveMountPoint(path));
+
+  const base::FilePath drive_path = drive::util::ExtractDrivePath(path);
+
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system) {
+    // |file_system| is NULL if Drive is disabled.
+    return false;
+  }
+
+  file_system->GetShareUrl(
+      drive_path,
+      GURL("chrome-extension://" + extension_id()),  // embed origin
+      base::Bind(&FileManagerPrivateInternalGetShareUrlFunction::OnGetShareUrl,
+                 this));
+  return true;
+}
+
+void FileManagerPrivateInternalGetShareUrlFunction::OnGetShareUrl(
+    drive::FileError error,
+    const GURL& share_url) {
+  if (error != drive::FILE_ERROR_OK) {
+    SetError("Share Url for this item is not available.");
+    SendResponse(false);
+    return;
+  }
+
+  SetResult(std::make_unique<base::Value>(share_url.spec()));
+  SendResponse(true);
+}
+
+bool FileManagerPrivateInternalRequestDriveShareFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::RequestDriveShare::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const base::FilePath path = file_manager::util::GetLocalPathFromURL(
+      render_frame_host(), GetProfile(), GURL(params->url));
+  const base::FilePath drive_path = drive::util::ExtractDrivePath(path);
+  Profile* const owner_profile = drive::util::ExtractProfileFromPath(path);
+
+  if (!owner_profile)
+    return false;
+
+  drive::FileSystemInterface* const owner_file_system =
+      drive::util::GetFileSystemByProfile(owner_profile);
+  if (!owner_file_system)
+    return false;
+
+  const user_manager::User* const user =
+      chromeos::ProfileHelper::Get()->GetUserByProfile(GetProfile());
+  if (!user || !user->is_logged_in())
+    return false;
+
+  google_apis::drive::PermissionRole role =
+      google_apis::drive::PERMISSION_ROLE_READER;
+  switch (params->share_type) {
+    case api::file_manager_private::DRIVE_SHARE_TYPE_NONE:
+      NOTREACHED();
+      return false;
+    case api::file_manager_private::DRIVE_SHARE_TYPE_CAN_EDIT:
+      role = google_apis::drive::PERMISSION_ROLE_WRITER;
+      break;
+    case api::file_manager_private::DRIVE_SHARE_TYPE_CAN_COMMENT:
+      role = google_apis::drive::PERMISSION_ROLE_COMMENTER;
+      break;
+    case api::file_manager_private::DRIVE_SHARE_TYPE_CAN_VIEW:
+      role = google_apis::drive::PERMISSION_ROLE_READER;
+      break;
+  }
+
+  // Share |drive_path| in |owner_file_system| to
+  // |user->GetAccountId().GetUserEmail()|.
+  owner_file_system->AddPermission(
+      drive_path, user->GetAccountId().GetUserEmail(), role,
+      base::Bind(
+          &FileManagerPrivateInternalRequestDriveShareFunction::OnAddPermission,
+          this));
+  return true;
+}
+
+void FileManagerPrivateInternalRequestDriveShareFunction::OnAddPermission(
+    drive::FileError error) {
+  SendResponse(error == drive::FILE_ERROR_OK);
+}
+
+FileManagerPrivateInternalGetDownloadUrlFunction::
+    FileManagerPrivateInternalGetDownloadUrlFunction() = default;
+
+FileManagerPrivateInternalGetDownloadUrlFunction::
+    ~FileManagerPrivateInternalGetDownloadUrlFunction() = default;
+
+bool FileManagerPrivateInternalGetDownloadUrlFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::GetShareUrl::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+  const GURL url = GURL(params->url);
+  const storage::FileSystemURL file_system_url =
+      file_system_context->CrackURL(url);
+
+  switch (file_system_url.type()) {
+    case storage::kFileSystemTypeDrive:
+      return RunAsyncForDrive(url);
+    case storage::kFileSystemTypeDriveFs:
+      return RunAsyncForDriveFs(file_system_url);
+    default:
+      return false;
+  }
+}
+
+bool FileManagerPrivateInternalGetDownloadUrlFunction::RunAsyncForDrive(
+    const GURL& url) {
+  // Start getting the file info.
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system) {
+    // |file_system| is NULL if Drive is disabled or not mounted.
+    SetError("Drive is disabled or not mounted.");
+    // Intentionally returns a blank.
+    SetResult(std::make_unique<base::Value>(std::string()));
+    return false;
+  }
+
+  const base::FilePath path = file_manager::util::GetLocalPathFromURL(
+      render_frame_host(), GetProfile(), url);
+  if (!drive::util::IsUnderDriveMountPoint(path)) {
+    SetError("The given file is not in Drive.");
+    // Intentionally returns a blank.
+    SetResult(std::make_unique<base::Value>(std::string()));
+    return false;
+  }
+  base::FilePath file_path = drive::util::ExtractDrivePath(path);
+
+  file_system->GetResourceEntry(
+      file_path,
+      base::BindOnce(
+          &FileManagerPrivateInternalGetDownloadUrlFunction::OnGetResourceEntry,
+          this));
+  return true;
+}
+
+void FileManagerPrivateInternalGetDownloadUrlFunction::OnGetResourceEntry(
+    drive::FileError error,
+    std::unique_ptr<drive::ResourceEntry> entry) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (error != drive::FILE_ERROR_OK) {
+    OnGotDownloadUrl(GURL());
+    return;
+  }
+
+  DriveApiUrlGenerator url_generator(
+      (GURL(google_apis::DriveApiUrlGenerator::kBaseUrlForProduction)),
+      (GURL(google_apis::DriveApiUrlGenerator::kBaseThumbnailUrlForProduction)),
+      google_apis::GetTeamDrivesIntegrationSwitch());
+  OnGotDownloadUrl(url_generator.GenerateDownloadFileUrl(entry->resource_id()));
+}
+
+void FileManagerPrivateInternalGetDownloadUrlFunction::OnGotDownloadUrl(
+    GURL download_url) {
+  if (download_url.is_empty()) {
+    SetError("Download Url for this item is not available.");
+    // Intentionally returns a blank.
+    SetResult(std::make_unique<base::Value>(std::string()));
+    SendResponse(false);
+    return;
+  }
+  download_url_ = std::move(download_url);
+  ProfileOAuth2TokenService* oauth2_token_service =
+      ProfileOAuth2TokenServiceFactory::GetForProfile(GetProfile());
+  SigninManagerBase* signin_manager =
+      SigninManagerFactory::GetForProfile(GetProfile());
+  const std::string& account_id = signin_manager->GetAuthenticatedAccountId();
+  std::vector<std::string> scopes;
+  scopes.emplace_back("https://www.googleapis.com/auth/drive.readonly");
+
+  scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory =
+      content::BrowserContext::GetDefaultStoragePartition(GetProfile())
+          ->GetURLLoaderFactoryForBrowserProcess();
+  auth_service_ = std::make_unique<google_apis::AuthService>(
+      oauth2_token_service, account_id, url_loader_factory, scopes);
+  auth_service_->StartAuthentication(base::Bind(
+      &FileManagerPrivateInternalGetDownloadUrlFunction::OnTokenFetched, this));
+}
+
+void FileManagerPrivateInternalGetDownloadUrlFunction::OnTokenFetched(
+    google_apis::DriveApiErrorCode code,
+    const std::string& access_token) {
+  if (code != google_apis::HTTP_SUCCESS) {
+    SetError("Not able to fetch the token.");
+    // Intentionally returns a blank.
+    SetResult(std::make_unique<base::Value>(std::string()));
+    SendResponse(false);
+    return;
+  }
+
+  SetResult(std::make_unique<base::Value>(
+      download_url_.Resolve("?alt=media&access_token=" + access_token).spec()));
+
+  SendResponse(true);
+}
+
+bool FileManagerPrivateInternalGetDownloadUrlFunction::RunAsyncForDriveFs(
+    const storage::FileSystemURL& file_system_url) {
+  drive::DriveIntegrationService* integration_service =
+      drive::DriveIntegrationServiceFactory::FindForProfile(GetProfile());
+  base::FilePath path;
+  if (!integration_service || !integration_service->GetRelativeDrivePath(
+                                  file_system_url.path(), &path)) {
+    return false;
+  }
+
+  auto* drivefs_interface = integration_service->GetDriveFsInterface();
+  if (!drivefs_interface)
+    return false;
+
+  drivefs_interface->GetMetadata(
+      path, false,
+      mojo::WrapCallbackWithDefaultInvokeIfNotRun(
+          base::BindOnce(
+              &FileManagerPrivateInternalGetDownloadUrlFunction::OnGotMetadata,
+              this),
+          drive::FILE_ERROR_SERVICE_UNAVAILABLE, nullptr));
+  return true;
+}
+
+void FileManagerPrivateInternalGetDownloadUrlFunction::OnGotMetadata(
+    drive::FileError error,
+    drivefs::mojom::FileMetadataPtr metadata) {
+  OnGotDownloadUrl(metadata ? GURL(metadata->download_url) : GURL());
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_manager/chromeos/private_api_drive.h b/chrome/browser/extensions/api/file_manager/chromeos/private_api_drive.h
new file mode 100644
index 0000000000000..4fad99a816dee
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/chromeos/private_api_drive.h
@@ -0,0 +1,286 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides Drive specific API functions.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_CHROMEOS_PRIVATE_API_DRIVE_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_CHROMEOS_PRIVATE_API_DRIVE_H_
+
+#include <stddef.h>
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/files/file.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_base.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chromeos/components/drivefs/mojom/drivefs.mojom.h"
+#include "components/drive/chromeos/file_system_interface.h"
+#include "components/drive/file_errors.h"
+
+namespace drive {
+class ResourceEntry;
+struct SearchResultInfo;
+}
+
+namespace google_apis {
+class AuthService;
+}
+
+namespace extensions {
+
+namespace api {
+namespace file_manager_private {
+struct EntryProperties;
+}  // namespace file_manager_private
+}  // namespace api
+
+// Implements the chrome.fileManagerPrivate.ensureFileDownloaded method.
+class FileManagerPrivateInternalEnsureFileDownloadedFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.ensureFileDownloaded",
+                             FILEMANAGERPRIVATE_ENSUREFILEDOWNLOADED)
+
+ protected:
+  ~FileManagerPrivateInternalEnsureFileDownloadedFunction() override = default;
+
+  // AsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  // Callback for RunAsync().
+  void OnDownloadFinished(drive::FileError error,
+                          const base::FilePath& file_path,
+                          std::unique_ptr<drive::ResourceEntry> entry);
+};
+
+// Retrieves property information for an entry and returns it as a dictionary.
+// On error, returns a dictionary with the key "error" set to the error number
+// (base::File::Error).
+class FileManagerPrivateInternalGetEntryPropertiesFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getEntryProperties",
+                             FILEMANAGERPRIVATEINTERNAL_GETENTRYPROPERTIES)
+
+  FileManagerPrivateInternalGetEntryPropertiesFunction();
+
+ protected:
+  ~FileManagerPrivateInternalGetEntryPropertiesFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  void CompleteGetEntryProperties(
+      size_t index,
+      const storage::FileSystemURL& url,
+      std::unique_ptr<api::file_manager_private::EntryProperties> properties,
+      base::File::Error error);
+
+  size_t processed_count_;
+  std::vector<api::file_manager_private::EntryProperties> properties_list_;
+};
+
+// Implements the chrome.fileManagerPrivate.pinDriveFile method.
+class FileManagerPrivateInternalPinDriveFileFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.pinDriveFile",
+                             FILEMANAGERPRIVATEINTERNAL_PINDRIVEFILE)
+
+ protected:
+  ~FileManagerPrivateInternalPinDriveFileFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  bool RunAsyncForDrive(const GURL& url, bool pin);
+  bool RunAsyncForDriveFs(const storage::FileSystemURL& file_system_url,
+                          bool pin);
+
+  // Callback for RunAsyncForDrive() and RunAsyncForDriveFs.
+  void OnPinStateSet(drive::FileError error);
+};
+
+// Implements the chrome.fileManagerPrivate.cancelFileTransfers method.
+class FileManagerPrivateInternalCancelFileTransfersFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.cancelFileTransfers",
+                             FILEMANAGERPRIVATEINTERNAL_CANCELFILETRANSFERS)
+
+ protected:
+  ~FileManagerPrivateInternalCancelFileTransfersFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+class FileManagerPrivateSearchDriveFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  typedef std::vector<drive::SearchResultInfo> SearchResultInfoList;
+
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.searchDrive",
+                             FILEMANAGERPRIVATE_SEARCHDRIVE)
+
+ protected:
+  ~FileManagerPrivateSearchDriveFunction() override = default;
+
+  bool RunAsync() override;
+
+ private:
+  // Callback for Search().
+  void OnSearch(
+      drive::FileError error,
+      const GURL& next_link,
+      std::unique_ptr<std::vector<drive::SearchResultInfo>> result_paths);
+
+  // Called when |result_paths| in OnSearch() are converted to a list of
+  // entry definitions.
+  void OnEntryDefinitionList(
+      const GURL& next_link,
+      std::unique_ptr<SearchResultInfoList> search_result_info_list,
+      std::unique_ptr<file_manager::util::EntryDefinitionList>
+          entry_definition_list);
+};
+
+// Similar to FileManagerPrivateSearchDriveFunction but this one is used for
+// searching drive metadata which is stored locally.
+class FileManagerPrivateSearchDriveMetadataFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.searchDriveMetadata",
+                             FILEMANAGERPRIVATE_SEARCHDRIVEMETADATA)
+
+ protected:
+  ~FileManagerPrivateSearchDriveMetadataFunction() override = default;
+
+  bool RunAsync() override;
+
+ private:
+  // Callback for SearchMetadata();
+  void OnSearchMetadata(
+      drive::FileError error,
+      std::unique_ptr<drive::MetadataSearchResultVector> results);
+
+  // Called when |results| in OnSearchMetadata() are converted to a list of
+  // entry definitions.
+  void OnEntryDefinitionList(
+      std::unique_ptr<drive::MetadataSearchResultVector>
+          search_result_info_list,
+      std::unique_ptr<file_manager::util::EntryDefinitionList>
+          entry_definition_list);
+};
+
+// Implements the chrome.fileManagerPrivate.getDriveConnectionState method.
+class FileManagerPrivateGetDriveConnectionStateFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileManagerPrivate.getDriveConnectionState",
+      FILEMANAGERPRIVATE_GETDRIVECONNECTIONSTATE);
+
+ protected:
+  ~FileManagerPrivateGetDriveConnectionStateFunction() override = default;
+
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.requestAccessToken method.
+class FileManagerPrivateRequestAccessTokenFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.requestAccessToken",
+                             FILEMANAGERPRIVATE_REQUESTACCESSTOKEN)
+
+ protected:
+  ~FileManagerPrivateRequestAccessTokenFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+  // Callback with a cached auth token (if available) or a fetched one.
+  void OnAccessTokenFetched(google_apis::DriveApiErrorCode code,
+                            const std::string& access_token);
+};
+
+// Implements the chrome.fileManagerPrivate.getShareUrl method.
+class FileManagerPrivateInternalGetShareUrlFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getShareUrl",
+                             FILEMANAGERPRIVATEINTERNAL_GETSHAREURL)
+
+ protected:
+  ~FileManagerPrivateInternalGetShareUrlFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+  // Callback with an url to the sharing dialog as |share_url|, called by
+  // FileSystem::GetShareUrl.
+  void OnGetShareUrl(drive::FileError error, const GURL& share_url);
+};
+
+// Implements the chrome.fileManagerPrivate.requestDriveShare method.
+class FileManagerPrivateInternalRequestDriveShareFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.requestDriveShare",
+                             FILEMANAGERPRIVATEINTERNAL_REQUESTDRIVESHARE);
+
+ protected:
+  ~FileManagerPrivateInternalRequestDriveShareFunction() override = default;
+  bool RunAsync() override;
+
+ private:
+  // Called back after the drive file system operation is finished.
+  void OnAddPermission(drive::FileError error);
+};
+
+// Implements the chrome.fileManagerPrivate.getDownloadUrl method.
+class FileManagerPrivateInternalGetDownloadUrlFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  FileManagerPrivateInternalGetDownloadUrlFunction();
+
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getDownloadUrl",
+                             FILEMANAGERPRIVATEINTERNAL_GETDOWNLOADURL)
+
+ protected:
+  ~FileManagerPrivateInternalGetDownloadUrlFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  bool RunAsyncForDrive(const GURL& url);
+
+  void OnGetResourceEntry(drive::FileError error,
+                          std::unique_ptr<drive::ResourceEntry> entry);
+
+  void OnGotDownloadUrl(GURL download_url);
+
+  // Callback with an |access_token|, called by
+  // drive::DriveReadonlyTokenFetcher.
+  void OnTokenFetched(google_apis::DriveApiErrorCode code,
+                      const std::string& access_token);
+
+  bool RunAsyncForDriveFs(const storage::FileSystemURL& file_system_url);
+  void OnGotMetadata(drive::FileError error,
+                     drivefs::mojom::FileMetadataPtr metadata);
+
+ private:
+  GURL download_url_;
+  std::unique_ptr<google_apis::AuthService> auth_service_;
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_CHROMEOS_PRIVATE_API_DRIVE_H_
diff --git a/chrome/browser/extensions/api/file_manager/chromeos/private_api_file_system.cc b/chrome/browser/extensions/api/file_manager/chromeos/private_api_file_system.cc
new file mode 100644
index 0000000000000..f7d8d55ba1efe
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/chromeos/private_api_file_system.cc
@@ -0,0 +1,1076 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/chromeos/private_api_file_system.h"
+
+#include <sys/statvfs.h>
+
+#include <algorithm>
+#include <utility>
+
+#include "base/files/file_util.h"
+#include "base/posix/eintr_wrapper.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/sys_info.h"
+#include "base/task/post_task.h"
+#include "base/task_runner_util.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/extensions/api/file_manager/event_router.h"
+#include "chrome/browser/extensions/api/file_manager/event_router_factory.h"
+#include "chrome/browser/extensions/api/file_manager/file_stream_md5_digester.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/path_util.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/browser/fileapi/file_system_backend.h"
+#include "chrome/browser/metrics/chrome_metrics_service_accessor.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "chrome/common/extensions/api/file_manager_private_internal.h"
+#include "chromeos/chromeos_features.h"
+#include "chromeos/disks/disk_mount_manager.h"
+#include "components/drive/chromeos/file_system_interface.h"
+#include "components/drive/drive.pb.h"
+#include "components/drive/event_logger.h"
+#include "components/storage_monitor/storage_info.h"
+#include "components/storage_monitor/storage_monitor.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/child_process_security_policy.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/storage_partition.h"
+#include "content/public/common/url_constants.h"
+#include "extensions/browser/extension_util.h"
+#include "net/base/escape.h"
+#include "services/device/public/mojom/mtp_manager.mojom.h"
+#include "storage/browser/fileapi/file_stream_reader.h"
+#include "storage/browser/fileapi/file_system_context.h"
+#include "storage/browser/fileapi/file_system_file_util.h"
+#include "storage/browser/fileapi/file_system_operation_context.h"
+#include "storage/browser/fileapi/file_system_operation_runner.h"
+#include "storage/common/fileapi/file_system_info.h"
+#include "storage/common/fileapi/file_system_types.h"
+#include "storage/common/fileapi/file_system_util.h"
+#include "third_party/cros_system_api/constants/cryptohome.h"
+
+using chromeos::disks::DiskMountManager;
+using content::BrowserThread;
+using content::ChildProcessSecurityPolicy;
+using file_manager::util::EntryDefinition;
+using file_manager::util::FileDefinition;
+using storage::FileSystemURL;
+
+namespace extensions {
+namespace {
+
+const char kRootPath[] = "/";
+
+// Retrieves total and remaining available size on |mount_path|.
+void GetSizeStatsAsync(const base::FilePath& mount_path,
+                       uint64_t* total_size,
+                       uint64_t* remaining_size) {
+  int64_t size = base::SysInfo::AmountOfTotalDiskSpace(mount_path);
+  if (size >= 0)
+    *total_size = size;
+  size = base::SysInfo::AmountOfFreeDiskSpace(mount_path);
+  if (size >= 0)
+    *remaining_size = size;
+}
+
+// Retrieves the maximum file name length of the file system of |path|.
+// Returns 0 if it could not be queried.
+size_t GetFileNameMaxLengthAsync(const std::string& path) {
+  struct statvfs stat = {};
+  if (HANDLE_EINTR(statvfs(path.c_str(), &stat)) != 0) {
+    // The filesystem seems not supporting statvfs(). Assume it to be a commonly
+    // used bound 255, and log the failure.
+    LOG(ERROR) << "Cannot statvfs() the name length limit for: " << path;
+    return 255;
+  }
+  return stat.f_namemax;
+}
+
+// Returns EventRouter for the |profile_id| if available.
+file_manager::EventRouter* GetEventRouterByProfileId(void* profile_id) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  // |profile_id| needs to be checked with ProfileManager::IsValidProfile
+  // before using it.
+  if (!g_browser_process->profile_manager()->IsValidProfile(profile_id))
+    return nullptr;
+  Profile* profile = reinterpret_cast<Profile*>(profile_id);
+
+  return file_manager::EventRouterFactory::GetForProfile(profile);
+}
+
+// Notifies the copy progress to extensions via event router.
+void NotifyCopyProgress(
+    void* profile_id,
+    storage::FileSystemOperationRunner::OperationID operation_id,
+    storage::FileSystemOperation::CopyProgressType type,
+    const FileSystemURL& source_url,
+    const FileSystemURL& destination_url,
+    int64_t size) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  file_manager::EventRouter* event_router =
+      GetEventRouterByProfileId(profile_id);
+  if (event_router) {
+    event_router->OnCopyProgress(
+        operation_id, type,
+        source_url.ToGURL(), destination_url.ToGURL(), size);
+  }
+}
+
+// Callback invoked periodically on progress update of Copy().
+void OnCopyProgress(
+    void* profile_id,
+    storage::FileSystemOperationRunner::OperationID* operation_id,
+    storage::FileSystemOperation::CopyProgressType type,
+    const FileSystemURL& source_url,
+    const FileSystemURL& destination_url,
+    int64_t size) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  BrowserThread::PostTask(
+      BrowserThread::UI, FROM_HERE,
+      base::BindOnce(&NotifyCopyProgress, profile_id, *operation_id, type,
+                     source_url, destination_url, size));
+}
+
+// Notifies the copy completion to extensions via event router.
+void NotifyCopyCompletion(
+    void* profile_id,
+    storage::FileSystemOperationRunner::OperationID operation_id,
+    const FileSystemURL& source_url,
+    const FileSystemURL& destination_url,
+    base::File::Error error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  file_manager::EventRouter* event_router =
+      GetEventRouterByProfileId(profile_id);
+  if (event_router)
+    event_router->OnCopyCompleted(
+        operation_id,
+        source_url.ToGURL(), destination_url.ToGURL(), error);
+}
+
+// Callback invoked upon completion of Copy() (regardless of succeeded or
+// failed).
+void OnCopyCompleted(
+    void* profile_id,
+    storage::FileSystemOperationRunner::OperationID* operation_id,
+    const FileSystemURL& source_url,
+    const FileSystemURL& destination_url,
+    base::File::Error error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  BrowserThread::PostTask(
+      BrowserThread::UI, FROM_HERE,
+      base::BindOnce(&NotifyCopyCompletion, profile_id, *operation_id,
+                     source_url, destination_url, error));
+}
+
+// Starts the copy operation via FileSystemOperationRunner.
+storage::FileSystemOperationRunner::OperationID StartCopyOnIOThread(
+    void* profile_id,
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const FileSystemURL& source_url,
+    const FileSystemURL& destination_url) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  // Note: |operation_id| is owned by the callback for
+  // FileSystemOperationRunner::Copy(). It is always called in the next message
+  // loop or later, so at least during this invocation it should alive.
+  //
+  // TODO(yawano): change ERROR_BEHAVIOR_ABORT to ERROR_BEHAVIOR_SKIP after
+  //     error messages of individual operations become appear in the Files app
+  //     UI.
+  storage::FileSystemOperationRunner::OperationID* operation_id =
+      new storage::FileSystemOperationRunner::OperationID;
+  *operation_id = file_system_context->operation_runner()->Copy(
+      source_url, destination_url,
+      storage::FileSystemOperation::OPTION_PRESERVE_LAST_MODIFIED,
+      storage::FileSystemOperation::ERROR_BEHAVIOR_ABORT,
+      base::Bind(&OnCopyProgress, profile_id, base::Unretained(operation_id)),
+      base::Bind(&OnCopyCompleted, profile_id, base::Owned(operation_id),
+                 source_url, destination_url));
+  return *operation_id;
+}
+
+void OnCopyCancelled(base::File::Error error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  // We just ignore the status if the copy is actually cancelled or not,
+  // because failing cancellation means the operation is not running now.
+  DLOG_IF(WARNING, error != base::File::FILE_OK)
+      << "Failed to cancel copy: " << error;
+}
+
+// Cancels the running copy operation identified by |operation_id|.
+void CancelCopyOnIOThread(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    storage::FileSystemOperationRunner::OperationID operation_id) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  file_system_context->operation_runner()->Cancel(
+      operation_id, base::Bind(&OnCopyCancelled));
+}
+
+// Converts a status code to a bool value and calls the |callback| with it.
+void StatusCallbackToResponseCallback(
+    const base::Callback<void(bool)>& callback,
+    base::File::Error result) {
+  callback.Run(result == base::File::FILE_OK);
+}
+
+// Calls a response callback (on the UI thread) with a file content hash
+// computed on the IO thread.
+void ComputeChecksumRespondOnUIThread(
+    const base::Callback<void(const std::string&)>& callback,
+    const std::string& hash) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
+                          base::BindOnce(callback, hash));
+}
+
+// Calls a response callback on the UI thread.
+void GetFileMetadataRespondOnUIThread(
+    const storage::FileSystemOperation::GetMetadataCallback& callback,
+    base::File::Error result,
+    const base::File::Info& file_info) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
+                          base::BindOnce(callback, result, file_info));
+}
+
+}  // namespace
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateEnableExternalFileSchemeFunction::Run() {
+  ChildProcessSecurityPolicy::GetInstance()->GrantRequestScheme(
+      render_frame_host()->GetProcess()->GetID(), content::kExternalFileScheme);
+  return RespondNow(NoArguments());
+}
+
+FileManagerPrivateGrantAccessFunction::FileManagerPrivateGrantAccessFunction()
+    : chrome_details_(this) {
+}
+
+ExtensionFunction::ResponseAction FileManagerPrivateGrantAccessFunction::Run() {
+  using extensions::api::file_manager_private::GrantAccess::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          chrome_details_.GetProfile(), render_frame_host());
+
+  storage::ExternalFileSystemBackend* const backend =
+      file_system_context->external_backend();
+  DCHECK(backend);
+
+  const std::vector<Profile*>& profiles =
+      g_browser_process->profile_manager()->GetLoadedProfiles();
+  for (auto* profile : profiles) {
+    if (profile->IsOffTheRecord())
+      continue;
+    const GURL site = util::GetSiteForExtensionId(extension_id(), profile);
+    storage::FileSystemContext* const context =
+        content::BrowserContext::GetStoragePartitionForSite(profile, site)
+            ->GetFileSystemContext();
+    for (const auto& url : params->entry_urls) {
+      const storage::FileSystemURL file_system_url =
+          context->CrackURL(GURL(url));
+      // Grant permissions only to valid urls backed by the external file system
+      // backend.
+      if (!file_system_url.is_valid() ||
+          file_system_url.mount_type() != storage::kFileSystemTypeExternal) {
+        continue;
+      }
+      backend->GrantFileAccessToExtension(extension_->id(),
+                                          file_system_url.virtual_path());
+      content::ChildProcessSecurityPolicy::GetInstance()
+          ->GrantCreateReadWriteFile(render_frame_host()->GetProcess()->GetID(),
+                                     file_system_url.path());
+    }
+  }
+  return RespondNow(NoArguments());
+}
+
+namespace {
+
+void PostResponseCallbackTaskToUIThread(
+    const FileWatchFunctionBase::ResponseCallback& callback,
+    bool success) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
+                          base::BindOnce(callback, success));
+}
+
+void PostNotificationCallbackTaskToUIThread(
+    const storage::WatcherManager::NotificationCallback& callback,
+    storage::WatcherManager::ChangeType type) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
+                          base::BindOnce(callback, type));
+}
+
+}  // namespace
+
+void FileWatchFunctionBase::Respond(bool success) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  SetResult(std::make_unique<base::Value>(success));
+  SendResponse(success);
+}
+
+bool FileWatchFunctionBase::RunAsync() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (!render_frame_host() || !render_frame_host()->GetProcess())
+    return false;
+
+  // First param is url of a file to watch.
+  std::string url;
+  if (!args_->GetString(0, &url) || url.empty())
+    return false;
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  const FileSystemURL file_system_url =
+      file_system_context->CrackURL(GURL(url));
+  if (file_system_url.path().empty()) {
+    Respond(false);
+    return true;
+  }
+
+  file_manager::EventRouter* const event_router =
+      file_manager::EventRouterFactory::GetForProfile(GetProfile());
+
+  BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::BindOnce(&FileWatchFunctionBase::RunAsyncOnIOThread, this,
+                     file_system_context, file_system_url,
+                     event_router->GetWeakPtr()));
+  return true;
+}
+
+void FileWatchFunctionBase::RunAsyncOnIOThread(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const storage::FileSystemURL& file_system_url,
+    base::WeakPtr<file_manager::EventRouter> event_router) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  storage::WatcherManager* const watcher_manager =
+      file_system_context->GetWatcherManager(file_system_url.type());
+
+  if (!watcher_manager) {
+    BrowserThread::PostTask(
+        BrowserThread::UI, FROM_HERE,
+        base::BindOnce(
+            &FileWatchFunctionBase::PerformFallbackFileWatchOperationOnUIThread,
+            this, file_system_url, event_router));
+    return;
+  }
+
+  PerformFileWatchOperationOnIOThread(file_system_context, watcher_manager,
+                                      file_system_url, event_router);
+}
+
+void FileManagerPrivateInternalAddFileWatchFunction::
+    PerformFileWatchOperationOnIOThread(
+        scoped_refptr<storage::FileSystemContext> file_system_context,
+        storage::WatcherManager* watcher_manager,
+        const storage::FileSystemURL& file_system_url,
+        base::WeakPtr<file_manager::EventRouter> event_router) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  watcher_manager->AddWatcher(
+      file_system_url, false /* recursive */,
+      base::Bind(&StatusCallbackToResponseCallback,
+                 base::Bind(&PostResponseCallbackTaskToUIThread,
+                            base::Bind(&FileWatchFunctionBase::Respond, this))),
+      base::Bind(
+          &PostNotificationCallbackTaskToUIThread,
+          base::Bind(&file_manager::EventRouter::OnWatcherManagerNotification,
+                     event_router, file_system_url, extension_id())));
+}
+
+void FileManagerPrivateInternalAddFileWatchFunction::
+    PerformFallbackFileWatchOperationOnUIThread(
+        const storage::FileSystemURL& file_system_url,
+        base::WeakPtr<file_manager::EventRouter> event_router) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(event_router);
+
+  // Obsolete. Fallback code if storage::WatcherManager is not implemented.
+  event_router->AddFileWatch(file_system_url.path(),
+                             file_system_url.virtual_path(), extension_id(),
+                             base::Bind(&FileWatchFunctionBase::Respond, this));
+}
+
+void FileManagerPrivateInternalRemoveFileWatchFunction::
+    PerformFileWatchOperationOnIOThread(
+        scoped_refptr<storage::FileSystemContext> file_system_context,
+        storage::WatcherManager* watcher_manager,
+        const storage::FileSystemURL& file_system_url,
+        base::WeakPtr<file_manager::EventRouter> event_router) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  watcher_manager->RemoveWatcher(
+      file_system_url, false /* recursive */,
+      base::Bind(
+          &StatusCallbackToResponseCallback,
+          base::Bind(&PostResponseCallbackTaskToUIThread,
+                     base::Bind(&FileWatchFunctionBase::Respond, this))));
+}
+
+void FileManagerPrivateInternalRemoveFileWatchFunction::
+    PerformFallbackFileWatchOperationOnUIThread(
+        const storage::FileSystemURL& file_system_url,
+        base::WeakPtr<file_manager::EventRouter> event_router) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(event_router);
+
+  // Obsolete. Fallback code if storage::WatcherManager is not implemented.
+  event_router->RemoveFileWatch(file_system_url.path(), extension_id());
+  Respond(true);
+}
+
+bool FileManagerPrivateGetSizeStatsFunction::RunAsync() {
+  using extensions::api::file_manager_private::GetSizeStats::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  using file_manager::VolumeManager;
+  using file_manager::Volume;
+  VolumeManager* const volume_manager = VolumeManager::Get(GetProfile());
+  if (!volume_manager)
+    return false;
+
+  base::WeakPtr<Volume> volume =
+      volume_manager->FindVolumeById(params->volume_id);
+  if (!volume.get())
+    return false;
+
+  if (volume->type() == file_manager::VOLUME_TYPE_GOOGLE_DRIVE &&
+      !base::FeatureList::IsEnabled(chromeos::features::kDriveFs)) {
+    drive::FileSystemInterface* file_system =
+        drive::util::GetFileSystemByProfile(GetProfile());
+    if (!file_system) {
+      // |file_system| is NULL if Drive is disabled.
+      // If stats couldn't be gotten for drive, result should be left
+      // undefined. See comments in GetDriveAvailableSpaceCallback().
+      SendResponse(true);
+      return true;
+    }
+
+    file_system->GetAvailableSpace(base::Bind(
+        &FileManagerPrivateGetSizeStatsFunction::OnGetDriveAvailableSpace,
+        this));
+  } else if (volume->type() == file_manager::VOLUME_TYPE_MTP) {
+    // Resolve storage_name.
+    storage_monitor::StorageMonitor* storage_monitor =
+        storage_monitor::StorageMonitor::GetInstance();
+    storage_monitor::StorageInfo info;
+    storage_monitor->GetStorageInfoForPath(volume->mount_path(), &info);
+    std::string storage_name;
+    base::RemoveChars(info.location(), kRootPath, &storage_name);
+    DCHECK(!storage_name.empty());
+
+    // Get MTP StorageInfo.
+    auto* manager = storage_monitor->media_transfer_protocol_manager();
+    manager->GetStorageInfoFromDevice(
+        storage_name,
+        base::Bind(
+            &FileManagerPrivateGetSizeStatsFunction::OnGetMtpAvailableSpace,
+            this));
+  } else {
+    uint64_t* total_size = new uint64_t(0);
+    uint64_t* remaining_size = new uint64_t(0);
+    base::PostTaskWithTraitsAndReply(
+        FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_VISIBLE},
+        base::BindOnce(&GetSizeStatsAsync, volume->mount_path(), total_size,
+                       remaining_size),
+        base::BindOnce(&FileManagerPrivateGetSizeStatsFunction::OnGetSizeStats,
+                       this, base::Owned(total_size),
+                       base::Owned(remaining_size)));
+  }
+  return true;
+}
+
+void FileManagerPrivateGetSizeStatsFunction::OnGetDriveAvailableSpace(
+    drive::FileError error,
+    int64_t bytes_total,
+    int64_t bytes_used) {
+  if (error == drive::FILE_ERROR_OK) {
+    const uint64_t bytes_total_unsigned = bytes_total;
+    // bytes_used can be larger than bytes_total (over quota).
+    const uint64_t bytes_remaining_unsigned =
+        std::max(bytes_total - bytes_used, int64_t(0));
+    OnGetSizeStats(&bytes_total_unsigned, &bytes_remaining_unsigned);
+  } else {
+    // If stats couldn't be gotten for drive, result should be left undefined.
+    SendResponse(true);
+  }
+}
+
+void FileManagerPrivateGetSizeStatsFunction::OnGetMtpAvailableSpace(
+    device::mojom::MtpStorageInfoPtr mtp_storage_info,
+    const bool error) {
+  if (error) {
+    // If stats couldn't be gotten from MTP volume, result should be left
+    // undefined same as we do for Drive.
+    SendResponse(true);
+    return;
+  }
+
+  const uint64_t max_capacity = mtp_storage_info->max_capacity;
+  const uint64_t free_space_in_bytes = mtp_storage_info->free_space_in_bytes;
+  OnGetSizeStats(&max_capacity, &free_space_in_bytes);
+}
+
+void FileManagerPrivateGetSizeStatsFunction::OnGetSizeStats(
+    const uint64_t* total_size,
+    const uint64_t* remaining_size) {
+  std::unique_ptr<base::DictionaryValue> sizes(new base::DictionaryValue());
+
+  sizes->SetDouble("totalSize", static_cast<double>(*total_size));
+  sizes->SetDouble("remainingSize", static_cast<double>(*remaining_size));
+
+  SetResult(std::move(sizes));
+  SendResponse(true);
+}
+
+bool FileManagerPrivateInternalValidatePathNameLengthFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::ValidatePathNameLength::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  const storage::FileSystemURL file_system_url(
+      file_system_context->CrackURL(GURL(params->parent_url)));
+  if (!chromeos::FileSystemBackend::CanHandleURL(file_system_url))
+    return false;
+
+  // No explicit limit on the length of Drive file names.
+  if (file_system_url.type() == storage::kFileSystemTypeDrive) {
+    SetResult(std::make_unique<base::Value>(true));
+    SendResponse(true);
+    return true;
+  }
+
+  base::PostTaskWithTraitsAndReplyWithResult(
+      FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_BLOCKING},
+      base::Bind(&GetFileNameMaxLengthAsync,
+                 file_system_url.path().AsUTF8Unsafe()),
+      base::Bind(&FileManagerPrivateInternalValidatePathNameLengthFunction::
+                     OnFilePathLimitRetrieved,
+                 this, params->name.size()));
+  return true;
+}
+
+void FileManagerPrivateInternalValidatePathNameLengthFunction::
+    OnFilePathLimitRetrieved(size_t current_length, size_t max_length) {
+  SetResult(std::make_unique<base::Value>(current_length <= max_length));
+  SendResponse(true);
+}
+
+bool FileManagerPrivateFormatVolumeFunction::RunAsync() {
+  using extensions::api::file_manager_private::FormatVolume::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  using file_manager::VolumeManager;
+  using file_manager::Volume;
+  VolumeManager* const volume_manager = VolumeManager::Get(GetProfile());
+  if (!volume_manager)
+    return false;
+
+  base::WeakPtr<Volume> volume =
+      volume_manager->FindVolumeById(params->volume_id);
+  if (!volume)
+    return false;
+
+  DiskMountManager::GetInstance()->FormatMountedDevice(
+      volume->mount_path().AsUTF8Unsafe());
+  SendResponse(true);
+  return true;
+}
+
+bool FileManagerPrivateRenameVolumeFunction::RunAsync() {
+  using extensions::api::file_manager_private::RenameVolume::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  using file_manager::VolumeManager;
+  using file_manager::Volume;
+  VolumeManager* const volume_manager = VolumeManager::Get(GetProfile());
+  if (!volume_manager)
+    return false;
+
+  base::WeakPtr<Volume> volume =
+      volume_manager->FindVolumeById(params->volume_id);
+  if (!volume)
+    return false;
+
+  DiskMountManager::GetInstance()->RenameMountedDevice(
+      volume->mount_path().AsUTF8Unsafe(), params->new_name);
+  SendResponse(true);
+  return true;
+}
+
+// Obtains file size of URL.
+void GetFileMetadataOnIOThread(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const FileSystemURL& url,
+    int fields,
+    const storage::FileSystemOperation::GetMetadataCallback& callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  file_system_context->operation_runner()->GetMetadata(
+      url, fields, base::Bind(&GetFileMetadataRespondOnUIThread, callback));
+}
+
+// Checks if the available space of the |path| is enough for required |bytes|.
+bool CheckLocalDiskSpace(const base::FilePath& path, int64_t bytes) {
+  return bytes <= base::SysInfo::AmountOfFreeDiskSpace(path) -
+                      cryptohome::kMinFreeSpaceInBytes;
+}
+
+bool FileManagerPrivateInternalStartCopyFunction::RunAsync() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  using extensions::api::file_manager_private_internal::StartCopy::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  if (params->url.empty() || params->parent_url.empty() ||
+      params->new_name.empty()) {
+    // Error code in format of DOMError.name.
+    SetError("EncodingError");
+    return false;
+  }
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  // |parent| may have a trailing slash if it is a root directory.
+  std::string destination_url_string = params->parent_url;
+  if (destination_url_string.back() != '/')
+    destination_url_string += '/';
+  destination_url_string += net::EscapePath(params->new_name);
+
+  source_url_ = file_system_context->CrackURL(GURL(params->url));
+  destination_url_ =
+      file_system_context->CrackURL(GURL(destination_url_string));
+
+  if (!source_url_.is_valid() || !destination_url_.is_valid()) {
+    // Error code in format of DOMError.name.
+    SetError("EncodingError");
+    return false;
+  }
+
+  // Check if the destination directory is downloads. If so, secure available
+  // spece by freeing drive caches.
+  if (destination_url_.filesystem_id() ==
+      file_manager::util::GetDownloadsMountPointName(GetProfile())) {
+    return BrowserThread::PostTask(
+        BrowserThread::IO, FROM_HERE,
+        base::BindOnce(&GetFileMetadataOnIOThread, file_system_context,
+                       source_url_,
+                       storage::FileSystemOperation::GET_METADATA_FIELD_SIZE,
+                       base::Bind(&FileManagerPrivateInternalStartCopyFunction::
+                                      RunAfterGetFileMetadata,
+                                  this)));
+  }
+
+  return BrowserThread::PostTask(
+      BrowserThread::UI, FROM_HERE,
+      base::BindOnce(
+          &FileManagerPrivateInternalStartCopyFunction::RunAfterFreeDiskSpace,
+          this, true));
+}
+
+void FileManagerPrivateInternalStartCopyFunction::RunAfterGetFileMetadata(
+    base::File::Error result,
+    const base::File::Info& file_info) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (result != base::File::FILE_OK) {
+    SetError("NotFoundError");
+    SendResponse(false);
+    return;
+  }
+
+  drive::FileSystemInterface* const drive_file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (drive_file_system) {
+    drive_file_system->FreeDiskSpaceIfNeededFor(
+        file_info.size,
+        base::Bind(
+            &FileManagerPrivateInternalStartCopyFunction::RunAfterFreeDiskSpace,
+            this));
+  } else {
+    base::PostTaskWithTraitsAndReplyWithResult(
+        FROM_HERE, {base::MayBlock()},
+        base::BindOnce(
+            &CheckLocalDiskSpace,
+            file_manager::util::GetDownloadsFolderForProfile(GetProfile()),
+            file_info.size),
+        base::BindOnce(
+            &FileManagerPrivateInternalStartCopyFunction::RunAfterFreeDiskSpace,
+            this));
+  }
+}
+
+void FileManagerPrivateInternalStartCopyFunction::RunAfterFreeDiskSpace(
+    bool available) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (!available) {
+    SetError("QuotaExceededError");
+    SendResponse(false);
+    return;
+  }
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+  const bool result = BrowserThread::PostTaskAndReplyWithResult(
+      BrowserThread::IO, FROM_HERE,
+      base::Bind(&StartCopyOnIOThread, GetProfile(), file_system_context,
+                 source_url_, destination_url_),
+      base::Bind(
+          &FileManagerPrivateInternalStartCopyFunction::RunAfterStartCopy,
+          this));
+  if (!result)
+    SendResponse(false);
+}
+
+void FileManagerPrivateInternalStartCopyFunction::RunAfterStartCopy(
+    int operation_id) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  SetResult(std::make_unique<base::Value>(operation_id));
+  SendResponse(true);
+}
+
+bool FileManagerPrivateCancelCopyFunction::RunAsync() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  using extensions::api::file_manager_private::CancelCopy::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  // We don't much take care about the result of cancellation.
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+                          base::BindOnce(&CancelCopyOnIOThread,
+                                         file_system_context, params->copy_id));
+  SendResponse(true);
+  return true;
+}
+
+bool FileManagerPrivateInternalResolveIsolatedEntriesFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::ResolveIsolatedEntries::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+  DCHECK(file_system_context.get());
+
+  const storage::ExternalFileSystemBackend* external_backend =
+      file_system_context->external_backend();
+  DCHECK(external_backend);
+
+  file_manager::util::FileDefinitionList file_definition_list;
+  for (size_t i = 0; i < params->urls.size(); ++i) {
+    const FileSystemURL file_system_url =
+        file_system_context->CrackURL(GURL(params->urls[i]));
+    DCHECK(external_backend->CanHandleType(file_system_url.type()))
+        << "GURL: " << file_system_url.ToGURL()
+        << "type: " << file_system_url.type();
+    FileDefinition file_definition;
+    const bool result =
+        file_manager::util::ConvertAbsoluteFilePathToRelativeFileSystemPath(
+            GetProfile(), extension_->id(), file_system_url.path(),
+            &file_definition.virtual_path);
+    if (!result)
+      continue;
+    // The API only supports isolated files. It still works for directories,
+    // as the value is ignored for existing entries.
+    file_definition.is_directory = false;
+    file_definition_list.push_back(file_definition);
+  }
+
+  file_manager::util::ConvertFileDefinitionListToEntryDefinitionList(
+      GetProfile(),
+      extension_->id(),
+      file_definition_list,  // Safe, since copied internally.
+      base::Bind(
+          &FileManagerPrivateInternalResolveIsolatedEntriesFunction::
+              RunAsyncAfterConvertFileDefinitionListToEntryDefinitionList,
+          this));
+  return true;
+}
+
+void FileManagerPrivateInternalResolveIsolatedEntriesFunction::
+    RunAsyncAfterConvertFileDefinitionListToEntryDefinitionList(
+        std::unique_ptr<file_manager::util::EntryDefinitionList>
+            entry_definition_list) {
+  using extensions::api::file_manager_private_internal::EntryDescription;
+  std::vector<EntryDescription> entries;
+
+  for (const auto& definition : *entry_definition_list) {
+    if (definition.error != base::File::FILE_OK)
+      continue;
+    EntryDescription entry;
+    entry.file_system_name = definition.file_system_name;
+    entry.file_system_root = definition.file_system_root_url;
+    entry.file_full_path = "/" + definition.full_path.AsUTF8Unsafe();
+    entry.file_is_directory = definition.is_directory;
+    entries.push_back(std::move(entry));
+  }
+
+  results_ = extensions::api::file_manager_private_internal::
+      ResolveIsolatedEntries::Results::Create(entries);
+  SendResponse(true);
+}
+
+FileManagerPrivateInternalComputeChecksumFunction::
+    FileManagerPrivateInternalComputeChecksumFunction()
+    : digester_(new drive::util::FileStreamMd5Digester()) {
+}
+
+FileManagerPrivateInternalComputeChecksumFunction::
+    ~FileManagerPrivateInternalComputeChecksumFunction() = default;
+
+bool FileManagerPrivateInternalComputeChecksumFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::ComputeChecksum::Params;
+  using drive::util::FileStreamMd5Digester;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  if (params->url.empty()) {
+    SetError("File URL must be provided.");
+    return false;
+  }
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  FileSystemURL file_system_url(
+      file_system_context->CrackURL(GURL(params->url)));
+  if (!file_system_url.is_valid()) {
+    SetError("File URL was invalid");
+    return false;
+  }
+
+  std::unique_ptr<storage::FileStreamReader> reader =
+      file_system_context->CreateFileStreamReader(
+          file_system_url, 0, storage::kMaximumLength, base::Time());
+
+  FileStreamMd5Digester::ResultCallback result_callback = base::Bind(
+      &ComputeChecksumRespondOnUIThread,
+      base::Bind(&FileManagerPrivateInternalComputeChecksumFunction::Respond,
+                 this));
+  BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::BindOnce(&FileStreamMd5Digester::GetMd5Digest,
+                     base::Unretained(digester_.get()), base::Passed(&reader),
+                     result_callback));
+
+  return true;
+}
+
+void FileManagerPrivateInternalComputeChecksumFunction::Respond(
+    const std::string& hash) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  SetResult(std::make_unique<base::Value>(hash));
+  SendResponse(true);
+}
+
+bool FileManagerPrivateSearchFilesByHashesFunction::RunAsync() {
+  using api::file_manager_private::SearchFilesByHashes::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  // TODO(hirono): Check the volume ID and fail the function for volumes other
+  // than Drive.
+
+  drive::EventLogger* const logger =
+      file_manager::util::GetLogger(GetProfile());
+  if (logger) {
+    logger->Log(logging::LOG_INFO,
+                "%s[%d] called. (volume id: %s, number of hashes: %zd)", name(),
+                request_id(), params->volume_id.c_str(),
+                params->hash_list.size());
+  }
+  set_log_on_completion(true);
+
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system) {
+    // |file_system| is NULL if Drive is disabled.
+    return false;
+  }
+
+  std::set<std::string> hashes(params->hash_list.begin(),
+                               params->hash_list.end());
+  file_system->SearchByHashes(
+      hashes,
+      base::Bind(
+          &FileManagerPrivateSearchFilesByHashesFunction::OnSearchByHashes,
+          this, hashes));
+  return true;
+}
+
+void FileManagerPrivateSearchFilesByHashesFunction::OnSearchByHashes(
+    const std::set<std::string>& hashes,
+    drive::FileError error,
+    const std::vector<drive::HashAndFilePath>& search_results) {
+  if (error != drive::FileError::FILE_ERROR_OK) {
+    SendResponse(false);
+    return;
+  }
+
+  std::unique_ptr<base::DictionaryValue> result(new base::DictionaryValue());
+  for (const auto& hash : hashes) {
+    result->SetWithoutPathExpansion(hash, std::make_unique<base::ListValue>());
+  }
+
+  for (const auto& hashAndPath : search_results) {
+    DCHECK(result->HasKey(hashAndPath.hash));
+    base::ListValue* list;
+    result->GetListWithoutPathExpansion(hashAndPath.hash, &list);
+    list->AppendString(
+        file_manager::util::ConvertDrivePathToFileSystemUrl(
+            GetProfile(), hashAndPath.path, extension_id()).spec());
+  }
+  SetResult(std::move(result));
+  SendResponse(true);
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateIsUMAEnabledFunction::Run() {
+  return RespondNow(OneArgument(std::make_unique<base::Value>(
+      ChromeMetricsServiceAccessor::IsMetricsAndCrashReportingEnabled())));
+}
+
+FileManagerPrivateInternalSetEntryTagFunction::
+    FileManagerPrivateInternalSetEntryTagFunction()
+    : chrome_details_(this) {}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateInternalSetEntryTagFunction::Run() {
+  using extensions::api::file_manager_private_internal::SetEntryTag::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const base::FilePath local_path = file_manager::util::GetLocalPathFromURL(
+      render_frame_host(), chrome_details_.GetProfile(), GURL(params->url));
+  const base::FilePath drive_path = drive::util::ExtractDrivePath(local_path);
+  if (drive_path.empty())
+    return RespondNow(Error("Only Drive files and directories are supported."));
+
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(chrome_details_.GetProfile());
+  // |file_system| is NULL if Drive is disabled.
+  if (!file_system)
+    return RespondNow(Error("Drive is disabled."));
+
+  google_apis::drive::Property::Visibility visibility;
+  switch (params->visibility) {
+    case extensions::api::file_manager_private::ENTRY_TAG_VISIBILITY_PRIVATE:
+      visibility = google_apis::drive::Property::VISIBILITY_PRIVATE;
+      break;
+    case extensions::api::file_manager_private::ENTRY_TAG_VISIBILITY_PUBLIC:
+      visibility = google_apis::drive::Property::VISIBILITY_PUBLIC;
+      break;
+    default:
+      NOTREACHED();
+      return RespondNow(Error("Invalid visibility."));
+      break;
+  }
+
+  file_system->SetProperty(
+      drive_path, visibility, params->key, params->value,
+      base::Bind(&FileManagerPrivateInternalSetEntryTagFunction::
+                     OnSetEntryPropertyCompleted,
+                 this));
+  return RespondLater();
+}
+
+void FileManagerPrivateInternalSetEntryTagFunction::OnSetEntryPropertyCompleted(
+    drive::FileError result) {
+  Respond(result == drive::FILE_ERROR_OK ? NoArguments()
+                                         : Error("Failed to set a tag."));
+}
+
+bool FileManagerPrivateInternalGetDirectorySizeFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::GetDirectorySize::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  if (params->url.empty()) {
+    SetError("File URL must be provided.");
+    return false;
+  }
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+  const storage::FileSystemURL file_system_url(
+      file_system_context->CrackURL(GURL(params->url)));
+  if (!chromeos::FileSystemBackend::CanHandleURL(file_system_url)) {
+    SetError("FileSystemBackend failed to handle the entry's url.");
+    return false;
+  }
+  if (file_system_url.type() != storage::kFileSystemTypeNativeLocal) {
+    SetError("Only local directories are supported.");
+    return false;
+  }
+
+  const base::FilePath root_path = file_manager::util::GetLocalPathFromURL(
+      render_frame_host(), GetProfile(), GURL(params->url));
+  if (root_path.empty()) {
+    SetError("Failed to get a local path from the entry's url.");
+    return false;
+  }
+
+  base::PostTaskWithTraitsAndReplyWithResult(
+      FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_VISIBLE},
+      base::Bind(&base::ComputeDirectorySize, root_path),
+      base::Bind(&FileManagerPrivateInternalGetDirectorySizeFunction::
+                     OnDirectorySizeRetrieved,
+                 this));
+  return true;
+}
+
+void FileManagerPrivateInternalGetDirectorySizeFunction::
+    OnDirectorySizeRetrieved(int64_t size) {
+  SetResult(std::make_unique<base::Value>(static_cast<double>(size)));
+  SendResponse(true);
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_manager/chromeos/private_api_file_system.h b/chrome/browser/extensions/api/file_manager/chromeos/private_api_file_system.h
new file mode 100644
index 0000000000000..e3b807b033abc
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/chromeos/private_api_file_system.h
@@ -0,0 +1,400 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides file system related API functions.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_CHROMEOS_PRIVATE_API_FILE_SYSTEM_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_CHROMEOS_PRIVATE_API_FILE_SYSTEM_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <memory>
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/callback_forward.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_base.h"
+#include "chrome/browser/extensions/chrome_extension_function.h"
+#include "chrome/browser/extensions/chrome_extension_function_details.h"
+#include "components/drive/file_errors.h"
+#include "extensions/browser/extension_function.h"
+#include "services/device/public/mojom/mtp_storage_info.mojom.h"
+#include "storage/browser/fileapi/file_system_url.h"
+
+namespace storage {
+class FileSystemContext;
+class FileSystemURL;
+class WatcherManager;
+}  // namespace storage
+
+namespace file_manager {
+class EventRouter;
+namespace util {
+struct EntryDefinition;
+typedef std::vector<EntryDefinition> EntryDefinitionList;
+}  // namespace util
+}  // namespace file_manager
+
+namespace drive {
+namespace util {
+class FileStreamMd5Digester;
+}  // namespace util
+struct HashAndFilePath;
+}  // namespace drive
+
+namespace extensions {
+
+// Grant permission to request externalfile scheme. The permission is needed to
+// start drag for external file URL.
+class FileManagerPrivateEnableExternalFileSchemeFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.enableExternalFileScheme",
+                             FILEMANAGERPRIVATE_ENABLEEXTERNALFILESCHEME);
+
+ protected:
+  ~FileManagerPrivateEnableExternalFileSchemeFunction() override = default;
+
+ private:
+  ExtensionFunction::ResponseAction Run() override;
+};
+
+// Grants R/W permissions to profile-specific directories (Drive, Downloads)
+// from other profiles.
+class FileManagerPrivateGrantAccessFunction : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateGrantAccessFunction();
+
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.grantAccess",
+                             FILEMANAGERPRIVATE_GRANTACCESS)
+
+ protected:
+  ~FileManagerPrivateGrantAccessFunction() override = default;
+
+ private:
+  ExtensionFunction::ResponseAction Run() override;
+  const ChromeExtensionFunctionDetails chrome_details_;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateGrantAccessFunction);
+};
+
+// Base class for FileManagerPrivateInternalAddFileWatchFunction and
+// FileManagerPrivateInternalRemoveFileWatchFunction. Although it's called
+// "FileWatch",
+// the class and its sub classes are used only for watching changes in
+// directories.
+class FileWatchFunctionBase : public LoggedAsyncExtensionFunction {
+ public:
+  using ResponseCallback = base::Callback<void(bool success)>;
+
+  // Calls SendResponse() with |success| converted to base::Value.
+  void Respond(bool success);
+
+ protected:
+  ~FileWatchFunctionBase() override = default;
+
+  // Performs a file watch operation (ex. adds or removes a file watch) on
+  // the IO thread with storage::WatcherManager.
+  virtual void PerformFileWatchOperationOnIOThread(
+      scoped_refptr<storage::FileSystemContext> file_system_context,
+      storage::WatcherManager* watcher_manager,
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router) = 0;
+
+  // Performs a file watch operation (ex. adds or removes a file watch) on
+  // the UI thread with file_manager::EventRouter. This is a fallback operation
+  // called only when WatcherManager is unavailable.
+  virtual void PerformFallbackFileWatchOperationOnUIThread(
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router) = 0;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  void RunAsyncOnIOThread(
+      scoped_refptr<storage::FileSystemContext> file_system_context,
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router);
+};
+
+// Implements the chrome.fileManagerPrivate.addFileWatch method.
+// Starts watching changes in directories.
+class FileManagerPrivateInternalAddFileWatchFunction
+    : public FileWatchFunctionBase {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.addFileWatch",
+                             FILEMANAGERPRIVATEINTERNAL_ADDFILEWATCH)
+
+ protected:
+  ~FileManagerPrivateInternalAddFileWatchFunction() override = default;
+
+  // FileWatchFunctionBase override.
+  void PerformFileWatchOperationOnIOThread(
+      scoped_refptr<storage::FileSystemContext> file_system_context,
+      storage::WatcherManager* watcher_manager,
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router) override;
+  void PerformFallbackFileWatchOperationOnUIThread(
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router) override;
+};
+
+
+// Implements the chrome.fileManagerPrivate.removeFileWatch method.
+// Stops watching changes in directories.
+class FileManagerPrivateInternalRemoveFileWatchFunction
+    : public FileWatchFunctionBase {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.removeFileWatch",
+                             FILEMANAGERPRIVATEINTERNAL_REMOVEFILEWATCH)
+
+ protected:
+  ~FileManagerPrivateInternalRemoveFileWatchFunction() override = default;
+
+  // FileWatchFunctionBase override.
+  void PerformFileWatchOperationOnIOThread(
+      scoped_refptr<storage::FileSystemContext> file_system_context,
+      storage::WatcherManager* watcher_manager,
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router) override;
+  void PerformFallbackFileWatchOperationOnUIThread(
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router) override;
+};
+
+// Implements the chrome.fileManagerPrivate.getSizeStats method.
+class FileManagerPrivateGetSizeStatsFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.getSizeStats",
+                             FILEMANAGERPRIVATE_GETSIZESTATS)
+
+ protected:
+  ~FileManagerPrivateGetSizeStatsFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  void OnGetDriveAvailableSpace(drive::FileError error,
+                                int64_t bytes_total,
+                                int64_t bytes_used);
+
+  void OnGetMtpAvailableSpace(device::mojom::MtpStorageInfoPtr mtp_storage_info,
+                              const bool error);
+
+  void OnGetSizeStats(const uint64_t* total_size,
+                      const uint64_t* remaining_size);
+};
+
+// Implements the chrome.fileManagerPrivate.validatePathNameLength method.
+class FileManagerPrivateInternalValidatePathNameLengthFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileManagerPrivateInternal.validatePathNameLength",
+      FILEMANAGERPRIVATEINTERNAL_VALIDATEPATHNAMELENGTH)
+
+ protected:
+  ~FileManagerPrivateInternalValidatePathNameLengthFunction() override =
+      default;
+
+  void OnFilePathLimitRetrieved(size_t current_length, size_t max_length);
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivate.formatVolume method.
+// Formats Volume given its mount path.
+class FileManagerPrivateFormatVolumeFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.formatVolume",
+                             FILEMANAGERPRIVATE_FORMATVOLUME)
+
+ protected:
+  ~FileManagerPrivateFormatVolumeFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivate.renameVolume method.
+// Renames Volume given its mount path and new Volume name.
+class FileManagerPrivateRenameVolumeFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.renameVolume",
+                             FILEMANAGERPRIVATE_RENAMEVOLUME)
+
+ protected:
+  ~FileManagerPrivateRenameVolumeFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivate.startCopy method.
+class FileManagerPrivateInternalStartCopyFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.startCopy",
+                             FILEMANAGERPRIVATEINTERNAL_STARTCOPY)
+
+ protected:
+  ~FileManagerPrivateInternalStartCopyFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  void RunAfterGetFileMetadata(base::File::Error result,
+                               const base::File::Info& file_info);
+
+  // Part of RunAsync(). Called after FreeDiskSpaceIfNeededFor() is completed on
+  // IO thread.
+  void RunAfterFreeDiskSpace(bool available);
+
+  // Part of RunAsync(). Called after Copy() is started on IO thread.
+  void RunAfterStartCopy(int operation_id);
+
+  storage::FileSystemURL source_url_;
+  storage::FileSystemURL destination_url_;
+};
+
+// Implements the chrome.fileManagerPrivate.cancelCopy method.
+class FileManagerPrivateCancelCopyFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.cancelCopy",
+                             FILEMANAGERPRIVATE_CANCELCOPY)
+
+ protected:
+  ~FileManagerPrivateCancelCopyFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivateInternal.resolveIsolatedEntries
+// method.
+class FileManagerPrivateInternalResolveIsolatedEntriesFunction
+    : public ChromeAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileManagerPrivateInternal.resolveIsolatedEntries",
+      FILEMANAGERPRIVATE_RESOLVEISOLATEDENTRIES)
+
+ protected:
+  ~FileManagerPrivateInternalResolveIsolatedEntriesFunction() override =
+      default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  void RunAsyncAfterConvertFileDefinitionListToEntryDefinitionList(
+      std::unique_ptr<file_manager::util::EntryDefinitionList>
+          entry_definition_list);
+};
+
+class FileManagerPrivateInternalComputeChecksumFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  FileManagerPrivateInternalComputeChecksumFunction();
+
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.computeChecksum",
+                             FILEMANAGERPRIVATEINTERNAL_COMPUTECHECKSUM)
+
+ protected:
+  ~FileManagerPrivateInternalComputeChecksumFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  std::unique_ptr<drive::util::FileStreamMd5Digester> digester_;
+
+  void Respond(const std::string& hash);
+};
+
+// Implements the chrome.fileManagerPrivate.searchFilesByHashes method.
+class FileManagerPrivateSearchFilesByHashesFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.searchFilesByHashes",
+                             FILEMANAGERPRIVATE_SEARCHFILESBYHASHES)
+
+ protected:
+  ~FileManagerPrivateSearchFilesByHashesFunction() override = default;
+
+ private:
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+  // Sends a response with |results| to the extension.
+  void OnSearchByHashes(const std::set<std::string>& hashes,
+                        drive::FileError error,
+                        const std::vector<drive::HashAndFilePath>& results);
+};
+
+// Implements the chrome.fileManagerPrivate.isUMAEnabled method.
+class FileManagerPrivateIsUMAEnabledFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateIsUMAEnabledFunction() = default;
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.isUMAEnabled",
+                             FILEMANAGERPRIVATE_ISUMAENABLED)
+ protected:
+  ~FileManagerPrivateIsUMAEnabledFunction() override = default;
+
+ private:
+  ExtensionFunction::ResponseAction Run() override;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateIsUMAEnabledFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.setEntryTag method.
+class FileManagerPrivateInternalSetEntryTagFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateInternalSetEntryTagFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.setEntryTag",
+                             FILEMANAGERPRIVATEINTERNAL_SETENTRYTAG)
+ protected:
+  ~FileManagerPrivateInternalSetEntryTagFunction() override = default;
+
+ private:
+  const ChromeExtensionFunctionDetails chrome_details_;
+
+  // Called when setting a tag is completed with either a success or an error.
+  void OnSetEntryPropertyCompleted(drive::FileError result);
+
+  ExtensionFunction::ResponseAction Run() override;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateInternalSetEntryTagFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.getDirectorySize method.
+class FileManagerPrivateInternalGetDirectorySizeFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getDirectorySize",
+                             FILEMANAGERPRIVATEINTERNAL_GETDIRECTORYSIZE)
+
+ protected:
+  ~FileManagerPrivateInternalGetDirectorySizeFunction() override = default;
+
+  void OnDirectorySizeRetrieved(int64_t size);
+
+  // ChromeAsyncExtensionFunction overrides
+  bool RunAsync() override;
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_CHROMEOS_PRIVATE_API_FILE_SYSTEM_H_
diff --git a/chrome/browser/extensions/api/file_manager/chromeos/private_api_misc.cc b/chrome/browser/extensions/api/file_manager/chromeos/private_api_misc.cc
new file mode 100644
index 0000000000000..28097bb8f0206
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/chromeos/private_api_misc.cc
@@ -0,0 +1,910 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/private_api_misc.h"
+
+#include <stddef.h>
+
+#include <algorithm>
+#include <memory>
+#include <set>
+#include <utility>
+#include <vector>
+
+#include "base/base64.h"
+#include "base/command_line.h"
+#include "base/files/file_path.h"
+#include "base/memory/ref_counted.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/chromeos/crostini/crostini_package_installer_service.h"
+#include "chrome/browser/chromeos/crostini/crostini_util.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/chromeos/file_system_provider/mount_path_util.h"
+#include "chrome/browser/chromeos/file_system_provider/service.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/path_util.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/browser/fileapi/recent_file.h"
+#include "chrome/browser/fileapi/recent_model.h"
+#include "chrome/browser/chromeos/profiles/profile_helper.h"
+#include "chrome/browser/chromeos/settings/cros_settings.h"
+#include "chrome/browser/devtools/devtools_window.h"
+#include "chrome/browser/extensions/devtools_util.h"
+#include "chrome/browser/lifetime/application_lifetime.h"
+#include "chrome/browser/net/system_network_context_manager.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/browser/profiles/profiles_state.h"
+#include "chrome/browser/signin/profile_oauth2_token_service_factory.h"
+#include "chrome/browser/signin/signin_manager_factory.h"
+#include "chrome/browser/ui/ash/multi_user/multi_user_util.h"
+#include "chrome/browser/ui/ash/multi_user/multi_user_window_manager.h"
+#include "chrome/browser/ui/chrome_pages.h"
+#include "chrome/common/extensions/api/file_manager_private_internal.h"
+#include "chrome/common/extensions/api/manifest_types.h"
+#include "chrome/common/pref_names.h"
+#include "chrome/services/file_util/public/cpp/zip_file_creator.h"
+#include "chromeos/settings/timezone_settings.h"
+#include "components/account_id/account_id.h"
+#include "components/drive/drive_pref_names.h"
+#include "components/drive/event_logger.h"
+#include "components/prefs/pref_service.h"
+#include "components/signin/core/browser/profile_oauth2_token_service.h"
+#include "components/signin/core/browser/signin_manager.h"
+#include "components/user_manager/user_manager.h"
+#include "components/zoom/page_zoom.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/common/page_zoom.h"
+#include "content/public/common/service_manager_connection.h"
+#include "extensions/browser/api/file_handlers/mime_util.h"
+#include "extensions/browser/app_window/app_window.h"
+#include "extensions/browser/app_window/app_window_registry.h"
+#include "google_apis/drive/auth_service.h"
+#include "services/network/public/cpp/shared_url_loader_factory.h"
+#include "storage/common/fileapi/file_system_types.h"
+#include "ui/base/webui/web_ui_util.h"
+#include "url/gurl.h"
+
+namespace extensions {
+namespace {
+
+using api::file_manager_private::ProfileInfo;
+
+const char kCWSScope[] = "https://www.googleapis.com/auth/chromewebstore";
+
+// Obtains the current app window.
+AppWindow* GetCurrentAppWindow(UIThreadExtensionFunction* function) {
+  content::WebContents* const contents = function->GetSenderWebContents();
+  return contents
+             ? AppWindowRegistry::Get(function->browser_context())
+                   ->GetAppWindowForWebContents(contents)
+             : nullptr;
+}
+
+std::vector<ProfileInfo> GetLoggedInProfileInfoList() {
+  DCHECK(user_manager::UserManager::IsInitialized());
+  const std::vector<Profile*>& profiles =
+      g_browser_process->profile_manager()->GetLoadedProfiles();
+  std::set<Profile*> original_profiles;
+  std::vector<ProfileInfo> result_profiles;
+
+  for (Profile* profile : profiles) {
+    // Filter the profile.
+    profile = profile->GetOriginalProfile();
+    if (original_profiles.count(profile))
+      continue;
+    original_profiles.insert(profile);
+    const user_manager::User* const user =
+        chromeos::ProfileHelper::Get()->GetUserByProfile(profile);
+    if (!user || !user->is_logged_in())
+      continue;
+
+    // Make a ProfileInfo.
+    ProfileInfo profile_info;
+    profile_info.profile_id =
+        multi_user_util::GetAccountIdFromProfile(profile).GetUserEmail();
+    profile_info.display_name = base::UTF16ToUTF8(user->GetDisplayName());
+    // TODO(hirono): Remove the property from the profile_info.
+    profile_info.is_current_profile = true;
+
+    result_profiles.push_back(std::move(profile_info));
+  }
+
+  return result_profiles;
+}
+
+// Converts a list of file system urls (as strings) to a pair of a provided file
+// system object and a list of unique paths on the file system. In case of an
+// error, false is returned and the error message set.
+bool ConvertURLsToProvidedInfo(
+    const scoped_refptr<storage::FileSystemContext>& file_system_context,
+    const std::vector<std::string>& urls,
+    chromeos::file_system_provider::ProvidedFileSystemInterface** file_system,
+    std::vector<base::FilePath>* paths,
+    std::string* error) {
+  DCHECK(file_system);
+  DCHECK(error);
+
+  if (urls.empty()) {
+    *error = "At least one file must be specified.";
+    return false;
+  }
+
+  *file_system = nullptr;
+  for (const auto url : urls) {
+    const storage::FileSystemURL file_system_url(
+        file_system_context->CrackURL(GURL(url)));
+
+    chromeos::file_system_provider::util::FileSystemURLParser parser(
+        file_system_url);
+    if (!parser.Parse()) {
+      *error = "Related provided file system not found.";
+      return false;
+    }
+
+    if (*file_system != nullptr) {
+      if (*file_system != parser.file_system()) {
+        *error = "All entries must be on the same file system.";
+        return false;
+      }
+    } else {
+      *file_system = parser.file_system();
+    }
+    paths->push_back(parser.file_path());
+  }
+
+  // Erase duplicates.
+  std::sort(paths->begin(), paths->end());
+  paths->erase(std::unique(paths->begin(), paths->end()), paths->end());
+
+  return true;
+}
+
+bool IsAllowedSource(storage::FileSystemType type,
+                     api::file_manager_private::SourceRestriction restriction) {
+  switch (restriction) {
+    case api::file_manager_private::SOURCE_RESTRICTION_NONE:
+      NOTREACHED();
+      return false;
+
+    case api::file_manager_private::SOURCE_RESTRICTION_ANY_SOURCE:
+      return true;
+
+    case api::file_manager_private::SOURCE_RESTRICTION_NATIVE_SOURCE:
+      return type == storage::kFileSystemTypeNativeLocal;
+
+    case api::file_manager_private::SOURCE_RESTRICTION_NATIVE_OR_DRIVE_SOURCE:
+      return type == storage::kFileSystemTypeNativeLocal ||
+             type == storage::kFileSystemTypeDrive;
+  }
+}
+
+}  // namespace
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateLogoutUserForReauthenticationFunction::Run() {
+  const user_manager::User* user =
+      chromeos::ProfileHelper::Get()->GetUserByProfile(
+          Profile::FromBrowserContext(browser_context()));
+  if (user) {
+    user_manager::UserManager::Get()->SaveUserOAuthStatus(
+        user->GetAccountId(), user_manager::User::OAUTH2_TOKEN_STATUS_INVALID);
+  }
+
+  chrome::AttemptUserExit();
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateGetPreferencesFunction::Run() {
+  api::file_manager_private::Preferences result;
+  Profile* profile = Profile::FromBrowserContext(browser_context());
+  const PrefService* const service = profile->GetPrefs();
+
+  result.drive_enabled = drive::util::IsDriveEnabledForProfile(profile);
+  result.cellular_disabled =
+      service->GetBoolean(drive::prefs::kDisableDriveOverCellular);
+  result.hosted_files_disabled =
+      service->GetBoolean(drive::prefs::kDisableDriveHostedFiles);
+  result.search_suggest_enabled =
+      service->GetBoolean(prefs::kSearchSuggestEnabled);
+  result.use24hour_clock = service->GetBoolean(prefs::kUse24HourClock);
+  result.allow_redeem_offers = true;
+  if (!chromeos::CrosSettings::Get()->GetBoolean(
+          chromeos::kAllowRedeemChromeOsRegistrationOffers,
+          &result.allow_redeem_offers)) {
+    result.allow_redeem_offers = true;
+  }
+  result.timezone =
+      base::UTF16ToUTF8(chromeos::system::TimezoneSettings::GetInstance()
+                            ->GetCurrentTimezoneID());
+
+  drive::EventLogger* logger = file_manager::util::GetLogger(profile);
+  if (logger)
+    logger->Log(logging::LOG_INFO, "%s succeeded.", name());
+
+  return RespondNow(OneArgument(result.ToValue()));
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateSetPreferencesFunction::Run() {
+  using extensions::api::file_manager_private::SetPreferences::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  Profile* profile = Profile::FromBrowserContext(browser_context());
+  PrefService* const service = profile->GetPrefs();
+
+  if (params->change_info.cellular_disabled)
+    service->SetBoolean(drive::prefs::kDisableDriveOverCellular,
+                        *params->change_info.cellular_disabled);
+
+  if (params->change_info.hosted_files_disabled)
+    service->SetBoolean(drive::prefs::kDisableDriveHostedFiles,
+                        *params->change_info.hosted_files_disabled);
+
+  drive::EventLogger* logger = file_manager::util::GetLogger(profile);
+  if (logger)
+    logger->Log(logging::LOG_INFO, "%s succeeded.", name());
+  return RespondNow(NoArguments());
+}
+
+FileManagerPrivateInternalZipSelectionFunction::
+    FileManagerPrivateInternalZipSelectionFunction() = default;
+
+FileManagerPrivateInternalZipSelectionFunction::
+    ~FileManagerPrivateInternalZipSelectionFunction() = default;
+
+bool FileManagerPrivateInternalZipSelectionFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::ZipSelection::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  // First param is the parent directory URL.
+  if (params->parent_url.empty())
+    return false;
+
+  base::FilePath src_dir = file_manager::util::GetLocalPathFromURL(
+      render_frame_host(), GetProfile(), GURL(params->parent_url));
+  if (src_dir.empty())
+    return false;
+
+  // Second param is the list of selected file URLs to be zipped.
+  if (params->urls.empty())
+    return false;
+
+  std::vector<base::FilePath> files;
+  for (size_t i = 0; i < params->urls.size(); ++i) {
+    base::FilePath path = file_manager::util::GetLocalPathFromURL(
+        render_frame_host(), GetProfile(), GURL(params->urls[i]));
+    if (path.empty())
+      return false;
+    files.push_back(path);
+  }
+
+  // Third param is the name of the output zip file.
+  if (params->dest_name.empty())
+    return false;
+
+  // Check if the dir path is under Drive mount point.
+  // TODO(hshi): support create zip file on Drive (crbug.com/158690).
+  if (drive::util::IsUnderDriveMountPoint(src_dir))
+    return false;
+
+  base::FilePath dest_file = src_dir.Append(params->dest_name);
+  std::vector<base::FilePath> src_relative_paths;
+  for (size_t i = 0; i != files.size(); ++i) {
+    const base::FilePath& file_path = files[i];
+
+    // Obtain the relative path of |file_path| under |src_dir|.
+    base::FilePath relative_path;
+    if (!src_dir.AppendRelativePath(file_path, &relative_path))
+      return false;
+    src_relative_paths.push_back(relative_path);
+  }
+
+  (new ZipFileCreator(
+       base::Bind(&FileManagerPrivateInternalZipSelectionFunction::OnZipDone,
+                  this),
+       src_dir, src_relative_paths, dest_file))
+      ->Start(
+          content::ServiceManagerConnection::GetForProcess()->GetConnector());
+  return true;
+}
+
+void FileManagerPrivateInternalZipSelectionFunction::OnZipDone(bool success) {
+  SetResult(std::make_unique<base::Value>(success));
+  SendResponse(true);
+}
+
+ExtensionFunction::ResponseAction FileManagerPrivateZoomFunction::Run() {
+  using extensions::api::file_manager_private::Zoom::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  content::PageZoom zoom_type;
+  switch (params->operation) {
+    case api::file_manager_private::ZOOM_OPERATION_TYPE_IN:
+      zoom_type = content::PAGE_ZOOM_IN;
+      break;
+    case api::file_manager_private::ZOOM_OPERATION_TYPE_OUT:
+      zoom_type = content::PAGE_ZOOM_OUT;
+      break;
+    case api::file_manager_private::ZOOM_OPERATION_TYPE_RESET:
+      zoom_type = content::PAGE_ZOOM_RESET;
+      break;
+    default:
+      NOTREACHED();
+      return RespondNow(Error(kUnknownErrorDoNotUse));
+  }
+  zoom::PageZoom::Zoom(GetSenderWebContents(), zoom_type);
+  return RespondNow(NoArguments());
+}
+
+FileManagerPrivateRequestWebStoreAccessTokenFunction::
+    FileManagerPrivateRequestWebStoreAccessTokenFunction() = default;
+
+FileManagerPrivateRequestWebStoreAccessTokenFunction::
+    ~FileManagerPrivateRequestWebStoreAccessTokenFunction() = default;
+
+bool FileManagerPrivateRequestWebStoreAccessTokenFunction::RunAsync() {
+  std::vector<std::string> scopes;
+  scopes.emplace_back(kCWSScope);
+
+  ProfileOAuth2TokenService* oauth_service =
+      ProfileOAuth2TokenServiceFactory::GetForProfile(GetProfile());
+
+  if (!oauth_service) {
+    drive::EventLogger* logger = file_manager::util::GetLogger(GetProfile());
+    if (logger) {
+      logger->Log(logging::LOG_ERROR,
+                  "CWS OAuth token fetch failed. OAuth2TokenService can't "
+                  "be retrieved.");
+    }
+    SetResult(std::make_unique<base::Value>());
+    return false;
+  }
+
+  SigninManagerBase* signin_manager =
+      SigninManagerFactory::GetForProfile(GetProfile());
+  auth_service_ = std::make_unique<google_apis::AuthService>(
+      oauth_service, signin_manager->GetAuthenticatedAccountId(),
+      g_browser_process->system_network_context_manager()
+          ->GetSharedURLLoaderFactory(),
+      scopes);
+  auth_service_->StartAuthentication(base::Bind(
+      &FileManagerPrivateRequestWebStoreAccessTokenFunction::
+          OnAccessTokenFetched,
+      this));
+
+  return true;
+}
+
+void FileManagerPrivateRequestWebStoreAccessTokenFunction::OnAccessTokenFetched(
+    google_apis::DriveApiErrorCode code,
+    const std::string& access_token) {
+  drive::EventLogger* logger = file_manager::util::GetLogger(GetProfile());
+
+  if (code == google_apis::HTTP_SUCCESS) {
+    DCHECK(auth_service_->HasAccessToken());
+    DCHECK(access_token == auth_service_->access_token());
+    if (logger)
+      logger->Log(logging::LOG_INFO, "CWS OAuth token fetch succeeded.");
+    SetResult(std::make_unique<base::Value>(access_token));
+    SendResponse(true);
+  } else {
+    if (logger) {
+      logger->Log(logging::LOG_ERROR,
+                  "CWS OAuth token fetch failed. (DriveApiErrorCode: %s)",
+                  google_apis::DriveApiErrorCodeToString(code).c_str());
+    }
+    SetResult(std::make_unique<base::Value>());
+    SendResponse(false);
+  }
+}
+
+ExtensionFunction::ResponseAction FileManagerPrivateGetProfilesFunction::Run() {
+  const std::vector<ProfileInfo>& profiles = GetLoggedInProfileInfoList();
+
+  // Obtains the display profile ID.
+  AppWindow* const app_window = GetCurrentAppWindow(this);
+  MultiUserWindowManager* const window_manager =
+      MultiUserWindowManager::GetInstance();
+  const AccountId current_profile_id = multi_user_util::GetAccountIdFromProfile(
+      Profile::FromBrowserContext(browser_context()));
+  const AccountId display_profile_id =
+      window_manager && app_window
+          ? window_manager->GetUserPresentingWindow(
+                app_window->GetNativeWindow())
+          : EmptyAccountId();
+
+  return RespondNow(
+      ArgumentList(api::file_manager_private::GetProfiles::Results::Create(
+          profiles, current_profile_id.GetUserEmail(),
+          display_profile_id.is_valid() ? display_profile_id.GetUserEmail()
+                                        : current_profile_id.GetUserEmail())));
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateOpenInspectorFunction::Run() {
+  using extensions::api::file_manager_private::OpenInspector::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  switch (params->type) {
+    case extensions::api::file_manager_private::INSPECTION_TYPE_NORMAL:
+      // Open inspector for foreground page.
+      DevToolsWindow::OpenDevToolsWindow(GetSenderWebContents());
+      break;
+    case extensions::api::file_manager_private::INSPECTION_TYPE_CONSOLE:
+      // Open inspector for foreground page and bring focus to the console.
+      DevToolsWindow::OpenDevToolsWindow(
+          GetSenderWebContents(), DevToolsToggleAction::ShowConsolePanel());
+      break;
+    case extensions::api::file_manager_private::INSPECTION_TYPE_ELEMENT:
+      // Open inspector for foreground page in inspect element mode.
+      DevToolsWindow::OpenDevToolsWindow(GetSenderWebContents(),
+                                         DevToolsToggleAction::Inspect());
+      break;
+    case extensions::api::file_manager_private::INSPECTION_TYPE_BACKGROUND:
+      // Open inspector for background page.
+      extensions::devtools_util::InspectBackgroundPage(
+          extension(), Profile::FromBrowserContext(browser_context()));
+      break;
+    default:
+      NOTREACHED();
+      return RespondNow(Error(
+          base::StringPrintf("Unexpected inspection type(%d) is specified.",
+                             static_cast<int>(params->type))));
+  }
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateOpenSettingsSubpageFunction::Run() {
+  using extensions::api::file_manager_private::OpenSettingsSubpage::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  chrome::ShowSettingsSubPageForProfile(ProfileManager::GetActiveUserProfile(),
+                                        params->sub_page);
+  return RespondNow(NoArguments());
+}
+
+FileManagerPrivateInternalGetMimeTypeFunction::
+    FileManagerPrivateInternalGetMimeTypeFunction() = default;
+
+FileManagerPrivateInternalGetMimeTypeFunction::
+    ~FileManagerPrivateInternalGetMimeTypeFunction() = default;
+
+bool FileManagerPrivateInternalGetMimeTypeFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::GetMimeType::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  // Convert file url to local path.
+  const scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  storage::FileSystemURL file_system_url(
+      file_system_context->CrackURL(GURL(params->url)));
+
+  app_file_handler_util::GetMimeTypeForLocalPath(
+      GetProfile(), file_system_url.path(),
+      base::Bind(&FileManagerPrivateInternalGetMimeTypeFunction::OnGetMimeType,
+                 this));
+
+  return true;
+}
+
+void FileManagerPrivateInternalGetMimeTypeFunction::OnGetMimeType(
+    const std::string& mimeType) {
+  SetResult(std::make_unique<base::Value>(mimeType));
+  SendResponse(true);
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateIsPiexLoaderEnabledFunction::Run() {
+#if defined(OFFICIAL_BUILD)
+  return RespondNow(OneArgument(std::make_unique<base::Value>(true)));
+#else
+  return RespondNow(OneArgument(std::make_unique<base::Value>(false)));
+#endif
+}
+
+FileManagerPrivateGetProvidersFunction::FileManagerPrivateGetProvidersFunction()
+    : chrome_details_(this) {}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateGetProvidersFunction::Run() {
+  using chromeos::file_system_provider::Capabilities;
+  using chromeos::file_system_provider::IconSet;
+  using chromeos::file_system_provider::ProviderId;
+  using chromeos::file_system_provider::ProviderInterface;
+  using chromeos::file_system_provider::Service;
+  const Service* const service = Service::Get(chrome_details_.GetProfile());
+
+  using api::file_manager_private::Provider;
+  std::vector<Provider> result;
+  for (const auto& pair : service->GetProviders()) {
+    const ProviderInterface* const provider = pair.second.get();
+    const ProviderId provider_id = provider->GetId();
+
+    Provider result_item;
+    result_item.provider_id = provider->GetId().ToString();
+    const IconSet& icon_set = provider->GetIconSet();
+    file_manager::util::FillIconSet(&result_item.icon_set, icon_set);
+    result_item.name = provider->GetName();
+
+    const Capabilities capabilities = provider->GetCapabilities();
+    result_item.configurable = capabilities.configurable;
+    result_item.watchable = capabilities.watchable;
+    result_item.multiple_mounts = capabilities.multiple_mounts;
+    switch (capabilities.source) {
+      case SOURCE_FILE:
+        result_item.source =
+            api::manifest_types::FILE_SYSTEM_PROVIDER_SOURCE_FILE;
+        break;
+      case SOURCE_DEVICE:
+        result_item.source =
+            api::manifest_types::FILE_SYSTEM_PROVIDER_SOURCE_DEVICE;
+        break;
+      case SOURCE_NETWORK:
+        result_item.source =
+            api::manifest_types::FILE_SYSTEM_PROVIDER_SOURCE_NETWORK;
+        break;
+    }
+    result.push_back(std::move(result_item));
+  }
+
+  return RespondNow(ArgumentList(
+      api::file_manager_private::GetProviders::Results::Create(result)));
+}
+
+FileManagerPrivateAddProvidedFileSystemFunction::
+    FileManagerPrivateAddProvidedFileSystemFunction()
+    : chrome_details_(this) {
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateAddProvidedFileSystemFunction::Run() {
+  using extensions::api::file_manager_private::AddProvidedFileSystem::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  using chromeos::file_system_provider::Service;
+  using chromeos::file_system_provider::ProvidingExtensionInfo;
+  using chromeos::file_system_provider::ProviderId;
+  Service* const service = Service::Get(chrome_details_.GetProfile());
+
+  if (!service->RequestMount(ProviderId::FromString(params->provider_id)))
+    return RespondNow(Error("Failed to request a new mount."));
+
+  return RespondNow(NoArguments());
+}
+
+FileManagerPrivateConfigureVolumeFunction::
+    FileManagerPrivateConfigureVolumeFunction()
+    : chrome_details_(this) {
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateConfigureVolumeFunction::Run() {
+  using extensions::api::file_manager_private::ConfigureVolume::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  using file_manager::VolumeManager;
+  using file_manager::Volume;
+  VolumeManager* const volume_manager =
+      VolumeManager::Get(chrome_details_.GetProfile());
+  base::WeakPtr<Volume> volume =
+      volume_manager->FindVolumeById(params->volume_id);
+  if (!volume.get())
+    return RespondNow(Error("Volume not found."));
+  if (!volume->configurable())
+    return RespondNow(Error("Volume not configurable."));
+
+  switch (volume->type()) {
+    case file_manager::VOLUME_TYPE_PROVIDED: {
+      using chromeos::file_system_provider::Service;
+      Service* const service = Service::Get(chrome_details_.GetProfile());
+      DCHECK(service);
+
+      using chromeos::file_system_provider::ProvidedFileSystemInterface;
+      ProvidedFileSystemInterface* const file_system =
+          service->GetProvidedFileSystem(volume->provider_id(),
+                                         volume->file_system_id());
+      if (file_system)
+        file_system->Configure(base::Bind(
+            &FileManagerPrivateConfigureVolumeFunction::OnCompleted, this));
+      break;
+    }
+    default:
+      NOTIMPLEMENTED();
+  }
+
+  return RespondLater();
+}
+
+void FileManagerPrivateConfigureVolumeFunction::OnCompleted(
+    base::File::Error result) {
+  if (result != base::File::FILE_OK) {
+    Respond(Error("Failed to complete configuration."));
+    return;
+  }
+
+  Respond(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateIsCrostiniEnabledFunction::Run() {
+  return RespondNow(OneArgument(std::make_unique<base::Value>(
+      IsCrostiniEnabled(Profile::FromBrowserContext(browser_context())))));
+}
+
+FileManagerPrivateMountCrostiniContainerFunction::
+    FileManagerPrivateMountCrostiniContainerFunction() = default;
+
+FileManagerPrivateMountCrostiniContainerFunction::
+    ~FileManagerPrivateMountCrostiniContainerFunction() = default;
+
+bool FileManagerPrivateMountCrostiniContainerFunction::RunAsync() {
+  Profile* profile = Profile::FromBrowserContext(browser_context());
+  DCHECK(IsCrostiniEnabled(profile));
+  crostini::CrostiniManager::GetInstance()->RestartCrostini(
+      profile, kCrostiniDefaultVmName, kCrostiniDefaultContainerName,
+      base::BindOnce(
+          &FileManagerPrivateMountCrostiniContainerFunction::RestartCallback,
+          this));
+  return true;
+}
+
+void FileManagerPrivateMountCrostiniContainerFunction::RestartCallback(
+    crostini::ConciergeClientResult result) {
+  if (result != crostini::ConciergeClientResult::SUCCESS) {
+    Respond(Error(
+        base::StringPrintf("Error mounting crostini container: %d", result)));
+    return;
+  }
+  Respond(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateInternalInstallLinuxPackageFunction::Run() {
+  using extensions::api::file_manager_private_internal::InstallLinuxPackage::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  Profile* profile = Profile::FromBrowserContext(browser_context());
+  const scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          profile, render_frame_host());
+
+  std::string url =
+      file_manager::util::ConvertFileSystemURLToPathInsideCrostini(
+          profile, file_system_context->CrackURL(GURL(params->url)));
+  crostini::CrostiniPackageInstallerService::GetForProfile(profile)
+      ->InstallLinuxPackage(
+          kCrostiniDefaultVmName, kCrostiniDefaultContainerName, url,
+          base::BindOnce(
+              &FileManagerPrivateInternalInstallLinuxPackageFunction::
+                  OnInstallLinuxPackage,
+              this));
+  return RespondLater();
+}
+
+void FileManagerPrivateInternalInstallLinuxPackageFunction::
+    OnInstallLinuxPackage(crostini::ConciergeClientResult result,
+                          const std::string& failure_reason) {
+  extensions::api::file_manager_private::InstallLinuxPackageResponse response;
+  switch (result) {
+    case crostini::ConciergeClientResult::SUCCESS:
+      response = extensions::api::file_manager_private::
+          INSTALL_LINUX_PACKAGE_RESPONSE_STARTED;
+      break;
+    case crostini::ConciergeClientResult::INSTALL_LINUX_PACKAGE_FAILED:
+      response = extensions::api::file_manager_private::
+          INSTALL_LINUX_PACKAGE_RESPONSE_FAILED;
+      break;
+    case crostini::ConciergeClientResult::INSTALL_LINUX_PACKAGE_ALREADY_ACTIVE:
+      response = extensions::api::file_manager_private::
+          INSTALL_LINUX_PACKAGE_RESPONSE_INSTALL_ALREADY_ACTIVE;
+      break;
+    default:
+      NOTREACHED();
+  }
+  Respond(ArgumentList(
+      extensions::api::file_manager_private_internal::InstallLinuxPackage::
+          Results::Create(response, failure_reason)));
+}
+
+FileManagerPrivateInternalGetCustomActionsFunction::
+    FileManagerPrivateInternalGetCustomActionsFunction()
+    : chrome_details_(this) {}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateInternalGetCustomActionsFunction::Run() {
+  using extensions::api::file_manager_private_internal::GetCustomActions::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          chrome_details_.GetProfile(), render_frame_host());
+
+  std::vector<base::FilePath> paths;
+  chromeos::file_system_provider::ProvidedFileSystemInterface* file_system =
+      nullptr;
+  std::string error;
+
+  if (!ConvertURLsToProvidedInfo(file_system_context, params->urls,
+                                 &file_system, &paths, &error)) {
+    return RespondNow(Error(error));
+  }
+
+  DCHECK(file_system);
+  file_system->GetActions(
+      paths,
+      base::Bind(
+          &FileManagerPrivateInternalGetCustomActionsFunction::OnCompleted,
+          this));
+  return RespondLater();
+}
+
+void FileManagerPrivateInternalGetCustomActionsFunction::OnCompleted(
+    const chromeos::file_system_provider::Actions& actions,
+    base::File::Error result) {
+  if (result != base::File::FILE_OK) {
+    Respond(Error("Failed to fetch actions."));
+    return;
+  }
+
+  using api::file_system_provider::Action;
+  std::vector<Action> items;
+  for (const auto& action : actions) {
+    Action item;
+    item.id = action.id;
+    item.title = std::make_unique<std::string>(action.title);
+    items.push_back(std::move(item));
+  }
+
+  Respond(ArgumentList(
+      api::file_manager_private_internal::GetCustomActions::Results::Create(
+          items)));
+}
+
+FileManagerPrivateInternalExecuteCustomActionFunction::
+    FileManagerPrivateInternalExecuteCustomActionFunction()
+    : chrome_details_(this) {}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateInternalExecuteCustomActionFunction::Run() {
+  using extensions::api::file_manager_private_internal::ExecuteCustomAction::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          chrome_details_.GetProfile(), render_frame_host());
+
+  std::vector<base::FilePath> paths;
+  chromeos::file_system_provider::ProvidedFileSystemInterface* file_system =
+      nullptr;
+  std::string error;
+
+  if (!ConvertURLsToProvidedInfo(file_system_context, params->urls,
+                                 &file_system, &paths, &error)) {
+    return RespondNow(Error(error));
+  }
+
+  DCHECK(file_system);
+  file_system->ExecuteAction(
+      paths, params->action_id,
+      base::Bind(
+          &FileManagerPrivateInternalExecuteCustomActionFunction::OnCompleted,
+          this));
+  return RespondLater();
+}
+
+void FileManagerPrivateInternalExecuteCustomActionFunction::OnCompleted(
+    base::File::Error result) {
+  if (result != base::File::FILE_OK) {
+    Respond(Error("Failed to execute the action."));
+    return;
+  }
+
+  Respond(NoArguments());
+}
+
+FileManagerPrivateInternalGetRecentFilesFunction::
+    FileManagerPrivateInternalGetRecentFilesFunction()
+    : chrome_details_(this) {}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateInternalGetRecentFilesFunction::Run() {
+  using extensions::api::file_manager_private_internal::GetRecentFiles::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          chrome_details_.GetProfile(), render_frame_host());
+
+  chromeos::RecentModel* model =
+      chromeos::RecentModel::GetForProfile(chrome_details_.GetProfile());
+
+  model->GetRecentFiles(
+      file_system_context.get(),
+      Extension::GetBaseURLFromExtensionId(extension_id()),
+      base::BindOnce(
+          &FileManagerPrivateInternalGetRecentFilesFunction::OnGetRecentFiles,
+          this, params->restriction));
+  return RespondLater();
+}
+
+void FileManagerPrivateInternalGetRecentFilesFunction::OnGetRecentFiles(
+    api::file_manager_private::SourceRestriction restriction,
+    const std::vector<chromeos::RecentFile>& files) {
+  file_manager::util::FileDefinitionList file_definition_list;
+  for (const auto& file : files) {
+    // Filter out files from non-allowed sources.
+    // We do this filtering here rather than in RecentModel so that the set of
+    // files returned with some restriction is a subset of what would be
+    // returned without restriction. Anyway, the maximum number of files
+    // returned from RecentModel is large enough.
+    if (!IsAllowedSource(file.url().type(), restriction))
+      continue;
+
+    file_manager::util::FileDefinition file_definition;
+    const bool result =
+        file_manager::util::ConvertAbsoluteFilePathToRelativeFileSystemPath(
+            chrome_details_.GetProfile(), extension_id(), file.url().path(),
+            &file_definition.virtual_path);
+    if (!result)
+      continue;
+
+    // Recent file system only lists regular files, not directories.
+    file_definition.is_directory = false;
+    file_definition_list.emplace_back(std::move(file_definition));
+  }
+
+  file_manager::util::ConvertFileDefinitionListToEntryDefinitionList(
+      chrome_details_.GetProfile(), extension_id(),
+      file_definition_list,  // Safe, since copied internally.
+      base::Bind(&FileManagerPrivateInternalGetRecentFilesFunction::
+                     OnConvertFileDefinitionListToEntryDefinitionList,
+                 this));
+}
+
+void FileManagerPrivateInternalGetRecentFilesFunction::
+    OnConvertFileDefinitionListToEntryDefinitionList(
+        std::unique_ptr<file_manager::util::EntryDefinitionList>
+            entry_definition_list) {
+  DCHECK(entry_definition_list);
+
+  auto entries = std::make_unique<base::ListValue>();
+
+  for (const auto& definition : *entry_definition_list) {
+    if (definition.error != base::File::FILE_OK)
+      continue;
+    auto entry = std::make_unique<base::DictionaryValue>();
+    entry->SetString("fileSystemName", definition.file_system_name);
+    entry->SetString("fileSystemRoot", definition.file_system_root_url);
+    entry->SetString("fileFullPath", "/" + definition.full_path.AsUTF8Unsafe());
+    entry->SetBoolean("fileIsDirectory", definition.is_directory);
+    entries->Append(std::move(entry));
+  }
+
+  Respond(OneArgument(std::move(entries)));
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_manager/chromeos/private_api_misc.h b/chrome/browser/extensions/api/file_manager/chromeos/private_api_misc.h
new file mode 100644
index 0000000000000..b45a19876d713
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/chromeos/private_api_misc.h
@@ -0,0 +1,382 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides miscellaneous API functions, which don't belong to
+// other files.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_CHROMEOS_PRIVATE_API_MISC_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_CHROMEOS_PRIVATE_API_MISC_H_
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/files/file.h"
+#include "base/macros.h"
+#include "chrome/browser/chromeos/file_system_provider/provided_file_system_interface.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_base.h"
+#include "chrome/browser/extensions/chrome_extension_function.h"
+#include "chrome/browser/extensions/chrome_extension_function_details.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "google_apis/drive/drive_api_error_codes.h"
+#include "storage/browser/fileapi/file_system_url.h"
+
+namespace chromeos {
+class RecentFile;
+}  // namespace chromeos
+
+namespace crostini {
+enum class ConciergeClientResult;
+}
+
+namespace file_manager {
+namespace util {
+struct EntryDefinition;
+typedef std::vector<EntryDefinition> EntryDefinitionList;
+}  // namespace util
+}  // namespace file_manager
+
+namespace google_apis {
+class AuthServiceInterface;
+}  // namespace google_apis
+
+namespace extensions {
+
+// Implements the chrome.fileManagerPrivate.logoutUserForReauthentication
+// method.
+class FileManagerPrivateLogoutUserForReauthenticationFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.logoutUserForReauthentication",
+                             FILEMANAGERPRIVATE_LOGOUTUSERFORREAUTHENTICATION)
+
+ protected:
+  ~FileManagerPrivateLogoutUserForReauthenticationFunction() override = default;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.getPreferences method.
+// Gets settings for the Files app.
+class FileManagerPrivateGetPreferencesFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.getPreferences",
+                             FILEMANAGERPRIVATE_GETPREFERENCES)
+
+ protected:
+  ~FileManagerPrivateGetPreferencesFunction() override = default;
+
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.setPreferences method.
+// Sets settings for the Files app.
+class FileManagerPrivateSetPreferencesFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.setPreferences",
+                             FILEMANAGERPRIVATE_SETPREFERENCES)
+
+ protected:
+  ~FileManagerPrivateSetPreferencesFunction() override = default;
+
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.zipSelection method.
+// Creates a zip file for the selected files.
+class FileManagerPrivateInternalZipSelectionFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.zipSelection",
+                             FILEMANAGERPRIVATEINTERNAL_ZIPSELECTION)
+
+  FileManagerPrivateInternalZipSelectionFunction();
+
+ protected:
+  ~FileManagerPrivateInternalZipSelectionFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+  // Receives the result from ZipFileCreator.
+  void OnZipDone(bool success);
+};
+
+// Implements the chrome.fileManagerPrivate.zoom method.
+// Changes the zoom level of the file manager by modifying the zoom level of the
+// WebContents.
+// TODO(hirono): Remove this function once the zoom level change is supported
+// for all apps. crbug.com/227175.
+class FileManagerPrivateZoomFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.zoom",
+                             FILEMANAGERPRIVATE_ZOOM);
+
+ protected:
+  ~FileManagerPrivateZoomFunction() override = default;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+};
+
+class FileManagerPrivateRequestWebStoreAccessTokenFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.requestWebStoreAccessToken",
+                             FILEMANAGERPRIVATE_REQUESTWEBSTOREACCESSTOKEN);
+
+  FileManagerPrivateRequestWebStoreAccessTokenFunction();
+
+ protected:
+  ~FileManagerPrivateRequestWebStoreAccessTokenFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  std::unique_ptr<google_apis::AuthServiceInterface> auth_service_;
+
+  void OnAccessTokenFetched(google_apis::DriveApiErrorCode code,
+                            const std::string& access_token);
+};
+
+class FileManagerPrivateGetProfilesFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.getProfiles",
+                             FILEMANAGERPRIVATE_GETPROFILES);
+
+ protected:
+  ~FileManagerPrivateGetProfilesFunction() override = default;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.openInspector method.
+class FileManagerPrivateOpenInspectorFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.openInspector",
+                             FILEMANAGERPRIVATE_OPENINSPECTOR);
+
+ protected:
+  ~FileManagerPrivateOpenInspectorFunction() override = default;
+
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.openSettingsSubpage method.
+class FileManagerPrivateOpenSettingsSubpageFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.openSettingsSubpage",
+                             FILEMANAGERPRIVATE_OPENSETTINGSSUBPAGE);
+
+ protected:
+  ~FileManagerPrivateOpenSettingsSubpageFunction() override = default;
+
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.getMimeType method.
+class FileManagerPrivateInternalGetMimeTypeFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getMimeType",
+                             FILEMANAGERPRIVATEINTERNAL_GETMIMETYPE)
+
+  FileManagerPrivateInternalGetMimeTypeFunction();
+
+ protected:
+  ~FileManagerPrivateInternalGetMimeTypeFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+  void OnGetMimeType(const std::string& mimeType);
+};
+
+// Implements the chrome.fileManagerPrivate.isPiexLoaderEnabled method.
+class FileManagerPrivateIsPiexLoaderEnabledFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateIsPiexLoaderEnabledFunction() = default;
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.isPiexLoaderEnabled",
+                             FILEMANAGERPRIVATE_ISPIEXLOADERENABLED)
+ protected:
+  ~FileManagerPrivateIsPiexLoaderEnabledFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateIsPiexLoaderEnabledFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.getProviders method.
+class FileManagerPrivateGetProvidersFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateGetProvidersFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.getProviders",
+                             FILEMANAGERPRIVATE_GETPROVIDERS)
+ protected:
+  ~FileManagerPrivateGetProvidersFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  const ChromeExtensionFunctionDetails chrome_details_;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateGetProvidersFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.addProvidedFileSystem method.
+class FileManagerPrivateAddProvidedFileSystemFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateAddProvidedFileSystemFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.addProvidedFileSystem",
+                             FILEMANAGERPRIVATE_ADDPROVIDEDFILESYSTEM)
+ protected:
+  ~FileManagerPrivateAddProvidedFileSystemFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  const ChromeExtensionFunctionDetails chrome_details_;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateAddProvidedFileSystemFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.configureVolume method.
+class FileManagerPrivateConfigureVolumeFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateConfigureVolumeFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.configureVolume",
+                             FILEMANAGERPRIVATE_CONFIGUREVOLUME)
+ protected:
+  ~FileManagerPrivateConfigureVolumeFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  void OnCompleted(base::File::Error result);
+
+  const ChromeExtensionFunctionDetails chrome_details_;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateConfigureVolumeFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.isCrostiniEnabled method.
+// Gets crostini sftp mount params.
+class FileManagerPrivateIsCrostiniEnabledFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.isCrostiniEnabled",
+                             FILEMANAGERPRIVATE_ISCROSTINIENABLED)
+
+ protected:
+  ~FileManagerPrivateIsCrostiniEnabledFunction() override = default;
+
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.mountCrostiniContainer method.
+// Starts and mounts crostini container.
+class FileManagerPrivateMountCrostiniContainerFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.mountCrostiniContainer",
+                             FILEMANAGERPRIVATE_MOUNTCROSTINICONTAINER)
+  FileManagerPrivateMountCrostiniContainerFunction();
+
+ protected:
+  ~FileManagerPrivateMountCrostiniContainerFunction() override;
+
+  bool RunAsync() override;
+  void RestartCallback(crostini::ConciergeClientResult);
+
+ private:
+  std::string source_path_;
+  std::string mount_label_;
+};
+
+// Implements the chrome.fileManagerPrivate.installLinuxPackage method.
+// Starts installation of a Linux package.
+class FileManagerPrivateInternalInstallLinuxPackageFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.installLinuxPackage",
+                             FILEMANAGERPRIVATEINTERNAL_INSTALLLINUXPACKAGE)
+
+ protected:
+  ~FileManagerPrivateInternalInstallLinuxPackageFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  void OnInstallLinuxPackage(crostini::ConciergeClientResult result,
+                             const std::string& failure_reason);
+};
+
+// Implements the chrome.fileManagerPrivate.getCustomActions method.
+class FileManagerPrivateInternalGetCustomActionsFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateInternalGetCustomActionsFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getCustomActions",
+                             FILEMANAGERPRIVATEINTERNAL_GETCUSTOMACTIONS)
+ protected:
+  ~FileManagerPrivateInternalGetCustomActionsFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  void OnCompleted(const chromeos::file_system_provider::Actions& actions,
+                   base::File::Error result);
+
+  const ChromeExtensionFunctionDetails chrome_details_;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateInternalGetCustomActionsFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.executeCustomAction method.
+class FileManagerPrivateInternalExecuteCustomActionFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateInternalExecuteCustomActionFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.executeCustomAction",
+                             FILEMANAGERPRIVATEINTERNAL_EXECUTECUSTOMACTION)
+ protected:
+  ~FileManagerPrivateInternalExecuteCustomActionFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  void OnCompleted(base::File::Error result);
+
+  const ChromeExtensionFunctionDetails chrome_details_;
+  DISALLOW_COPY_AND_ASSIGN(
+      FileManagerPrivateInternalExecuteCustomActionFunction);
+};
+
+// Implements the chrome.fileManagerPrivateInternal.getRecentFiles method.
+class FileManagerPrivateInternalGetRecentFilesFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateInternalGetRecentFilesFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getRecentFiles",
+                             FILEMANAGERPRIVATE_GETRECENTFILES)
+ protected:
+  ~FileManagerPrivateInternalGetRecentFilesFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  void OnGetRecentFiles(
+      api::file_manager_private::SourceRestriction restriction,
+      const std::vector<chromeos::RecentFile>& files);
+  void OnConvertFileDefinitionListToEntryDefinitionList(
+      std::unique_ptr<file_manager::util::EntryDefinitionList>
+          entry_definition_list);
+
+  const ChromeExtensionFunctionDetails chrome_details_;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateInternalGetRecentFilesFunction);
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_CHROMEOS_PRIVATE_API_MISC_H_
diff --git a/chrome/browser/extensions/api/file_manager/chromeos/private_api_mount.cc b/chrome/browser/extensions/api/file_manager/chromeos/private_api_mount.cc
new file mode 100644
index 0000000000000..6794825e94a25
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/chromeos/private_api_mount.cc
@@ -0,0 +1,391 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/chromeos/private_api_mount.h"
+
+#include <memory>
+#include <string>
+
+#include "base/files/file_util.h"
+#include "base/format_macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/task/post_task.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "chromeos/disks/disk_mount_manager.h"
+#include "components/drive/chromeos/file_system_interface.h"
+#include "components/drive/event_logger.h"
+#include "content/public/browser/browser_thread.h"
+#include "google_apis/drive/task_util.h"
+#include "ui/shell_dialogs/selected_file_info.h"
+
+using chromeos::disks::DiskMountManager;
+using content::BrowserThread;
+namespace file_manager_private = extensions::api::file_manager_private;
+
+namespace extensions {
+
+namespace {
+
+// Does chmod o+r for the given path to ensure the file is readable from avfs.
+void EnsureReadableFilePermissionAsync(
+    const base::FilePath& path,
+    const base::Callback<void(drive::FileError, const base::FilePath&)>&
+        callback) {
+  int mode = 0;
+  if (!base::GetPosixFilePermissions(path, &mode) ||
+      !base::SetPosixFilePermissions(path, mode | S_IROTH)) {
+    callback.Run(drive::FILE_ERROR_ACCESS_DENIED, base::FilePath());
+    return;
+  }
+  callback.Run(drive::FILE_ERROR_OK, path);
+}
+
+}  // namespace
+
+bool FileManagerPrivateAddMountFunction::RunAsync() {
+  using file_manager_private::AddMount::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  drive::EventLogger* logger = file_manager::util::GetLogger(GetProfile());
+  if (logger) {
+    logger->Log(logging::LOG_INFO, "%s[%d] called. (source: '%s')", name(),
+                request_id(),
+                params->source.empty() ? "(none)" : params->source.c_str());
+  }
+  set_log_on_completion(true);
+
+  const base::FilePath path = file_manager::util::GetLocalPathFromURL(
+      render_frame_host(), GetProfile(), GURL(params->source));
+
+  if (path.empty())
+    return false;
+
+  // Check if the source path is under Drive cache directory.
+  if (drive::util::IsUnderDriveMountPoint(path)) {
+    drive::FileSystemInterface* file_system =
+        drive::util::GetFileSystemByProfile(GetProfile());
+    if (!file_system)
+      return false;
+
+    // Ensure that the cache file exists.
+    const base::FilePath drive_path = drive::util::ExtractDrivePath(path);
+    file_system->GetFile(
+        drive_path,
+        base::Bind(&FileManagerPrivateAddMountFunction::RunAfterGetDriveFile,
+                   this,
+                   drive_path));
+  } else {
+    file_manager::VolumeManager* volume_manager =
+        file_manager::VolumeManager::Get(GetProfile());
+    DCHECK(volume_manager);
+
+    bool is_under_downloads = false;
+    const std::vector<base::WeakPtr<file_manager::Volume>> volumes =
+        volume_manager->GetVolumeList();
+    for (const auto& volume : volumes) {
+      if (volume->type() == file_manager::VOLUME_TYPE_DOWNLOADS_DIRECTORY &&
+          volume->mount_path().IsParent(path)) {
+        is_under_downloads = true;
+        break;
+      }
+    }
+
+    if (is_under_downloads) {
+      // For files under downloads, change the file permission and make it
+      // readable from avfs/fuse if needed.
+      base::PostTaskWithTraits(
+          FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_BLOCKING},
+          base::BindOnce(&EnsureReadableFilePermissionAsync, path,
+                         google_apis::CreateRelayCallback(
+                             base::Bind(&FileManagerPrivateAddMountFunction::
+                                            RunAfterMarkCacheFileAsMounted,
+                                        this, path.BaseName()))));
+    } else {
+      RunAfterMarkCacheFileAsMounted(
+          path.BaseName(), drive::FILE_ERROR_OK, path);
+    }
+  }
+  return true;
+}
+
+void FileManagerPrivateAddMountFunction::RunAfterGetDriveFile(
+    const base::FilePath& drive_path,
+    drive::FileError error,
+    const base::FilePath& cache_path,
+    std::unique_ptr<drive::ResourceEntry> entry) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (error != drive::FILE_ERROR_OK) {
+    SendResponse(false);
+    return;
+  }
+
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system) {
+    SendResponse(false);
+    return;
+  }
+
+  file_system->IsCacheFileMarkedAsMounted(
+      drive_path, base::Bind(&FileManagerPrivateAddMountFunction::
+                                 RunAfterIsCacheFileMarkedAsMounted,
+                             this, drive_path, cache_path));
+}
+
+void FileManagerPrivateAddMountFunction::RunAfterIsCacheFileMarkedAsMounted(
+    const base::FilePath& drive_path,
+    const base::FilePath& cache_path,
+    drive::FileError error,
+    bool is_marked_as_mounted) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  if (error != drive::FILE_ERROR_OK) {
+    SetError(FileErrorToString(error));
+    SendResponse(false);
+    return;
+  }
+  if (is_marked_as_mounted) {
+    // When the file is already mounted, we call the mount function as usual,
+    // so that it can issue events containing the VolumeInfo, which is
+    // necessary to make the app navigate to the mounted volume.
+    RunAfterMarkCacheFileAsMounted(drive_path.BaseName(), drive::FILE_ERROR_OK,
+                                   cache_path);
+    return;
+  }
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system) {
+    SendResponse(false);
+    return;
+  }
+  file_system->MarkCacheFileAsMounted(
+      drive_path,
+      base::Bind(
+          &FileManagerPrivateAddMountFunction::RunAfterMarkCacheFileAsMounted,
+          this,
+          drive_path.BaseName()));
+}
+
+void FileManagerPrivateAddMountFunction::RunAfterMarkCacheFileAsMounted(
+    const base::FilePath& display_name,
+    drive::FileError error,
+    const base::FilePath& file_path) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (error != drive::FILE_ERROR_OK) {
+    SendResponse(false);
+    return;
+  }
+
+  // Pass back the actual source path of the mount point.
+  SetResult(std::make_unique<base::Value>(file_path.AsUTF8Unsafe()));
+  SendResponse(true);
+
+  // MountPath() takes a std::string.
+  DiskMountManager* disk_mount_manager = DiskMountManager::GetInstance();
+  disk_mount_manager->MountPath(
+      file_path.AsUTF8Unsafe(),
+      base::FilePath(display_name.Extension()).AsUTF8Unsafe(),
+      display_name.AsUTF8Unsafe(), {}, chromeos::MOUNT_TYPE_ARCHIVE,
+      chromeos::MOUNT_ACCESS_MODE_READ_WRITE);
+}
+
+bool FileManagerPrivateRemoveMountFunction::RunAsync() {
+  using file_manager_private::RemoveMount::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  drive::EventLogger* logger = file_manager::util::GetLogger(GetProfile());
+  if (logger) {
+    logger->Log(logging::LOG_INFO, "%s[%d] called. (volume_id: '%s')", name(),
+                request_id(), params->volume_id.c_str());
+  }
+  set_log_on_completion(true);
+
+  using file_manager::VolumeManager;
+  using file_manager::Volume;
+  VolumeManager* const volume_manager = VolumeManager::Get(GetProfile());
+  DCHECK(volume_manager);
+
+  base::WeakPtr<Volume> volume =
+      volume_manager->FindVolumeById(params->volume_id);
+  if (!volume.get())
+    return false;
+
+  // TODO(tbarzic): Send response when callback is received, it would make more
+  // sense than remembering issued unmount requests in file manager and showing
+  // errors for them when MountCompleted event is received.
+  switch (volume->type()) {
+    case file_manager::VOLUME_TYPE_REMOVABLE_DISK_PARTITION:
+    case file_manager::VOLUME_TYPE_MOUNTED_ARCHIVE_FILE: {
+      chromeos::UnmountOptions unmount_options = chromeos::UNMOUNT_OPTIONS_NONE;
+      if (volume->is_read_only())
+        unmount_options = chromeos::UNMOUNT_OPTIONS_LAZY;
+
+      DiskMountManager::GetInstance()->UnmountPath(
+          volume->mount_path().value(), unmount_options,
+          DiskMountManager::UnmountPathCallback());
+      break;
+    }
+    case file_manager::VOLUME_TYPE_PROVIDED: {
+      chromeos::file_system_provider::Service* service =
+          chromeos::file_system_provider::Service::Get(GetProfile());
+      DCHECK(service);
+      // TODO(mtomasz): Pass a more detailed error than just a bool.
+      if (!service->RequestUnmount(volume->provider_id(),
+                                   volume->file_system_id())) {
+        return false;
+      }
+      break;
+    }
+    default:
+      // Requested unmounting a device which is not unmountable.
+      return false;
+  }
+
+  SendResponse(true);
+  return true;
+}
+
+bool FileManagerPrivateMarkCacheAsMountedFunction::RunAsync() {
+  using file_manager_private::MarkCacheAsMounted::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const base::FilePath path(params->source_path);
+  bool is_mounted = params->is_mounted;
+
+  if (path.empty())
+    return false;
+
+  if (!drive::util::IsUnderDriveMountPoint(path)) {
+    // Ignore non-drive files. Treated as success.
+    SendResponse(true);
+    return true;
+  }
+
+  drive::FileSystemInterface* file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system)
+    return false;
+
+  // Ensure that the cache file exists.
+  const base::FilePath drive_path = drive::util::ExtractDrivePath(path);
+  file_system->GetFile(
+      drive_path,
+      base::Bind(
+          &FileManagerPrivateMarkCacheAsMountedFunction::RunAfterGetDriveFile,
+          this, drive_path, is_mounted));
+  return true;
+}
+
+void FileManagerPrivateMarkCacheAsMountedFunction::RunAfterGetDriveFile(
+    const base::FilePath& drive_path,
+    bool is_mounted,
+    drive::FileError error,
+    const base::FilePath& cache_path,
+    std::unique_ptr<drive::ResourceEntry> entry) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (error != drive::FILE_ERROR_OK) {
+    SetError(FileErrorToString(error));
+    SendResponse(false);
+    return;
+  }
+
+  drive::FileSystemInterface* const file_system =
+      drive::util::GetFileSystemByProfile(GetProfile());
+  if (!file_system) {
+    SendResponse(false);
+    return;
+  }
+
+  // TODO(yamaguchi): Check the current status of the file.
+  // Currently calling this method twice will result in error, although it
+  // doesn't give bad side effect.
+  if (is_mounted) {
+    file_system->MarkCacheFileAsMounted(
+        drive_path, base::Bind(&FileManagerPrivateMarkCacheAsMountedFunction::
+                                   RunAfterMarkCacheFileAsMounted,
+                               this));
+  } else {
+    file_system->MarkCacheFileAsUnmounted(
+        cache_path, base::Bind(&FileManagerPrivateMarkCacheAsMountedFunction::
+                                   RunAfterMarkCacheFileAsUnmounted,
+                               this));
+  }
+}
+
+void FileManagerPrivateMarkCacheAsMountedFunction::
+    RunAfterMarkCacheFileAsMounted(drive::FileError error,
+                                   const base::FilePath& file_path) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  switch (error) {
+    case drive::FILE_ERROR_INVALID_OPERATION:
+    // The file was already marked as mounted. Ignore and treat as success.
+    case drive::FILE_ERROR_OK:
+      SendResponse(true);
+      break;
+    default:
+      SetError(FileErrorToString(error));
+      SendResponse(false);
+  }
+}
+
+void FileManagerPrivateMarkCacheAsMountedFunction::
+    RunAfterMarkCacheFileAsUnmounted(drive::FileError error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  switch (error) {
+    case drive::FILE_ERROR_INVALID_OPERATION:
+    // The file was already marked as unmounted. Ignore and treat as success.
+    case drive::FILE_ERROR_OK:
+      SendResponse(true);
+      break;
+    default:
+      SetError(FileErrorToString(error));
+      SendResponse(false);
+  }
+}
+
+bool FileManagerPrivateGetVolumeMetadataListFunction::RunAsync() {
+  if (args_->GetSize())
+    return false;
+
+  const std::vector<base::WeakPtr<file_manager::Volume>>& volume_list =
+      file_manager::VolumeManager::Get(GetProfile())->GetVolumeList();
+
+  std::string log_string;
+  std::vector<file_manager_private::VolumeMetadata> result;
+  for (const auto& volume : volume_list) {
+    file_manager_private::VolumeMetadata volume_metadata;
+    file_manager::util::VolumeToVolumeMetadata(GetProfile(), *volume,
+                                               &volume_metadata);
+    result.push_back(std::move(volume_metadata));
+    if (!log_string.empty())
+      log_string += ", ";
+    log_string += volume->mount_path().AsUTF8Unsafe();
+  }
+
+  drive::EventLogger* logger = file_manager::util::GetLogger(GetProfile());
+  if (logger) {
+    logger->Log(logging::LOG_INFO,
+                "%s[%d] succeeded. (results: '[%s]', %" PRIuS " mount points)",
+                name(), request_id(), log_string.c_str(), result.size());
+  }
+
+  results_ =
+      file_manager_private::GetVolumeMetadataList::Results::Create(result);
+  SendResponse(true);
+  return true;
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_manager/chromeos/private_api_mount.h b/chrome/browser/extensions/api/file_manager/chromeos/private_api_mount.h
new file mode 100644
index 0000000000000..59aa98e1d2955
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/chromeos/private_api_mount.h
@@ -0,0 +1,114 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides task related API functions.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_CHROMEOS_PRIVATE_API_MOUNT_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_CHROMEOS_PRIVATE_API_MOUNT_H_
+
+#include <vector>
+
+#include "base/files/file_path.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_base.h"
+#include "components/drive/drive.pb.h"
+#include "components/drive/file_errors.h"
+
+namespace extensions {
+
+// Implements chrome.fileManagerPrivate.addMount method.
+// Mounts removable devices and archive files.
+class FileManagerPrivateAddMountFunction : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.addMount",
+                             FILEMANAGERPRIVATE_ADDMOUNT)
+
+ protected:
+  ~FileManagerPrivateAddMountFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  // Part of Run(). Called after GetFile for Drive File System.
+  void RunAfterGetDriveFile(const base::FilePath& drive_path,
+                            drive::FileError error,
+                            const base::FilePath& cache_path,
+                            std::unique_ptr<drive::ResourceEntry> entry);
+
+  // Part of Run(). Called after IsCacheMarkedAsMounted for Drive File System.
+  void RunAfterIsCacheFileMarkedAsMounted(const base::FilePath& display_name,
+                                          const base::FilePath& cache_path,
+                                          drive::FileError error,
+                                          bool is_marked_as_mounted);
+
+  // Part of Run(). Called after MarkCacheFielAsMounted for Drive File System.
+  // (or directly called from RunAsync() for other file system, or when the
+  // file is already marked as mounted).
+  void RunAfterMarkCacheFileAsMounted(const base::FilePath& display_name,
+                                      drive::FileError error,
+                                      const base::FilePath& file_path);
+};
+
+// Implements chrome.fileManagerPrivate.removeMount method.
+// Unmounts selected volume. Expects volume id as an argument.
+class FileManagerPrivateRemoveMountFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.removeMount",
+                             FILEMANAGERPRIVATE_REMOVEMOUNT)
+
+ protected:
+  ~FileManagerPrivateRemoveMountFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements chrome.fileManagerPrivate.markCacheAsMounted method.
+// Marks a cached file as mounted or unmounted.
+class FileManagerPrivateMarkCacheAsMountedFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.markCacheAsMounted",
+                             FILEMANAGERPRIVATE_MARKCACHEASMOUNTED)
+
+ protected:
+  ~FileManagerPrivateMarkCacheAsMountedFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  // Part of Run(). Called after GetFile for Drive File System.
+  void RunAfterGetDriveFile(const base::FilePath& drive_path,
+                            bool is_mounted,
+                            drive::FileError error,
+                            const base::FilePath& cache_path,
+                            std::unique_ptr<drive::ResourceEntry> entry);
+
+  // Part of Run(). Called after MarkCacheFielAsMounted for Drive File System.
+  void RunAfterMarkCacheFileAsMounted(drive::FileError error,
+                                      const base::FilePath& file_path);
+
+  // Part of Run(). Called after MarkCacheFielAsUnmounted for Drive File System.
+  void RunAfterMarkCacheFileAsUnmounted(drive::FileError error);
+};
+
+// Implements chrome.fileManagerPrivate.getVolumeMetadataList method.
+class FileManagerPrivateGetVolumeMetadataListFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.getVolumeMetadataList",
+                             FILEMANAGERPRIVATE_GETVOLUMEMETADATALIST)
+
+ protected:
+  ~FileManagerPrivateGetVolumeMetadataListFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_CHROMEOS_PRIVATE_API_MOUNT_H_
diff --git a/chrome/browser/extensions/api/file_manager/linux/event_router.cc b/chrome/browser/extensions/api/file_manager/linux/event_router.cc
new file mode 100644
index 0000000000000..9b9f1e127ca0d
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/linux/event_router.cc
@@ -0,0 +1,513 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/linux/event_router.h"
+
+#include "base/bind.h"
+#include "base/files/file_util.h"
+#include "base/macros.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "base/values.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/open_util.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/browser/extensions/api/file_system/chrome_file_system_delegate.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/extensions/extension_util.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/common/chrome_switches.h"
+#include "chrome/common/pref_names.h"
+#include "components/drive/file_change.h"
+#include "components/prefs/pref_change_registrar.h"
+#include "components/prefs/pref_service.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/storage_partition.h"
+#include "extensions/browser/event_router.h"
+#include "extensions/browser/extension_host.h"
+#include "extensions/browser/extension_prefs.h"
+#include "storage/common/fileapi/file_system_types.h"
+#include "storage/common/fileapi/file_system_util.h"
+
+using content::BrowserThread;
+using file_manager::util::EntryDefinition;
+using file_manager::util::FileDefinition;
+
+namespace file_manager_private = extensions::api::file_manager_private;
+
+namespace file_manager {
+namespace {
+
+// Frequency of sending onFileTransferUpdated.
+const int64_t kProgressEventFrequencyInMilliseconds = 1000;
+
+// Maximim size of detailed change info on directory change event. If the size
+// exceeds the maximum size, the detailed info is omitted and the force refresh
+// is kicked.
+const size_t kDirectoryChangeEventMaxDetailInfoSize = 1000;
+
+// This time(millisecond) is used for confirm following event exists.
+const int64_t kFileTransferEventDelayTimeInMilliseconds = 300;
+
+// Sends an event named |event_name| with arguments |event_args| to extensions.
+void BroadcastEvent(Profile* profile,
+                    extensions::events::HistogramValue histogram_value,
+                    const std::string& event_name,
+                    std::unique_ptr<base::ListValue> event_args) {
+  extensions::EventRouter::Get(profile)->BroadcastEvent(
+      std::make_unique<extensions::Event>(histogram_value, event_name,
+                                          std::move(event_args)));
+}
+
+// Sends an event named |event_name| with arguments |event_args| to an extension
+// of |extention_id|.
+void DispatchEventToExtension(
+    Profile* profile,
+    const std::string& extension_id,
+    extensions::events::HistogramValue histogram_value,
+    const std::string& event_name,
+    std::unique_ptr<base::ListValue> event_args) {
+  extensions::EventRouter::Get(profile)->DispatchEventToExtension(
+      extension_id, std::make_unique<extensions::Event>(
+                        histogram_value, event_name, std::move(event_args)));
+}
+
+file_manager_private::CopyProgressStatusType
+CopyProgressTypeToCopyProgressStatusType(
+    storage::FileSystemOperation::CopyProgressType type) {
+  switch (type) {
+    case storage::FileSystemOperation::BEGIN_COPY_ENTRY:
+      return file_manager_private::COPY_PROGRESS_STATUS_TYPE_BEGIN_COPY_ENTRY;
+    case storage::FileSystemOperation::END_COPY_ENTRY:
+      return file_manager_private::COPY_PROGRESS_STATUS_TYPE_END_COPY_ENTRY;
+    case storage::FileSystemOperation::PROGRESS:
+      return file_manager_private::COPY_PROGRESS_STATUS_TYPE_PROGRESS;
+    case storage::FileSystemOperation::ERROR_COPY_ENTRY:
+      return file_manager_private::COPY_PROGRESS_STATUS_TYPE_ERROR;
+  }
+  NOTREACHED();
+  return file_manager_private::COPY_PROGRESS_STATUS_TYPE_NONE;
+}
+
+file_manager_private::ChangeType ConvertChangeTypeFromDriveToApi(
+    drive::FileChange::ChangeType type) {
+  switch (type) {
+    case drive::FileChange::CHANGE_TYPE_ADD_OR_UPDATE:
+      return file_manager_private::CHANGE_TYPE_ADD_OR_UPDATE;
+    case drive::FileChange::CHANGE_TYPE_DELETE:
+      return file_manager_private::CHANGE_TYPE_DELETE;
+  }
+  NOTREACHED();
+  return file_manager_private::CHANGE_TYPE_ADD_OR_UPDATE;
+}
+
+std::string FileErrorToErrorName(base::File::Error error_code) {
+  namespace js = extensions::api::file_manager_private;
+  switch (error_code) {
+    case base::File::FILE_ERROR_NOT_FOUND:
+      return "NotFoundError";
+    case base::File::FILE_ERROR_INVALID_OPERATION:
+    case base::File::FILE_ERROR_EXISTS:
+    case base::File::FILE_ERROR_NOT_EMPTY:
+      return "InvalidModificationError";
+    case base::File::FILE_ERROR_NOT_A_DIRECTORY:
+    case base::File::FILE_ERROR_NOT_A_FILE:
+      return "TypeMismatchError";
+    case base::File::FILE_ERROR_ACCESS_DENIED:
+      return "NoModificationAllowedError";
+    case base::File::FILE_ERROR_FAILED:
+      return "InvalidStateError";
+    case base::File::FILE_ERROR_ABORT:
+      return "AbortError";
+    case base::File::FILE_ERROR_SECURITY:
+      return "SecurityError";
+    case base::File::FILE_ERROR_NO_SPACE:
+      return "QuotaExceededError";
+    case base::File::FILE_ERROR_INVALID_URL:
+      return "EncodingError";
+    default:
+      return "InvalidModificationError";
+  }
+}
+
+// Checks if we should send a progress event or not according to the
+// |last_time| of sending an event. If |always| is true, the function always
+// returns true. If the function returns true, the function also updates
+// |last_time|.
+bool ShouldSendProgressEvent(bool always, base::Time* last_time) {
+  const base::Time now = base::Time::Now();
+  const int64_t delta = (now - *last_time).InMilliseconds();
+  // delta < 0 may rarely happen if system clock is synced and rewinded.
+  // To be conservative, we don't skip in that case.
+  if (!always && 0 <= delta && delta < kProgressEventFrequencyInMilliseconds) {
+    return false;
+  } else {
+    *last_time = now;
+    return true;
+  }
+}
+
+class JobEventRouterImpl : public JobEventRouter {
+ public:
+  explicit JobEventRouterImpl(Profile* profile)
+      : JobEventRouter(base::TimeDelta::FromMilliseconds(
+            kFileTransferEventDelayTimeInMilliseconds)),
+        profile_(profile) {}
+
+ protected:
+  std::set<std::string> GetFileTransfersUpdateEventListenerExtensionIds()
+      override {
+    const extensions::EventListenerMap::ListenerList& listeners =
+        extensions::EventRouter::Get(profile_)
+            ->listeners()
+            .GetEventListenersByName(
+                file_manager_private::OnFileTransfersUpdated::kEventName);
+
+    std::set<std::string> extension_ids;
+
+    for (const auto& listener : listeners) {
+      extension_ids.insert(listener->extension_id());
+    }
+
+    return extension_ids;
+  }
+
+  GURL ConvertDrivePathToFileSystemUrl(
+      const base::FilePath& file_path,
+      const std::string& extension_id) override {
+    return file_manager::util::ConvertDrivePathToFileSystemUrl(
+        profile_, file_path, extension_id);
+  }
+
+  void DispatchEventToExtension(
+      const std::string& extension_id,
+      extensions::events::HistogramValue histogram_value,
+      const std::string& event_name,
+      std::unique_ptr<base::ListValue> event_args) override {
+    ::file_manager::DispatchEventToExtension(profile_, extension_id,
+                                             histogram_value, event_name,
+                                             std::move(event_args));
+  }
+
+ private:
+  Profile* const profile_;
+
+  DISALLOW_COPY_AND_ASSIGN(JobEventRouterImpl);
+};
+
+}  // namespace
+
+EventRouter::EventRouter(Profile* profile)
+    : pref_change_registrar_(std::make_unique<PrefChangeRegistrar>()),
+      profile_(profile),
+      job_event_router_(std::make_unique<JobEventRouterImpl>(profile)),
+      dispatch_directory_change_event_impl_(
+          base::Bind(&EventRouter::DispatchDirectoryChangeEventImpl,
+                     base::Unretained(this))),
+      weak_factory_(this) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  ObserveEvents();
+}
+
+EventRouter::~EventRouter() = default;
+
+void EventRouter::Shutdown() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  DLOG_IF(WARNING, !file_watchers_.empty())
+      << "Not all file watchers are "
+      << "removed. This can happen when the Files app is open during shutdown.";
+  file_watchers_.clear();
+  if (!profile_) {
+    NOTREACHED();
+    return;
+  }
+
+  pref_change_registrar_->RemoveAll();
+
+  profile_ = nullptr;
+}
+
+void EventRouter::ObserveEvents() {
+  if (!profile_) {
+    NOTREACHED();
+    return;
+  }
+
+  pref_change_registrar_->Init(profile_->GetPrefs());
+  base::Closure callback =
+      base::Bind(&EventRouter::OnFileManagerPrefsChanged,
+                 weak_factory_.GetWeakPtr());
+  pref_change_registrar_->Add(prefs::kSearchSuggestEnabled, callback);
+}
+
+// File watch setup routines.
+void EventRouter::AddFileWatch(const base::FilePath& local_path,
+                               const base::FilePath& virtual_path,
+                               const std::string& extension_id,
+                               const BoolCallback& callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(!callback.is_null());
+
+  base::FilePath watch_path = local_path;
+
+  auto iter = file_watchers_.find(watch_path);
+  if (iter == file_watchers_.end()) {
+    std::unique_ptr<FileWatcher> watcher(new FileWatcher(virtual_path));
+    watcher->AddExtension(extension_id);
+
+    // For local files, start watching using FileWatcher.
+    watcher->WatchLocalFile(
+        watch_path,
+        base::Bind(&EventRouter::HandleFileWatchNotification,
+                   weak_factory_.GetWeakPtr(),
+                   static_cast<drive::FileChange*>(nullptr)),
+        callback);
+    file_watchers_[watch_path] = std::move(watcher);
+  } else {
+    iter->second->AddExtension(extension_id);
+    base::ThreadTaskRunnerHandle::Get()->PostTask(
+        FROM_HERE, base::BindOnce(callback, true));
+  }
+}
+
+void EventRouter::RemoveFileWatch(const base::FilePath& local_path,
+                                  const std::string& extension_id) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  base::FilePath watch_path = local_path;
+  auto iter = file_watchers_.find(watch_path);
+  if (iter == file_watchers_.end())
+    return;
+  // Remove the watcher if |watch_path| is no longer watched by any extensions.
+  iter->second->RemoveExtension(extension_id);
+  if (iter->second->GetExtensionIds().empty())
+    file_watchers_.erase(iter);
+}
+
+void EventRouter::OnCopyCompleted(int copy_id,
+                                  const GURL& source_url,
+                                  const GURL& destination_url,
+                                  base::File::Error error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  file_manager_private::CopyProgressStatus status;
+  if (error == base::File::FILE_OK) {
+    // Send success event.
+    status.type = file_manager_private::COPY_PROGRESS_STATUS_TYPE_SUCCESS;
+    status.source_url = std::make_unique<std::string>(source_url.spec());
+    status.destination_url =
+        std::make_unique<std::string>(destination_url.spec());
+  } else {
+    // Send error event.
+    status.type = file_manager_private::COPY_PROGRESS_STATUS_TYPE_ERROR;
+    status.error = std::make_unique<std::string>(FileErrorToErrorName(error));
+  }
+
+  BroadcastEvent(profile_,
+                 extensions::events::FILE_MANAGER_PRIVATE_ON_COPY_PROGRESS,
+                 file_manager_private::OnCopyProgress::kEventName,
+                 file_manager_private::OnCopyProgress::Create(copy_id, status));
+}
+
+void EventRouter::OnCopyProgress(
+    int copy_id,
+    storage::FileSystemOperation::CopyProgressType type,
+    const GURL& source_url,
+    const GURL& destination_url,
+    int64_t size) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  file_manager_private::CopyProgressStatus status;
+  status.type = CopyProgressTypeToCopyProgressStatusType(type);
+  status.source_url = std::make_unique<std::string>(source_url.spec());
+  if (type == storage::FileSystemOperation::END_COPY_ENTRY ||
+      type == storage::FileSystemOperation::ERROR_COPY_ENTRY)
+    status.destination_url =
+        std::make_unique<std::string>(destination_url.spec());
+  if (type == storage::FileSystemOperation::ERROR_COPY_ENTRY)
+    status.error = std::make_unique<std::string>(
+        FileErrorToErrorName(base::File::FILE_ERROR_FAILED));
+  if (type == storage::FileSystemOperation::PROGRESS)
+    status.size = std::make_unique<double>(size);
+
+  // Discard error progress since current JS code cannot handle this properly.
+  // TODO(yawano): Remove this after JS side is implemented correctly.
+  if (type == storage::FileSystemOperation::ERROR_COPY_ENTRY)
+    return;
+
+  // Should not skip events other than TYPE_PROGRESS.
+  const bool always =
+      status.type != file_manager_private::COPY_PROGRESS_STATUS_TYPE_PROGRESS;
+  if (!ShouldSendProgressEvent(always, &last_copy_progress_event_))
+    return;
+
+  BroadcastEvent(profile_,
+                 extensions::events::FILE_MANAGER_PRIVATE_ON_COPY_PROGRESS,
+                 file_manager_private::OnCopyProgress::kEventName,
+                 file_manager_private::OnCopyProgress::Create(copy_id, status));
+}
+
+void EventRouter::OnWatcherManagerNotification(
+    const storage::FileSystemURL& file_system_url,
+    const std::string& extension_id,
+    storage::WatcherManager::ChangeType /* change_type */) {
+  std::vector<std::string> extension_ids;
+  extension_ids.push_back(extension_id);
+
+  DispatchDirectoryChangeEvent(file_system_url.virtual_path(), nullptr,
+                               false /* error */, extension_ids);
+}
+
+void EventRouter::OnFileManagerPrefsChanged() {
+  if (!profile_ || !extensions::EventRouter::Get(profile_)) {
+    NOTREACHED();
+    return;
+  }
+
+  BroadcastEvent(
+      profile_, extensions::events::FILE_MANAGER_PRIVATE_ON_PREFERENCES_CHANGED,
+      file_manager_private::OnPreferencesChanged::kEventName,
+      file_manager_private::OnPreferencesChanged::Create());
+}
+
+void EventRouter::HandleFileWatchNotification(const drive::FileChange* list,
+                                              const base::FilePath& local_path,
+                                              bool got_error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  auto iter = file_watchers_.find(local_path);
+  if (iter == file_watchers_.end()) {
+    return;
+  }
+
+  if (list && list->size() > kDirectoryChangeEventMaxDetailInfoSize) {
+    // Removes the detailed information, if the list size is more than
+    // kDirectoryChangeEventMaxDetailInfoSize, since passing large list
+    // and processing it may cause more itme.
+    // This will be invoked full-refresh in the Files app.
+    list = nullptr;
+  }
+
+  DispatchDirectoryChangeEvent(iter->second->virtual_path(),
+                               list,
+                               got_error,
+                               iter->second->GetExtensionIds());
+}
+
+void EventRouter::DispatchDirectoryChangeEvent(
+    const base::FilePath& virtual_path,
+    const drive::FileChange* list,
+    bool got_error,
+    const std::vector<std::string>& extension_ids) {
+  dispatch_directory_change_event_impl_.Run(virtual_path, list, got_error,
+                                            extension_ids);
+}
+
+void EventRouter::DispatchDirectoryChangeEventImpl(
+    const base::FilePath& virtual_path,
+    const drive::FileChange* list,
+    bool got_error,
+    const std::vector<std::string>& extension_ids) {
+  if (!profile_) {
+    NOTREACHED();
+    return;
+  }
+  linked_ptr<drive::FileChange> changes;
+  if (list)
+    changes.reset(new drive::FileChange(*list));  // Copy
+
+  for (size_t i = 0; i < extension_ids.size(); ++i) {
+    std::string* extension_id = new std::string(extension_ids[i]);
+
+    FileDefinition file_definition;
+    file_definition.virtual_path = virtual_path;
+    // TODO(mtomasz): Add support for watching files in File System Provider
+    // API.
+    file_definition.is_directory = true;
+
+    file_manager::util::ConvertFileDefinitionToEntryDefinition(
+        profile_,
+        *extension_id,
+        file_definition,
+        base::Bind(
+            &EventRouter::DispatchDirectoryChangeEventWithEntryDefinition,
+            weak_factory_.GetWeakPtr(),
+            changes,
+            base::Owned(extension_id),
+            got_error));
+  }
+}
+
+void EventRouter::DispatchDirectoryChangeEventWithEntryDefinition(
+    const linked_ptr<drive::FileChange> list,
+    const std::string* extension_id,
+    bool watcher_error,
+    const EntryDefinition& entry_definition) {
+  // TODO(mtomasz): Add support for watching files in File System Provider API.
+  if (entry_definition.error != base::File::FILE_OK ||
+      !entry_definition.is_directory) {
+    DVLOG(1) << "Unable to dispatch event because resolving the directory "
+             << "entry definition failed.";
+    return;
+  }
+
+  file_manager_private::FileWatchEvent event;
+  event.event_type = watcher_error
+      ? file_manager_private::FILE_WATCH_EVENT_TYPE_ERROR
+      : file_manager_private::FILE_WATCH_EVENT_TYPE_CHANGED;
+
+  // Detailed information is available.
+  if (list.get()) {
+    event.changed_files =
+        std::make_unique<std::vector<file_manager_private::FileChange>>();
+
+    if (list->map().empty())
+      return;
+
+    for (drive::FileChange::Map::const_iterator it = list->map().begin();
+         it != list->map().end();
+         it++) {
+      file_manager_private::FileChange change_list;
+
+      GURL url = util::ConvertDrivePathToFileSystemUrl(
+          profile_, it->first, *extension_id);
+      change_list.url = url.spec();
+
+      for (drive::FileChange::ChangeList::List::const_iterator change =
+               it->second.list().begin();
+           change != it->second.list().end();
+           change++) {
+        change_list.changes.push_back(
+            ConvertChangeTypeFromDriveToApi(change->change()));
+      }
+
+      event.changed_files->push_back(std::move(change_list));
+    }
+  }
+
+  event.entry.additional_properties.SetString(
+      "fileSystemName", entry_definition.file_system_name);
+  event.entry.additional_properties.SetString(
+      "fileSystemRoot", entry_definition.file_system_root_url);
+  event.entry.additional_properties.SetString(
+      "fileFullPath", "/" + entry_definition.full_path.value());
+  event.entry.additional_properties.SetBoolean("fileIsDirectory",
+                                               entry_definition.is_directory);
+
+  DispatchEventToExtension(
+      profile_, *extension_id,
+      extensions::events::FILE_MANAGER_PRIVATE_ON_DIRECTORY_CHANGED,
+      file_manager_private::OnDirectoryChanged::kEventName,
+      file_manager_private::OnDirectoryChanged::Create(event));
+}
+
+base::WeakPtr<EventRouter> EventRouter::GetWeakPtr() {
+  return weak_factory_.GetWeakPtr();
+}
+
+}  // namespace file_manager
diff --git a/chrome/browser/extensions/api/file_manager/linux/event_router.h b/chrome/browser/extensions/api/file_manager/linux/event_router.h
new file mode 100644
index 0000000000000..9300cbfdd78a3
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/linux/event_router.h
@@ -0,0 +1,147 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_LINUX_EVENT_ROUTER_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_LINUX_EVENT_ROUTER_H_
+
+#include "base/compiler_specific.h"
+#include "base/files/file_path_watcher.h"
+#include "base/macros.h"
+#include "base/memory/linked_ptr.h"
+#include "chrome/browser/extensions/api/file_manager/drivefs_event_router.h"
+#include "chrome/browser/extensions/api/file_manager/job_event_router.h"
+#include "chrome/browser/file_manager/file_watcher.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "components/keyed_service/core/keyed_service.h"
+#include "storage/browser/fileapi/file_system_operation.h"
+#include "storage/browser/fileapi/watcher_manager.h"
+
+class PrefChangeRegistrar;
+class Profile;
+
+using file_manager::util::EntryDefinition;
+
+namespace drive {
+class FileChange;
+}
+
+namespace file_manager {
+
+// Monitors changes in disk mounts, network connection state and preferences
+// affecting File Manager. Dispatches appropriate File Browser events.
+class EventRouter : public KeyedService {
+ public:
+  typedef base::Callback<void(const base::FilePath& virtual_path,
+                              const drive::FileChange* list,
+                              bool got_error,
+                              const std::vector<std::string>& extension_ids)>
+      DispatchDirectoryChangeEventImplCallback;
+
+  explicit EventRouter(Profile* profile);
+  ~EventRouter() override;
+
+  // KeyedService overrides.
+  void Shutdown() override;
+
+  typedef base::Callback<void(bool success)> BoolCallback;
+
+  // Adds a file watch at |local_path|, associated with |virtual_path|, for
+  // an extension with |extension_id|.
+  //
+  // |callback| will be called with true on success, or false on failure.
+  // |callback| must not be null.
+  //
+  // Obsolete. Used as fallback for files which backends do not implement the
+  // storage::WatcherManager interface.
+  void AddFileWatch(const base::FilePath& local_path,
+                    const base::FilePath& virtual_path,
+                    const std::string& extension_id,
+                    const BoolCallback& callback);
+
+  // Removes a file watch at |local_path| for an extension with |extension_id|.
+  //
+  // Obsolete. Used as fallback for files which backends do not implement the
+  // storage::WatcherManager interface.
+  void RemoveFileWatch(const base::FilePath& local_path,
+                       const std::string& extension_id);
+
+  // Called when a copy task is completed.
+  void OnCopyCompleted(
+      int copy_id, const GURL& source_url, const GURL& destination_url,
+      base::File::Error error);
+
+  // Called when a copy task progress is updated.
+  void OnCopyProgress(int copy_id,
+                      storage::FileSystemOperation::CopyProgressType type,
+                      const GURL& source_url,
+                      const GURL& destination_url,
+                      int64_t size);
+
+  // Called when a notification from a watcher manager arrives.
+  void OnWatcherManagerNotification(
+      const storage::FileSystemURL& file_system_url,
+      const std::string& extension_id,
+      storage::WatcherManager::ChangeType change_type);
+
+  // Returns a weak pointer for the event router.
+  base::WeakPtr<EventRouter> GetWeakPtr();
+
+ private:
+  // Starts observing file system change events.
+  void ObserveEvents();
+
+  // Called when prefs related to file manager change.
+  void OnFileManagerPrefsChanged();
+
+  // Process file watch notifications.
+  void HandleFileWatchNotification(const drive::FileChange* list,
+                                   const base::FilePath& path,
+                                   bool got_error);
+
+  // Sends directory change event.
+  void DispatchDirectoryChangeEvent(
+      const base::FilePath& path,
+      const drive::FileChange* list,
+      bool got_error,
+      const std::vector<std::string>& extension_ids);
+
+  // Default implementation of DispatchDirectoryChangeEvent.
+  void DispatchDirectoryChangeEventImpl(
+      const base::FilePath& path,
+      const drive::FileChange* list,
+      bool got_error,
+      const std::vector<std::string>& extension_ids);
+
+  // Sends directory change event, after converting the file definition to entry
+  // definition.
+  void DispatchDirectoryChangeEventWithEntryDefinition(
+      const linked_ptr<drive::FileChange> list,
+      const std::string* extension_id,
+      bool watcher_error,
+      const EntryDefinition& entry_definition);
+
+  base::Time last_copy_progress_event_;
+
+  std::map<base::FilePath, std::unique_ptr<FileWatcher>> file_watchers_;
+  std::unique_ptr<PrefChangeRegistrar> pref_change_registrar_;
+  Profile* profile_;
+
+  std::unique_ptr<JobEventRouter> job_event_router_;
+  std::unique_ptr<DriveFsEventRouter> drivefs_event_router_;
+
+  DispatchDirectoryChangeEventImplCallback
+      dispatch_directory_change_event_impl_;
+
+  // Note: This should remain the last member so it'll be destroyed and
+  // invalidate the weak pointers before any other members are destroyed.
+  base::WeakPtrFactory<EventRouter> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(EventRouter);
+};
+
+}  // namespace file_manager
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_LINUX_EVENT_ROUTER_H_
diff --git a/chrome/browser/extensions/api/file_manager/linux/private_api_drive.cc b/chrome/browser/extensions/api/file_manager/linux/private_api_drive.cc
new file mode 100644
index 0000000000000..b1ea7265691a5
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/linux/private_api_drive.cc
@@ -0,0 +1,175 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/linux/private_api_drive.h"
+
+#include "base/base64.h"
+#include "base/command_line.h"
+#include "base/memory/ptr_util.h"
+#include "base/strings/strcat.h"
+#include "base/task/post_task.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+#include "chrome/browser/file_manager/file_tasks.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/url_util.h"
+#include "chrome/browser/fileapi/external_file_url_util.h"
+#include "chrome/browser/fileapi/file_system_backend.h"
+#include "chrome/browser/net/system_network_context_manager.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/common/extensions/api/file_manager_private_internal.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/storage_partition.h"
+#include "mojo/public/cpp/bindings/callback_helpers.h"
+#include "services/network/public/cpp/shared_url_loader_factory.h"
+#include "storage/common/fileapi/file_system_info.h"
+#include "storage/common/fileapi/file_system_util.h"
+#include "url/gurl.h"
+
+using content::BrowserThread;
+
+using extensions::api::file_manager_private::EntryProperties;
+using extensions::api::file_manager_private::EntryPropertyName;
+
+namespace extensions {
+namespace {
+
+// List of connection types of drive.
+// Keep this in sync with the DriveConnectionType in common/js/util.js.
+const char kDriveConnectionTypeOffline[] = "offline";
+
+// List of reasons of kDriveConnectionType*.
+// Keep this in sync with the DriveConnectionReason in common/js/util.js.
+const char kDriveConnectionReasonNoService[] = "no_service";
+
+}  // namespace
+
+FileManagerPrivateInternalGetEntryPropertiesFunction::
+    FileManagerPrivateInternalGetEntryPropertiesFunction()
+    : processed_count_(0) {
+}
+
+FileManagerPrivateInternalGetEntryPropertiesFunction::
+    ~FileManagerPrivateInternalGetEntryPropertiesFunction() = default;
+
+bool FileManagerPrivateInternalGetEntryPropertiesFunction::RunAsync() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  using api::file_manager_private_internal::GetEntryProperties::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  properties_list_.resize(params->urls.size());
+  const std::set<EntryPropertyName> names_as_set(params->names.begin(),
+                                                 params->names.end());
+  for (size_t i = 0; i < params->urls.size(); i++) {
+    const GURL url = GURL(params->urls[i]);
+    const storage::FileSystemURL file_system_url =
+        file_system_context->CrackURL(url);
+    // TODO(yawano) Change this to support other voluems (e.g. local) ,and
+    // integrate fileManagerPrivate.getMimeType to this method.
+    LOG(ERROR) << "Not supported file system type.";
+    CompleteGetEntryProperties(i, file_system_url,
+                               base::WrapUnique(new EntryProperties),
+                               base::File::FILE_ERROR_INVALID_OPERATION);
+  }
+
+  return true;
+}
+
+void FileManagerPrivateInternalGetEntryPropertiesFunction::
+    CompleteGetEntryProperties(size_t index,
+                               const storage::FileSystemURL& url,
+                               std::unique_ptr<EntryProperties> properties,
+                               base::File::Error error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(0 <= processed_count_ && processed_count_ < properties_list_.size());
+
+  if (error == base::File::FILE_OK) {
+    properties->external_file_url = std::make_unique<std::string>(
+        chromeos::FileSystemURLToExternalFileURL(url).spec());
+  }
+  properties_list_[index] = std::move(*properties);
+
+  processed_count_++;
+  if (processed_count_ < properties_list_.size())
+    return;
+
+  results_ = extensions::api::file_manager_private_internal::
+      GetEntryProperties::Results::Create(properties_list_);
+  SendResponse(true);
+}
+
+bool FileManagerPrivateInternalPinDriveFileFunction::RunAsync() {
+  return false;
+}
+
+bool FileManagerPrivateInternalEnsureFileDownloadedFunction::RunAsync() {
+  SendResponse(true);
+  return true;
+}
+
+bool FileManagerPrivateInternalCancelFileTransfersFunction::RunAsync() {
+  return false;
+}
+
+bool FileManagerPrivateCancelAllFileTransfersFunction::RunAsync() {
+  SendResponse(false);
+  return false;
+}
+
+bool FileManagerPrivateSearchDriveFunction::RunAsync() {
+  return false;
+}
+
+bool FileManagerPrivateSearchDriveMetadataFunction::RunAsync() {
+  return false;
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateGetDriveConnectionStateFunction::Run() {
+  api::file_manager_private::DriveConnectionState result;
+  result.type = kDriveConnectionTypeOffline;
+  result.reason =
+      std::make_unique<std::string>(kDriveConnectionReasonNoService);
+
+  return RespondNow(ArgumentList(
+      api::file_manager_private::GetDriveConnectionState::Results::Create(
+          result)));
+}
+
+bool FileManagerPrivateRequestAccessTokenFunction::RunAsync() {
+  // DriveService is not available.
+  SetResult(std::make_unique<base::Value>(std::string()));
+  SendResponse(true);
+  return true;
+}
+
+bool FileManagerPrivateInternalGetShareUrlFunction::RunAsync() {
+  return false;
+}
+
+bool FileManagerPrivateInternalRequestDriveShareFunction::RunAsync() {
+  return false;
+}
+
+FileManagerPrivateInternalGetDownloadUrlFunction::
+    FileManagerPrivateInternalGetDownloadUrlFunction() = default;
+
+FileManagerPrivateInternalGetDownloadUrlFunction::
+    ~FileManagerPrivateInternalGetDownloadUrlFunction() = default;
+
+bool FileManagerPrivateInternalGetDownloadUrlFunction::RunAsync() {
+  SetError("Drive is disabled or not mounted.");
+  // Intentionally returns a blank.
+  SetResult(std::make_unique<base::Value>(std::string()));
+  return false;
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_manager/linux/private_api_drive.h b/chrome/browser/extensions/api/file_manager/linux/private_api_drive.h
new file mode 100644
index 0000000000000..f0660e359cf42
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/linux/private_api_drive.h
@@ -0,0 +1,207 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides Drive specific API functions.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_LINUX_PRIVATE_API_DRIVE_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_LINUX_PRIVATE_API_DRIVE_H_
+
+#include "base/files/file.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_base.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+
+namespace extensions {
+
+namespace api {
+namespace file_manager_private {
+struct EntryProperties;
+}  // namespace file_manager_private
+}  // namespace api
+
+// Implements the chrome.fileManagerPrivate.ensureFileDownloaded method.
+class FileManagerPrivateInternalEnsureFileDownloadedFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.ensureFileDownloaded",
+                             FILEMANAGERPRIVATE_ENSUREFILEDOWNLOADED)
+
+ protected:
+  ~FileManagerPrivateInternalEnsureFileDownloadedFunction() override = default;
+
+  // AsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Retrieves property information for an entry and returns it as a dictionary.
+// On error, returns a dictionary with the key "error" set to the error number
+// (base::File::Error).
+class FileManagerPrivateInternalGetEntryPropertiesFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getEntryProperties",
+                             FILEMANAGERPRIVATEINTERNAL_GETENTRYPROPERTIES)
+
+  FileManagerPrivateInternalGetEntryPropertiesFunction();
+
+ protected:
+  ~FileManagerPrivateInternalGetEntryPropertiesFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  void CompleteGetEntryProperties(
+      size_t index,
+      const storage::FileSystemURL& url,
+      std::unique_ptr<api::file_manager_private::EntryProperties> properties,
+      base::File::Error error);
+
+  size_t processed_count_;
+  std::vector<api::file_manager_private::EntryProperties> properties_list_;
+};
+
+// Implements the chrome.fileManagerPrivate.pinDriveFile method.
+class FileManagerPrivateInternalPinDriveFileFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.pinDriveFile",
+                             FILEMANAGERPRIVATEINTERNAL_PINDRIVEFILE)
+
+ protected:
+  ~FileManagerPrivateInternalPinDriveFileFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivate.cancelFileTransfers method.
+class FileManagerPrivateInternalCancelFileTransfersFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.cancelFileTransfers",
+                             FILEMANAGERPRIVATEINTERNAL_CANCELFILETRANSFERS)
+
+ protected:
+  ~FileManagerPrivateInternalCancelFileTransfersFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivate.cancelAllFileTransfers method.
+class FileManagerPrivateCancelAllFileTransfersFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.cancelAllFileTransfers",
+                             FILEMANAGERPRIVATE_CANCELALLFILETRANSFERS)
+
+ protected:
+  ~FileManagerPrivateCancelAllFileTransfersFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+class FileManagerPrivateSearchDriveFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.searchDrive",
+                             FILEMANAGERPRIVATE_SEARCHDRIVE)
+
+ protected:
+  ~FileManagerPrivateSearchDriveFunction() override = default;
+
+  bool RunAsync() override;
+};
+
+// Similar to FileManagerPrivateSearchDriveFunction but this one is used for
+// searching drive metadata which is stored locally.
+class FileManagerPrivateSearchDriveMetadataFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.searchDriveMetadata",
+                             FILEMANAGERPRIVATE_SEARCHDRIVEMETADATA)
+
+ protected:
+  ~FileManagerPrivateSearchDriveMetadataFunction() override = default;
+
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivate.getDriveConnectionState method.
+class FileManagerPrivateGetDriveConnectionStateFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileManagerPrivate.getDriveConnectionState",
+      FILEMANAGERPRIVATE_GETDRIVECONNECTIONSTATE);
+
+ protected:
+  ~FileManagerPrivateGetDriveConnectionStateFunction() override = default;
+
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.requestAccessToken method.
+class FileManagerPrivateRequestAccessTokenFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.requestAccessToken",
+                             FILEMANAGERPRIVATE_REQUESTACCESSTOKEN)
+
+ protected:
+  ~FileManagerPrivateRequestAccessTokenFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivate.getShareUrl method.
+class FileManagerPrivateInternalGetShareUrlFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getShareUrl",
+                             FILEMANAGERPRIVATEINTERNAL_GETSHAREURL)
+
+ protected:
+  ~FileManagerPrivateInternalGetShareUrlFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivate.requestDriveShare method.
+class FileManagerPrivateInternalRequestDriveShareFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.requestDriveShare",
+                             FILEMANAGERPRIVATEINTERNAL_REQUESTDRIVESHARE);
+
+ protected:
+  ~FileManagerPrivateInternalRequestDriveShareFunction() override = default;
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivate.getDownloadUrl method.
+class FileManagerPrivateInternalGetDownloadUrlFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  FileManagerPrivateInternalGetDownloadUrlFunction();
+
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getDownloadUrl",
+                             FILEMANAGERPRIVATEINTERNAL_GETDOWNLOADURL)
+
+ protected:
+  ~FileManagerPrivateInternalGetDownloadUrlFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  GURL download_url_;
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_LINUX_PRIVATE_API_DRIVE_H_
diff --git a/chrome/browser/extensions/api/file_manager/linux/private_api_file_system.cc b/chrome/browser/extensions/api/file_manager/linux/private_api_file_system.cc
new file mode 100644
index 0000000000000..91199e080e717
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/linux/private_api_file_system.cc
@@ -0,0 +1,853 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/linux/private_api_file_system.h"
+
+#include <sys/statvfs.h>
+
+#include "base/files/file_util.h"
+#include "base/posix/eintr_wrapper.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/sys_info.h"
+#include "base/task/post_task.h"
+#include "base/task_runner_util.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/extensions/api/file_manager/event_router.h"
+#include "chrome/browser/extensions/api/file_manager/event_router_factory.h"
+#include "chrome/browser/extensions/api/file_manager/file_stream_md5_digester.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/path_util.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/browser/fileapi/file_system_backend.h"
+#include "chrome/browser/metrics/chrome_metrics_service_accessor.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "chrome/common/extensions/api/file_manager_private_internal.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/child_process_security_policy.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/storage_partition.h"
+#include "content/public/common/url_constants.h"
+#include "extensions/browser/extension_util.h"
+#include "net/base/escape.h"
+#include "storage/browser/fileapi/file_stream_reader.h"
+#include "storage/browser/fileapi/file_system_context.h"
+#include "storage/browser/fileapi/file_system_file_util.h"
+#include "storage/browser/fileapi/file_system_operation_context.h"
+#include "storage/browser/fileapi/file_system_operation_runner.h"
+#include "storage/common/fileapi/file_system_info.h"
+#include "storage/common/fileapi/file_system_types.h"
+#include "storage/common/fileapi/file_system_util.h"
+#include "third_party/cros_system_api/constants/cryptohome.h"
+
+using content::BrowserThread;
+using content::ChildProcessSecurityPolicy;
+using file_manager::util::EntryDefinition;
+using file_manager::util::FileDefinition;
+using storage::FileSystemURL;
+
+namespace extensions {
+namespace {
+
+// Retrieves total and remaining available size on |mount_path|.
+void GetSizeStatsAsync(const base::FilePath& mount_path,
+                       uint64_t* total_size,
+                       uint64_t* remaining_size) {
+  int64_t size = base::SysInfo::AmountOfTotalDiskSpace(mount_path);
+  if (size >= 0)
+    *total_size = size;
+  size = base::SysInfo::AmountOfFreeDiskSpace(mount_path);
+  if (size >= 0)
+    *remaining_size = size;
+}
+
+// Retrieves the maximum file name length of the file system of |path|.
+// Returns 0 if it could not be queried.
+size_t GetFileNameMaxLengthAsync(const std::string& path) {
+  struct statvfs stat = {};
+  if (HANDLE_EINTR(statvfs(path.c_str(), &stat)) != 0) {
+    // The filesystem seems not supporting statvfs(). Assume it to be a commonly
+    // used bound 255, and log the failure.
+    LOG(ERROR) << "Cannot statvfs() the name length limit for: " << path;
+    return 255;
+  }
+  return stat.f_namemax;
+}
+
+// Returns EventRouter for the |profile_id| if available.
+file_manager::EventRouter* GetEventRouterByProfileId(void* profile_id) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  // |profile_id| needs to be checked with ProfileManager::IsValidProfile
+  // before using it.
+  if (!g_browser_process->profile_manager()->IsValidProfile(profile_id))
+    return nullptr;
+  Profile* profile = reinterpret_cast<Profile*>(profile_id);
+
+  return file_manager::EventRouterFactory::GetForProfile(profile);
+}
+
+// Notifies the copy progress to extensions via event router.
+void NotifyCopyProgress(
+    void* profile_id,
+    storage::FileSystemOperationRunner::OperationID operation_id,
+    storage::FileSystemOperation::CopyProgressType type,
+    const FileSystemURL& source_url,
+    const FileSystemURL& destination_url,
+    int64_t size) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  file_manager::EventRouter* event_router =
+      GetEventRouterByProfileId(profile_id);
+  if (event_router) {
+    event_router->OnCopyProgress(
+        operation_id, type,
+        source_url.ToGURL(), destination_url.ToGURL(), size);
+  }
+}
+
+// Callback invoked periodically on progress update of Copy().
+void OnCopyProgress(
+    void* profile_id,
+    storage::FileSystemOperationRunner::OperationID* operation_id,
+    storage::FileSystemOperation::CopyProgressType type,
+    const FileSystemURL& source_url,
+    const FileSystemURL& destination_url,
+    int64_t size) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  BrowserThread::PostTask(
+      BrowserThread::UI, FROM_HERE,
+      base::BindOnce(&NotifyCopyProgress, profile_id, *operation_id, type,
+                     source_url, destination_url, size));
+}
+
+// Notifies the copy completion to extensions via event router.
+void NotifyCopyCompletion(
+    void* profile_id,
+    storage::FileSystemOperationRunner::OperationID operation_id,
+    const FileSystemURL& source_url,
+    const FileSystemURL& destination_url,
+    base::File::Error error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  file_manager::EventRouter* event_router =
+      GetEventRouterByProfileId(profile_id);
+  if (event_router)
+    event_router->OnCopyCompleted(
+        operation_id,
+        source_url.ToGURL(), destination_url.ToGURL(), error);
+}
+
+// Callback invoked upon completion of Copy() (regardless of succeeded or
+// failed).
+void OnCopyCompleted(
+    void* profile_id,
+    storage::FileSystemOperationRunner::OperationID* operation_id,
+    const FileSystemURL& source_url,
+    const FileSystemURL& destination_url,
+    base::File::Error error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  BrowserThread::PostTask(
+      BrowserThread::UI, FROM_HERE,
+      base::BindOnce(&NotifyCopyCompletion, profile_id, *operation_id,
+                     source_url, destination_url, error));
+}
+
+// Starts the copy operation via FileSystemOperationRunner.
+storage::FileSystemOperationRunner::OperationID StartCopyOnIOThread(
+    void* profile_id,
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const FileSystemURL& source_url,
+    const FileSystemURL& destination_url) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  // Note: |operation_id| is owned by the callback for
+  // FileSystemOperationRunner::Copy(). It is always called in the next message
+  // loop or later, so at least during this invocation it should alive.
+  //
+  // TODO(yawano): change ERROR_BEHAVIOR_ABORT to ERROR_BEHAVIOR_SKIP after
+  //     error messages of individual operations become appear in the Files app
+  //     UI.
+  storage::FileSystemOperationRunner::OperationID* operation_id =
+      new storage::FileSystemOperationRunner::OperationID;
+  *operation_id = file_system_context->operation_runner()->Copy(
+      source_url, destination_url,
+      storage::FileSystemOperation::OPTION_PRESERVE_LAST_MODIFIED,
+      storage::FileSystemOperation::ERROR_BEHAVIOR_ABORT,
+      base::Bind(&OnCopyProgress, profile_id, base::Unretained(operation_id)),
+      base::Bind(&OnCopyCompleted, profile_id, base::Owned(operation_id),
+                 source_url, destination_url));
+  return *operation_id;
+}
+
+void OnCopyCancelled(base::File::Error error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  // We just ignore the status if the copy is actually cancelled or not,
+  // because failing cancellation means the operation is not running now.
+  DLOG_IF(WARNING, error != base::File::FILE_OK)
+      << "Failed to cancel copy: " << error;
+}
+
+// Cancels the running copy operation identified by |operation_id|.
+void CancelCopyOnIOThread(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    storage::FileSystemOperationRunner::OperationID operation_id) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  file_system_context->operation_runner()->Cancel(
+      operation_id, base::Bind(&OnCopyCancelled));
+}
+
+// Converts a status code to a bool value and calls the |callback| with it.
+void StatusCallbackToResponseCallback(
+    const base::Callback<void(bool)>& callback,
+    base::File::Error result) {
+  callback.Run(result == base::File::FILE_OK);
+}
+
+// Calls a response callback (on the UI thread) with a file content hash
+// computed on the IO thread.
+void ComputeChecksumRespondOnUIThread(
+    const base::Callback<void(const std::string&)>& callback,
+    const std::string& hash) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
+                          base::BindOnce(callback, hash));
+}
+
+// Calls a response callback on the UI thread.
+void GetFileMetadataRespondOnUIThread(
+    const storage::FileSystemOperation::GetMetadataCallback& callback,
+    base::File::Error result,
+    const base::File::Info& file_info) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
+                          base::BindOnce(callback, result, file_info));
+}
+
+}  // namespace
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateEnableExternalFileSchemeFunction::Run() {
+  ChildProcessSecurityPolicy::GetInstance()->GrantRequestScheme(
+      render_frame_host()->GetProcess()->GetID(), content::kExternalFileScheme);
+  return RespondNow(NoArguments());
+}
+
+FileManagerPrivateGrantAccessFunction::FileManagerPrivateGrantAccessFunction()
+    : chrome_details_(this) {
+}
+
+ExtensionFunction::ResponseAction FileManagerPrivateGrantAccessFunction::Run() {
+  using extensions::api::file_manager_private::GrantAccess::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          chrome_details_.GetProfile(), render_frame_host());
+
+  storage::ExternalFileSystemBackend* const backend =
+      file_system_context->external_backend();
+  DCHECK(backend);
+
+  const std::vector<Profile*>& profiles =
+      g_browser_process->profile_manager()->GetLoadedProfiles();
+  for (auto* profile : profiles) {
+    if (profile->IsOffTheRecord())
+      continue;
+    const GURL site = util::GetSiteForExtensionId(extension_id(), profile);
+    storage::FileSystemContext* const context =
+        content::BrowserContext::GetStoragePartitionForSite(profile, site)
+            ->GetFileSystemContext();
+    for (const auto& url : params->entry_urls) {
+      const storage::FileSystemURL file_system_url =
+          context->CrackURL(GURL(url));
+      // Grant permissions only to valid urls backed by the external file system
+      // backend.
+      if (!file_system_url.is_valid() ||
+          file_system_url.mount_type() != storage::kFileSystemTypeExternal) {
+        continue;
+      }
+      backend->GrantFileAccessToExtension(extension_->id(),
+                                          file_system_url.virtual_path());
+      content::ChildProcessSecurityPolicy::GetInstance()
+          ->GrantCreateReadWriteFile(render_frame_host()->GetProcess()->GetID(),
+                                     file_system_url.path());
+    }
+  }
+  return RespondNow(NoArguments());
+}
+
+namespace {
+
+void PostResponseCallbackTaskToUIThread(
+    const FileWatchFunctionBase::ResponseCallback& callback,
+    bool success) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
+                          base::BindOnce(callback, success));
+}
+
+void PostNotificationCallbackTaskToUIThread(
+    const storage::WatcherManager::NotificationCallback& callback,
+    storage::WatcherManager::ChangeType type) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
+                          base::BindOnce(callback, type));
+}
+
+}  // namespace
+
+void FileWatchFunctionBase::Respond(bool success) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  SetResult(std::make_unique<base::Value>(success));
+  SendResponse(success);
+}
+
+bool FileWatchFunctionBase::RunAsync() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (!render_frame_host() || !render_frame_host()->GetProcess())
+    return false;
+
+  // First param is url of a file to watch.
+  std::string url;
+  if (!args_->GetString(0, &url) || url.empty())
+    return false;
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  const FileSystemURL file_system_url =
+      file_system_context->CrackURL(GURL(url));
+  if (file_system_url.path().empty()) {
+    Respond(false);
+    return true;
+  }
+
+  file_manager::EventRouter* const event_router =
+      file_manager::EventRouterFactory::GetForProfile(GetProfile());
+
+  BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::BindOnce(&FileWatchFunctionBase::RunAsyncOnIOThread, this,
+                     file_system_context, file_system_url,
+                     event_router->GetWeakPtr()));
+  return true;
+}
+
+void FileWatchFunctionBase::RunAsyncOnIOThread(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const storage::FileSystemURL& file_system_url,
+    base::WeakPtr<file_manager::EventRouter> event_router) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  storage::WatcherManager* const watcher_manager =
+      file_system_context->GetWatcherManager(file_system_url.type());
+
+  if (!watcher_manager) {
+    BrowserThread::PostTask(
+        BrowserThread::UI, FROM_HERE,
+        base::BindOnce(
+            &FileWatchFunctionBase::PerformFallbackFileWatchOperationOnUIThread,
+            this, file_system_url, event_router));
+    return;
+  }
+
+  PerformFileWatchOperationOnIOThread(file_system_context, watcher_manager,
+                                      file_system_url, event_router);
+}
+
+void FileManagerPrivateInternalAddFileWatchFunction::
+    PerformFileWatchOperationOnIOThread(
+        scoped_refptr<storage::FileSystemContext> file_system_context,
+        storage::WatcherManager* watcher_manager,
+        const storage::FileSystemURL& file_system_url,
+        base::WeakPtr<file_manager::EventRouter> event_router) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  watcher_manager->AddWatcher(
+      file_system_url, false /* recursive */,
+      base::Bind(&StatusCallbackToResponseCallback,
+                 base::Bind(&PostResponseCallbackTaskToUIThread,
+                            base::Bind(&FileWatchFunctionBase::Respond, this))),
+      base::Bind(
+          &PostNotificationCallbackTaskToUIThread,
+          base::Bind(&file_manager::EventRouter::OnWatcherManagerNotification,
+                     event_router, file_system_url, extension_id())));
+}
+
+void FileManagerPrivateInternalAddFileWatchFunction::
+    PerformFallbackFileWatchOperationOnUIThread(
+        const storage::FileSystemURL& file_system_url,
+        base::WeakPtr<file_manager::EventRouter> event_router) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(event_router);
+
+  // Obsolete. Fallback code if storage::WatcherManager is not implemented.
+  event_router->AddFileWatch(file_system_url.path(),
+                             file_system_url.virtual_path(), extension_id(),
+                             base::Bind(&FileWatchFunctionBase::Respond, this));
+}
+
+void FileManagerPrivateInternalRemoveFileWatchFunction::
+    PerformFileWatchOperationOnIOThread(
+        scoped_refptr<storage::FileSystemContext> file_system_context,
+        storage::WatcherManager* watcher_manager,
+        const storage::FileSystemURL& file_system_url,
+        base::WeakPtr<file_manager::EventRouter> event_router) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  watcher_manager->RemoveWatcher(
+      file_system_url, false /* recursive */,
+      base::Bind(
+          &StatusCallbackToResponseCallback,
+          base::Bind(&PostResponseCallbackTaskToUIThread,
+                     base::Bind(&FileWatchFunctionBase::Respond, this))));
+}
+
+void FileManagerPrivateInternalRemoveFileWatchFunction::
+    PerformFallbackFileWatchOperationOnUIThread(
+        const storage::FileSystemURL& file_system_url,
+        base::WeakPtr<file_manager::EventRouter> event_router) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(event_router);
+
+  // Obsolete. Fallback code if storage::WatcherManager is not implemented.
+  event_router->RemoveFileWatch(file_system_url.path(), extension_id());
+  Respond(true);
+}
+
+bool FileManagerPrivateGetSizeStatsFunction::RunAsync() {
+  using extensions::api::file_manager_private::GetSizeStats::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  using file_manager::VolumeManager;
+  using file_manager::Volume;
+  VolumeManager* const volume_manager = VolumeManager::Get(GetProfile());
+  if (!volume_manager)
+    return false;
+
+  base::WeakPtr<Volume> volume =
+      volume_manager->FindVolumeById(params->volume_id);
+  if (!volume.get())
+    return false;
+
+  uint64_t* total_size = new uint64_t(0);
+  uint64_t* remaining_size = new uint64_t(0);
+  base::PostTaskWithTraitsAndReply(
+      FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_VISIBLE},
+      base::BindOnce(&GetSizeStatsAsync, volume->mount_path(), total_size,
+                     remaining_size),
+      base::BindOnce(&FileManagerPrivateGetSizeStatsFunction::OnGetSizeStats,
+                     this, base::Owned(total_size),
+                     base::Owned(remaining_size)));
+
+  return true;
+}
+
+void FileManagerPrivateGetSizeStatsFunction::OnGetSizeStats(
+    const uint64_t* total_size,
+    const uint64_t* remaining_size) {
+  std::unique_ptr<base::DictionaryValue> sizes(new base::DictionaryValue());
+
+  sizes->SetDouble("totalSize", static_cast<double>(*total_size));
+  sizes->SetDouble("remainingSize", static_cast<double>(*remaining_size));
+
+  SetResult(std::move(sizes));
+  SendResponse(true);
+}
+
+bool FileManagerPrivateInternalValidatePathNameLengthFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::ValidatePathNameLength::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  const storage::FileSystemURL file_system_url(
+      file_system_context->CrackURL(GURL(params->parent_url)));
+  if (!chromeos::FileSystemBackend::CanHandleURL(file_system_url))
+    return false;
+
+  // No explicit limit on the length of Drive file names.
+  if (file_system_url.type() == storage::kFileSystemTypeDrive) {
+    SetResult(std::make_unique<base::Value>(true));
+    SendResponse(true);
+    return true;
+  }
+
+  base::PostTaskWithTraitsAndReplyWithResult(
+      FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_BLOCKING},
+      base::Bind(&GetFileNameMaxLengthAsync,
+                 file_system_url.path().AsUTF8Unsafe()),
+      base::Bind(&FileManagerPrivateInternalValidatePathNameLengthFunction::
+                     OnFilePathLimitRetrieved,
+                 this, params->name.size()));
+  return true;
+}
+
+void FileManagerPrivateInternalValidatePathNameLengthFunction::
+    OnFilePathLimitRetrieved(size_t current_length, size_t max_length) {
+  SetResult(std::make_unique<base::Value>(current_length <= max_length));
+  SendResponse(true);
+}
+
+bool FileManagerPrivateFormatVolumeFunction::RunAsync() {
+  return false;
+}
+
+bool FileManagerPrivateRenameVolumeFunction::RunAsync() {
+  return false;
+}
+
+// Obtains file size of URL.
+void GetFileMetadataOnIOThread(
+    scoped_refptr<storage::FileSystemContext> file_system_context,
+    const FileSystemURL& url,
+    int fields,
+    const storage::FileSystemOperation::GetMetadataCallback& callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+  file_system_context->operation_runner()->GetMetadata(
+      url, fields, base::Bind(&GetFileMetadataRespondOnUIThread, callback));
+}
+
+// Checks if the available space of the |path| is enough for required |bytes|.
+bool CheckLocalDiskSpace(const base::FilePath& path, int64_t bytes) {
+  return bytes <= base::SysInfo::AmountOfFreeDiskSpace(path) -
+                      cryptohome::kMinFreeSpaceInBytes;
+}
+
+bool FileManagerPrivateInternalStartCopyFunction::RunAsync() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  using extensions::api::file_manager_private_internal::StartCopy::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  if (params->url.empty() || params->parent_url.empty() ||
+      params->new_name.empty()) {
+    // Error code in format of DOMError.name.
+    SetError("EncodingError");
+    return false;
+  }
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  // |parent| may have a trailing slash if it is a root directory.
+  std::string destination_url_string = params->parent_url;
+  if (destination_url_string.back() != '/')
+    destination_url_string += '/';
+  destination_url_string += net::EscapePath(params->new_name);
+
+  source_url_ = file_system_context->CrackURL(GURL(params->url));
+  destination_url_ =
+      file_system_context->CrackURL(GURL(destination_url_string));
+
+  if (!source_url_.is_valid() || !destination_url_.is_valid()) {
+    // Error code in format of DOMError.name.
+    SetError("EncodingError");
+    return false;
+  }
+
+  // Check if the destination directory is downloads. If so, secure available
+  // spece by freeing drive caches.
+  if (destination_url_.filesystem_id() ==
+      file_manager::util::GetDownloadsMountPointName(GetProfile())) {
+    return BrowserThread::PostTask(
+        BrowserThread::IO, FROM_HERE,
+        base::BindOnce(&GetFileMetadataOnIOThread, file_system_context,
+                       source_url_,
+                       storage::FileSystemOperation::GET_METADATA_FIELD_SIZE,
+                       base::Bind(&FileManagerPrivateInternalStartCopyFunction::
+                                      RunAfterGetFileMetadata,
+                                  this)));
+  }
+
+  return BrowserThread::PostTask(
+      BrowserThread::UI, FROM_HERE,
+      base::BindOnce(
+          &FileManagerPrivateInternalStartCopyFunction::RunAfterFreeDiskSpace,
+          this, true));
+}
+
+void FileManagerPrivateInternalStartCopyFunction::RunAfterGetFileMetadata(
+    base::File::Error result,
+    const base::File::Info& file_info) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (result != base::File::FILE_OK) {
+    SetError("NotFoundError");
+    SendResponse(false);
+    return;
+  }
+
+  base::PostTaskWithTraitsAndReplyWithResult(
+      FROM_HERE, {base::MayBlock()},
+      base::BindOnce(
+          &CheckLocalDiskSpace,
+          file_manager::util::GetDownloadsFolderForProfile(GetProfile()),
+          file_info.size),
+      base::BindOnce(
+          &FileManagerPrivateInternalStartCopyFunction::RunAfterFreeDiskSpace,
+          this));
+}
+
+void FileManagerPrivateInternalStartCopyFunction::RunAfterFreeDiskSpace(
+    bool available) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (!available) {
+    SetError("QuotaExceededError");
+    SendResponse(false);
+    return;
+  }
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+  const bool result = BrowserThread::PostTaskAndReplyWithResult(
+      BrowserThread::IO, FROM_HERE,
+      base::Bind(&StartCopyOnIOThread, GetProfile(), file_system_context,
+                 source_url_, destination_url_),
+      base::Bind(
+          &FileManagerPrivateInternalStartCopyFunction::RunAfterStartCopy,
+          this));
+  if (!result)
+    SendResponse(false);
+}
+
+void FileManagerPrivateInternalStartCopyFunction::RunAfterStartCopy(
+    int operation_id) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  SetResult(std::make_unique<base::Value>(operation_id));
+  SendResponse(true);
+}
+
+bool FileManagerPrivateCancelCopyFunction::RunAsync() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  using extensions::api::file_manager_private::CancelCopy::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  // We don't much take care about the result of cancellation.
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+                          base::BindOnce(&CancelCopyOnIOThread,
+                                         file_system_context, params->copy_id));
+  SendResponse(true);
+  return true;
+}
+
+bool FileManagerPrivateInternalResolveIsolatedEntriesFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::ResolveIsolatedEntries::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+  DCHECK(file_system_context.get());
+
+  const storage::ExternalFileSystemBackend* external_backend =
+      file_system_context->external_backend();
+  DCHECK(external_backend);
+
+  file_manager::util::FileDefinitionList file_definition_list;
+  for (size_t i = 0; i < params->urls.size(); ++i) {
+    const FileSystemURL file_system_url =
+        file_system_context->CrackURL(GURL(params->urls[i]));
+    DCHECK(external_backend->CanHandleType(file_system_url.type()))
+        << "GURL: " << file_system_url.ToGURL()
+        << "type: " << file_system_url.type();
+    FileDefinition file_definition;
+    const bool result =
+        file_manager::util::ConvertAbsoluteFilePathToRelativeFileSystemPath(
+            GetProfile(), extension_->id(), file_system_url.path(),
+            &file_definition.virtual_path);
+    if (!result)
+      continue;
+    // The API only supports isolated files. It still works for directories,
+    // as the value is ignored for existing entries.
+    file_definition.is_directory = false;
+    file_definition_list.push_back(file_definition);
+  }
+
+  file_manager::util::ConvertFileDefinitionListToEntryDefinitionList(
+      GetProfile(),
+      extension_->id(),
+      file_definition_list,  // Safe, since copied internally.
+      base::Bind(
+          &FileManagerPrivateInternalResolveIsolatedEntriesFunction::
+              RunAsyncAfterConvertFileDefinitionListToEntryDefinitionList,
+          this));
+  return true;
+}
+
+void FileManagerPrivateInternalResolveIsolatedEntriesFunction::
+    RunAsyncAfterConvertFileDefinitionListToEntryDefinitionList(
+        std::unique_ptr<file_manager::util::EntryDefinitionList>
+            entry_definition_list) {
+  using extensions::api::file_manager_private_internal::EntryDescription;
+  std::vector<EntryDescription> entries;
+
+  for (const auto& definition : *entry_definition_list) {
+    if (definition.error != base::File::FILE_OK)
+      continue;
+    EntryDescription entry;
+    entry.file_system_name = definition.file_system_name;
+    entry.file_system_root = definition.file_system_root_url;
+    entry.file_full_path = "/" + definition.full_path.AsUTF8Unsafe();
+    entry.file_is_directory = definition.is_directory;
+    entries.push_back(std::move(entry));
+  }
+
+  results_ = extensions::api::file_manager_private_internal::
+      ResolveIsolatedEntries::Results::Create(entries);
+  SendResponse(true);
+}
+
+FileManagerPrivateInternalComputeChecksumFunction::
+    FileManagerPrivateInternalComputeChecksumFunction()
+    : digester_(new drive::util::FileStreamMd5Digester()) {
+}
+
+FileManagerPrivateInternalComputeChecksumFunction::
+    ~FileManagerPrivateInternalComputeChecksumFunction() = default;
+
+bool FileManagerPrivateInternalComputeChecksumFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::ComputeChecksum::Params;
+  using drive::util::FileStreamMd5Digester;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  if (params->url.empty()) {
+    SetError("File URL must be provided.");
+    return false;
+  }
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  FileSystemURL file_system_url(
+      file_system_context->CrackURL(GURL(params->url)));
+  if (!file_system_url.is_valid()) {
+    SetError("File URL was invalid");
+    return false;
+  }
+
+  std::unique_ptr<storage::FileStreamReader> reader =
+      file_system_context->CreateFileStreamReader(
+          file_system_url, 0, storage::kMaximumLength, base::Time());
+
+  FileStreamMd5Digester::ResultCallback result_callback = base::Bind(
+      &ComputeChecksumRespondOnUIThread,
+      base::Bind(&FileManagerPrivateInternalComputeChecksumFunction::Respond,
+                 this));
+  BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::BindOnce(&FileStreamMd5Digester::GetMd5Digest,
+                     base::Unretained(digester_.get()), base::Passed(&reader),
+                     result_callback));
+
+  return true;
+}
+
+void FileManagerPrivateInternalComputeChecksumFunction::Respond(
+    const std::string& hash) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  SetResult(std::make_unique<base::Value>(hash));
+  SendResponse(true);
+}
+
+bool FileManagerPrivateSearchFilesByHashesFunction::RunAsync() {
+  return false;
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateIsUMAEnabledFunction::Run() {
+  return RespondNow(OneArgument(std::make_unique<base::Value>(
+      ChromeMetricsServiceAccessor::IsMetricsAndCrashReportingEnabled())));
+}
+
+FileManagerPrivateInternalSetEntryTagFunction::
+    FileManagerPrivateInternalSetEntryTagFunction()
+    : chrome_details_(this) {}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateInternalSetEntryTagFunction::Run() {
+  return RespondNow(Error("Drive is disabled."));
+}
+
+bool FileManagerPrivateInternalGetDirectorySizeFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::GetDirectorySize::
+      Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  if (params->url.empty()) {
+    SetError("File URL must be provided.");
+    return false;
+  }
+
+  scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+  const storage::FileSystemURL file_system_url(
+      file_system_context->CrackURL(GURL(params->url)));
+  if (!chromeos::FileSystemBackend::CanHandleURL(file_system_url)) {
+    SetError("FileSystemBackend failed to handle the entry's url.");
+    return false;
+  }
+  if (file_system_url.type() != storage::kFileSystemTypeNativeLocal) {
+    SetError("Only local directories are supported.");
+    return false;
+  }
+
+  const base::FilePath root_path = file_manager::util::GetLocalPathFromURL(
+      render_frame_host(), GetProfile(), GURL(params->url));
+  if (root_path.empty()) {
+    SetError("Failed to get a local path from the entry's url.");
+    return false;
+  }
+
+  base::PostTaskWithTraitsAndReplyWithResult(
+      FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_VISIBLE},
+      base::Bind(&base::ComputeDirectorySize, root_path),
+      base::Bind(&FileManagerPrivateInternalGetDirectorySizeFunction::
+                     OnDirectorySizeRetrieved,
+                 this));
+  return true;
+}
+
+void FileManagerPrivateInternalGetDirectorySizeFunction::
+    OnDirectorySizeRetrieved(int64_t size) {
+  SetResult(std::make_unique<base::Value>(static_cast<double>(size)));
+  SendResponse(true);
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_manager/linux/private_api_file_system.h b/chrome/browser/extensions/api/file_manager/linux/private_api_file_system.h
new file mode 100644
index 0000000000000..fb120fd216b7f
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/linux/private_api_file_system.h
@@ -0,0 +1,375 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides file system related API functions.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_LINUX_PRIVATE_API_FILE_SYSTEM_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_LINUX_PRIVATE_API_FILE_SYSTEM_H_
+
+#include "base/callback_forward.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_base.h"
+#include "chrome/browser/extensions/chrome_extension_function.h"
+#include "chrome/browser/extensions/chrome_extension_function_details.h"
+#include "extensions/browser/extension_function.h"
+#include "storage/browser/fileapi/file_system_url.h"
+
+namespace storage {
+class FileSystemContext;
+class FileSystemURL;
+class WatcherManager;
+}  // namespace storage
+
+namespace file_manager {
+class EventRouter;
+namespace util {
+struct EntryDefinition;
+typedef std::vector<EntryDefinition> EntryDefinitionList;
+}  // namespace util
+}  // namespace file_manager
+
+namespace drive {
+namespace util {
+class FileStreamMd5Digester;
+}  // namespace util
+struct HashAndFilePath;
+}  // namespace drive
+
+namespace extensions {
+
+// Grant permission to request externalfile scheme. The permission is needed to
+// start drag for external file URL.
+class FileManagerPrivateEnableExternalFileSchemeFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.enableExternalFileScheme",
+                             FILEMANAGERPRIVATE_ENABLEEXTERNALFILESCHEME);
+
+ protected:
+  ~FileManagerPrivateEnableExternalFileSchemeFunction() override = default;
+
+ private:
+  ExtensionFunction::ResponseAction Run() override;
+};
+
+// Grants R/W permissions to profile-specific directories (Drive, Downloads)
+// from other profiles.
+class FileManagerPrivateGrantAccessFunction : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateGrantAccessFunction();
+
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.grantAccess",
+                             FILEMANAGERPRIVATE_GRANTACCESS)
+
+ protected:
+  ~FileManagerPrivateGrantAccessFunction() override = default;
+
+ private:
+  ExtensionFunction::ResponseAction Run() override;
+  const ChromeExtensionFunctionDetails chrome_details_;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateGrantAccessFunction);
+};
+
+// Base class for FileManagerPrivateInternalAddFileWatchFunction and
+// FileManagerPrivateInternalRemoveFileWatchFunction. Although it's called
+// "FileWatch",
+// the class and its sub classes are used only for watching changes in
+// directories.
+class FileWatchFunctionBase : public LoggedAsyncExtensionFunction {
+ public:
+  using ResponseCallback = base::Callback<void(bool success)>;
+
+  // Calls SendResponse() with |success| converted to base::Value.
+  void Respond(bool success);
+
+ protected:
+  ~FileWatchFunctionBase() override = default;
+
+  // Performs a file watch operation (ex. adds or removes a file watch) on
+  // the IO thread with storage::WatcherManager.
+  virtual void PerformFileWatchOperationOnIOThread(
+      scoped_refptr<storage::FileSystemContext> file_system_context,
+      storage::WatcherManager* watcher_manager,
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router) = 0;
+
+  // Performs a file watch operation (ex. adds or removes a file watch) on
+  // the UI thread with file_manager::EventRouter. This is a fallback operation
+  // called only when WatcherManager is unavailable.
+  virtual void PerformFallbackFileWatchOperationOnUIThread(
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router) = 0;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  void RunAsyncOnIOThread(
+      scoped_refptr<storage::FileSystemContext> file_system_context,
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router);
+};
+
+// Implements the chrome.fileManagerPrivate.addFileWatch method.
+// Starts watching changes in directories.
+class FileManagerPrivateInternalAddFileWatchFunction
+    : public FileWatchFunctionBase {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.addFileWatch",
+                             FILEMANAGERPRIVATEINTERNAL_ADDFILEWATCH)
+
+ protected:
+  ~FileManagerPrivateInternalAddFileWatchFunction() override = default;
+
+  // FileWatchFunctionBase override.
+  void PerformFileWatchOperationOnIOThread(
+      scoped_refptr<storage::FileSystemContext> file_system_context,
+      storage::WatcherManager* watcher_manager,
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router) override;
+  void PerformFallbackFileWatchOperationOnUIThread(
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router) override;
+};
+
+
+// Implements the chrome.fileManagerPrivate.removeFileWatch method.
+// Stops watching changes in directories.
+class FileManagerPrivateInternalRemoveFileWatchFunction
+    : public FileWatchFunctionBase {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.removeFileWatch",
+                             FILEMANAGERPRIVATEINTERNAL_REMOVEFILEWATCH)
+
+ protected:
+  ~FileManagerPrivateInternalRemoveFileWatchFunction() override = default;
+
+  // FileWatchFunctionBase override.
+  void PerformFileWatchOperationOnIOThread(
+      scoped_refptr<storage::FileSystemContext> file_system_context,
+      storage::WatcherManager* watcher_manager,
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router) override;
+  void PerformFallbackFileWatchOperationOnUIThread(
+      const storage::FileSystemURL& file_system_url,
+      base::WeakPtr<file_manager::EventRouter> event_router) override;
+};
+
+// Implements the chrome.fileManagerPrivate.getSizeStats method.
+class FileManagerPrivateGetSizeStatsFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.getSizeStats",
+                             FILEMANAGERPRIVATE_GETSIZESTATS)
+
+ protected:
+  ~FileManagerPrivateGetSizeStatsFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  void OnGetSizeStats(const uint64_t* total_size,
+                      const uint64_t* remaining_size);
+};
+
+// Implements the chrome.fileManagerPrivate.validatePathNameLength method.
+class FileManagerPrivateInternalValidatePathNameLengthFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileManagerPrivateInternal.validatePathNameLength",
+      FILEMANAGERPRIVATEINTERNAL_VALIDATEPATHNAMELENGTH)
+
+ protected:
+  ~FileManagerPrivateInternalValidatePathNameLengthFunction() override =
+      default;
+
+  void OnFilePathLimitRetrieved(size_t current_length, size_t max_length);
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivate.formatVolume method.
+// Formats Volume given its mount path.
+class FileManagerPrivateFormatVolumeFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.formatVolume",
+                             FILEMANAGERPRIVATE_FORMATVOLUME)
+
+ protected:
+  ~FileManagerPrivateFormatVolumeFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivate.renameVolume method.
+// Renames Volume given its mount path and new Volume name.
+class FileManagerPrivateRenameVolumeFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.renameVolume",
+                             FILEMANAGERPRIVATE_RENAMEVOLUME)
+
+ protected:
+  ~FileManagerPrivateRenameVolumeFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivate.startCopy method.
+class FileManagerPrivateInternalStartCopyFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.startCopy",
+                             FILEMANAGERPRIVATEINTERNAL_STARTCOPY)
+
+ protected:
+  ~FileManagerPrivateInternalStartCopyFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  void RunAfterGetFileMetadata(base::File::Error result,
+                               const base::File::Info& file_info);
+
+  // Part of RunAsync(). Called after FreeDiskSpaceIfNeededFor() is completed on
+  // IO thread.
+  void RunAfterFreeDiskSpace(bool available);
+
+  // Part of RunAsync(). Called after Copy() is started on IO thread.
+  void RunAfterStartCopy(int operation_id);
+
+  storage::FileSystemURL source_url_;
+  storage::FileSystemURL destination_url_;
+};
+
+// Implements the chrome.fileManagerPrivate.cancelCopy method.
+class FileManagerPrivateCancelCopyFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.cancelCopy",
+                             FILEMANAGERPRIVATE_CANCELCOPY)
+
+ protected:
+  ~FileManagerPrivateCancelCopyFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivateInternal.resolveIsolatedEntries
+// method.
+class FileManagerPrivateInternalResolveIsolatedEntriesFunction
+    : public ChromeAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "fileManagerPrivateInternal.resolveIsolatedEntries",
+      FILEMANAGERPRIVATE_RESOLVEISOLATEDENTRIES)
+
+ protected:
+  ~FileManagerPrivateInternalResolveIsolatedEntriesFunction() override =
+      default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  void RunAsyncAfterConvertFileDefinitionListToEntryDefinitionList(
+      std::unique_ptr<file_manager::util::EntryDefinitionList>
+          entry_definition_list);
+};
+
+class FileManagerPrivateInternalComputeChecksumFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  FileManagerPrivateInternalComputeChecksumFunction();
+
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.computeChecksum",
+                             FILEMANAGERPRIVATEINTERNAL_COMPUTECHECKSUM)
+
+ protected:
+  ~FileManagerPrivateInternalComputeChecksumFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+ private:
+  std::unique_ptr<drive::util::FileStreamMd5Digester> digester_;
+
+  void Respond(const std::string& hash);
+};
+
+// Implements the chrome.fileManagerPrivate.searchFilesByHashes method.
+class FileManagerPrivateSearchFilesByHashesFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.searchFilesByHashes",
+                             FILEMANAGERPRIVATE_SEARCHFILESBYHASHES)
+
+ protected:
+  ~FileManagerPrivateSearchFilesByHashesFunction() override = default;
+
+ private:
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivate.isUMAEnabled method.
+class FileManagerPrivateIsUMAEnabledFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateIsUMAEnabledFunction() = default;
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.isUMAEnabled",
+                             FILEMANAGERPRIVATE_ISUMAENABLED)
+ protected:
+  ~FileManagerPrivateIsUMAEnabledFunction() override = default;
+
+ private:
+  ExtensionFunction::ResponseAction Run() override;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateIsUMAEnabledFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.setEntryTag method.
+class FileManagerPrivateInternalSetEntryTagFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateInternalSetEntryTagFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.setEntryTag",
+                             FILEMANAGERPRIVATEINTERNAL_SETENTRYTAG)
+ protected:
+  ~FileManagerPrivateInternalSetEntryTagFunction() override = default;
+
+ private:
+  const ChromeExtensionFunctionDetails chrome_details_;
+
+  ExtensionFunction::ResponseAction Run() override;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateInternalSetEntryTagFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.getDirectorySize method.
+class FileManagerPrivateInternalGetDirectorySizeFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getDirectorySize",
+                             FILEMANAGERPRIVATEINTERNAL_GETDIRECTORYSIZE)
+
+ protected:
+  ~FileManagerPrivateInternalGetDirectorySizeFunction() override = default;
+
+  void OnDirectorySizeRetrieved(int64_t size);
+
+  // ChromeAsyncExtensionFunction overrides
+  bool RunAsync() override;
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_LINUX_PRIVATE_API_FILE_SYSTEM_H_
diff --git a/chrome/browser/extensions/api/file_manager/linux/private_api_misc.cc b/chrome/browser/extensions/api/file_manager/linux/private_api_misc.cc
new file mode 100644
index 0000000000000..33a4812b88f53
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/linux/private_api_misc.cc
@@ -0,0 +1,361 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/linux/private_api_misc.h"
+
+#include "base/base64.h"
+#include "base/command_line.h"
+#include "base/files/file_path.h"
+#include "base/memory/ref_counted.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/browser/fileapi/recent_file.h"
+#include "chrome/browser/fileapi/recent_model.h"
+#include "chrome/browser/chromeos/profiles/profile_helper.h"
+#include "chrome/browser/chromeos/settings/cros_settings.h"
+#include "chrome/browser/devtools/devtools_window.h"
+#include "chrome/browser/extensions/devtools_util.h"
+#include "chrome/browser/lifetime/application_lifetime.h"
+#include "chrome/browser/net/system_network_context_manager.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/browser/ui/chrome_pages.h"
+#include "chrome/common/extensions/api/file_manager_private_internal.h"
+#include "chrome/common/extensions/api/manifest_types.h"
+#include "components/zoom/page_zoom.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/common/page_zoom.h"
+#include "content/public/common/service_manager_connection.h"
+#include "extensions/browser/api/file_handlers/mime_util.h"
+#include "services/network/public/cpp/shared_url_loader_factory.h"
+#include "storage/common/fileapi/file_system_types.h"
+#include "ui/base/webui/web_ui_util.h"
+#include "url/gurl.h"
+
+namespace extensions {
+namespace {
+
+using api::file_manager_private::ProfileInfo;
+
+bool IsAllowedSource(storage::FileSystemType type,
+                     api::file_manager_private::SourceRestriction restriction) {
+  switch (restriction) {
+    case api::file_manager_private::SOURCE_RESTRICTION_NONE:
+      NOTREACHED();
+      return false;
+
+    case api::file_manager_private::SOURCE_RESTRICTION_ANY_SOURCE:
+      return true;
+
+    case api::file_manager_private::SOURCE_RESTRICTION_NATIVE_SOURCE:
+      return type == storage::kFileSystemTypeNativeLocal;
+
+    case api::file_manager_private::SOURCE_RESTRICTION_NATIVE_OR_DRIVE_SOURCE:
+      return type == storage::kFileSystemTypeNativeLocal ||
+             type == storage::kFileSystemTypeDrive;
+  }
+}
+
+}  // namespace
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateLogoutUserForReauthenticationFunction::Run() {
+  chrome::AttemptUserExit();
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateGetPreferencesFunction::Run() {
+  api::file_manager_private::Preferences result;
+  return RespondNow(OneArgument(result.ToValue()));
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateSetPreferencesFunction::Run() {
+  return RespondNow(NoArguments());
+}
+
+FileManagerPrivateInternalZipSelectionFunction::
+    FileManagerPrivateInternalZipSelectionFunction() = default;
+
+FileManagerPrivateInternalZipSelectionFunction::
+    ~FileManagerPrivateInternalZipSelectionFunction() = default;
+
+bool FileManagerPrivateInternalZipSelectionFunction::RunAsync() {
+  return false;
+}
+
+ExtensionFunction::ResponseAction FileManagerPrivateZoomFunction::Run() {
+  using extensions::api::file_manager_private::Zoom::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  content::PageZoom zoom_type;
+  switch (params->operation) {
+    case api::file_manager_private::ZOOM_OPERATION_TYPE_IN:
+      zoom_type = content::PAGE_ZOOM_IN;
+      break;
+    case api::file_manager_private::ZOOM_OPERATION_TYPE_OUT:
+      zoom_type = content::PAGE_ZOOM_OUT;
+      break;
+    case api::file_manager_private::ZOOM_OPERATION_TYPE_RESET:
+      zoom_type = content::PAGE_ZOOM_RESET;
+      break;
+    default:
+      NOTREACHED();
+      return RespondNow(Error(kUnknownErrorDoNotUse));
+  }
+  zoom::PageZoom::Zoom(GetSenderWebContents(), zoom_type);
+  return RespondNow(NoArguments());
+}
+
+FileManagerPrivateRequestWebStoreAccessTokenFunction::
+    FileManagerPrivateRequestWebStoreAccessTokenFunction() = default;
+
+FileManagerPrivateRequestWebStoreAccessTokenFunction::
+    ~FileManagerPrivateRequestWebStoreAccessTokenFunction() = default;
+
+bool FileManagerPrivateRequestWebStoreAccessTokenFunction::RunAsync() {
+  SetResult(std::make_unique<base::Value>());
+  return false;
+}
+
+ExtensionFunction::ResponseAction FileManagerPrivateGetProfilesFunction::Run() {
+  return RespondNow(Error("Failed to get profile."));
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateOpenInspectorFunction::Run() {
+  using extensions::api::file_manager_private::OpenInspector::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  switch (params->type) {
+    case extensions::api::file_manager_private::INSPECTION_TYPE_NORMAL:
+      // Open inspector for foreground page.
+      DevToolsWindow::OpenDevToolsWindow(GetSenderWebContents());
+      break;
+    case extensions::api::file_manager_private::INSPECTION_TYPE_CONSOLE:
+      // Open inspector for foreground page and bring focus to the console.
+      DevToolsWindow::OpenDevToolsWindow(
+          GetSenderWebContents(), DevToolsToggleAction::ShowConsolePanel());
+      break;
+    case extensions::api::file_manager_private::INSPECTION_TYPE_ELEMENT:
+      // Open inspector for foreground page in inspect element mode.
+      DevToolsWindow::OpenDevToolsWindow(GetSenderWebContents(),
+                                         DevToolsToggleAction::Inspect());
+      break;
+    case extensions::api::file_manager_private::INSPECTION_TYPE_BACKGROUND:
+      // Open inspector for background page.
+      extensions::devtools_util::InspectBackgroundPage(
+          extension(), Profile::FromBrowserContext(browser_context()));
+      break;
+    default:
+      NOTREACHED();
+      return RespondNow(Error(
+          base::StringPrintf("Unexpected inspection type(%d) is specified.",
+                             static_cast<int>(params->type))));
+  }
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateOpenSettingsSubpageFunction::Run() {
+  using extensions::api::file_manager_private::OpenSettingsSubpage::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  chrome::ShowSettingsSubPageForProfile(ProfileManager::GetActiveUserProfile(),
+                                        params->sub_page);
+  return RespondNow(NoArguments());
+}
+
+FileManagerPrivateInternalGetMimeTypeFunction::
+    FileManagerPrivateInternalGetMimeTypeFunction() = default;
+
+FileManagerPrivateInternalGetMimeTypeFunction::
+    ~FileManagerPrivateInternalGetMimeTypeFunction() = default;
+
+bool FileManagerPrivateInternalGetMimeTypeFunction::RunAsync() {
+  using extensions::api::file_manager_private_internal::GetMimeType::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  // Convert file url to local path.
+  const scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          GetProfile(), render_frame_host());
+
+  storage::FileSystemURL file_system_url(
+      file_system_context->CrackURL(GURL(params->url)));
+
+  app_file_handler_util::GetMimeTypeForLocalPath(
+      GetProfile(), file_system_url.path(),
+      base::Bind(&FileManagerPrivateInternalGetMimeTypeFunction::OnGetMimeType,
+                 this));
+
+  return true;
+}
+
+void FileManagerPrivateInternalGetMimeTypeFunction::OnGetMimeType(
+    const std::string& mimeType) {
+  SetResult(std::make_unique<base::Value>(mimeType));
+  SendResponse(true);
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateIsPiexLoaderEnabledFunction::Run() {
+#if defined(OFFICIAL_BUILD)
+  return RespondNow(OneArgument(std::make_unique<base::Value>(true)));
+#else
+  return RespondNow(OneArgument(std::make_unique<base::Value>(false)));
+#endif
+}
+
+FileManagerPrivateGetProvidersFunction::FileManagerPrivateGetProvidersFunction() {}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateGetProvidersFunction::Run() {
+  return RespondNow(Error("Not supported"));;
+}
+
+FileManagerPrivateAddProvidedFileSystemFunction::
+    FileManagerPrivateAddProvidedFileSystemFunction() {}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateAddProvidedFileSystemFunction::Run() {
+  return RespondNow(Error("Failed to request a new mount."));
+}
+
+FileManagerPrivateConfigureVolumeFunction::
+    FileManagerPrivateConfigureVolumeFunction() {}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateConfigureVolumeFunction::Run() {
+  return RespondNow(Error("Volume not configurable."));
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateIsCrostiniEnabledFunction::Run() {
+  return RespondNow(OneArgument(std::make_unique<base::Value>(false)));
+}
+
+FileManagerPrivateMountCrostiniContainerFunction::
+    FileManagerPrivateMountCrostiniContainerFunction() = default;
+
+FileManagerPrivateMountCrostiniContainerFunction::
+    ~FileManagerPrivateMountCrostiniContainerFunction() = default;
+
+bool FileManagerPrivateMountCrostiniContainerFunction::RunAsync() {
+  return false;
+}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateInternalInstallLinuxPackageFunction::Run() {
+  return RespondNow(Error("Not supported."));
+}
+
+FileManagerPrivateInternalGetCustomActionsFunction::
+    FileManagerPrivateInternalGetCustomActionsFunction() {}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateInternalGetCustomActionsFunction::Run() {
+  return RespondNow(Error("Not supported."));
+}
+
+FileManagerPrivateInternalExecuteCustomActionFunction::
+    FileManagerPrivateInternalExecuteCustomActionFunction() {}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateInternalExecuteCustomActionFunction::Run() {
+  return RespondNow(Error("Failed to execute the action."));
+}
+
+FileManagerPrivateInternalGetRecentFilesFunction::
+    FileManagerPrivateInternalGetRecentFilesFunction()
+    : chrome_details_(this) {}
+
+ExtensionFunction::ResponseAction
+FileManagerPrivateInternalGetRecentFilesFunction::Run() {
+  using extensions::api::file_manager_private_internal::GetRecentFiles::Params;
+  const std::unique_ptr<Params> params(Params::Create(*args_));
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  const scoped_refptr<storage::FileSystemContext> file_system_context =
+      file_manager::util::GetFileSystemContextForRenderFrameHost(
+          chrome_details_.GetProfile(), render_frame_host());
+
+  chromeos::RecentModel* model =
+      chromeos::RecentModel::GetForProfile(chrome_details_.GetProfile());
+
+  model->GetRecentFiles(
+      file_system_context.get(),
+      Extension::GetBaseURLFromExtensionId(extension_id()),
+      base::BindOnce(
+          &FileManagerPrivateInternalGetRecentFilesFunction::OnGetRecentFiles,
+          this, params->restriction));
+  return RespondLater();
+}
+
+void FileManagerPrivateInternalGetRecentFilesFunction::OnGetRecentFiles(
+    api::file_manager_private::SourceRestriction restriction,
+    const std::vector<chromeos::RecentFile>& files) {
+  file_manager::util::FileDefinitionList file_definition_list;
+  for (const auto& file : files) {
+    // Filter out files from non-allowed sources.
+    // We do this filtering here rather than in RecentModel so that the set of
+    // files returned with some restriction is a subset of what would be
+    // returned without restriction. Anyway, the maximum number of files
+    // returned from RecentModel is large enough.
+    if (!IsAllowedSource(file.url().type(), restriction))
+      continue;
+
+    file_manager::util::FileDefinition file_definition;
+    const bool result =
+        file_manager::util::ConvertAbsoluteFilePathToRelativeFileSystemPath(
+            chrome_details_.GetProfile(), extension_id(), file.url().path(),
+            &file_definition.virtual_path);
+    if (!result)
+      continue;
+
+    // Recent file system only lists regular files, not directories.
+    file_definition.is_directory = false;
+    file_definition_list.emplace_back(std::move(file_definition));
+  }
+
+  file_manager::util::ConvertFileDefinitionListToEntryDefinitionList(
+      chrome_details_.GetProfile(), extension_id(),
+      file_definition_list,  // Safe, since copied internally.
+      base::Bind(&FileManagerPrivateInternalGetRecentFilesFunction::
+                     OnConvertFileDefinitionListToEntryDefinitionList,
+                 this));
+}
+
+void FileManagerPrivateInternalGetRecentFilesFunction::
+    OnConvertFileDefinitionListToEntryDefinitionList(
+        std::unique_ptr<file_manager::util::EntryDefinitionList>
+            entry_definition_list) {
+  DCHECK(entry_definition_list);
+
+  auto entries = std::make_unique<base::ListValue>();
+
+  for (const auto& definition : *entry_definition_list) {
+    if (definition.error != base::File::FILE_OK)
+      continue;
+    auto entry = std::make_unique<base::DictionaryValue>();
+    entry->SetString("fileSystemName", definition.file_system_name);
+    entry->SetString("fileSystemRoot", definition.file_system_root_url);
+    entry->SetString("fileFullPath", "/" + definition.full_path.AsUTF8Unsafe());
+    entry->SetBoolean("fileIsDirectory", definition.is_directory);
+    entries->Append(std::move(entry));
+  }
+
+  Respond(OneArgument(std::move(entries)));
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_manager/linux/private_api_misc.h b/chrome/browser/extensions/api/file_manager/linux/private_api_misc.h
new file mode 100644
index 0000000000000..c9128defd1988
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/linux/private_api_misc.h
@@ -0,0 +1,343 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides miscellaneous API functions, which don't belong to
+// other files.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_LINUX_PRIVATE_API_MISC_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_LINUX_PRIVATE_API_MISC_H_
+
+#include "base/files/file.h"
+#include "base/macros.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_base.h"
+#include "chrome/browser/extensions/chrome_extension_function.h"
+#include "chrome/browser/extensions/chrome_extension_function_details.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+
+namespace chromeos {
+class RecentFile;
+}  // namespace chromeos
+
+namespace file_manager {
+namespace util {
+struct EntryDefinition;
+typedef std::vector<EntryDefinition> EntryDefinitionList;
+}  // namespace util
+}  // namespace file_manager
+
+namespace extensions {
+
+// Implements the chrome.fileManagerPrivate.logoutUserForReauthentication
+// method.
+class FileManagerPrivateLogoutUserForReauthenticationFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.logoutUserForReauthentication",
+                             FILEMANAGERPRIVATE_LOGOUTUSERFORREAUTHENTICATION)
+
+ protected:
+  ~FileManagerPrivateLogoutUserForReauthenticationFunction() override = default;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.getPreferences method.
+// Gets settings for the Files app.
+class FileManagerPrivateGetPreferencesFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.getPreferences",
+                             FILEMANAGERPRIVATE_GETPREFERENCES)
+
+ protected:
+  ~FileManagerPrivateGetPreferencesFunction() override = default;
+
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.setPreferences method.
+// Sets settings for the Files app.
+class FileManagerPrivateSetPreferencesFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.setPreferences",
+                             FILEMANAGERPRIVATE_SETPREFERENCES)
+
+ protected:
+  ~FileManagerPrivateSetPreferencesFunction() override = default;
+
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.zipSelection method.
+// Creates a zip file for the selected files.
+class FileManagerPrivateInternalZipSelectionFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.zipSelection",
+                             FILEMANAGERPRIVATEINTERNAL_ZIPSELECTION)
+
+  FileManagerPrivateInternalZipSelectionFunction();
+
+ protected:
+  ~FileManagerPrivateInternalZipSelectionFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements the chrome.fileManagerPrivate.zoom method.
+// Changes the zoom level of the file manager by modifying the zoom level of the
+// WebContents.
+// TODO(hirono): Remove this function once the zoom level change is supported
+// for all apps. crbug.com/227175.
+class FileManagerPrivateZoomFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.zoom",
+                             FILEMANAGERPRIVATE_ZOOM);
+
+ protected:
+  ~FileManagerPrivateZoomFunction() override = default;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+};
+
+class FileManagerPrivateRequestWebStoreAccessTokenFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.requestWebStoreAccessToken",
+                             FILEMANAGERPRIVATE_REQUESTWEBSTOREACCESSTOKEN);
+
+  FileManagerPrivateRequestWebStoreAccessTokenFunction();
+
+ protected:
+  ~FileManagerPrivateRequestWebStoreAccessTokenFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+class FileManagerPrivateGetProfilesFunction : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.getProfiles",
+                             FILEMANAGERPRIVATE_GETPROFILES);
+
+ protected:
+  ~FileManagerPrivateGetProfilesFunction() override = default;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.openInspector method.
+class FileManagerPrivateOpenInspectorFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.openInspector",
+                             FILEMANAGERPRIVATE_OPENINSPECTOR);
+
+ protected:
+  ~FileManagerPrivateOpenInspectorFunction() override = default;
+
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.openSettingsSubpage method.
+class FileManagerPrivateOpenSettingsSubpageFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.openSettingsSubpage",
+                             FILEMANAGERPRIVATE_OPENSETTINGSSUBPAGE);
+
+ protected:
+  ~FileManagerPrivateOpenSettingsSubpageFunction() override = default;
+
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.getMimeType method.
+class FileManagerPrivateInternalGetMimeTypeFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getMimeType",
+                             FILEMANAGERPRIVATEINTERNAL_GETMIMETYPE)
+
+  FileManagerPrivateInternalGetMimeTypeFunction();
+
+ protected:
+  ~FileManagerPrivateInternalGetMimeTypeFunction() override;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+
+  void OnGetMimeType(const std::string& mimeType);
+};
+
+// Implements the chrome.fileManagerPrivate.isPiexLoaderEnabled method.
+class FileManagerPrivateIsPiexLoaderEnabledFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateIsPiexLoaderEnabledFunction() = default;
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.isPiexLoaderEnabled",
+                             FILEMANAGERPRIVATE_ISPIEXLOADERENABLED)
+ protected:
+  ~FileManagerPrivateIsPiexLoaderEnabledFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateIsPiexLoaderEnabledFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.getProviders method.
+class FileManagerPrivateGetProvidersFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateGetProvidersFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.getProviders",
+                             FILEMANAGERPRIVATE_GETPROVIDERS)
+ protected:
+  ~FileManagerPrivateGetProvidersFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateGetProvidersFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.addProvidedFileSystem method.
+class FileManagerPrivateAddProvidedFileSystemFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateAddProvidedFileSystemFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.addProvidedFileSystem",
+                             FILEMANAGERPRIVATE_ADDPROVIDEDFILESYSTEM)
+ protected:
+  ~FileManagerPrivateAddProvidedFileSystemFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateAddProvidedFileSystemFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.configureVolume method.
+class FileManagerPrivateConfigureVolumeFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateConfigureVolumeFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.configureVolume",
+                             FILEMANAGERPRIVATE_CONFIGUREVOLUME)
+ protected:
+  ~FileManagerPrivateConfigureVolumeFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateConfigureVolumeFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.isCrostiniEnabled method.
+// Gets crostini sftp mount params.
+class FileManagerPrivateIsCrostiniEnabledFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.isCrostiniEnabled",
+                             FILEMANAGERPRIVATE_ISCROSTINIENABLED)
+
+ protected:
+  ~FileManagerPrivateIsCrostiniEnabledFunction() override = default;
+
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.mountCrostiniContainer method.
+// Starts and mounts crostini container.
+class FileManagerPrivateMountCrostiniContainerFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.mountCrostiniContainer",
+                             FILEMANAGERPRIVATE_MOUNTCROSTINICONTAINER)
+  FileManagerPrivateMountCrostiniContainerFunction();
+
+ protected:
+  ~FileManagerPrivateMountCrostiniContainerFunction() override;
+
+  bool RunAsync() override;
+
+ private:
+  std::string source_path_;
+  std::string mount_label_;
+};
+
+// Implements the chrome.fileManagerPrivate.installLinuxPackage method.
+// Starts installation of a Linux package.
+class FileManagerPrivateInternalInstallLinuxPackageFunction
+    : public UIThreadExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.installLinuxPackage",
+                             FILEMANAGERPRIVATEINTERNAL_INSTALLLINUXPACKAGE)
+
+ protected:
+  ~FileManagerPrivateInternalInstallLinuxPackageFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+};
+
+// Implements the chrome.fileManagerPrivate.getCustomActions method.
+class FileManagerPrivateInternalGetCustomActionsFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateInternalGetCustomActionsFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getCustomActions",
+                             FILEMANAGERPRIVATEINTERNAL_GETCUSTOMACTIONS)
+ protected:
+  ~FileManagerPrivateInternalGetCustomActionsFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateInternalGetCustomActionsFunction);
+};
+
+// Implements the chrome.fileManagerPrivate.executeCustomAction method.
+class FileManagerPrivateInternalExecuteCustomActionFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateInternalExecuteCustomActionFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.executeCustomAction",
+                             FILEMANAGERPRIVATEINTERNAL_EXECUTECUSTOMACTION)
+ protected:
+  ~FileManagerPrivateInternalExecuteCustomActionFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  DISALLOW_COPY_AND_ASSIGN(
+      FileManagerPrivateInternalExecuteCustomActionFunction);
+};
+
+// Implements the chrome.fileManagerPrivateInternal.getRecentFiles method.
+class FileManagerPrivateInternalGetRecentFilesFunction
+    : public UIThreadExtensionFunction {
+ public:
+  FileManagerPrivateInternalGetRecentFilesFunction();
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivateInternal.getRecentFiles",
+                             FILEMANAGERPRIVATE_GETRECENTFILES)
+ protected:
+  ~FileManagerPrivateInternalGetRecentFilesFunction() override = default;
+
+ private:
+  ResponseAction Run() override;
+  void OnGetRecentFiles(
+      api::file_manager_private::SourceRestriction restriction,
+      const std::vector<chromeos::RecentFile>& files);
+  void OnConvertFileDefinitionListToEntryDefinitionList(
+      std::unique_ptr<file_manager::util::EntryDefinitionList>
+          entry_definition_list);
+
+  const ChromeExtensionFunctionDetails chrome_details_;
+  DISALLOW_COPY_AND_ASSIGN(FileManagerPrivateInternalGetRecentFilesFunction);
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_LINUX_PRIVATE_API_MISC_H_
diff --git a/chrome/browser/extensions/api/file_manager/linux/private_api_mount.cc b/chrome/browser/extensions/api/file_manager/linux/private_api_mount.cc
new file mode 100644
index 0000000000000..00026f1416e5d
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/linux/private_api_mount.cc
@@ -0,0 +1,62 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/file_manager/linux/private_api_mount.h"
+
+#include "base/files/file_util.h"
+#include "base/format_macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/task/post_task.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/file_manager/volume_manager.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/common/extensions/api/file_manager_private.h"
+#include "content/public/browser/browser_thread.h"
+#include "ui/shell_dialogs/selected_file_info.h"
+
+using content::BrowserThread;
+namespace file_manager_private = extensions::api::file_manager_private;
+
+namespace extensions {
+
+bool FileManagerPrivateAddMountFunction::RunAsync() {
+  return false;
+}
+
+bool FileManagerPrivateRemoveMountFunction::RunAsync() {
+  return false;
+}
+
+bool FileManagerPrivateMarkCacheAsMountedFunction::RunAsync() {
+  SendResponse(true);
+  return true;
+}
+
+bool FileManagerPrivateGetVolumeMetadataListFunction::RunAsync() {
+  if (args_->GetSize())
+    return false;
+
+  const std::vector<base::WeakPtr<file_manager::Volume>>& volume_list =
+      file_manager::VolumeManager::Get(GetProfile())->GetVolumeList();
+
+  std::string log_string;
+  std::vector<file_manager_private::VolumeMetadata> result;
+  for (const auto& volume : volume_list) {
+    file_manager_private::VolumeMetadata volume_metadata;
+    file_manager::util::VolumeToVolumeMetadata(GetProfile(), *volume,
+                                               &volume_metadata);
+    result.push_back(std::move(volume_metadata));
+    if (!log_string.empty())
+      log_string += ", ";
+    log_string += volume->mount_path().AsUTF8Unsafe();
+  }
+
+  results_ =
+      file_manager_private::GetVolumeMetadataList::Results::Create(result);
+  SendResponse(true);
+  return true;
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_manager/linux/private_api_mount.h b/chrome/browser/extensions/api/file_manager/linux/private_api_mount.h
new file mode 100644
index 0000000000000..48c9ad7331533
--- /dev/null
+++ b/chrome/browser/extensions/api/file_manager/linux/private_api_mount.h
@@ -0,0 +1,75 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file provides task related API functions.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_LINUX_PRIVATE_API_MOUNT_H_
+#define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_LINUX_PRIVATE_API_MOUNT_H_
+
+#include "base/files/file_path.h"
+#include "chrome/browser/extensions/api/file_manager/private_api_base.h"
+
+namespace extensions {
+
+// Implements chrome.fileManagerPrivate.addMount method.
+// Mounts removable devices and archive files.
+class FileManagerPrivateAddMountFunction : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.addMount",
+                             FILEMANAGERPRIVATE_ADDMOUNT)
+
+ protected:
+  ~FileManagerPrivateAddMountFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements chrome.fileManagerPrivate.removeMount method.
+// Unmounts selected volume. Expects volume id as an argument.
+class FileManagerPrivateRemoveMountFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.removeMount",
+                             FILEMANAGERPRIVATE_REMOVEMOUNT)
+
+ protected:
+  ~FileManagerPrivateRemoveMountFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements chrome.fileManagerPrivate.markCacheAsMounted method.
+// Marks a cached file as mounted or unmounted.
+class FileManagerPrivateMarkCacheAsMountedFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.markCacheAsMounted",
+                             FILEMANAGERPRIVATE_MARKCACHEASMOUNTED)
+
+ protected:
+  ~FileManagerPrivateMarkCacheAsMountedFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+// Implements chrome.fileManagerPrivate.getVolumeMetadataList method.
+class FileManagerPrivateGetVolumeMetadataListFunction
+    : public LoggedAsyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("fileManagerPrivate.getVolumeMetadataList",
+                             FILEMANAGERPRIVATE_GETVOLUMEMETADATALIST)
+
+ protected:
+  ~FileManagerPrivateGetVolumeMetadataListFunction() override = default;
+
+  // ChromeAsyncExtensionFunction overrides.
+  bool RunAsync() override;
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_LINUX_PRIVATE_API_MOUNT_H_

From 271aba6c5ec6edca263908184d7b2baf92411555 Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Tue, 14 Aug 2018 20:42:37 +0900
Subject: [PATCH 27/32] Add OS_CHROMEOS guard to chrome/browser/file_manager

In order to share file_manager with Linux, it adds OS_CHROMEOS
guard for ChromeOS specific code.
---
 chrome/browser/BUILD.gn                       |    4 +-
 .../file_manager/file_browser_handlers.cc     |    8 +-
 chrome/browser/file_manager/file_tasks.cc     |   43 +-
 chrome/browser/file_manager/file_tasks.h      |    2 +
 chrome/browser/file_manager/fileapi_util.cc   |    9 +
 .../file_manager/filesystem_api_util.cc       |   22 +-
 chrome/browser/file_manager/open_util.cc      |    6 +-
 .../browser/file_manager/open_with_browser.cc |   16 +-
 chrome/browser/file_manager/path_util.cc      |   36 +-
 chrome/browser/file_manager/volume_manager.cc | 1200 -----------------
 chrome/browser/file_manager/volume_manager.h  |  398 +-----
 .../file_manager/volume_manager_factory.cc    |   16 +-
 .../file_manager/volume_manager_observer.h    |    4 +
 13 files changed, 139 insertions(+), 1625 deletions(-)
 delete mode 100644 chrome/browser/file_manager/volume_manager.cc

diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
index 3ba619cd7ff2b..2106fc7bb0293 100644
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -3065,8 +3065,8 @@ jumbo_split_static_library("browser") {
       "file_manager/snapshot_manager.h",
       "file_manager/url_util.cc",
       "file_manager/url_util.h",
-      "file_manager/volume_manager.cc",
-      "file_manager/volume_manager.h",
+      "file_manager/chromeos/volume_manager.cc",
+      "file_manager/chromeos/volume_manager.h",
       "file_manager/volume_manager_factory.cc",
       "file_manager/volume_manager_factory.h",
       "file_manager/volume_manager_observer.h",
diff --git a/chrome/browser/file_manager/file_browser_handlers.cc b/chrome/browser/file_manager/file_browser_handlers.cc
index f34d3d267e480..7387c4d85ecc8 100644
--- a/chrome/browser/file_manager/file_browser_handlers.cc
+++ b/chrome/browser/file_manager/file_browser_handlers.cc
@@ -27,7 +27,6 @@
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/common/extensions/api/file_browser_handlers/file_browser_handler.h"
 #include "chrome/common/extensions/api/file_manager_private.h"
-#include "chromeos/chromeos_switches.h"
 #include "content/public/browser/browser_thread.h"
 #include "content/public/browser/child_process_security_policy.h"
 #include "content/public/browser/render_process_host.h"
@@ -46,6 +45,9 @@
 #include "storage/browser/fileapi/file_system_url.h"
 #include "storage/common/fileapi/file_system_info.h"
 #include "storage/common/fileapi/file_system_util.h"
+#if defined(OS_CHROMEOS)
+#include "chromeos/chromeos_switches.h"
+#endif
 
 using content::BrowserThread;
 using content::ChildProcessSecurityPolicy;
@@ -136,6 +138,7 @@ FileBrowserHandlerList FindFileBrowserHandlersForURL(
       if (!handler->MatchesURL(lowercase_url))
         continue;
 
+#if defined(OS_CHROMEOS)
       // Filter out Files app from handling ZIP files via a handler, as it's
       // now handled by:
       // - ZIP unpacker extension based on File System Provider API
@@ -150,6 +153,7 @@ FileBrowserHandlerList FindFileBrowserHandlersForURL(
         continue;
       }
       results.push_back(handler);
+#endif
     }
   }
   return results;
@@ -238,8 +242,10 @@ FileBrowserHandlerExecutor::SetupFileAccessPermissions(
     base::FilePath local_path = url.path();
     base::FilePath virtual_path = url.virtual_path();
 
+#if defined(OS_CHROMEOS)
     const bool is_drive_file = url.type() == storage::kFileSystemTypeDrive;
     DCHECK(!is_drive_file || drive::util::IsUnderDriveMountPoint(local_path));
+#endif
 
     const bool is_native_file =
         url.type() == storage::kFileSystemTypeNativeLocal ||
diff --git a/chrome/browser/file_manager/file_tasks.cc b/chrome/browser/file_manager/file_tasks.cc
index d022109551cf8..797767ae97923 100644
--- a/chrome/browser/file_manager/file_tasks.cc
+++ b/chrome/browser/file_manager/file_tasks.cc
@@ -14,8 +14,6 @@
 #include "base/metrics/histogram_macros.h"
 #include "base/strings/string_split.h"
 #include "base/strings/stringprintf.h"
-#include "chrome/browser/chromeos/crostini/crostini_util.h"
-#include "chrome/browser/chromeos/drive/file_system_util.h"
 #include "chrome/browser/chromeos/drive/file_task_executor.h"
 #include "chrome/browser/file_manager/app_id.h"
 #include "chrome/browser/file_manager/arc_file_tasks.h"
@@ -31,9 +29,6 @@
 #include "chrome/common/extensions/api/file_manager_private.h"
 #include "chrome/common/extensions/extension_constants.h"
 #include "chrome/common/pref_names.h"
-#include "chromeos/chromeos_switches.h"
-#include "components/drive/drive_api_util.h"
-#include "components/drive/drive_app_registry.h"
 #include "components/prefs/pref_service.h"
 #include "components/prefs/scoped_user_pref_update.h"
 #include "extensions/browser/api/file_handlers/mime_util.h"
@@ -46,6 +41,13 @@
 #include "extensions/common/extension_set.h"
 #include "storage/browser/fileapi/file_system_url.h"
 #include "third_party/blink/public/common/mime_util/mime_util.h"
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/chromeos/crostini/crostini_util.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chromeos/chromeos_switches.h"
+#include "components/drive/drive_api_util.h"
+#include "components/drive/drive_app_registry.h"
+#endif
 
 using extensions::Extension;
 using extensions::api::file_manager_private::Verb;
@@ -65,8 +67,13 @@ const char kDriveAppTaskType[] = "drive";
 const char kArcAppTaskType[] = "arc";
 const char kCrostiniAppTaskType[] = "crostini";
 
+#if defined(OS_CHROMEOS)
 // Drive apps always use the action ID.
 const char kDriveAppActionID[] = "open-with";
+const int kPreferredIconSize = drive::util::kPreferredIconSize;
+#else
+const int kPreferredIconSize = 32;
+#endif
 
 // Converts a TaskType to a string.
 std::string TaskTypeToString(TaskType task_type) {
@@ -109,6 +116,7 @@ const char kDriveTaskExtensionPrefix[] = "drive-app:";
 const size_t kDriveTaskExtensionPrefixLength =
     arraysize(kDriveTaskExtensionPrefix) - 1;
 
+#if defined(OS_CHROMEOS)
 // Returns true if path_mime_set contains a Google document.
 bool ContainsGoogleDocument(const std::vector<extensions::EntryInfo>& entries) {
   for (const auto& it : entries) {
@@ -127,6 +135,7 @@ void KeepOnlyFileManagerInternalTasks(std::vector<FullTaskDescriptor>* tasks) {
   }
   tasks->swap(filtered);
 }
+#endif
 
 // Returns true if the given task is a handler by built-in apps like the Files
 // app itself or QuickOffice etc. They are used as the initial default app.
@@ -170,6 +179,7 @@ Profile* GetProfileForExtensionTask(Profile* profile,
   return profile;
 }
 
+#if defined(OS_CHROMEOS)
 void ExecuteByArcAfterMimeTypesCollected(
     Profile* profile,
     const TaskDescriptor& task,
@@ -179,15 +189,18 @@ void ExecuteByArcAfterMimeTypesCollected(
     std::unique_ptr<std::vector<std::string>> mime_types) {
   ExecuteArcTask(profile, task, file_urls, *mime_types, done);
 }
+#endif
 
 void PostProcessFoundTasks(
     Profile* profile,
     const std::vector<extensions::EntryInfo>& entries,
     const FindTasksCallback& callback,
     std::unique_ptr<std::vector<FullTaskDescriptor>> result_list) {
+#if defined(OS_CHROMEOS)
   // Google documents can only be handled by internal handlers.
   if (ContainsGoogleDocument(entries))
     KeepOnlyFileManagerInternalTasks(result_list.get());
+#endif
   ChooseAndSetDefaultTask(*profile->GetPrefs(), entries, result_list.get());
   callback.Run(std::move(result_list));
 }
@@ -332,6 +345,7 @@ bool ExecuteFileTask(Profile* profile,
   UMA_HISTOGRAM_ENUMERATION("FileBrowser.ViewingTaskType", task.task_type,
                             NUM_TASK_TYPE);
 
+#if defined(OS_CHROMEOS)
   // ARC apps needs mime types for launching. Retrieve them first.
   if (task.task_type == TASK_TYPE_ARC_APP) {
     extensions::app_file_handler_util::MimeTypeCollector* mime_collector =
@@ -357,6 +371,7 @@ bool ExecuteFileTask(Profile* profile,
     executor->Execute(file_urls, done);
     return true;
   }
+#endif
 
   // Get the extension.
   const Extension* extension = extensions::ExtensionRegistry::Get(
@@ -385,6 +400,7 @@ bool ExecuteFileTask(Profile* profile,
   return false;
 }
 
+#if defined(OS_CHROMEOS)
 void FindDriveAppTasks(const drive::DriveAppRegistry& drive_app_registry,
                        const std::vector<extensions::EntryInfo>& entries,
                        std::vector<FullTaskDescriptor>* result_list) {
@@ -446,6 +462,7 @@ void FindDriveAppTasks(const drive::DriveAppRegistry& drive_app_registry,
         false /* is_default */, false /* is_generic_file_handler */));
   }
 }
+#endif
 
 bool IsGoodMatchFileHandler(
     const extensions::FileHandlerInfo& file_handler_info,
@@ -502,6 +519,7 @@ void FindFileHandlerTasks(Profile* profile,
     if (file_handlers.empty())
       continue;
 
+#if defined(OS_CHROMEOS)
     // If the new ZIP unpacker is disabled, then hide its handlers, so we don't
     // show both the legacy one and the new one in Files app for ZIP files.
     if (extension->id() == extension_misc::kZIPUnpackerExtensionId &&
@@ -509,6 +527,7 @@ void FindFileHandlerTasks(Profile* profile,
             chromeos::switches::kDisableNewZIPUnpacker)) {
       continue;
     }
+#endif
 
     // A map which has as key a handler verb, and as value a pair of the
     // handler with which to open the given entries and a boolean marking
@@ -535,7 +554,7 @@ void FindFileHandlerTasks(Profile* profile,
           extension->id(), file_tasks::TASK_TYPE_FILE_HANDLER, handler->id);
 
       GURL best_icon = extensions::ExtensionIconSource::GetIconURL(
-          extension, drive::util::kPreferredIconSize,
+          extension, kPreferredIconSize,
           ExtensionIconSet::MATCH_BIGGER,
           false);  // grayscale
 
@@ -620,15 +639,22 @@ void FindExtensionAndAppTasks(
   // be used in the same manifest.json.
   FindFileBrowserHandlerTasks(profile, file_urls, result_list_ptr);
 
+#if defined(OS_CHROMEOS)
   // 5. Find and append Crostini tasks.
   FindCrostiniTasks(profile, entries, result_list_ptr,
                     // Done. Apply post-filtering and callback.
                     base::BindOnce(PostProcessFoundTasks, profile, entries,
                                    callback, std::move(result_list)));
+#else
+  // Done. Apply post-filtering and callback.
+  PostProcessFoundTasks(profile, entries, callback, std::move(result_list));
+#endif
 }
 
 void FindAllTypesOfTasks(Profile* profile,
+#if defined(OS_CHROMEOS)
                          const drive::DriveAppRegistry* drive_app_registry,
+#endif
                          const std::vector<extensions::EntryInfo>& entries,
                          const std::vector<GURL>& file_urls,
                          const FindTasksCallback& callback) {
@@ -636,6 +662,7 @@ void FindAllTypesOfTasks(Profile* profile,
   std::unique_ptr<std::vector<FullTaskDescriptor>> result_list(
       new std::vector<FullTaskDescriptor>);
 
+#if defined(OS_CHROMEOS)
   // 1. Find Drive app tasks, if the drive app registry is present.
   if (drive_app_registry)
     FindDriveAppTasks(*drive_app_registry, entries, result_list.get());
@@ -644,6 +671,10 @@ void FindAllTypesOfTasks(Profile* profile,
   FindArcTasks(profile, entries, file_urls, std::move(result_list),
                base::Bind(&FindExtensionAndAppTasks, profile, entries,
                           file_urls, callback));
+#else
+  FindExtensionAndAppTasks(profile, entries, file_urls, callback,
+                           std::move(result_list));
+#endif
 }
 
 void ChooseAndSetDefaultTask(const PrefService& pref_service,
diff --git a/chrome/browser/file_manager/file_tasks.h b/chrome/browser/file_manager/file_tasks.h
index 4fb4531cd0b94..05f981bf74517 100644
--- a/chrome/browser/file_manager/file_tasks.h
+++ b/chrome/browser/file_manager/file_tasks.h
@@ -323,7 +323,9 @@ typedef base::Callback<void(
 // the Files app provides, and to avoid listing normal file handler and file
 // browser handler tasks, which can handle only normal files.
 void FindAllTypesOfTasks(Profile* profile,
+#if defined(OS_CHROMEOS)
                          const drive::DriveAppRegistry* drive_app_registry,
+#endif
                          const std::vector<extensions::EntryInfo>& entries,
                          const std::vector<GURL>& file_urls,
                          const FindTasksCallback& callback);
diff --git a/chrome/browser/file_manager/fileapi_util.cc b/chrome/browser/file_manager/fileapi_util.cc
index 20e9a92583ef5..a1f2e20b83ffa 100644
--- a/chrome/browser/file_manager/fileapi_util.cc
+++ b/chrome/browser/file_manager/fileapi_util.cc
@@ -30,6 +30,9 @@
 #include "storage/common/fileapi/file_system_util.h"
 #include "ui/shell_dialogs/selected_file_info.h"
 #include "url/gurl.h"
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#endif
 
 using content::BrowserThread;
 
@@ -449,6 +452,7 @@ storage::FileSystemContext* GetFileSystemContextForRenderFrameHost(
       GetFileSystemContext();
 }
 
+#if defined(OS_CHROMEOS)
 base::FilePath ConvertDrivePathToRelativeFileSystemPath(
     Profile* profile,
     const std::string& extension_id,
@@ -465,16 +469,21 @@ base::FilePath ConvertDrivePathToRelativeFileSystemPath(
                                                   &relative_path);
   return relative_path;
 }
+#endif
 
 GURL ConvertDrivePathToFileSystemUrl(Profile* profile,
                                      const base::FilePath& drive_path,
                                      const std::string& extension_id) {
+#if defined(OS_CHROMEOS)
   const base::FilePath relative_path =
       ConvertDrivePathToRelativeFileSystemPath(profile, extension_id,
                                                drive_path);
   if (relative_path.empty())
     return GURL();
   return ConvertRelativeFilePathToFileSystemUrl(relative_path, extension_id);
+#else
+  return GURL();
+#endif
 }
 
 bool ConvertAbsoluteFilePathToFileSystemUrl(Profile* profile,
diff --git a/chrome/browser/file_manager/filesystem_api_util.cc b/chrome/browser/file_manager/filesystem_api_util.cc
index 78901679abb09..b816ce0d20c8a 100644
--- a/chrome/browser/file_manager/filesystem_api_util.cc
+++ b/chrome/browser/file_manager/filesystem_api_util.cc
@@ -9,29 +9,32 @@
 #include "base/callback.h"
 #include "base/files/file.h"
 #include "base/files/file_path.h"
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/file_manager/fileapi_util.h"
+#include "chrome/browser/extensions/extension_util.h"
+#include "chrome/browser/profiles/profile.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/storage_partition.h"
+#include "google_apis/drive/task_util.h"
+#include "storage/browser/fileapi/file_system_context.h"
+#if defined(OS_CHROMEOS)
 #include "chrome/browser/chromeos/arc/arc_util.h"
 #include "chrome/browser/chromeos/arc/fileapi/arc_content_file_system_url_util.h"
 #include "chrome/browser/chromeos/arc/fileapi/arc_file_system_operation_runner.h"
 #include "chrome/browser/chromeos/drive/file_system_util.h"
 #include "chrome/browser/chromeos/file_system_provider/mount_path_util.h"
 #include "chrome/browser/chromeos/file_system_provider/provided_file_system_interface.h"
-#include "chrome/browser/file_manager/app_id.h"
-#include "chrome/browser/file_manager/fileapi_util.h"
-#include "chrome/browser/extensions/extension_util.h"
-#include "chrome/browser/profiles/profile.h"
 #include "components/arc/arc_service_manager.h"
 #include "components/drive/chromeos/file_system_interface.h"
 #include "components/drive/file_errors.h"
 #include "components/drive/file_system_core_util.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/storage_partition.h"
-#include "google_apis/drive/task_util.h"
-#include "storage/browser/fileapi/file_system_context.h"
+#endif
 
 namespace file_manager {
 namespace util {
 namespace {
 
+#if defined(OS_CHROMEOS)
 // Helper function used to implement GetNonNativeLocalPathMimeType. It extracts
 // the mime type from the passed Drive resource entry.
 void GetMimeTypeAfterGetResourceEntryForDrive(
@@ -75,6 +78,7 @@ void GetMimeTypeAfterGetMimeTypeForArcContentFileSystem(
     callback.Run(false, std::string());
   }
 }
+#endif
 
 // Helper function to converts a callback that takes boolean value to that takes
 // File::Error, by regarding FILE_OK as the only successful value.
@@ -164,6 +168,7 @@ void GetNonNativeLocalPathMimeType(
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
   DCHECK(IsUnderNonNativeLocalPath(profile, path));
 
+#if defined(OS_CHROMEOS)
   if (drive::util::IsUnderDriveMountPoint(path)) {
     drive::FileSystemInterface* file_system =
         drive::util::GetFileSystemByProfile(profile);
@@ -215,6 +220,7 @@ void GetNonNativeLocalPathMimeType(
                             callback));
     return;
   }
+#endif
 
   // We don't have a way to obtain metadata other than drive and FSP. Returns an
   // error with empty MIME type, that leads fallback guessing mime type from
diff --git a/chrome/browser/file_manager/open_util.cc b/chrome/browser/file_manager/open_util.cc
index 2600feefc430b..c0883be78de79 100644
--- a/chrome/browser/file_manager/open_util.cc
+++ b/chrome/browser/file_manager/open_util.cc
@@ -119,7 +119,11 @@ void OpenFileWithMimeType(Profile* profile,
   file_urls.push_back(url);
 
   file_tasks::FindAllTypesOfTasks(
-      profile, drive::util::GetDriveAppRegistryByProfile(profile), entries,
+      profile,
+#if defined(OS_CHROMEOS)
+      drive::util::GetDriveAppRegistryByProfile(profile),
+#endif
+      entries,
       file_urls,
       base::Bind(&OpenFileMimeTypeAfterTasksListed, profile, url, callback));
 }
diff --git a/chrome/browser/file_manager/open_with_browser.cc b/chrome/browser/file_manager/open_with_browser.cc
index 55fe7a834e359..8267414462f7e 100644
--- a/chrome/browser/file_manager/open_with_browser.cc
+++ b/chrome/browser/file_manager/open_with_browser.cc
@@ -13,7 +13,6 @@
 #include "base/path_service.h"
 #include "base/task/post_task.h"
 #include "chrome/browser/browser_process.h"
-#include "chrome/browser/chromeos/drive/drive_integration_service.h"
 #include "chrome/browser/file_manager/filesystem_api_util.h"
 #include "chrome/browser/fileapi/external_file_url_util.h"
 #include "chrome/browser/plugins/plugin_prefs.h"
@@ -26,13 +25,16 @@
 #include "chrome/common/chrome_content_client.h"
 #include "chrome/common/chrome_paths.h"
 #include "chrome/common/chrome_switches.h"
-#include "chromeos/components/drivefs/mojom/drivefs.mojom.h"
-#include "components/drive/drive_api_util.h"
-#include "components/drive/file_system_core_util.h"
 #include "content/public/browser/browser_thread.h"
 #include "content/public/browser/plugin_service.h"
 #include "content/public/common/pepper_plugin_info.h"
 #include "net/base/filename_util.h"
+#if defined(CHROMEOS)
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chromeos/components/drivefs/mojom/drivefs.mojom.h"
+#include "components/drive/drive_api_util.h"
+#include "components/drive/file_system_core_util.h"
+#endif
 
 using content::BrowserThread;
 using content::PluginService;
@@ -111,12 +113,15 @@ void OpenNewTab(Profile* profile, const GURL& url) {
   chrome::AddSelectedTabWithURL(displayer.browser(), url,
       ui::PAGE_TRANSITION_LINK);
 
+#if defined(OS_CHROMEOS)
   // Since the ScopedTabbedBrowserDisplayer does not guarantee that the
   // browser will be shown on the active desktop, we ensure the visibility.
   multi_user_util::MoveWindowToCurrentDesktop(
       displayer.browser()->window()->GetNativeWindow());
+#endif
 }
 
+#if defined(OS_CHROMEOS)
 // Reads the alternate URL from a GDoc file. When it fails, returns a file URL
 // for |file_path| as fallback.
 // Note that an alternate url is a URL to open a hosted document.
@@ -152,6 +157,7 @@ void OpenHostedDriveFsFile(const base::FilePath& file_path,
 
   OpenNewTab(profile, hosted_url);
 }
+#endif
 
 }  // namespace
 
@@ -175,6 +181,7 @@ bool OpenFileWithBrowser(Profile* profile,
     return true;
   }
 
+#if defined(OS_CHROMEOS)
   if (drive::util::HasHostedDocumentExtension(file_path)) {
     if (file_manager::util::IsUnderNonNativeLocalPath(profile, file_path)) {
       // The file is on a non-native volume. Use external file URL. If the file
@@ -201,6 +208,7 @@ bool OpenFileWithBrowser(Profile* profile,
     }
     return true;
   }
+#endif
 
   // Failed to open the file of unknown type.
   LOG(WARNING) << "Unknown file type: " << file_path.value();
diff --git a/chrome/browser/file_manager/path_util.cc b/chrome/browser/file_manager/path_util.cc
index 54702646b58ba..77e9de9a986a9 100644
--- a/chrome/browser/file_manager/path_util.cc
+++ b/chrome/browser/file_manager/path_util.cc
@@ -9,13 +9,7 @@
 #include "base/logging.h"
 #include "base/strings/string_util.h"
 #include "base/sys_info.h"
-#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_root.h"
-#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_root_map.h"
-#include "chrome/browser/chromeos/arc/fileapi/chrome_content_provider_url_util.h"
-#include "chrome/browser/chromeos/crostini/crostini_util.h"
-#include "chrome/browser/chromeos/drive/file_system_util.h"
 #include "chrome/browser/fileapi/external_file_url_util.h"
-#include "chrome/browser/chromeos/profiles/profile_helper.h"
 #include "chrome/browser/download/download_prefs.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/grit/generated_resources.h"
@@ -27,6 +21,14 @@
 #include "net/base/filename_util.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "url/gurl.h"
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_root.h"
+#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_root_map.h"
+#include "chrome/browser/chromeos/arc/fileapi/chrome_content_provider_url_util.h"
+#include "chrome/browser/chromeos/crostini/crostini_util.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "chrome/browser/chromeos/profiles/profile_helper.h"
+#endif
 
 namespace file_manager {
 namespace util {
@@ -37,6 +39,7 @@ const char kDownloadsFolderName[] = "Downloads";
 const char kGoogleDriveDisplayName[] = "Google Drive";
 const char kRootRelativeToDriveMount[] = "root";
 
+#if defined(OS_CHROMEOS)
 // Sync with the file provider in ARC++ side.
 constexpr char kArcFileProviderUrl[] =
     "content://org.chromium.arc.intent_helper.fileprovider/";
@@ -72,6 +75,7 @@ void OnAllContentUrlsResolved(ConvertToContentUrlsCallback callback,
                               std::unique_ptr<std::vector<GURL>> urls) {
   std::move(callback).Run(*urls);
 }
+#endif
 
 }  // namespace
 
@@ -82,6 +86,7 @@ const base::FilePath::CharType kAndroidFilesPath[] =
     FILE_PATH_LITERAL("/run/arc/sdcard/write/emulated/0");
 
 base::FilePath GetDownloadsFolderForProfile(Profile* profile) {
+#if defined(OS_CHROMEOS)
   // On non-ChromeOS system (test+development), the primary profile uses
   // $HOME/Downloads for ease for accessing local files for debugging.
   if (!base::SysInfo::IsRunningOnChromeOS() &&
@@ -95,6 +100,9 @@ base::FilePath GetDownloadsFolderForProfile(Profile* profile) {
       return DownloadPrefs::GetDefaultDownloadDirectory();
   }
   return profile->GetPath().AppendASCII(kDownloadsFolderName);
+#else
+  return DownloadPrefs::GetDefaultDownloadDirectory();
+#endif
 }
 
 bool MigratePathFromOldFormat(Profile* profile,
@@ -114,6 +122,7 @@ bool MigratePathFromOldFormat(Profile* profile,
 }
 
 std::string GetDownloadsMountPointName(Profile* profile) {
+#if defined(OS_CHROMEOS)
   // To distinguish profiles in multi-profile session, we append user name hash
   // to "Downloads". Note that some profiles (like login or test profiles)
   // are not associated with an user account. In that case, no suffix is added
@@ -123,10 +132,14 @@ std::string GetDownloadsMountPointName(Profile* profile) {
           ? chromeos::ProfileHelper::Get()->GetUserByProfile(
                 profile->GetOriginalProfile())
           : nullptr;
+#else
+  const user_manager::User* const user = NULL;
+#endif
   const std::string id = user ? "-" + user->username_hash() : "";
   return net::EscapeQueryParamValue(kDownloadsFolderName + id, false);
 }
 
+#if defined(OS_CHROMEOS)
 std::string GetCrostiniMountPointName(Profile* profile) {
   // crostini_<hash>_termina_penguin
   return base::JoinString(
@@ -223,12 +236,15 @@ bool ConvertPathToArcUrl(const base::FilePath& path, GURL* arc_url_out) {
   // TODO(kinaba): Add conversion logic once other file systems are supported.
   return false;
 }
+#endif
 
 void ConvertToContentUrls(
     const std::vector<storage::FileSystemURL>& file_system_urls,
     ConvertToContentUrlsCallback callback) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
+#if defined(OS_CHROMEOS)
+
   if (file_system_urls.empty()) {
     std::move(callback).Run(std::vector<GURL>());
     return;
@@ -275,6 +291,9 @@ void ConvertToContentUrls(
     documents_provider_root->ResolveToContentUrl(
         filepath, base::BindRepeating(single_content_url_callback, index));
   }
+#else
+  std::move(callback).Run(std::vector<GURL>());
+#endif
 }
 
 bool ReplacePrefix(std::string* s,
@@ -296,7 +315,9 @@ std::string GetDownloadLocationText(Profile* profile, const std::string& path) {
                                profile->GetPath().BaseName().value() +
                                "/Downloads",
                            kDownloadsFolderName)) {
-  } else if (ReplacePrefix(&result,
+  }
+#if defined(OS_CHROMEOS)
+  else if (ReplacePrefix(&result,
                            drive::util::GetDriveMountPointPath(profile)
                                .Append(kRootRelativeToDriveMount)
                                .value(),
@@ -308,6 +329,7 @@ std::string GetDownloadLocationText(Profile* profile, const std::string& path) {
                            l10n_util::GetStringUTF8(
                                IDS_FILE_BROWSER_LINUX_FILES_ROOT_LABEL))) {
   }
+#endif
 
   base::ReplaceChars(result, "/", " \u203a ", &result);
   return result;
diff --git a/chrome/browser/file_manager/volume_manager.cc b/chrome/browser/file_manager/volume_manager.cc
deleted file mode 100644
index 6f80fb154f8ca..0000000000000
--- a/chrome/browser/file_manager/volume_manager.cc
+++ /dev/null
@@ -1,1200 +0,0 @@
-// Copyright 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/file_manager/volume_manager.h"
-
-#include <stddef.h>
-#include <stdint.h>
-
-#include <utility>
-
-#include "base/bind.h"
-#include "base/command_line.h"
-#include "base/feature_list.h"
-#include "base/files/file_path.h"
-#include "base/logging.h"
-#include "base/memory/weak_ptr.h"
-#include "base/metrics/histogram_macros.h"
-#include "base/strings/string_util.h"
-#include "base/strings/stringprintf.h"
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/browser/chromeos/arc/arc_util.h"
-#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_util.h"
-#include "chrome/browser/chromeos/arc/fileapi/arc_media_view_util.h"
-#include "chrome/browser/chromeos/crostini/crostini_manager.h"
-#include "chrome/browser/chromeos/crostini/crostini_util.h"
-#include "chrome/browser/chromeos/drive/drive_integration_service.h"
-#include "chrome/browser/chromeos/drive/file_system_util.h"
-#include "chrome/browser/chromeos/file_system_provider/provided_file_system_info.h"
-#include "chrome/browser/chromeos/profiles/profile_helper.h"
-#include "chrome/browser/file_manager/path_util.h"
-#include "chrome/browser/file_manager/snapshot_manager.h"
-#include "chrome/browser/file_manager/volume_manager_factory.h"
-#include "chrome/browser/file_manager/volume_manager_observer.h"
-#include "chrome/browser/media_galleries/fileapi/mtp_device_map_service.h"
-#include "chrome/browser/profiles/profile.h"
-#include "chrome/common/pref_names.h"
-#include "chromeos/chromeos_switches.h"
-#include "chromeos/disks/disk.h"
-#include "chromeos/disks/disk_mount_manager.h"
-#include "components/drive/chromeos/file_system_interface.h"
-#include "components/prefs/pref_service.h"
-#include "components/storage_monitor/storage_monitor.h"
-#include "content/public/browser/browser_context.h"
-#include "content/public/browser/browser_thread.h"
-#include "services/device/public/mojom/mtp_manager.mojom.h"
-#include "storage/browser/fileapi/external_mount_points.h"
-
-namespace file_manager {
-namespace {
-
-const uint32_t kAccessCapabilityReadWrite = 0;
-const uint32_t kFilesystemTypeGenericHierarchical = 2;
-const char kFileManagerMTPMountNamePrefix[] = "fileman-mtp-";
-const char kMtpVolumeIdPrefix[] = "mtp:";
-const char kRootPath[] = "/";
-const char kAndroidFilesMountPointName[] = "android_files";
-
-// Registers |path| as the "Downloads" folder to the FileSystem API backend.
-// If another folder is already mounted. It revokes and overrides the old one.
-bool RegisterDownloadsMountPoint(Profile* profile, const base::FilePath& path) {
-  // Although we show only profile's own "Downloads" folder in the Files app,
-  // in the backend we need to mount all profile's download directory globally.
-  // Otherwise, the Files app cannot support cross-profile file copies, etc.
-  // For this reason, we need to register to the global GetSystemInstance().
-  const std::string mount_point_name =
-      file_manager::util::GetDownloadsMountPointName(profile);
-  storage::ExternalMountPoints* const mount_points =
-      storage::ExternalMountPoints::GetSystemInstance();
-
-  // In some tests we want to override existing Downloads mount point, so we
-  // first revoke the existing mount point (if any).
-  mount_points->RevokeFileSystem(mount_point_name);
-  return mount_points->RegisterFileSystem(mount_point_name,
-                                          storage::kFileSystemTypeNativeLocal,
-                                          storage::FileSystemMountOption(),
-                                          path);
-}
-
-// Returns true if the "Play files" root should be shown based on the current
-// flag settings (chrome://flags/#android-files-in-files-app).
-bool IsShowAndroidFilesEnabled() {
-  return !base::CommandLine::ForCurrentProcess()->HasSwitch(
-      chromeos::switches::kHideAndroidFilesInFilesApp);
-}
-
-// Registers a mount point for Android files to ExternalMountPoints.
-bool RegisterAndroidFilesMountPoint() {
-  storage::ExternalMountPoints* const mount_points =
-      storage::ExternalMountPoints::GetSystemInstance();
-  return mount_points->RegisterFileSystem(
-      kAndroidFilesMountPointName, storage::kFileSystemTypeNativeLocal,
-      storage::FileSystemMountOption(),
-      base::FilePath(util::kAndroidFilesPath));
-}
-
-// Finds the path register as the "Downloads" folder to FileSystem API backend.
-// Returns false if it is not registered.
-bool FindDownloadsMountPointPath(Profile* profile, base::FilePath* path) {
-  const std::string mount_point_name =
-      util::GetDownloadsMountPointName(profile);
-  storage::ExternalMountPoints* const mount_points =
-      storage::ExternalMountPoints::GetSystemInstance();
-
-  return mount_points->GetRegisteredPath(mount_point_name, path);
-}
-
-VolumeType MountTypeToVolumeType(chromeos::MountType type) {
-  switch (type) {
-    case chromeos::MOUNT_TYPE_INVALID:
-      // We don't expect this value, but list here, so that when any value
-      // is added to the enum definition but this is not edited, the compiler
-      // warns it.
-      break;
-    case chromeos::MOUNT_TYPE_DEVICE:
-      return VOLUME_TYPE_REMOVABLE_DISK_PARTITION;
-    case chromeos::MOUNT_TYPE_ARCHIVE:
-      return VOLUME_TYPE_MOUNTED_ARCHIVE_FILE;
-    case chromeos::MOUNT_TYPE_NETWORK_STORAGE:
-      // Network storage mounts are handled by their mounters so
-      // MOUNT_TYPE_NETWORK_STORAGE should never need to be handled here.
-      break;
-  }
-
-  NOTREACHED();
-  return VOLUME_TYPE_DOWNLOADS_DIRECTORY;
-}
-
-// Returns a string representation of the given volume type.
-std::string VolumeTypeToString(VolumeType type) {
-  switch (type) {
-    case VOLUME_TYPE_GOOGLE_DRIVE:
-      return "drive";
-    case VOLUME_TYPE_DOWNLOADS_DIRECTORY:
-      return "downloads";
-    case VOLUME_TYPE_REMOVABLE_DISK_PARTITION:
-      return "removable";
-    case VOLUME_TYPE_MOUNTED_ARCHIVE_FILE:
-      return "archive";
-    case VOLUME_TYPE_PROVIDED:
-      return "provided";
-    case VOLUME_TYPE_MTP:
-      return "mtp";
-    case VOLUME_TYPE_MEDIA_VIEW:
-      return "media_view";
-    case VOLUME_TYPE_ANDROID_FILES:
-      return "android_files";
-    case VOLUME_TYPE_TESTING:
-      return "testing";
-    case VOLUME_TYPE_CROSTINI:
-      return "crostini";
-    case NUM_VOLUME_TYPE:
-      break;
-  }
-  NOTREACHED();
-  return "";
-}
-
-// Generates a unique volume ID for the given volume info.
-std::string GenerateVolumeId(const Volume& volume) {
-  // For the same volume type, base names are unique, as mount points are
-  // flat for the same volume type.
-  return (VolumeTypeToString(volume.type()) + ":" +
-          volume.mount_path().BaseName().AsUTF8Unsafe());
-}
-
-std::string GetMountPointNameForMediaStorage(
-    const storage_monitor::StorageInfo& info) {
-  std::string name(kFileManagerMTPMountNamePrefix);
-  name += info.device_id();
-  return name;
-}
-
-chromeos::MountAccessMode GetExternalStorageAccessMode(const Profile* profile) {
-  return profile->GetPrefs()->GetBoolean(prefs::kExternalStorageReadOnly)
-             ? chromeos::MOUNT_ACCESS_MODE_READ_ONLY
-             : chromeos::MOUNT_ACCESS_MODE_READ_WRITE;
-}
-
-}  // namespace
-
-Volume::Volume()
-    : source_(SOURCE_FILE),
-      type_(VOLUME_TYPE_GOOGLE_DRIVE),
-      device_type_(chromeos::DEVICE_TYPE_UNKNOWN),
-      mount_condition_(chromeos::disks::MOUNT_CONDITION_NONE),
-      mount_context_(MOUNT_CONTEXT_UNKNOWN),
-      is_parent_(false),
-      is_read_only_(false),
-      is_read_only_removable_device_(false),
-      has_media_(false),
-      configurable_(false),
-      watchable_(false) {
-}
-
-Volume::~Volume() = default;
-
-// static
-std::unique_ptr<Volume> Volume::CreateForDrive(
-    const base::FilePath& drive_path) {
-  std::unique_ptr<Volume> volume(new Volume());
-  volume->type_ = VOLUME_TYPE_GOOGLE_DRIVE;
-  volume->device_type_ = chromeos::DEVICE_TYPE_UNKNOWN;
-  volume->source_path_ = drive_path;
-  volume->source_ = SOURCE_NETWORK;
-  volume->mount_path_ = drive_path;
-  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
-  volume->volume_id_ = GenerateVolumeId(*volume);
-  volume->watchable_ = true;
-  return volume;
-}
-
-// static
-std::unique_ptr<Volume> Volume::CreateForDownloads(
-    const base::FilePath& downloads_path) {
-  std::unique_ptr<Volume> volume(new Volume());
-  volume->type_ = VOLUME_TYPE_DOWNLOADS_DIRECTORY;
-  volume->device_type_ = chromeos::DEVICE_TYPE_UNKNOWN;
-  // Keep source_path empty.
-  volume->source_ = SOURCE_SYSTEM;
-  volume->mount_path_ = downloads_path;
-  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
-  volume->volume_id_ = GenerateVolumeId(*volume);
-  volume->watchable_ = true;
-  return volume;
-}
-
-// static
-std::unique_ptr<Volume> Volume::CreateForRemovable(
-    const chromeos::disks::DiskMountManager::MountPointInfo& mount_point,
-    const chromeos::disks::Disk* disk) {
-  std::unique_ptr<Volume> volume(new Volume());
-  volume->type_ = MountTypeToVolumeType(mount_point.mount_type);
-  volume->source_path_ = base::FilePath(mount_point.source_path);
-  volume->source_ = mount_point.mount_type == chromeos::MOUNT_TYPE_ARCHIVE
-                        ? SOURCE_FILE
-                        : SOURCE_DEVICE;
-  volume->mount_path_ = base::FilePath(mount_point.mount_path);
-  volume->mount_condition_ = mount_point.mount_condition;
-
-  if (disk) {
-    volume->file_system_type_ = disk->file_system_type();
-    volume->volume_label_ = disk->device_label();
-    volume->device_type_ = disk->device_type();
-    volume->system_path_prefix_ = base::FilePath(disk->system_path_prefix());
-    volume->is_parent_ = disk->is_parent();
-    volume->is_read_only_ = disk->is_read_only();
-    volume->is_read_only_removable_device_ = disk->is_read_only_hardware();
-    volume->has_media_ = disk->has_media();
-  } else {
-    volume->volume_label_ = volume->mount_path().BaseName().AsUTF8Unsafe();
-    volume->device_type_ = chromeos::DEVICE_TYPE_UNKNOWN;
-    volume->is_read_only_ =
-        (mount_point.mount_type == chromeos::MOUNT_TYPE_ARCHIVE);
-  }
-  volume->volume_id_ = GenerateVolumeId(*volume);
-  volume->watchable_ = true;
-  return volume;
-}
-
-// static
-std::unique_ptr<Volume> Volume::CreateForProvidedFileSystem(
-    const chromeos::file_system_provider::ProvidedFileSystemInfo&
-        file_system_info,
-    MountContext mount_context) {
-  std::unique_ptr<Volume> volume(new Volume());
-  volume->file_system_id_ = file_system_info.file_system_id();
-  volume->provider_id_ = file_system_info.provider_id();
-  switch (file_system_info.source()) {
-    case extensions::SOURCE_FILE:
-      volume->source_ = SOURCE_FILE;
-      break;
-    case extensions::SOURCE_DEVICE:
-      volume->source_ = SOURCE_DEVICE;
-      break;
-    case extensions::SOURCE_NETWORK:
-      volume->source_ = SOURCE_NETWORK;
-      break;
-  }
-  volume->volume_label_ = file_system_info.display_name();
-  volume->type_ = VOLUME_TYPE_PROVIDED;
-  volume->mount_path_ = file_system_info.mount_path();
-  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
-  volume->mount_context_ = mount_context;
-  volume->is_parent_ = true;
-  volume->is_read_only_ = !file_system_info.writable();
-  volume->configurable_ = file_system_info.configurable();
-  volume->watchable_ = file_system_info.watchable();
-  volume->volume_id_ = GenerateVolumeId(*volume);
-  volume->icon_set_ = file_system_info.icon_set();
-  return volume;
-}
-
-// static
-std::unique_ptr<Volume> Volume::CreateForMTP(const base::FilePath& mount_path,
-                                             const std::string& label,
-                                             bool read_only) {
-  std::unique_ptr<Volume> volume(new Volume());
-  volume->type_ = VOLUME_TYPE_MTP;
-  volume->mount_path_ = mount_path;
-  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
-  volume->is_parent_ = true;
-  volume->is_read_only_ = read_only;
-  volume->volume_id_ = kMtpVolumeIdPrefix + label;
-  volume->volume_label_ = label;
-  volume->source_path_ = mount_path;
-  volume->source_ = SOURCE_DEVICE;
-  volume->device_type_ = chromeos::DEVICE_TYPE_MOBILE;
-  return volume;
-}
-
-// static
-std::unique_ptr<Volume> Volume::CreateForMediaView(
-    const std::string& root_document_id) {
-  std::unique_ptr<Volume> volume(new Volume());
-  volume->type_ = VOLUME_TYPE_MEDIA_VIEW;
-  volume->device_type_ = chromeos::DEVICE_TYPE_UNKNOWN;
-  volume->source_ = SOURCE_SYSTEM;
-  volume->mount_path_ = arc::GetDocumentsProviderMountPath(
-      arc::kMediaDocumentsProviderAuthority, root_document_id);
-  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
-  volume->volume_label_ = root_document_id;
-  volume->is_read_only_ = true;
-  volume->watchable_ = false;
-  volume->volume_id_ = arc::GetMediaViewVolumeId(root_document_id);
-  return volume;
-}
-
-// static
-std::unique_ptr<Volume> Volume::CreateForSshfsCrostini(
-    const base::FilePath& sshfs_mount_path) {
-  std::unique_ptr<Volume> volume(new Volume());
-  volume->type_ = VOLUME_TYPE_CROSTINI;
-  volume->device_type_ = chromeos::DEVICE_TYPE_UNKNOWN;
-  // Keep source_path empty.
-  volume->source_ = SOURCE_SYSTEM;
-  volume->mount_path_ = sshfs_mount_path;
-  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
-  volume->volume_id_ = GenerateVolumeId(*volume);
-  volume->watchable_ = false;
-  return volume;
-}
-
-// static
-std::unique_ptr<Volume> Volume::CreateForAndroidFiles() {
-  std::unique_ptr<Volume> volume(new Volume());
-  volume->type_ = VOLUME_TYPE_ANDROID_FILES;
-  volume->device_type_ = chromeos::DEVICE_TYPE_UNKNOWN;
-  // Keep source_path empty.
-  volume->source_ = SOURCE_SYSTEM;
-  volume->mount_path_ = base::FilePath(util::kAndroidFilesPath);
-  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
-  volume->volume_id_ = GenerateVolumeId(*volume);
-  volume->watchable_ = true;
-  return volume;
-}
-
-// static
-std::unique_ptr<Volume> Volume::CreateForTesting(
-    const base::FilePath& path,
-    VolumeType volume_type,
-    chromeos::DeviceType device_type,
-    bool read_only) {
-  std::unique_ptr<Volume> volume(new Volume());
-  volume->type_ = volume_type;
-  volume->device_type_ = device_type;
-  // Keep source_path empty.
-  volume->source_ = SOURCE_DEVICE;
-  volume->mount_path_ = path;
-  volume->mount_condition_ = chromeos::disks::MOUNT_CONDITION_NONE;
-  volume->is_read_only_ = read_only;
-  volume->volume_id_ = GenerateVolumeId(*volume);
-  return volume;
-}
-
-// static
-std::unique_ptr<Volume> Volume::CreateForTesting(
-    const base::FilePath& device_path,
-    const base::FilePath& mount_path) {
-  std::unique_ptr<Volume> volume(new Volume());
-  volume->system_path_prefix_ = device_path;
-  volume->mount_path_ = mount_path;
-  return volume;
-}
-
-VolumeManager::VolumeManager(
-    Profile* profile,
-    drive::DriveIntegrationService* drive_integration_service,
-    chromeos::PowerManagerClient* power_manager_client,
-    chromeos::disks::DiskMountManager* disk_mount_manager,
-    chromeos::file_system_provider::Service* file_system_provider_service,
-    const GetMtpStorageInfoCallback& get_mtp_storage_info_callback)
-    : profile_(profile),
-      drive_integration_service_(drive_integration_service),
-      disk_mount_manager_(disk_mount_manager),
-      file_system_provider_service_(file_system_provider_service),
-      get_mtp_storage_info_callback_(get_mtp_storage_info_callback),
-      snapshot_manager_(new SnapshotManager(profile_)),
-      weak_ptr_factory_(this) {
-  DCHECK(disk_mount_manager);
-}
-
-VolumeManager::~VolumeManager() = default;
-
-VolumeManager* VolumeManager::Get(content::BrowserContext* context) {
-  return VolumeManagerFactory::Get(context);
-}
-
-void VolumeManager::Initialize() {
-  // If in the Sign in profile pr the lock screen app profile, skip mounting
-  // and listening for mount events.
-  if (chromeos::ProfileHelper::IsSigninProfile(profile_) ||
-      chromeos::ProfileHelper::IsLockScreenAppProfile(profile_)) {
-    return;
-  }
-
-  // Register 'Downloads' folder for the profile to the file system.
-  const base::FilePath downloads =
-      file_manager::util::GetDownloadsFolderForProfile(profile_);
-  const bool success = RegisterDownloadsMountPoint(profile_, downloads);
-  DCHECK(success);
-
-  DoMountEvent(chromeos::MOUNT_ERROR_NONE,
-               Volume::CreateForDownloads(downloads));
-
-  // Subscribe to DriveIntegrationService.
-  drive_integration_service_->AddObserver(this);
-  if (drive_integration_service_->IsMounted()) {
-    DoMountEvent(chromeos::MOUNT_ERROR_NONE,
-                 Volume::CreateForDrive(GetDriveMountPointPath()));
-  }
-
-  // Subscribe to DiskMountManager.
-  disk_mount_manager_->AddObserver(this);
-  disk_mount_manager_->EnsureMountInfoRefreshed(
-      base::Bind(&VolumeManager::OnDiskMountManagerRefreshed,
-                 weak_ptr_factory_.GetWeakPtr()),
-      false /* force */);
-
-  // Subscribe to FileSystemProviderService and register currently mounted
-  // volumes for the profile.
-  if (file_system_provider_service_) {
-    using chromeos::file_system_provider::ProvidedFileSystemInfo;
-    file_system_provider_service_->AddObserver(this);
-
-    std::vector<ProvidedFileSystemInfo> file_system_info_list =
-        file_system_provider_service_->GetProvidedFileSystemInfoList();
-    for (size_t i = 0; i < file_system_info_list.size(); ++i) {
-      std::unique_ptr<Volume> volume = Volume::CreateForProvidedFileSystem(
-          file_system_info_list[i], MOUNT_CONTEXT_AUTO);
-      DoMountEvent(chromeos::MOUNT_ERROR_NONE, std::move(volume));
-    }
-  }
-
-  // Subscribe to Profile Preference change.
-  pref_change_registrar_.Init(profile_->GetPrefs());
-  pref_change_registrar_.Add(
-      prefs::kExternalStorageDisabled,
-      base::Bind(&VolumeManager::OnExternalStorageDisabledChanged,
-                 weak_ptr_factory_.GetWeakPtr()));
-  pref_change_registrar_.Add(
-      prefs::kExternalStorageReadOnly,
-      base::Bind(&VolumeManager::OnExternalStorageReadOnlyChanged,
-                 weak_ptr_factory_.GetWeakPtr()));
-
-  // Subscribe to storage monitor for MTP notifications.
-  if (storage_monitor::StorageMonitor::GetInstance()) {
-    storage_monitor::StorageMonitor::GetInstance()->EnsureInitialized(
-        base::Bind(&VolumeManager::OnStorageMonitorInitialized,
-                   weak_ptr_factory_.GetWeakPtr()));
-  }
-
-  // Subscribe to ARC file system events.
-  if (base::FeatureList::IsEnabled(arc::kMediaViewFeature) &&
-      arc::IsArcAllowedForProfile(profile_)) {
-    // Registers a mount point for Android files only when the flag is enabled.
-    if (IsShowAndroidFilesEnabled())
-      RegisterAndroidFilesMountPoint();
-
-    arc::ArcSessionManager::Get()->AddObserver(this);
-    OnArcPlayStoreEnabledChanged(
-        arc::IsArcPlayStoreEnabledForProfile(profile_));
-  }
-}
-
-void VolumeManager::Shutdown() {
-  weak_ptr_factory_.InvalidateWeakPtrs();
-
-  snapshot_manager_.reset();
-  pref_change_registrar_.RemoveAll();
-  disk_mount_manager_->RemoveObserver(this);
-  if (storage_monitor::StorageMonitor::GetInstance())
-    storage_monitor::StorageMonitor::GetInstance()->RemoveObserver(this);
-
-  if (drive_integration_service_)
-    drive_integration_service_->RemoveObserver(this);
-
-  if (file_system_provider_service_)
-    file_system_provider_service_->RemoveObserver(this);
-
-  // Unsubscribe from ARC file system events.
-  if (base::FeatureList::IsEnabled(arc::kMediaViewFeature) &&
-      arc::IsArcAllowedForProfile(profile_)) {
-    auto* session_manager = arc::ArcSessionManager::Get();
-    // TODO(crbug.com/672829): We need nullptr check here because
-    // ArcSessionManager may or may not be alive at this point.
-    if (session_manager)
-      session_manager->RemoveObserver(this);
-  }
-}
-
-void VolumeManager::AddObserver(VolumeManagerObserver* observer) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  DCHECK(observer);
-  observers_.AddObserver(observer);
-}
-
-void VolumeManager::RemoveObserver(VolumeManagerObserver* observer) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  DCHECK(observer);
-  observers_.RemoveObserver(observer);
-}
-
-std::vector<base::WeakPtr<Volume>> VolumeManager::GetVolumeList() {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  std::vector<base::WeakPtr<Volume>> result;
-  result.reserve(mounted_volumes_.size());
-  for (const auto& pair : mounted_volumes_) {
-    result.push_back(pair.second->AsWeakPtr());
-  }
-  return result;
-}
-
-base::WeakPtr<Volume> VolumeManager::FindVolumeById(
-    const std::string& volume_id) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  const auto it = mounted_volumes_.find(volume_id);
-  if (it != mounted_volumes_.end())
-    return it->second->AsWeakPtr();
-  return base::WeakPtr<Volume>();
-}
-
-void VolumeManager::AddSshfsCrostiniVolume(
-    const base::FilePath& sshfs_mount_path) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  std::unique_ptr<Volume> volume =
-      Volume::CreateForSshfsCrostini(sshfs_mount_path);
-  // Ignore if volume already exists.
-  if (mounted_volumes_.find(volume->volume_id()) != mounted_volumes_.end())
-    return;
-  DoMountEvent(chromeos::MOUNT_ERROR_NONE, std::move(volume));
-
-  // Listen for crostini container shutdown and remove volume.
-  crostini::CrostiniManager::GetInstance()->AddShutdownContainerCallback(
-      profile_, kCrostiniDefaultVmName, kCrostiniDefaultContainerName,
-      base::BindOnce(&VolumeManager::RemoveSshfsCrostiniVolume,
-                     weak_ptr_factory_.GetWeakPtr(), sshfs_mount_path));
-}
-
-void VolumeManager::RemoveSshfsCrostiniVolume(
-    const base::FilePath& sshfs_mount_path) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
-                 *Volume::CreateForSshfsCrostini(sshfs_mount_path));
-  disk_mount_manager_->UnmountPath(
-      sshfs_mount_path.value(), chromeos::UNMOUNT_OPTIONS_NONE,
-      chromeos::disks::DiskMountManager::UnmountPathCallback());
-}
-
-bool VolumeManager::RegisterDownloadsDirectoryForTesting(
-    const base::FilePath& path) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  base::FilePath old_path;
-  if (FindDownloadsMountPointPath(profile_, &old_path)) {
-    DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
-                   *Volume::CreateForDownloads(old_path));
-  }
-
-  bool success = RegisterDownloadsMountPoint(profile_, path);
-  DoMountEvent(
-      success ? chromeos::MOUNT_ERROR_NONE : chromeos::MOUNT_ERROR_INVALID_PATH,
-      Volume::CreateForDownloads(path));
-  return success;
-}
-
-bool VolumeManager::RegisterCrostiniDirectoryForTesting(
-    const base::FilePath& path) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  bool success =
-      storage::ExternalMountPoints::GetSystemInstance()->RegisterFileSystem(
-          file_manager::util::GetCrostiniMountPointName(profile_),
-          storage::kFileSystemTypeNativeLocal, storage::FileSystemMountOption(),
-          path);
-  DoMountEvent(
-      success ? chromeos::MOUNT_ERROR_NONE : chromeos::MOUNT_ERROR_INVALID_PATH,
-      Volume::CreateForSshfsCrostini(path));
-  return true;
-}
-
-void VolumeManager::AddVolumeForTesting(const base::FilePath& path,
-                                        VolumeType volume_type,
-                                        chromeos::DeviceType device_type,
-                                        bool read_only) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  DoMountEvent(
-      chromeos::MOUNT_ERROR_NONE,
-      Volume::CreateForTesting(path, volume_type, device_type, read_only));
-}
-
-void VolumeManager::AddVolumeForTesting(std::unique_ptr<Volume> volume) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  DoMountEvent(chromeos::MOUNT_ERROR_NONE, std::move(volume));
-}
-
-void VolumeManager::OnFileSystemMounted() {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  // Raise mount event.
-  // We can pass chromeos::MOUNT_ERROR_NONE even when authentication is failed
-  // or network is unreachable. These two errors will be handled later.
-  DoMountEvent(chromeos::MOUNT_ERROR_NONE,
-               Volume::CreateForDrive(GetDriveMountPointPath()));
-}
-
-void VolumeManager::OnFileSystemBeingUnmounted() {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
-                 *Volume::CreateForDrive(GetDriveMountPointPath()));
-}
-
-void VolumeManager::OnAutoMountableDiskEvent(
-    chromeos::disks::DiskMountManager::DiskEvent event,
-    const chromeos::disks::Disk& disk) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  // Disregard hidden devices.
-  if (disk.is_hidden())
-    return;
-
-  switch (event) {
-    case chromeos::disks::DiskMountManager::DISK_ADDED:
-    case chromeos::disks::DiskMountManager::DISK_CHANGED: {
-      if (disk.device_path().empty()) {
-        DVLOG(1) << "Empty system path for " << disk.device_path();
-        return;
-      }
-
-      bool mounting = false;
-      if (disk.mount_path().empty() && disk.has_media() &&
-          !profile_->GetPrefs()->GetBoolean(prefs::kExternalStorageDisabled)) {
-        // TODO(crbug.com/774890): Remove |mount_label| when the issue gets
-        // resolved. Currently we suggest a mount point name, because in case
-        // when disk's name contains '#', content will not load in Files App.
-        std::string mount_label = disk.device_label();
-        std::replace(mount_label.begin(), mount_label.end(), '#', '_');
-
-        // If disk is not mounted yet and it has media and there is no policy
-        // forbidding external storage, give it a try.
-        // Initiate disk mount operation. MountPath auto-detects the filesystem
-        // format if the second argument is empty. The third argument (mount
-        // label) is not used in a disk mount operation.
-        disk_mount_manager_->MountPath(disk.device_path(), std::string(),
-                                       mount_label, {},
-                                       chromeos::MOUNT_TYPE_DEVICE,
-                                       GetExternalStorageAccessMode(profile_));
-        mounting = true;
-      }
-
-      // Notify to observers.
-      for (auto& observer : observers_)
-        observer.OnDiskAdded(disk, mounting);
-      return;
-    }
-
-    case chromeos::disks::DiskMountManager::DISK_REMOVED:
-      // If the disk is already mounted, unmount it.
-      if (!disk.mount_path().empty()) {
-        disk_mount_manager_->UnmountPath(
-            disk.mount_path(), chromeos::UNMOUNT_OPTIONS_LAZY,
-            chromeos::disks::DiskMountManager::UnmountPathCallback());
-      }
-
-      // Notify to observers.
-      for (auto& observer : observers_)
-        observer.OnDiskRemoved(disk);
-      return;
-  }
-  NOTREACHED();
-}
-
-void VolumeManager::OnDeviceEvent(
-    chromeos::disks::DiskMountManager::DeviceEvent event,
-    const std::string& device_path) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  DVLOG(1) << "OnDeviceEvent: " << event << ", " << device_path;
-  switch (event) {
-    case chromeos::disks::DiskMountManager::DEVICE_ADDED:
-      for (auto& observer : observers_)
-        observer.OnDeviceAdded(device_path);
-      return;
-    case chromeos::disks::DiskMountManager::DEVICE_REMOVED: {
-      for (auto& observer : observers_)
-        observer.OnDeviceRemoved(device_path);
-      return;
-    }
-    case chromeos::disks::DiskMountManager::DEVICE_SCANNED:
-      DVLOG(1) << "Ignore SCANNED event: " << device_path;
-      return;
-  }
-  NOTREACHED();
-}
-
-void VolumeManager::OnMountEvent(
-    chromeos::disks::DiskMountManager::MountEvent event,
-    chromeos::MountError error_code,
-    const chromeos::disks::DiskMountManager::MountPointInfo& mount_info) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  switch (mount_info.mount_type) {
-    case chromeos::MOUNT_TYPE_ARCHIVE: {
-      // If the file is not mounted now, tell it to drive file system so that
-      // it can handle file caching correctly.
-      // Note that drive file system knows if the file is managed by drive file
-      // system or not, so here we report all paths.
-      if ((event == chromeos::disks::DiskMountManager::MOUNTING &&
-           error_code != chromeos::MOUNT_ERROR_NONE) ||
-          (event == chromeos::disks::DiskMountManager::UNMOUNTING &&
-           error_code == chromeos::MOUNT_ERROR_NONE)) {
-        drive::FileSystemInterface* const file_system =
-            drive::util::GetFileSystemByProfile(profile_);
-        if (file_system) {
-          file_system->MarkCacheFileAsUnmounted(
-              base::FilePath(mount_info.source_path), base::DoNothing());
-        }
-      }
-      FALLTHROUGH;
-    }
-    case chromeos::MOUNT_TYPE_DEVICE: {
-      // Notify a mounting/unmounting event to observers.
-      const chromeos::disks::Disk* const disk =
-          disk_mount_manager_->FindDiskBySourcePath(mount_info.source_path);
-      std::unique_ptr<Volume> volume =
-          Volume::CreateForRemovable(mount_info, disk);
-      switch (event) {
-        case chromeos::disks::DiskMountManager::MOUNTING: {
-          DoMountEvent(error_code, std::move(volume));
-          return;
-        }
-        case chromeos::disks::DiskMountManager::UNMOUNTING:
-          DoUnmountEvent(error_code, *volume);
-          return;
-      }
-      NOTREACHED();
-    }
-
-    // Network storage is responsible for doing its own mounting.
-    case chromeos::MOUNT_TYPE_NETWORK_STORAGE: {
-      break;
-    }
-
-    case chromeos::MOUNT_TYPE_INVALID: {
-      NOTREACHED();
-      break;
-    }
-  }
-}
-
-void VolumeManager::OnFormatEvent(
-    chromeos::disks::DiskMountManager::FormatEvent event,
-    chromeos::FormatError error_code,
-    const std::string& device_path) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  DVLOG(1) << "OnDeviceEvent: " << event << ", " << error_code
-           << ", " << device_path;
-
-  switch (event) {
-    case chromeos::disks::DiskMountManager::FORMAT_STARTED:
-      for (auto& observer : observers_) {
-        observer.OnFormatStarted(device_path,
-                                 error_code == chromeos::FORMAT_ERROR_NONE);
-      }
-      return;
-    case chromeos::disks::DiskMountManager::FORMAT_COMPLETED:
-      if (error_code == chromeos::FORMAT_ERROR_NONE) {
-        // If format is completed successfully, try to mount the device.
-        // MountPath auto-detects filesystem format if second argument is
-        // empty. The third argument (mount label) is not used in a disk mount
-        // operation.
-        disk_mount_manager_->MountPath(device_path, std::string(),
-                                       std::string(), {},
-                                       chromeos::MOUNT_TYPE_DEVICE,
-                                       GetExternalStorageAccessMode(profile_));
-      }
-
-      for (auto& observer : observers_) {
-        observer.OnFormatCompleted(device_path,
-                                   error_code == chromeos::FORMAT_ERROR_NONE);
-      }
-
-      return;
-  }
-  NOTREACHED();
-}
-
-void VolumeManager::OnRenameEvent(
-    chromeos::disks::DiskMountManager::RenameEvent event,
-    chromeos::RenameError error_code,
-    const std::string& device_path) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  DVLOG(1) << "OnDeviceEvent: " << event << ", " << error_code << ", "
-           << device_path;
-
-  switch (event) {
-    case chromeos::disks::DiskMountManager::RENAME_STARTED:
-      for (auto& observer : observers_) {
-        observer.OnRenameStarted(device_path,
-                                 error_code == chromeos::RENAME_ERROR_NONE);
-      }
-      return;
-    case chromeos::disks::DiskMountManager::RENAME_COMPLETED:
-      // Find previous mount point label if it exists
-      std::string mount_label = "";
-      auto disk_map_iter = disk_mount_manager_->disks().find(device_path);
-      if (disk_map_iter != disk_mount_manager_->disks().end() &&
-          !disk_map_iter->second->base_mount_path().empty()) {
-        mount_label = base::FilePath(disk_map_iter->second->base_mount_path())
-                          .BaseName()
-                          .AsUTF8Unsafe();
-      }
-
-      // Try to mount the device. MountPath auto-detects filesystem format if
-      // second argument is empty. Third argument is a mount point name of the
-      // disk when it was first time mounted (to preserve mount point regardless
-      // of the volume name).
-      disk_mount_manager_->MountPath(device_path, std::string(), mount_label,
-                                     {}, chromeos::MOUNT_TYPE_DEVICE,
-                                     GetExternalStorageAccessMode(profile_));
-
-      bool successfully_renamed = error_code == chromeos::RENAME_ERROR_NONE;
-      for (auto& observer : observers_)
-        observer.OnRenameCompleted(device_path, successfully_renamed);
-
-      return;
-  }
-  NOTREACHED();
-}
-
-void VolumeManager::OnProvidedFileSystemMount(
-    const chromeos::file_system_provider::ProvidedFileSystemInfo&
-        file_system_info,
-    chromeos::file_system_provider::MountContext context,
-    base::File::Error error) {
-  MountContext volume_context = MOUNT_CONTEXT_UNKNOWN;
-  switch (context) {
-    case chromeos::file_system_provider::MOUNT_CONTEXT_USER:
-      volume_context = MOUNT_CONTEXT_USER;
-      break;
-    case chromeos::file_system_provider::MOUNT_CONTEXT_RESTORE:
-      volume_context = MOUNT_CONTEXT_AUTO;
-      break;
-  }
-
-  std::unique_ptr<Volume> volume =
-      Volume::CreateForProvidedFileSystem(file_system_info, volume_context);
-
-  // TODO(mtomasz): Introduce own type, and avoid using MountError internally,
-  // since it is related to cros disks only.
-  chromeos::MountError mount_error;
-  switch (error) {
-    case base::File::FILE_OK:
-      mount_error = chromeos::MOUNT_ERROR_NONE;
-      break;
-    case base::File::FILE_ERROR_EXISTS:
-      mount_error = chromeos::MOUNT_ERROR_PATH_ALREADY_MOUNTED;
-      break;
-    default:
-      mount_error = chromeos::MOUNT_ERROR_UNKNOWN;
-      break;
-  }
-
-  DoMountEvent(mount_error, std::move(volume));
-}
-
-void VolumeManager::OnProvidedFileSystemUnmount(
-    const chromeos::file_system_provider::ProvidedFileSystemInfo&
-        file_system_info,
-    base::File::Error error) {
-  // TODO(mtomasz): Introduce own type, and avoid using MountError internally,
-  // since it is related to cros disks only.
-  const chromeos::MountError mount_error = error == base::File::FILE_OK
-                                               ? chromeos::MOUNT_ERROR_NONE
-                                               : chromeos::MOUNT_ERROR_UNKNOWN;
-  std::unique_ptr<Volume> volume = Volume::CreateForProvidedFileSystem(
-      file_system_info, MOUNT_CONTEXT_UNKNOWN);
-  DoUnmountEvent(mount_error, *volume);
-}
-
-void VolumeManager::OnExternalStorageDisabledChangedUnmountCallback(
-    chromeos::MountError error_code) {
-  if (disk_mount_manager_->mount_points().empty())
-    return;
-  // Repeat until unmount all paths
-  const std::string& mount_path =
-      disk_mount_manager_->mount_points().begin()->second.mount_path;
-  disk_mount_manager_->UnmountPath(
-      mount_path, chromeos::UNMOUNT_OPTIONS_NONE,
-      base::Bind(
-          &VolumeManager::OnExternalStorageDisabledChangedUnmountCallback,
-          weak_ptr_factory_.GetWeakPtr()));
-}
-
-void VolumeManager::OnArcPlayStoreEnabledChanged(bool enabled) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  DCHECK(base::FeatureList::IsEnabled(arc::kMediaViewFeature));
-  DCHECK(arc::IsArcAllowedForProfile(profile_));
-
-  if (enabled == arc_volumes_mounted_)
-    return;
-
-  if (enabled) {
-    DoMountEvent(chromeos::MOUNT_ERROR_NONE,
-                 Volume::CreateForMediaView(arc::kImagesRootDocumentId));
-    DoMountEvent(chromeos::MOUNT_ERROR_NONE,
-                 Volume::CreateForMediaView(arc::kVideosRootDocumentId));
-    DoMountEvent(chromeos::MOUNT_ERROR_NONE,
-                 Volume::CreateForMediaView(arc::kAudioRootDocumentId));
-    if (IsShowAndroidFilesEnabled())
-      DoMountEvent(chromeos::MOUNT_ERROR_NONE, Volume::CreateForAndroidFiles());
-  } else {
-    DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
-                   *Volume::CreateForMediaView(arc::kImagesRootDocumentId));
-    DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
-                   *Volume::CreateForMediaView(arc::kVideosRootDocumentId));
-    DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
-                   *Volume::CreateForMediaView(arc::kAudioRootDocumentId));
-    if (IsShowAndroidFilesEnabled()) {
-      DoUnmountEvent(chromeos::MOUNT_ERROR_NONE,
-                     *Volume::CreateForAndroidFiles());
-    }
-  }
-
-  arc_volumes_mounted_ = enabled;
-}
-
-void VolumeManager::OnExternalStorageDisabledChanged() {
-  // If the policy just got disabled we have to unmount every device currently
-  // mounted. The opposite is fine - we can let the user re-plug their device to
-  // make it available.
-  if (profile_->GetPrefs()->GetBoolean(prefs::kExternalStorageDisabled)) {
-    // We do not iterate on mount_points directly, because mount_points can
-    // be changed by UnmountPath().
-    // TODO(hidehiko): Is it necessary to unmount mounted archives, too, here?
-    if (disk_mount_manager_->mount_points().empty())
-      return;
-    const std::string& mount_path =
-        disk_mount_manager_->mount_points().begin()->second.mount_path;
-    disk_mount_manager_->UnmountPath(
-        mount_path, chromeos::UNMOUNT_OPTIONS_NONE,
-        base::Bind(
-            &VolumeManager::OnExternalStorageDisabledChangedUnmountCallback,
-            weak_ptr_factory_.GetWeakPtr()));
-  }
-}
-
-void VolumeManager::OnExternalStorageReadOnlyChanged() {
-  disk_mount_manager_->RemountAllRemovableDrives(
-      GetExternalStorageAccessMode(profile_));
-}
-
-void VolumeManager::OnRemovableStorageAttached(
-    const storage_monitor::StorageInfo& info) {
-  if (!storage_monitor::StorageInfo::IsMTPDevice(info.device_id()))
-    return;
-  if (profile_->GetPrefs()->GetBoolean(prefs::kExternalStorageDisabled))
-    return;
-
-  // Resolve mtp storage name and get MtpStorageInfo.
-  std::string storage_name;
-  base::RemoveChars(info.location(), kRootPath, &storage_name);
-  DCHECK(!storage_name.empty());
-  if (get_mtp_storage_info_callback_.is_null()) {
-    storage_monitor::StorageMonitor::GetInstance()
-        ->media_transfer_protocol_manager()
-        ->GetStorageInfo(storage_name,
-                         base::BindOnce(&VolumeManager::DoAttachMtpStorage,
-                                        weak_ptr_factory_.GetWeakPtr(), info));
-  } else {
-    get_mtp_storage_info_callback_.Run(
-        storage_name, base::BindOnce(&VolumeManager::DoAttachMtpStorage,
-                                     weak_ptr_factory_.GetWeakPtr(), info));
-  }
-}
-
-void VolumeManager::DoAttachMtpStorage(
-    const storage_monitor::StorageInfo& info,
-    device::mojom::MtpStorageInfoPtr mtp_storage_info) {
-  if (!mtp_storage_info) {
-    // |mtp_storage_info| can be null. e.g. As OnRemovableStorageAttached and
-    // DoAttachMtpStorage are called asynchronously, there can be a race
-    // condition where the storage has been already removed in
-    // MediaTransferProtocolManager at the time when this method is called.
-    return;
-  }
-
-  // Mtp write is enabled only when the device is writable, supports generic
-  // hierarchical file system, and writing to external storage devices is not
-  // prohibited by the preference.
-  const bool read_only =
-      base::CommandLine::ForCurrentProcess()->HasSwitch(
-          chromeos::switches::kDisableMtpWriteSupport) ||
-      mtp_storage_info->access_capability != kAccessCapabilityReadWrite ||
-      mtp_storage_info->filesystem_type !=
-          kFilesystemTypeGenericHierarchical ||
-      GetExternalStorageAccessMode(profile_) ==
-          chromeos::MOUNT_ACCESS_MODE_READ_ONLY;
-
-  const base::FilePath path = base::FilePath::FromUTF8Unsafe(info.location());
-  const std::string fsid = GetMountPointNameForMediaStorage(info);
-  const std::string base_name = base::UTF16ToUTF8(info.model_name());
-
-  // Assign a fresh volume ID based on the volume name.
-  std::string label = base_name;
-  for (int i = 2; mounted_volumes_.count(kMtpVolumeIdPrefix + label); ++i)
-    label = base_name + base::StringPrintf(" (%d)", i);
-
-  bool result =
-      storage::ExternalMountPoints::GetSystemInstance()->RegisterFileSystem(
-          fsid, storage::kFileSystemTypeDeviceMediaAsFileStorage,
-          storage::FileSystemMountOption(), path);
-  DCHECK(result);
-
-  content::BrowserThread::PostTask(
-      content::BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&MTPDeviceMapService::RegisterMTPFileSystem,
-                     base::Unretained(MTPDeviceMapService::GetInstance()),
-                     info.location(), fsid, read_only));
-
-  std::unique_ptr<Volume> volume = Volume::CreateForMTP(path, label, read_only);
-  DoMountEvent(chromeos::MOUNT_ERROR_NONE, std::move(volume));
-}
-
-void VolumeManager::OnRemovableStorageDetached(
-    const storage_monitor::StorageInfo& info) {
-  if (!storage_monitor::StorageInfo::IsMTPDevice(info.device_id()))
-    return;
-
-  for (const auto& mounted_volume : mounted_volumes_) {
-    if (mounted_volume.second->source_path().value() == info.location()) {
-      DoUnmountEvent(chromeos::MOUNT_ERROR_NONE, *mounted_volume.second.get());
-
-      const std::string fsid = GetMountPointNameForMediaStorage(info);
-      storage::ExternalMountPoints::GetSystemInstance()->RevokeFileSystem(fsid);
-      content::BrowserThread::PostTask(
-          content::BrowserThread::IO, FROM_HERE,
-          base::BindOnce(&MTPDeviceMapService::RevokeMTPFileSystem,
-                         base::Unretained(MTPDeviceMapService::GetInstance()),
-                         fsid));
-      return;
-    }
-  }
-}
-
-void VolumeManager::OnDiskMountManagerRefreshed(bool success) {
-  if (!success) {
-    LOG(ERROR) << "Failed to refresh disk mount manager";
-    return;
-  }
-
-  std::vector<std::unique_ptr<Volume>> archives;
-
-  const chromeos::disks::DiskMountManager::MountPointMap& mount_points =
-      disk_mount_manager_->mount_points();
-  for (const auto& mount_point : mount_points) {
-    switch (mount_point.second.mount_type) {
-      case chromeos::MOUNT_TYPE_ARCHIVE: {
-        // Archives are mounted after other types of volume. See below.
-        archives.push_back(
-            Volume::CreateForRemovable(mount_point.second, nullptr));
-        break;
-      }
-      case chromeos::MOUNT_TYPE_DEVICE: {
-        DoMountEvent(
-            chromeos::MOUNT_ERROR_NONE,
-            Volume::CreateForRemovable(
-                mount_point.second, disk_mount_manager_->FindDiskBySourcePath(
-                                        mount_point.second.source_path)));
-        break;
-      }
-      case chromeos::MOUNT_TYPE_NETWORK_STORAGE: {
-        break;
-      }
-      case chromeos::MOUNT_TYPE_INVALID: {
-        NOTREACHED();
-      }
-    }
-  }
-
-  // We mount archives only if they are opened from currently mounted volumes.
-  // To check the condition correctly in DoMountEvent, we care about the order.
-  std::vector<bool> done(archives.size(), false);
-  for (size_t i = 0; i < archives.size(); ++i) {
-    if (done[i])
-      continue;
-
-    std::vector<std::unique_ptr<Volume>> chain;
-    // done[x] = true means archives[x] is null and that volume is in |chain|.
-    done[i] = true;
-    chain.push_back(std::move(archives[i]));
-
-    // If archives[i]'s source_path is in another archive, mount it first.
-    for (size_t parent = i + 1; parent < archives.size(); ++parent) {
-      if (!done[parent] &&
-          archives[parent]->mount_path().IsParent(
-              chain.back()->source_path())) {
-        // done[parent] started false, so archives[parent] is non-null.
-        done[parent] = true;
-        chain.push_back(std::move(archives[parent]));
-        parent = i + 1;  // Search archives[parent]'s parent from the beginning.
-      }
-    }
-
-    // Mount from the tail of chain.
-    for (size_t i = chain.size(); i > 0; --i) {
-      DoMountEvent(chromeos::MOUNT_ERROR_NONE, std::move(chain[i - 1]));
-    }
-  }
-}
-
-void VolumeManager::OnStorageMonitorInitialized() {
-  std::vector<storage_monitor::StorageInfo> storages =
-      storage_monitor::StorageMonitor::GetInstance()->GetAllAvailableStorages();
-  for (size_t i = 0; i < storages.size(); ++i)
-    OnRemovableStorageAttached(storages[i]);
-  storage_monitor::StorageMonitor::GetInstance()->AddObserver(this);
-}
-
-void VolumeManager::DoMountEvent(chromeos::MountError error_code,
-                                 std::unique_ptr<Volume> volume) {
-  // Archive files are mounted globally in system. We however don't want to show
-  // archives from profile-specific folders (Drive/Downloads) of other users in
-  // multi-profile session. To this end, we filter out archives not on the
-  // volumes already mounted on this VolumeManager instance.
-  if (volume->type() == VOLUME_TYPE_MOUNTED_ARCHIVE_FILE) {
-    // Source may be in Drive cache folder under the current profile directory.
-    bool from_current_profile =
-        profile_->GetPath().IsParent(volume->source_path());
-    for (const auto& mounted_volume : mounted_volumes_) {
-      if (mounted_volume.second->mount_path().IsParent(volume->source_path())) {
-        from_current_profile = true;
-        break;
-      }
-    }
-    if (!from_current_profile)
-      return;
-  }
-
-  // Filter out removable disks if forbidden by policy for this profile.
-  if (volume->type() == VOLUME_TYPE_REMOVABLE_DISK_PARTITION &&
-      profile_->GetPrefs()->GetBoolean(prefs::kExternalStorageDisabled)) {
-    return;
-  }
-
-  Volume* raw_volume = volume.get();
-  if (error_code == chromeos::MOUNT_ERROR_NONE || volume->mount_condition()) {
-    mounted_volumes_[volume->volume_id()] = std::move(volume);
-    UMA_HISTOGRAM_ENUMERATION("FileBrowser.VolumeType", raw_volume->type(),
-                              NUM_VOLUME_TYPE);
-  }
-
-  for (auto& observer : observers_)
-    observer.OnVolumeMounted(error_code, *raw_volume);
-}
-
-void VolumeManager::DoUnmountEvent(chromeos::MountError error_code,
-                                   const Volume& volume) {
-  auto iter = mounted_volumes_.find(volume.volume_id());
-  if (iter == mounted_volumes_.end())
-    return;
-  std::unique_ptr<Volume> volume_ref;
-  if (error_code == chromeos::MOUNT_ERROR_NONE) {
-    // It is important to hold a reference to the removed Volume from
-    // |mounted_volumes_|, because OnVolumeMounted() will access it.
-    volume_ref = std::move(iter->second);
-    mounted_volumes_.erase(iter);
-  }
-
-  for (auto& observer : observers_)
-    observer.OnVolumeUnmounted(error_code, volume);
-}
-
-base::FilePath VolumeManager::GetDriveMountPointPath() const {
-  return drive_integration_service_->GetMountPointPath();
-}
-
-}  // namespace file_manager
diff --git a/chrome/browser/file_manager/volume_manager.h b/chrome/browser/file_manager/volume_manager.h
index 3c7664fad0f8e..f561f2f355ec3 100644
--- a/chrome/browser/file_manager/volume_manager.h
+++ b/chrome/browser/file_manager/volume_manager.h
@@ -1,400 +1,14 @@
-// Copyright 2013 The Chromium Authors. All rights reserved.
+// Copyright 2018 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
 #ifndef CHROME_BROWSER_FILE_MANAGER_VOLUME_MANAGER_H_
 #define CHROME_BROWSER_FILE_MANAGER_VOLUME_MANAGER_H_
 
-#include <map>
-#include <memory>
-#include <string>
-#include <vector>
-
-#include "base/callback.h"
-#include "base/files/file.h"
-#include "base/files/file_path.h"
-#include "base/macros.h"
-#include "base/memory/weak_ptr.h"
-#include "base/observer_list.h"
-#include "chrome/browser/chromeos/arc/arc_session_manager.h"
-#include "chrome/browser/chromeos/drive/drive_integration_service.h"
-#include "chrome/browser/chromeos/file_system_provider/icon_set.h"
-#include "chrome/browser/chromeos/file_system_provider/observer.h"
-#include "chrome/browser/chromeos/file_system_provider/provided_file_system_info.h"
-#include "chrome/browser/chromeos/file_system_provider/service.h"
-#include "chromeos/dbus/cros_disks_client.h"
-#include "chromeos/disks/disk_mount_manager.h"
-#include "components/keyed_service/core/keyed_service.h"
-#include "components/prefs/pref_change_registrar.h"
-#include "components/storage_monitor/removable_storage_observer.h"
-#include "services/device/public/mojom/mtp_manager.mojom.h"
-
-class Profile;
-
-namespace chromeos {
-class PowerManagerClient;
-
-namespace disks {
-class Disk;
-}  // namespace disks
-
-}  // namespace chromeos
-
-namespace content {
-class BrowserContext;
-}  // namespace content
-
-namespace file_manager {
-
-class SnapshotManager;
-class VolumeManagerObserver;
-
-// Identifiers for volume types managed by Chrome OS file manager.
-enum VolumeType {
-  VOLUME_TYPE_TESTING = -1,  // Used only in tests.
-  VOLUME_TYPE_GOOGLE_DRIVE = 0,
-  VOLUME_TYPE_DOWNLOADS_DIRECTORY,
-  VOLUME_TYPE_REMOVABLE_DISK_PARTITION,
-  VOLUME_TYPE_MOUNTED_ARCHIVE_FILE,
-  VOLUME_TYPE_PROVIDED,  // File system provided by the FileSystemProvider API.
-  VOLUME_TYPE_MTP,
-  VOLUME_TYPE_MEDIA_VIEW,
-  VOLUME_TYPE_CROSTINI,
-  VOLUME_TYPE_ANDROID_FILES,
-  // The enum values must be kept in sync with FileManagerVolumeType in
-  // tools/metrics/histograms/histograms.xml. Since enums for histograms are
-  // append-only (for keeping the number consistent across versions), new values
-  // for this enum also has to be always appended at the end (i.e., here).
-  NUM_VOLUME_TYPE,
-};
-
-// Says how was the mount performed, whether due to user interaction, or
-// automatic. User interaction includes both hardware (pluggins a USB stick)
-// or software (mounting a ZIP archive) interaction.
-enum MountContext {
-  MOUNT_CONTEXT_USER,
-  MOUNT_CONTEXT_AUTO,
-  MOUNT_CONTEXT_UNKNOWN
-};
-
-// Source of a volume's data.
-enum Source { SOURCE_FILE, SOURCE_DEVICE, SOURCE_NETWORK, SOURCE_SYSTEM };
-
-// Represents a volume (mount point) in the volume manager. Validity of the data
-// is guaranteed by the weak pointer. Simply saying, the weak pointer should be
-// valid as long as the volume is mounted.
-class Volume : public base::SupportsWeakPtr<Volume> {
- public:
-  ~Volume();
-
-  // Factory static methods for different volume types.
-  static std::unique_ptr<Volume> CreateForDrive(
-      const base::FilePath& drive_path);
-  static std::unique_ptr<Volume> CreateForDownloads(
-      const base::FilePath& downloads_path);
-  static std::unique_ptr<Volume> CreateForRemovable(
-      const chromeos::disks::DiskMountManager::MountPointInfo& mount_point,
-      const chromeos::disks::Disk* disk);
-  static std::unique_ptr<Volume> CreateForProvidedFileSystem(
-      const chromeos::file_system_provider::ProvidedFileSystemInfo&
-          file_system_info,
-      MountContext mount_context);
-  static std::unique_ptr<Volume> CreateForMTP(const base::FilePath& mount_path,
-                                              const std::string& label,
-                                              bool read_only);
-  static std::unique_ptr<Volume> CreateForMediaView(
-      const std::string& root_document_id);
-  static std::unique_ptr<Volume> CreateForSshfsCrostini(
-      const base::FilePath& crostini_path);
-  static std::unique_ptr<Volume> CreateForAndroidFiles();
-  static std::unique_ptr<Volume> CreateForTesting(
-      const base::FilePath& path,
-      VolumeType volume_type,
-      chromeos::DeviceType device_type,
-      bool read_only);
-  static std::unique_ptr<Volume> CreateForTesting(
-      const base::FilePath& device_path,
-      const base::FilePath& mount_path);
-
-  // Getters for all members. See below for details.
-  const std::string& volume_id() const { return volume_id_; }
-  const std::string& file_system_id() const { return file_system_id_; }
-  const chromeos::file_system_provider::ProviderId& provider_id() const {
-    return provider_id_;
-  }
-  Source source() const { return source_; }
-  VolumeType type() const { return type_; }
-  chromeos::DeviceType device_type() const { return device_type_; }
-  const base::FilePath& source_path() const { return source_path_; }
-  const base::FilePath& mount_path() const { return mount_path_; }
-  chromeos::disks::MountCondition mount_condition() const {
-    return mount_condition_;
-  }
-  MountContext mount_context() const { return mount_context_; }
-  const base::FilePath& system_path_prefix() const {
-    return system_path_prefix_;
-  }
-  const std::string& volume_label() const { return volume_label_; }
-  bool is_parent() const { return is_parent_; }
-  // Whether the applications can write to the volume. True if not writable.
-  // For example, when write access to external storage is restricted by the
-  // policy (ExternalStorageReadOnly), is_read_only() will be true even when
-  // is_read_only_removable_device() is false.
-  bool is_read_only() const { return is_read_only_; }
-  // Whether the device is write-protected by hardware. This field is valid
-  // only when device_type is VOLUME_TYPE_REMOVABLE_DISK_PARTITION and
-  // source is SOURCE_DEVICE.
-  // When this value is true, is_read_only() is also true.
-  bool is_read_only_removable_device() const {
-    return is_read_only_removable_device_;
-  }
-  bool has_media() const { return has_media_; }
-  bool configurable() const { return configurable_; }
-  bool watchable() const { return watchable_; }
-  const std::string& file_system_type() const { return file_system_type_; }
-  const chromeos::file_system_provider::IconSet& icon_set() const {
-    return icon_set_;
-  }
-
- private:
-  Volume();
-
-  // The ID of the volume.
-  std::string volume_id_;
-
-  // The ID for provided file systems. If other type, then empty string. Unique
-  // per providing extension or native provider.
-  std::string file_system_id_;
-
-  // The ID of an extension or native provider providing the file system. If
-  // other type, then equal to a ProviderId of the type INVALID.
-  chromeos::file_system_provider::ProviderId provider_id_;
-
-  // The source of the volume's data.
-  Source source_;
-
-  // The type of mounted volume.
-  VolumeType type_;
-
-  // The type of device. (e.g. USB, SD card, DVD etc.)
-  chromeos::DeviceType device_type_;
-
-  // The source path of the volume.
-  // E.g.:
-  // - /home/chronos/user/Downloads/zipfile_path.zip
-  base::FilePath source_path_;
-
-  // The mount path of the volume.
-  // E.g.:
-  // - /home/chronos/user/Downloads
-  // - /media/removable/usb1
-  // - /media/archive/zip1
-  base::FilePath mount_path_;
-
-  // The mounting condition. See the enum for the details.
-  chromeos::disks::MountCondition mount_condition_;
-
-  // The context of the mount. Whether mounting was performed due to a user
-  // interaction or not.
-  MountContext mount_context_;
-
-  // Path of the system device this device's block is a part of.
-  // (e.g. /sys/devices/pci0000:00/.../8:0:0:0/)
-  base::FilePath system_path_prefix_;
-
-  // Label for the volume if the volume is either removable or a provided
-  // file system. In case of removables, if disk is a parent, then its label,
-  // else parents label (e.g. "TransMemory").
-  std::string volume_label_;
-
-  // Is the device is a parent device (i.e. sdb rather than sdb1).
-  bool is_parent_;
-
-  // True if the volume is not writable by applications.
-  bool is_read_only_;
-
-  // True if the volume is made read_only due to its hardware.
-  // This implies is_read_only_.
-  bool is_read_only_removable_device_;
-
-  // True if the volume contains media.
-  bool has_media_;
-
-  // True if the volume is configurable.
-  bool configurable_;
-
-  // True if the volume notifies about changes via file/directory watchers.
-  bool watchable_;
-
-  // Identifier for the file system type
-  std::string file_system_type_;
-
-  // Volume icon set.
-  chromeos::file_system_provider::IconSet icon_set_;
-
-  DISALLOW_COPY_AND_ASSIGN(Volume);
-};
-
-// Manages Volumes for file manager. Example of Volumes:
-// - Drive File System.
-// - Downloads directory.
-// - Removable disks (volume will be created for each partition, not only one
-//   for a device).
-// - Mounted zip archives.
-// - Linux/Crostini file system.
-// - Android/Arc++ file system.
-// - File System Providers.
-class VolumeManager : public KeyedService,
-                      public arc::ArcSessionManager::Observer,
-                      public drive::DriveIntegrationServiceObserver,
-                      public chromeos::disks::DiskMountManager::Observer,
-                      public chromeos::file_system_provider::Observer,
-                      public storage_monitor::RemovableStorageObserver {
- public:
-  // An alternate to device::mojom::MtpManager::GetStorageInfo.
-  // Used for injecting fake MTP manager for testing in VolumeManagerTest.
-  using GetMtpStorageInfoCallback = base::RepeatingCallback<void(
-      const std::string&,
-      device::mojom::MtpManager::GetStorageInfoCallback)>;
-
-  VolumeManager(
-      Profile* profile,
-      drive::DriveIntegrationService* drive_integration_service,
-      chromeos::PowerManagerClient* power_manager_client,
-      chromeos::disks::DiskMountManager* disk_mount_manager,
-      chromeos::file_system_provider::Service* file_system_provider_service,
-      const GetMtpStorageInfoCallback& get_mtp_storage_info_callback);
-  ~VolumeManager() override;
-
-  // Returns the instance corresponding to the |context|.
-  static VolumeManager* Get(content::BrowserContext* context);
-
-  // Initializes this instance.
-  void Initialize();
-
-  // Disposes this instance.
-  void Shutdown() override;
-
-  // Adds an observer.
-  void AddObserver(VolumeManagerObserver* observer);
-
-  // Removes the observer.
-  void RemoveObserver(VolumeManagerObserver* observer);
-
-  // Returns the information about all volumes currently mounted. The returned
-  // weak pointers are valid as long as the volumes are mounted.
-  std::vector<base::WeakPtr<Volume>> GetVolumeList();
-
-  // Finds Volume for the given volume ID. If found, then the returned weak
-  // pointer is valid. It is invalidated as soon as the volume is removed from
-  // the volume manager.
-  base::WeakPtr<Volume> FindVolumeById(const std::string& volume_id);
-
-  // Add sshfs crostini volume mounted at specified path.
-  void AddSshfsCrostiniVolume(const base::FilePath& sshfs_mount_path);
-
-  // Removes specified sshfs crostini mount.
-  void RemoveSshfsCrostiniVolume(const base::FilePath& sshfs_mount_path);
-
-  // For testing purpose, registers a native local file system pointing to
-  // |path| with DOWNLOADS type, and adds its volume info.
-  bool RegisterDownloadsDirectoryForTesting(const base::FilePath& path);
-
-  // For testing purpose, registers a native local file system pointing to
-  // |path| with CROSTINI type, and adds its volume info.
-  bool RegisterCrostiniDirectoryForTesting(const base::FilePath& path);
-
-  // For testing purpose, adds a volume info pointing to |path|, with TESTING
-  // type. Assumes that the mount point is already registered.
-  void AddVolumeForTesting(const base::FilePath& path,
-                           VolumeType volume_type,
-                           chromeos::DeviceType device_type,
-                           bool read_only);
-
-  // For testing purpose, adds the volume info to the volume manager.
-  void AddVolumeForTesting(std::unique_ptr<Volume> volume);
-
-  // drive::DriveIntegrationServiceObserver overrides.
-  void OnFileSystemMounted() override;
-  void OnFileSystemBeingUnmounted() override;
-
-  // chromeos::disks::DiskMountManager::Observer overrides.
-  void OnAutoMountableDiskEvent(
-      chromeos::disks::DiskMountManager::DiskEvent event,
-      const chromeos::disks::Disk& disk) override;
-  void OnDeviceEvent(chromeos::disks::DiskMountManager::DeviceEvent event,
-                     const std::string& device_path) override;
-  void OnMountEvent(chromeos::disks::DiskMountManager::MountEvent event,
-                    chromeos::MountError error_code,
-                    const chromeos::disks::DiskMountManager::MountPointInfo&
-                        mount_info) override;
-  void OnFormatEvent(chromeos::disks::DiskMountManager::FormatEvent event,
-                     chromeos::FormatError error_code,
-                     const std::string& device_path) override;
-  void OnRenameEvent(chromeos::disks::DiskMountManager::RenameEvent event,
-                     chromeos::RenameError error_code,
-                     const std::string& device_path) override;
-
-  // chromeos::file_system_provider::Observer overrides.
-  void OnProvidedFileSystemMount(
-      const chromeos::file_system_provider::ProvidedFileSystemInfo&
-          file_system_info,
-      chromeos::file_system_provider::MountContext context,
-      base::File::Error error) override;
-  void OnProvidedFileSystemUnmount(
-      const chromeos::file_system_provider::ProvidedFileSystemInfo&
-          file_system_info,
-      base::File::Error error) override;
-
-  // arc::ArcSessionManager::Observer overrides.
-  void OnArcPlayStoreEnabledChanged(bool enabled) override;
-
-  // Called on change to kExternalStorageDisabled pref.
-  void OnExternalStorageDisabledChanged();
-
-  // Called on change to kExternalStorageReadOnly pref.
-  void OnExternalStorageReadOnlyChanged();
-
-  // RemovableStorageObserver overrides.
-  void OnRemovableStorageAttached(
-      const storage_monitor::StorageInfo& info) override;
-  void OnRemovableStorageDetached(
-      const storage_monitor::StorageInfo& info) override;
-
-  SnapshotManager* snapshot_manager() { return snapshot_manager_.get(); }
-
- private:
-  void OnDiskMountManagerRefreshed(bool success);
-  void OnStorageMonitorInitialized();
-  void DoAttachMtpStorage(const storage_monitor::StorageInfo& info,
-                          device::mojom::MtpStorageInfoPtr mtp_storage_info);
-  void DoMountEvent(chromeos::MountError error_code,
-                    std::unique_ptr<Volume> volume);
-  void DoUnmountEvent(chromeos::MountError error_code, const Volume& volume);
-  void OnExternalStorageDisabledChangedUnmountCallback(
-      chromeos::MountError error_code);
-
-  // Returns the path of the mount point for drive.
-  base::FilePath GetDriveMountPointPath() const;
-
-  Profile* profile_;
-  drive::DriveIntegrationService* drive_integration_service_;  // Not owned.
-  chromeos::disks::DiskMountManager* disk_mount_manager_;      // Not owned.
-  PrefChangeRegistrar pref_change_registrar_;
-  base::ObserverList<VolumeManagerObserver>::Unchecked observers_;
-  chromeos::file_system_provider::Service*
-      file_system_provider_service_;  // Not owned by this class.
-  GetMtpStorageInfoCallback get_mtp_storage_info_callback_;
-  std::map<std::string, std::unique_ptr<Volume>> mounted_volumes_;
-  std::unique_ptr<SnapshotManager> snapshot_manager_;
-  bool arc_volumes_mounted_ = false;
-
-  // Note: This should remain the last member so it'll be destroyed and
-  // invalidate its weak pointers before any other members are destroyed.
-  base::WeakPtrFactory<VolumeManager> weak_ptr_factory_;
-  DISALLOW_COPY_AND_ASSIGN(VolumeManager);
-};
-
-}  // namespace file_manager
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/file_manager/chromeos/volume_manager.h"
+#else
+#include "chrome/browser/file_manager/linux/volume_manager.h"
+#endif
 
 #endif  // CHROME_BROWSER_FILE_MANAGER_VOLUME_MANAGER_H_
diff --git a/chrome/browser/file_manager/volume_manager_factory.cc b/chrome/browser/file_manager/volume_manager_factory.cc
index 8e694c3ec6d78..cf804966da4c7 100644
--- a/chrome/browser/file_manager/volume_manager_factory.cc
+++ b/chrome/browser/file_manager/volume_manager_factory.cc
@@ -6,15 +6,17 @@
 
 #include "base/bind.h"
 #include "base/memory/singleton.h"
-#include "chrome/browser/chromeos/drive/drive_integration_service.h"
-#include "chrome/browser/chromeos/file_system_provider/service_factory.h"
 #include "chrome/browser/file_manager/volume_manager.h"
 #include "chrome/browser/profiles/incognito_helpers.h"
 #include "chrome/browser/profiles/profile.h"
-#include "chromeos/dbus/dbus_thread_manager.h"
-#include "chromeos/disks/disk_mount_manager.h"
 #include "components/keyed_service/content/browser_context_dependency_manager.h"
 #include "components/storage_monitor/storage_monitor.h"
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/chromeos/file_system_provider/service_factory.h"
+#include "chromeos/dbus/dbus_thread_manager.h"
+#include "chromeos/disks/disk_mount_manager.h"
+#endif
 
 namespace file_manager {
 
@@ -44,12 +46,16 @@ bool VolumeManagerFactory::ServiceIsNULLWhileTesting() const {
 KeyedService* VolumeManagerFactory::BuildServiceInstanceFor(
     content::BrowserContext* context) const {
   Profile* const profile = Profile::FromBrowserContext(context);
+#if defined(OS_CHROMEOS)
   VolumeManager* instance = new VolumeManager(
       profile, drive::DriveIntegrationServiceFactory::GetForProfile(profile),
       chromeos::DBusThreadManager::Get()->GetPowerManagerClient(),
       chromeos::disks::DiskMountManager::GetInstance(),
       chromeos::file_system_provider::ServiceFactory::Get(context),
       VolumeManager::GetMtpStorageInfoCallback());
+#else
+  VolumeManager* instance = new VolumeManager(profile);
+#endif
   instance->Initialize();
   return instance;
 }
@@ -58,8 +64,10 @@ VolumeManagerFactory::VolumeManagerFactory()
     : BrowserContextKeyedServiceFactory(
           "VolumeManagerFactory",
           BrowserContextDependencyManager::GetInstance()) {
+#if defined(OS_CHROMEOS)
   DependsOn(drive::DriveIntegrationServiceFactory::GetInstance());
   DependsOn(chromeos::file_system_provider::ServiceFactory::GetInstance());
+#endif
 }
 
 VolumeManagerFactory::~VolumeManagerFactory() = default;
diff --git a/chrome/browser/file_manager/volume_manager_observer.h b/chrome/browser/file_manager/volume_manager_observer.h
index 227ea52546852..2fb8754d0c96c 100644
--- a/chrome/browser/file_manager/volume_manager_observer.h
+++ b/chrome/browser/file_manager/volume_manager_observer.h
@@ -5,6 +5,10 @@
 #ifndef CHROME_BROWSER_FILE_MANAGER_VOLUME_MANAGER_OBSERVER_H_
 #define CHROME_BROWSER_FILE_MANAGER_VOLUME_MANAGER_OBSERVER_H_
 
+#if !defined(OS_CHROMEOS)
+#error "VolumeManagerObserver only works on ChromeOS."
+#endif
+
 #include <string>
 
 #include "chromeos/dbus/cros_disks_client.h"

From d1c929ea20db44a0c2a883347322d4b3c54cf5b8 Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Tue, 14 Aug 2018 20:43:19 +0900
Subject: [PATCH 28/32] Add OS_CHROMEOS guard to chrome/browser/fileapi/

In order to share fileapi with Linux, it adds OS_CHROMEOS
guard for ChromeOS specific code.
---
 chrome/browser/fileapi/file_system_backend.cc | 82 +++++++++++++++----
 chrome/browser/fileapi/file_system_backend.h  |  4 +
 chrome/browser/fileapi/recent_model.cc        | 11 ++-
 .../browser/fileapi/recent_model_factory.cc   |  6 +-
 4 files changed, 82 insertions(+), 21 deletions(-)

diff --git a/chrome/browser/fileapi/file_system_backend.cc b/chrome/browser/fileapi/file_system_backend.cc
index 34e6062ac6e8d..bb569bef04737 100644
--- a/chrome/browser/fileapi/file_system_backend.cc
+++ b/chrome/browser/fileapi/file_system_backend.cc
@@ -11,13 +11,10 @@
 
 #include "base/command_line.h"
 #include "base/logging.h"
-#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_util.h"
 #include "chrome/browser/fileapi/file_access_permissions.h"
 #include "chrome/browser/fileapi/file_system_backend_delegate.h"
 #include "chrome/browser/media_galleries/fileapi/media_file_system_backend.h"
 #include "chrome/common/url_constants.h"
-#include "chromeos/chromeos_switches.h"
-#include "chromeos/dbus/cros_disks_client.h"
 #include "net/base/escape.h"
 #include "storage/browser/fileapi/async_file_util.h"
 #include "storage/browser/fileapi/external_mount_points.h"
@@ -29,6 +26,11 @@
 #include "storage/browser/fileapi/file_system_url.h"
 #include "storage/common/fileapi/file_system_mount_option.h"
 #include "storage/common/fileapi/file_system_util.h"
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_util.h"
+#include "chromeos/chromeos_switches.h"
+#include "chromeos/dbus/cros_disks_client.h"
+#endif
 
 namespace chromeos {
 namespace {
@@ -47,6 +49,7 @@ const char* kOemAccessibleExtensions[] = {
 bool FileSystemBackend::CanHandleURL(const storage::FileSystemURL& url) {
   if (!url.is_valid())
     return false;
+#if defined(OS_CHROMEOS)
   return url.type() == storage::kFileSystemTypeNativeLocal ||
          url.type() == storage::kFileSystemTypeRestrictedNativeLocal ||
          url.type() == storage::kFileSystemTypeDrive ||
@@ -55,19 +58,26 @@ bool FileSystemBackend::CanHandleURL(const storage::FileSystemURL& url) {
          url.type() == storage::kFileSystemTypeArcContent ||
          url.type() == storage::kFileSystemTypeArcDocumentsProvider ||
          url.type() == storage::kFileSystemTypeDriveFs;
+#else
+  return url.type() == storage::kFileSystemTypeNativeLocal ||
+         url.type() == storage::kFileSystemTypeRestrictedNativeLocal;
+#endif
 }
 
 FileSystemBackend::FileSystemBackend(
+#if defined(OS_CHROMEOS)
     std::unique_ptr<FileSystemBackendDelegate> drive_delegate,
     std::unique_ptr<FileSystemBackendDelegate> file_system_provider_delegate,
     std::unique_ptr<FileSystemBackendDelegate> mtp_delegate,
     std::unique_ptr<FileSystemBackendDelegate> arc_content_delegate,
     std::unique_ptr<FileSystemBackendDelegate> arc_documents_provider_delegate,
     std::unique_ptr<FileSystemBackendDelegate> drivefs_delegate,
+#endif
     scoped_refptr<storage::ExternalMountPoints> mount_points,
     storage::ExternalMountPoints* system_mount_points)
     : file_access_permissions_(new FileAccessPermissions()),
       local_file_util_(storage::AsyncFileUtil::CreateForLocalFileSystem()),
+#if defined(OS_CHROMEOS)
       drive_delegate_(std::move(drive_delegate)),
       file_system_provider_delegate_(std::move(file_system_provider_delegate)),
       mtp_delegate_(std::move(mtp_delegate)),
@@ -75,6 +85,7 @@ FileSystemBackend::FileSystemBackend(
       arc_documents_provider_delegate_(
           std::move(arc_documents_provider_delegate)),
       drivefs_delegate_(std::move(drivefs_delegate)),
+#endif
       mount_points_(mount_points),
       system_mount_points_(system_mount_points) {}
 
@@ -85,6 +96,7 @@ void FileSystemBackend::AddSystemMountPoints() {
   // RegisterFileSystem() is no-op if the mount point with the same name
   // already exists, hence it's safe to call without checking if a mount
   // point already exists or not.
+#if defined(OS_CHROMEOS)
   system_mount_points_->RegisterFileSystem(
       "archive",
       storage::kFileSystemTypeNativeLocal,
@@ -94,6 +106,7 @@ void FileSystemBackend::AddSystemMountPoints() {
       "removable", storage::kFileSystemTypeNativeLocal,
       storage::FileSystemMountOption(storage::FlushPolicy::FLUSH_ON_COMPLETION),
       chromeos::CrosDisksClient::GetRemovableDiskMountPoint());
+#endif
   system_mount_points_->RegisterFileSystem(
       "oem",
       storage::kFileSystemTypeRestrictedNativeLocal,
@@ -104,15 +117,17 @@ void FileSystemBackend::AddSystemMountPoints() {
 bool FileSystemBackend::CanHandleType(storage::FileSystemType type) const {
   switch (type) {
     case storage::kFileSystemTypeExternal:
+#if defined(OS_CHROMEOS)
     case storage::kFileSystemTypeDrive:
-    case storage::kFileSystemTypeRestrictedNativeLocal:
-    case storage::kFileSystemTypeNativeLocal:
     case storage::kFileSystemTypeNativeForPlatformApp:
     case storage::kFileSystemTypeDeviceMediaAsFileStorage:
     case storage::kFileSystemTypeProvided:
     case storage::kFileSystemTypeArcContent:
     case storage::kFileSystemTypeArcDocumentsProvider:
     case storage::kFileSystemTypeDriveFs:
+#endif
+    case storage::kFileSystemTypeRestrictedNativeLocal:
+    case storage::kFileSystemTypeNativeLocal:
       return true;
     default:
       return false;
@@ -150,6 +165,7 @@ void FileSystemBackend::ResolveURL(const storage::FileSystemURL& url,
 
   // For removable and archives, the file system root is the external mount
   // point plus the inner mount point.
+#if defined(OS_CHROMEOS)
   if (id == "archive" || id == "removable") {
     std::vector<std::string> components;
     url.virtual_path().GetComponents(&components);
@@ -188,6 +204,9 @@ void FileSystemBackend::ResolveURL(const storage::FileSystemURL& url,
   } else {
     name = id;
   }
+#else
+  name = id;
+#endif
 
   std::move(callback).Run(GURL(root_url), name, base::File::FILE_OK);
 }
@@ -276,13 +295,11 @@ std::vector<base::FilePath> FileSystemBackend::GetRootDirectories() const {
 storage::AsyncFileUtil* FileSystemBackend::GetAsyncFileUtil(
     storage::FileSystemType type) {
   switch (type) {
+#if defined(OS_CHROMEOS)
     case storage::kFileSystemTypeDrive:
       return drive_delegate_->GetAsyncFileUtil(type);
     case storage::kFileSystemTypeProvided:
       return file_system_provider_delegate_->GetAsyncFileUtil(type);
-    case storage::kFileSystemTypeNativeLocal:
-    case storage::kFileSystemTypeRestrictedNativeLocal:
-      return local_file_util_.get();
     case storage::kFileSystemTypeDeviceMediaAsFileStorage:
       return mtp_delegate_->GetAsyncFileUtil(type);
     case storage::kFileSystemTypeArcContent:
@@ -291,6 +308,10 @@ storage::AsyncFileUtil* FileSystemBackend::GetAsyncFileUtil(
       return arc_documents_provider_delegate_->GetAsyncFileUtil(type);
     case storage::kFileSystemTypeDriveFs:
       return drivefs_delegate_->GetAsyncFileUtil(type);
+#endif
+    case storage::kFileSystemTypeNativeLocal:
+    case storage::kFileSystemTypeRestrictedNativeLocal:
+      return local_file_util_.get();
     default:
       NOTREACHED();
   }
@@ -299,6 +320,7 @@ storage::AsyncFileUtil* FileSystemBackend::GetAsyncFileUtil(
 
 storage::WatcherManager* FileSystemBackend::GetWatcherManager(
     storage::FileSystemType type) {
+#if defined(OS_CHROMEOS)
   if (type == storage::kFileSystemTypeProvided)
     return file_system_provider_delegate_->GetWatcherManager(type);
 
@@ -310,6 +332,7 @@ storage::WatcherManager* FileSystemBackend::GetWatcherManager(
 
   if (type == storage::kFileSystemTypeArcDocumentsProvider)
     return arc_documents_provider_delegate_->GetWatcherManager(type);
+#endif
 
   // TODO(mtomasz): Add support for other backends.
   return NULL;
@@ -343,6 +366,7 @@ storage::FileSystemOperation* FileSystemBackend::CreateFileSystemOperation(
             context, MediaFileSystemBackend::MediaTaskRunner().get()));
   }
 
+#if defined(OS_CHROMEOS)
   DCHECK(url.type() == storage::kFileSystemTypeNativeLocal ||
          url.type() == storage::kFileSystemTypeRestrictedNativeLocal ||
          url.type() == storage::kFileSystemTypeDrive ||
@@ -350,6 +374,10 @@ storage::FileSystemOperation* FileSystemBackend::CreateFileSystemOperation(
          url.type() == storage::kFileSystemTypeArcContent ||
          url.type() == storage::kFileSystemTypeArcDocumentsProvider ||
          url.type() == storage::kFileSystemTypeDriveFs);
+#else
+  DCHECK(url.type() == storage::kFileSystemTypeNativeLocal ||
+         url.type() == storage::kFileSystemTypeRestrictedNativeLocal);
+#endif
   return storage::FileSystemOperation::Create(
       url, context,
       std::make_unique<storage::FileSystemOperationContext>(context));
@@ -357,25 +385,33 @@ storage::FileSystemOperation* FileSystemBackend::CreateFileSystemOperation(
 
 bool FileSystemBackend::SupportsStreaming(
     const storage::FileSystemURL& url) const {
+#if defined(OS_CHROMEOS)
   return url.type() == storage::kFileSystemTypeDrive ||
          url.type() == storage::kFileSystemTypeProvided ||
          url.type() == storage::kFileSystemTypeDeviceMediaAsFileStorage ||
          url.type() == storage::kFileSystemTypeArcContent ||
          url.type() == storage::kFileSystemTypeArcDocumentsProvider;
+#else
+  return false;
+#endif
 }
 
 bool FileSystemBackend::HasInplaceCopyImplementation(
     storage::FileSystemType type) const {
   switch (type) {
+#if defined(OS_CHROMEOS)
     case storage::kFileSystemTypeDrive:
     case storage::kFileSystemTypeProvided:
     case storage::kFileSystemTypeDeviceMediaAsFileStorage:
       return true;
+#endif
     case storage::kFileSystemTypeNativeLocal:
     case storage::kFileSystemTypeRestrictedNativeLocal:
+#if defined(OS_CHROMEOS)
     case storage::kFileSystemTypeArcContent:
     case storage::kFileSystemTypeArcDocumentsProvider:
     case storage::kFileSystemTypeDriveFs:
+#endif
       return false;
     default:
       NOTREACHED();
@@ -396,14 +432,13 @@ FileSystemBackend::CreateFileStreamReader(
     return std::unique_ptr<storage::FileStreamReader>();
 
   switch (url.type()) {
+#if defined(OS_CHROMEOS)
     case storage::kFileSystemTypeDrive:
       return drive_delegate_->CreateFileStreamReader(
           url, offset, max_bytes_to_read, expected_modification_time, context);
     case storage::kFileSystemTypeProvided:
       return file_system_provider_delegate_->CreateFileStreamReader(
           url, offset, max_bytes_to_read, expected_modification_time, context);
-    case storage::kFileSystemTypeNativeLocal:
-    case storage::kFileSystemTypeRestrictedNativeLocal:
     case storage::kFileSystemTypeDriveFs:
       return std::unique_ptr<storage::FileStreamReader>(
           storage::FileStreamReader::CreateForFileSystemFile(
@@ -417,6 +452,12 @@ FileSystemBackend::CreateFileStreamReader(
     case storage::kFileSystemTypeArcDocumentsProvider:
       return arc_documents_provider_delegate_->CreateFileStreamReader(
           url, offset, max_bytes_to_read, expected_modification_time, context);
+#endif
+    case storage::kFileSystemTypeNativeLocal:
+    case storage::kFileSystemTypeRestrictedNativeLocal:
+      return std::unique_ptr<storage::FileStreamReader>(
+          storage::FileStreamReader::CreateForFileSystemFile(
+              context, url, offset, expected_modification_time));
     default:
       NOTREACHED();
   }
@@ -434,23 +475,26 @@ FileSystemBackend::CreateFileStreamWriter(
     return std::unique_ptr<storage::FileStreamWriter>();
 
   switch (url.type()) {
+#if defined(OS_CHROMEOS)
     case storage::kFileSystemTypeDrive:
       return drive_delegate_->CreateFileStreamWriter(url, offset, context);
     case storage::kFileSystemTypeProvided:
       return file_system_provider_delegate_->CreateFileStreamWriter(
           url, offset, context);
-    case storage::kFileSystemTypeNativeLocal:
+    case storage::kFileSystemTypeDeviceMediaAsFileStorage:
+      return mtp_delegate_->CreateFileStreamWriter(url, offset, context);
+    case storage::kFileSystemTypeArcContent:
+    case storage::kFileSystemTypeArcDocumentsProvider:
+      return std::unique_ptr<storage::FileStreamWriter>();
     case storage::kFileSystemTypeDriveFs:
+#endif
+    case storage::kFileSystemTypeNativeLocal:
       return std::unique_ptr<storage::FileStreamWriter>(
           storage::FileStreamWriter::CreateForLocalFile(
               context->default_file_task_runner(), url.path(), offset,
               storage::FileStreamWriter::OPEN_EXISTING_FILE));
-    case storage::kFileSystemTypeDeviceMediaAsFileStorage:
-      return mtp_delegate_->CreateFileStreamWriter(url, offset, context);
     // Read only file systems.
     case storage::kFileSystemTypeRestrictedNativeLocal:
-    case storage::kFileSystemTypeArcContent:
-    case storage::kFileSystemTypeArcDocumentsProvider:
       return std::unique_ptr<storage::FileStreamWriter>();
     default:
       NOTREACHED();
@@ -473,6 +517,7 @@ void FileSystemBackend::GetRedirectURLForContents(
     return callback.Run(GURL());
 
   switch (url.type()) {
+#if defined(OS_CHROMEOS)
     case storage::kFileSystemTypeDrive:
       drive_delegate_->GetRedirectURLForContents(url, callback);
       return;
@@ -483,13 +528,16 @@ void FileSystemBackend::GetRedirectURLForContents(
     case storage::kFileSystemTypeDeviceMediaAsFileStorage:
       mtp_delegate_->GetRedirectURLForContents(url, callback);
       return;
-    case storage::kFileSystemTypeNativeLocal:
-    case storage::kFileSystemTypeRestrictedNativeLocal:
     case storage::kFileSystemTypeArcContent:
     case storage::kFileSystemTypeArcDocumentsProvider:
     case storage::kFileSystemTypeDriveFs:
       callback.Run(GURL());
       return;
+#endif
+    case storage::kFileSystemTypeNativeLocal:
+    case storage::kFileSystemTypeRestrictedNativeLocal:
+      callback.Run(GURL());
+      return;
     default:
       NOTREACHED();
   }
diff --git a/chrome/browser/fileapi/file_system_backend.h b/chrome/browser/fileapi/file_system_backend.h
index 2d02d51de3e31..ecfc85bb002b7 100644
--- a/chrome/browser/fileapi/file_system_backend.h
+++ b/chrome/browser/fileapi/file_system_backend.h
@@ -69,6 +69,7 @@ class FileSystemBackend : public storage::ExternalFileSystemBackend {
 
   // |system_mount_points| should outlive FileSystemBackend instance.
   FileSystemBackend(
+#if defined(OS_CHROMEOS)
       std::unique_ptr<FileSystemBackendDelegate> drive_delegate,
       std::unique_ptr<FileSystemBackendDelegate> file_system_provider_delegate,
       std::unique_ptr<FileSystemBackendDelegate> mtp_delegate,
@@ -76,6 +77,7 @@ class FileSystemBackend : public storage::ExternalFileSystemBackend {
       std::unique_ptr<FileSystemBackendDelegate>
           arc_documents_provider_delegate,
       std::unique_ptr<FileSystemBackendDelegate> drivefs_delegate,
+#endif
       scoped_refptr<storage::ExternalMountPoints> mount_points,
       storage::ExternalMountPoints* system_mount_points);
   ~FileSystemBackend() override;
@@ -146,6 +148,7 @@ class FileSystemBackend : public storage::ExternalFileSystemBackend {
   std::unique_ptr<FileAccessPermissions> file_access_permissions_;
   std::unique_ptr<storage::AsyncFileUtil> local_file_util_;
 
+#if defined(OS_CHROMEOS)
   // The delegate instance for the drive file system related operations.
   std::unique_ptr<FileSystemBackendDelegate> drive_delegate_;
 
@@ -160,6 +163,7 @@ class FileSystemBackend : public storage::ExternalFileSystemBackend {
 
   // The delegate instance for the ARC documents provider related operations.
   std::unique_ptr<FileSystemBackendDelegate> arc_documents_provider_delegate_;
+#endif
 
   // The delegate instance for the DriveFS file system related operations.
   std::unique_ptr<FileSystemBackendDelegate> drivefs_delegate_;
diff --git a/chrome/browser/fileapi/recent_model.cc b/chrome/browser/fileapi/recent_model.cc
index 56b761de0153e..1753ea915a50f 100644
--- a/chrome/browser/fileapi/recent_model.cc
+++ b/chrome/browser/fileapi/recent_model.cc
@@ -14,14 +14,17 @@
 #include "base/metrics/histogram_macros.h"
 #include "base/strings/stringprintf.h"
 #include "base/time/time.h"
-#include "chrome/browser/fileapi/recent_arc_media_source.h"
 #include "chrome/browser/fileapi/recent_download_source.h"
-#include "chrome/browser/fileapi/recent_drive_source.h"
 #include "chrome/browser/fileapi/recent_file.h"
 #include "chrome/browser/fileapi/recent_model_factory.h"
 #include "content/public/browser/browser_thread.h"
 #include "storage/browser/fileapi/file_system_context.h"
 
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/fileapi/recent_arc_media_source.h"
+#include "chrome/browser/fileapi/recent_drive_source.h"
+#endif
+
 using content::BrowserThread;
 
 namespace chromeos {
@@ -39,9 +42,11 @@ constexpr base::TimeDelta kCacheExpiration = base::TimeDelta::FromSeconds(10);
 std::vector<std::unique_ptr<RecentSource>> CreateDefaultSources(
     Profile* profile) {
   std::vector<std::unique_ptr<RecentSource>> sources;
-  sources.emplace_back(std::make_unique<RecentArcMediaSource>(profile));
   sources.emplace_back(std::make_unique<RecentDownloadSource>(profile));
+#if defined(OS_CHROMEOS)
+  sources.emplace_back(std::make_unique<RecentArcMediaSource>(profile));
   sources.emplace_back(std::make_unique<RecentDriveSource>(profile));
+#endif
   return sources;
 }
 
diff --git a/chrome/browser/fileapi/recent_model_factory.cc b/chrome/browser/fileapi/recent_model_factory.cc
index 5d8c9c453a928..98534389a314c 100644
--- a/chrome/browser/fileapi/recent_model_factory.cc
+++ b/chrome/browser/fileapi/recent_model_factory.cc
@@ -9,11 +9,13 @@
 #include <string>
 #include <utility>
 
-#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_root_map_factory.h"
 #include "chrome/browser/fileapi/recent_model.h"
 #include "chrome/browser/profiles/incognito_helpers.h"
 #include "chrome/browser/profiles/profile.h"
 #include "components/keyed_service/content/browser_context_dependency_manager.h"
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/chromeos/arc/fileapi/arc_documents_provider_root_map_factory.h"
+#endif
 
 namespace chromeos {
 
@@ -54,7 +56,9 @@ RecentModelFactory::RecentModelFactory()
     : BrowserContextKeyedServiceFactory(
           "RecentModel",
           BrowserContextDependencyManager::GetInstance()) {
+#if defined(OS_CHROMEOS)
   DependsOn(arc::ArcDocumentsProviderRootMapFactory::GetInstance());
+#endif
 }
 
 RecentModelFactory::~RecentModelFactory() = default;

From 7503d3bb48a35eb00876d3f1cb43deaecf88862b Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Tue, 14 Aug 2018 20:52:06 +0900
Subject: [PATCH 29/32] Add OS_CHROMEOS guard to chrome/browser/extensions/api

In order to share the extensions api code with Linux, it adds
OS_CHROMEOS guard for ChromeOS specific code.

chrome/browser/extensions/api/file_manager/ and
chrome/browser/extensions/api/file_system/ are updated.
---
 chrome/browser/extensions/BUILD.gn            |    4 +-
 .../file_manager/chromeos/private_api_misc.cc |    2 +-
 .../api/file_manager/event_router.h           |  237 +---
 .../api/file_manager/event_router_factory.cc  |   10 +-
 .../file_manager_private_api_functions.h      |   16 +-
 .../api/file_manager/private_api_base.cc      |    8 +
 .../file_manager/private_api_file_system.cc   | 1076 -----------------
 .../api/file_manager/private_api_strings.cc   |   24 +-
 .../api/file_manager/private_api_tasks.cc     |    5 +-
 .../api/file_manager/private_api_util.cc      |   32 +-
 .../chrome_file_system_delegate.cc            |   18 +-
 .../file_system/chrome_file_system_delegate.h |    8 +-
 .../api/file_system/consent_provider.cc       |   20 +-
 .../api/file_system/consent_provider.h        |    4 +
 .../api/file_system/file_system_delegate.h    |    2 +-
 15 files changed, 130 insertions(+), 1336 deletions(-)
 delete mode 100644 chrome/browser/extensions/api/file_manager/private_api_file_system.cc

diff --git a/chrome/browser/extensions/BUILD.gn b/chrome/browser/extensions/BUILD.gn
index a2073aff3527f..2eb3b30b790b7 100644
--- a/chrome/browser/extensions/BUILD.gn
+++ b/chrome/browser/extensions/BUILD.gn
@@ -170,6 +170,8 @@ jumbo_static_library("extensions") {
     "api/file_handlers/non_native_file_system_delegate_chromeos.h",
     "api/file_system/chrome_file_system_delegate.cc",
     "api/file_system/chrome_file_system_delegate.h",
+    "api/file_system/consent_provider.cc",
+    "api/file_system/consent_provider.h",
     "api/file_system/file_entry_picker.cc",
     "api/file_system/file_entry_picker.h",
     "api/font_settings/font_settings_api.cc",
@@ -974,8 +976,6 @@ jumbo_static_library("extensions") {
       "api/file_manager/private_api_tasks.h",
       "api/file_manager/private_api_util.cc",
       "api/file_manager/private_api_util.h",
-      "api/file_system/consent_provider.cc",
-      "api/file_system/consent_provider.h",
       "api/file_system/request_file_system_notification.cc",
       "api/file_system/request_file_system_notification.h",
       "api/file_system_provider/file_system_provider_api.cc",
diff --git a/chrome/browser/extensions/api/file_manager/chromeos/private_api_misc.cc b/chrome/browser/extensions/api/file_manager/chromeos/private_api_misc.cc
index 28097bb8f0206..00fef8f233471 100644
--- a/chrome/browser/extensions/api/file_manager/chromeos/private_api_misc.cc
+++ b/chrome/browser/extensions/api/file_manager/chromeos/private_api_misc.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "chrome/browser/extensions/api/file_manager/private_api_misc.h"
+#include "chrome/browser/extensions/api/file_manager/chromeos/private_api_misc.h"
 
 #include <stddef.h>
 
diff --git a/chrome/browser/extensions/api/file_manager/event_router.h b/chrome/browser/extensions/api/file_manager/event_router.h
index 1714bd0385bdd..289215724bee9 100644
--- a/chrome/browser/extensions/api/file_manager/event_router.h
+++ b/chrome/browser/extensions/api/file_manager/event_router.h
@@ -1,237 +1,12 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Copyright 2018 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
 #ifndef CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_EVENT_ROUTER_H_
 #define CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_EVENT_ROUTER_H_
-
-#include <stdint.h>
-
-#include <map>
-#include <memory>
-#include <string>
-#include <vector>
-
-#include "base/compiler_specific.h"
-#include "base/files/file_path_watcher.h"
-#include "base/macros.h"
-#include "chrome/browser/chromeos/drive/drive_integration_service.h"
-#include "chrome/browser/extensions/api/file_manager/device_event_router.h"
-#include "chrome/browser/extensions/api/file_manager/drivefs_event_router.h"
-#include "chrome/browser/extensions/api/file_manager/job_event_router.h"
-#include "chrome/browser/file_manager/file_watcher.h"
-#include "chrome/browser/file_manager/fileapi_util.h"
-#include "chrome/browser/file_manager/volume_manager.h"
-#include "chrome/browser/file_manager/volume_manager_observer.h"
-#include "chrome/common/extensions/api/file_manager_private.h"
-#include "chromeos/disks/disk_mount_manager.h"
-#include "chromeos/network/network_state_handler_observer.h"
-#include "chromeos/settings/timezone_settings.h"
-#include "components/arc/arc_service_manager.h"
-#include "components/arc/intent_helper/arc_intent_helper_observer.h"
-#include "components/drive/chromeos/file_system_observer.h"
-#include "components/drive/chromeos/sync_client.h"
-#include "components/drive/service/drive_service_interface.h"
-#include "components/keyed_service/core/keyed_service.h"
-#include "storage/browser/fileapi/file_system_operation.h"
-
-class PrefChangeRegistrar;
-class Profile;
-
-using file_manager::util::EntryDefinition;
-
-namespace chromeos {
-class NetworkState;
-}
-
-namespace drive {
-class FileChange;
-}
-
-namespace file_manager {
-
-// Monitors changes in disk mounts, network connection state and preferences
-// affecting File Manager. Dispatches appropriate File Browser events.
-class EventRouter : public KeyedService,
-                    public chromeos::NetworkStateHandlerObserver,
-                    public chromeos::system::TimezoneSettings::Observer,
-                    public drive::FileSystemObserver,
-                    public drive::DriveServiceObserver,
-                    public VolumeManagerObserver,
-                    public arc::ArcIntentHelperObserver {
- public:
-  typedef base::Callback<void(const base::FilePath& virtual_path,
-                              const drive::FileChange* list,
-                              bool got_error,
-                              const std::vector<std::string>& extension_ids)>
-      DispatchDirectoryChangeEventImplCallback;
-
-  explicit EventRouter(Profile* profile);
-  ~EventRouter() override;
-
-  // arc::ArcIntentHelperObserver overrides.
-  void OnIntentFiltersUpdated() override;
-
-  // KeyedService overrides.
-  void Shutdown() override;
-
-  typedef base::Callback<void(bool success)> BoolCallback;
-
-  // Adds a file watch at |local_path|, associated with |virtual_path|, for
-  // an extension with |extension_id|.
-  //
-  // |callback| will be called with true on success, or false on failure.
-  // |callback| must not be null.
-  //
-  // Obsolete. Used as fallback for files which backends do not implement the
-  // storage::WatcherManager interface.
-  void AddFileWatch(const base::FilePath& local_path,
-                    const base::FilePath& virtual_path,
-                    const std::string& extension_id,
-                    const BoolCallback& callback);
-
-  // Removes a file watch at |local_path| for an extension with |extension_id|.
-  //
-  // Obsolete. Used as fallback for files which backends do not implement the
-  // storage::WatcherManager interface.
-  void RemoveFileWatch(const base::FilePath& local_path,
-                       const std::string& extension_id);
-
-  // Called when a copy task is completed.
-  void OnCopyCompleted(
-      int copy_id, const GURL& source_url, const GURL& destination_url,
-      base::File::Error error);
-
-  // Called when a copy task progress is updated.
-  void OnCopyProgress(int copy_id,
-                      storage::FileSystemOperation::CopyProgressType type,
-                      const GURL& source_url,
-                      const GURL& destination_url,
-                      int64_t size);
-
-  // Called when a notification from a watcher manager arrives.
-  void OnWatcherManagerNotification(
-      const storage::FileSystemURL& file_system_url,
-      const std::string& extension_id,
-      storage::WatcherManager::ChangeType change_type);
-
-  // chromeos::NetworkStateHandlerObserver overrides.
-  void DefaultNetworkChanged(const chromeos::NetworkState* network) override;
-
-  // chromeos::system::TimezoneSettings::Observer overrides.
-  void TimezoneChanged(const icu::TimeZone& timezone) override;
-
-  // drive::DriveServiceObserver overrides.
-  void OnRefreshTokenInvalid() override;
-  void OnReadyToSendRequests() override;
-
-  // drive::FileSystemObserver overrides.
-  void OnDirectoryChanged(const base::FilePath& drive_path) override;
-  void OnFileChanged(const drive::FileChange& changed_files) override;
-  void OnDriveSyncError(drive::file_system::DriveSyncErrorType type,
-                        const base::FilePath& drive_path) override;
-
-  // VolumeManagerObserver overrides.
-  void OnDiskAdded(const chromeos::disks::Disk& disk, bool mounting) override;
-  void OnDiskRemoved(const chromeos::disks::Disk& disk) override;
-  void OnDeviceAdded(const std::string& device_path) override;
-  void OnDeviceRemoved(const std::string& device_path) override;
-  void OnVolumeMounted(chromeos::MountError error_code,
-                       const Volume& volume) override;
-  void OnVolumeUnmounted(chromeos::MountError error_code,
-                         const Volume& volume) override;
-  void OnFormatStarted(const std::string& device_path, bool success) override;
-  void OnFormatCompleted(const std::string& device_path, bool success) override;
-  void OnRenameStarted(const std::string& device_path, bool success) override;
-  void OnRenameCompleted(const std::string& device_path, bool success) override;
-  // Set custom dispatch directory change event implementation for testing.
-  void SetDispatchDirectoryChangeEventImplForTesting(
-      const DispatchDirectoryChangeEventImplCallback& callback);
-
-  // Returns a weak pointer for the event router.
-  base::WeakPtr<EventRouter> GetWeakPtr();
-
- private:
-  // Starts observing file system change events.
-  void ObserveEvents();
-
-  // Called when prefs related to file manager change.
-  void OnFileManagerPrefsChanged();
-
-  // Process file watch notifications.
-  void HandleFileWatchNotification(const drive::FileChange* list,
-                                   const base::FilePath& path,
-                                   bool got_error);
-
-  // Sends directory change event.
-  void DispatchDirectoryChangeEvent(
-      const base::FilePath& path,
-      const drive::FileChange* list,
-      bool got_error,
-      const std::vector<std::string>& extension_ids);
-
-  // Default implementation of DispatchDirectoryChangeEvent.
-  void DispatchDirectoryChangeEventImpl(
-      const base::FilePath& path,
-      const drive::FileChange* list,
-      bool got_error,
-      const std::vector<std::string>& extension_ids);
-
-  // Sends directory change event, after converting the file definition to entry
-  // definition.
-  void DispatchDirectoryChangeEventWithEntryDefinition(
-      const linked_ptr<drive::FileChange> list,
-      const std::string* extension_id,
-      bool watcher_error,
-      const EntryDefinition& entry_definition);
-
-  // Dispatches the mount completed event.
-  void DispatchMountCompletedEvent(
-      extensions::api::file_manager_private::MountCompletedEventType event_type,
-      chromeos::MountError error,
-      const Volume& volume);
-
-  // If needed, opens a file manager window for the removable device mounted at
-  // |mount_path|. Disk.mount_path() is empty, since it is being filled out
-  // after calling notifying observers by DiskMountManager.
-  void ShowRemovableDeviceInFileManager(VolumeType type,
-                                        const base::FilePath& mount_path);
-
-  // Sends onFileTransferUpdate event right now if |immediate| is set. Otherwise
-  // it refrains from sending for a short while, and after that it sends the
-  // most recently scheduled event once.
-  // The delay is for waiting subsequent 'added' events to come after the first
-  // one when multiple tasks are added. This way, we can avoid frequent UI
-  // update caused by differences between singular and plural cases.
-  void ScheduleDriveFileTransferEvent(const drive::JobInfo& job_info,
-                                      const std::string& status,
-                                      bool immediate);
-
-  // Sends the most recently scheduled onFileTransferUpdated event to
-  // extensions.
-  // This is used for implementing ScheduledDriveFileTransferEvent().
-  void SendDriveFileTransferEvent();
-
-  base::Time last_copy_progress_event_;
-
-  std::map<base::FilePath, std::unique_ptr<FileWatcher>> file_watchers_;
-  std::unique_ptr<PrefChangeRegistrar> pref_change_registrar_;
-  Profile* profile_;
-
-  std::unique_ptr<DeviceEventRouter> device_event_router_;
-  std::unique_ptr<JobEventRouter> job_event_router_;
-  std::unique_ptr<DriveFsEventRouter> drivefs_event_router_;
-
-  DispatchDirectoryChangeEventImplCallback
-      dispatch_directory_change_event_impl_;
-
-  // Note: This should remain the last member so it'll be destroyed and
-  // invalidate the weak pointers before any other members are destroyed.
-  base::WeakPtrFactory<EventRouter> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(EventRouter);
-};
-
-}  // namespace file_manager
-
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/extensions/api/file_manager/chromeos/event_router.h"
+#else
+#include "chrome/browser/extensions/api/file_manager/linux/event_router.h"
+#endif
 #endif  // CHROME_BROWSER_EXTENSIONS_API_FILE_MANAGER_EVENT_ROUTER_H_
diff --git a/chrome/browser/extensions/api/file_manager/event_router_factory.cc b/chrome/browser/extensions/api/file_manager/event_router_factory.cc
index 253997c1a549f..5f8ca54265b22 100644
--- a/chrome/browser/extensions/api/file_manager/event_router_factory.cc
+++ b/chrome/browser/extensions/api/file_manager/event_router_factory.cc
@@ -4,15 +4,17 @@
 
 #include "chrome/browser/extensions/api/file_manager/event_router_factory.h"
 
-#include "chrome/browser/chromeos/drive/drive_integration_service.h"
 #include "chrome/browser/extensions/api/file_manager/event_router.h"
 #include "chrome/browser/file_manager/volume_manager_factory.h"
 #include "chrome/browser/profiles/incognito_helpers.h"
 #include "chrome/browser/profiles/profile.h"
-#include "components/arc/intent_helper/arc_intent_helper_bridge.h"
 #include "components/keyed_service/content/browser_context_dependency_manager.h"
 #include "extensions/browser/extension_system_provider.h"
 #include "extensions/browser/extensions_browser_client.h"
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "components/arc/intent_helper/arc_intent_helper_bridge.h"
+#endif
 
 namespace file_manager {
 
@@ -31,11 +33,13 @@ EventRouterFactory::EventRouterFactory()
     : BrowserContextKeyedServiceFactory(
           "EventRouter",
           BrowserContextDependencyManager::GetInstance()) {
+#if defined(OS_CHROMEOS)
   DependsOn(drive::DriveIntegrationServiceFactory::GetInstance());
+  DependsOn(arc::ArcIntentHelperBridge::GetFactory());
+#endif
   DependsOn(
       extensions::ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
   DependsOn(VolumeManagerFactory::GetInstance());
-  DependsOn(arc::ArcIntentHelperBridge::GetFactory());
 }
 
 EventRouterFactory::~EventRouterFactory() = default;
diff --git a/chrome/browser/extensions/api/file_manager/file_manager_private_api_functions.h b/chrome/browser/extensions/api/file_manager/file_manager_private_api_functions.h
index 8dbfb8f6f7fab..4a4067a3f1e8d 100644
--- a/chrome/browser/extensions/api/file_manager/file_manager_private_api_functions.h
+++ b/chrome/browser/extensions/api/file_manager/file_manager_private_api_functions.h
@@ -9,11 +9,19 @@
 // API scheme compiler.
 // See also chrome/common/extensions/api/file_manager_private.idl.
 
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/extensions/api/file_manager/chromeos/private_api_drive.h"
+#include "chrome/browser/extensions/api/file_manager/chromeos/private_api_file_system.h"
+#include "chrome/browser/extensions/api/file_manager/chromeos/private_api_misc.h"
+#include "chrome/browser/extensions/api/file_manager/chromeos/private_api_mount.h"
+#else
+#include "chrome/browser/extensions/api/file_manager/linux/private_api_drive.h"
+#include "chrome/browser/extensions/api/file_manager/linux/private_api_file_system.h"
+#include "chrome/browser/extensions/api/file_manager/linux/private_api_misc.h"
+#include "chrome/browser/extensions/api/file_manager/linux/private_api_mount.h"
+#endif
+
 #include "chrome/browser/extensions/api/file_manager/private_api_dialog.h"
-#include "chrome/browser/extensions/api/file_manager/private_api_drive.h"
-#include "chrome/browser/extensions/api/file_manager/private_api_file_system.h"
-#include "chrome/browser/extensions/api/file_manager/private_api_misc.h"
-#include "chrome/browser/extensions/api/file_manager/private_api_mount.h"
 #include "chrome/browser/extensions/api/file_manager/private_api_strings.h"
 #include "chrome/browser/extensions/api/file_manager/private_api_tasks.h"
 
diff --git a/chrome/browser/extensions/api/file_manager/private_api_base.cc b/chrome/browser/extensions/api/file_manager/private_api_base.cc
index 71178d9e3943c..d0dd0c93cbaba 100644
--- a/chrome/browser/extensions/api/file_manager/private_api_base.cc
+++ b/chrome/browser/extensions/api/file_manager/private_api_base.cc
@@ -8,23 +8,30 @@
 
 #include "base/strings/string_number_conversions.h"
 #include "chrome/browser/extensions/api/file_manager/private_api_util.h"
+#if defined(OS_CHROMEOS)
 #include "components/drive/event_logger.h"
+#endif
 
 namespace extensions {
 namespace {
 
+#if defined(OS_CHROMEOS)
 const int kSlowOperationThresholdMs = 500;  // In ms.
+#endif
 
 }  // namespace
 
 LoggedAsyncExtensionFunction::LoggedAsyncExtensionFunction()
     : log_on_completion_(false) {
+#if defined(OS_CHROMEOS)
   start_time_  = base::Time::Now();
+#endif
 }
 
 LoggedAsyncExtensionFunction::~LoggedAsyncExtensionFunction() = default;
 
 void LoggedAsyncExtensionFunction::OnResponded() {
+#if defined(OS_CHROMEOS)
   drive::EventLogger* logger = file_manager::util::GetLogger(GetProfile());
   if (logger) {
     int64_t elapsed = (base::Time::Now() - start_time_).InMilliseconds();
@@ -40,6 +47,7 @@ void LoggedAsyncExtensionFunction::OnResponded() {
                   name(), request_id(), base::Int64ToString(elapsed).c_str());
     }
   }
+#endif
   ChromeAsyncExtensionFunction::OnResponded();
 }
 
diff --git a/chrome/browser/extensions/api/file_manager/private_api_file_system.cc b/chrome/browser/extensions/api/file_manager/private_api_file_system.cc
deleted file mode 100644
index 5993e22d03732..0000000000000
--- a/chrome/browser/extensions/api/file_manager/private_api_file_system.cc
+++ /dev/null
@@ -1,1076 +0,0 @@
-// Copyright 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/extensions/api/file_manager/private_api_file_system.h"
-
-#include <sys/statvfs.h>
-
-#include <algorithm>
-#include <utility>
-
-#include "base/files/file_util.h"
-#include "base/posix/eintr_wrapper.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/string_util.h"
-#include "base/sys_info.h"
-#include "base/task/post_task.h"
-#include "base/task_runner_util.h"
-#include "chrome/browser/browser_process.h"
-#include "chrome/browser/chromeos/drive/file_system_util.h"
-#include "chrome/browser/extensions/api/file_manager/event_router.h"
-#include "chrome/browser/extensions/api/file_manager/event_router_factory.h"
-#include "chrome/browser/extensions/api/file_manager/file_stream_md5_digester.h"
-#include "chrome/browser/extensions/api/file_manager/private_api_util.h"
-#include "chrome/browser/file_manager/fileapi_util.h"
-#include "chrome/browser/file_manager/path_util.h"
-#include "chrome/browser/file_manager/volume_manager.h"
-#include "chrome/browser/fileapi/file_system_backend.h"
-#include "chrome/browser/metrics/chrome_metrics_service_accessor.h"
-#include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/profiles/profile_manager.h"
-#include "chrome/common/extensions/api/file_manager_private.h"
-#include "chrome/common/extensions/api/file_manager_private_internal.h"
-#include "chromeos/chromeos_features.h"
-#include "chromeos/disks/disk_mount_manager.h"
-#include "components/drive/chromeos/file_system_interface.h"
-#include "components/drive/drive.pb.h"
-#include "components/drive/event_logger.h"
-#include "components/storage_monitor/storage_info.h"
-#include "components/storage_monitor/storage_monitor.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/child_process_security_policy.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/storage_partition.h"
-#include "content/public/common/url_constants.h"
-#include "extensions/browser/extension_util.h"
-#include "net/base/escape.h"
-#include "services/device/public/mojom/mtp_manager.mojom.h"
-#include "storage/browser/fileapi/file_stream_reader.h"
-#include "storage/browser/fileapi/file_system_context.h"
-#include "storage/browser/fileapi/file_system_file_util.h"
-#include "storage/browser/fileapi/file_system_operation_context.h"
-#include "storage/browser/fileapi/file_system_operation_runner.h"
-#include "storage/common/fileapi/file_system_info.h"
-#include "storage/common/fileapi/file_system_types.h"
-#include "storage/common/fileapi/file_system_util.h"
-#include "third_party/cros_system_api/constants/cryptohome.h"
-
-using chromeos::disks::DiskMountManager;
-using content::BrowserThread;
-using content::ChildProcessSecurityPolicy;
-using file_manager::util::EntryDefinition;
-using file_manager::util::FileDefinition;
-using storage::FileSystemURL;
-
-namespace extensions {
-namespace {
-
-const char kRootPath[] = "/";
-
-// Retrieves total and remaining available size on |mount_path|.
-void GetSizeStatsAsync(const base::FilePath& mount_path,
-                       uint64_t* total_size,
-                       uint64_t* remaining_size) {
-  int64_t size = base::SysInfo::AmountOfTotalDiskSpace(mount_path);
-  if (size >= 0)
-    *total_size = size;
-  size = base::SysInfo::AmountOfFreeDiskSpace(mount_path);
-  if (size >= 0)
-    *remaining_size = size;
-}
-
-// Retrieves the maximum file name length of the file system of |path|.
-// Returns 0 if it could not be queried.
-size_t GetFileNameMaxLengthAsync(const std::string& path) {
-  struct statvfs stat = {};
-  if (HANDLE_EINTR(statvfs(path.c_str(), &stat)) != 0) {
-    // The filesystem seems not supporting statvfs(). Assume it to be a commonly
-    // used bound 255, and log the failure.
-    LOG(ERROR) << "Cannot statvfs() the name length limit for: " << path;
-    return 255;
-  }
-  return stat.f_namemax;
-}
-
-// Returns EventRouter for the |profile_id| if available.
-file_manager::EventRouter* GetEventRouterByProfileId(void* profile_id) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  // |profile_id| needs to be checked with ProfileManager::IsValidProfile
-  // before using it.
-  if (!g_browser_process->profile_manager()->IsValidProfile(profile_id))
-    return nullptr;
-  Profile* profile = reinterpret_cast<Profile*>(profile_id);
-
-  return file_manager::EventRouterFactory::GetForProfile(profile);
-}
-
-// Notifies the copy progress to extensions via event router.
-void NotifyCopyProgress(
-    void* profile_id,
-    storage::FileSystemOperationRunner::OperationID operation_id,
-    storage::FileSystemOperation::CopyProgressType type,
-    const FileSystemURL& source_url,
-    const FileSystemURL& destination_url,
-    int64_t size) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  file_manager::EventRouter* event_router =
-      GetEventRouterByProfileId(profile_id);
-  if (event_router) {
-    event_router->OnCopyProgress(
-        operation_id, type,
-        source_url.ToGURL(), destination_url.ToGURL(), size);
-  }
-}
-
-// Callback invoked periodically on progress update of Copy().
-void OnCopyProgress(
-    void* profile_id,
-    storage::FileSystemOperationRunner::OperationID* operation_id,
-    storage::FileSystemOperation::CopyProgressType type,
-    const FileSystemURL& source_url,
-    const FileSystemURL& destination_url,
-    int64_t size) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  BrowserThread::PostTask(
-      BrowserThread::UI, FROM_HERE,
-      base::BindOnce(&NotifyCopyProgress, profile_id, *operation_id, type,
-                     source_url, destination_url, size));
-}
-
-// Notifies the copy completion to extensions via event router.
-void NotifyCopyCompletion(
-    void* profile_id,
-    storage::FileSystemOperationRunner::OperationID operation_id,
-    const FileSystemURL& source_url,
-    const FileSystemURL& destination_url,
-    base::File::Error error) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  file_manager::EventRouter* event_router =
-      GetEventRouterByProfileId(profile_id);
-  if (event_router)
-    event_router->OnCopyCompleted(
-        operation_id,
-        source_url.ToGURL(), destination_url.ToGURL(), error);
-}
-
-// Callback invoked upon completion of Copy() (regardless of succeeded or
-// failed).
-void OnCopyCompleted(
-    void* profile_id,
-    storage::FileSystemOperationRunner::OperationID* operation_id,
-    const FileSystemURL& source_url,
-    const FileSystemURL& destination_url,
-    base::File::Error error) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  BrowserThread::PostTask(
-      BrowserThread::UI, FROM_HERE,
-      base::BindOnce(&NotifyCopyCompletion, profile_id, *operation_id,
-                     source_url, destination_url, error));
-}
-
-// Starts the copy operation via FileSystemOperationRunner.
-storage::FileSystemOperationRunner::OperationID StartCopyOnIOThread(
-    void* profile_id,
-    scoped_refptr<storage::FileSystemContext> file_system_context,
-    const FileSystemURL& source_url,
-    const FileSystemURL& destination_url) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  // Note: |operation_id| is owned by the callback for
-  // FileSystemOperationRunner::Copy(). It is always called in the next message
-  // loop or later, so at least during this invocation it should alive.
-  //
-  // TODO(yawano): change ERROR_BEHAVIOR_ABORT to ERROR_BEHAVIOR_SKIP after
-  //     error messages of individual operations become appear in the Files app
-  //     UI.
-  storage::FileSystemOperationRunner::OperationID* operation_id =
-      new storage::FileSystemOperationRunner::OperationID;
-  *operation_id = file_system_context->operation_runner()->Copy(
-      source_url, destination_url,
-      storage::FileSystemOperation::OPTION_PRESERVE_LAST_MODIFIED,
-      storage::FileSystemOperation::ERROR_BEHAVIOR_ABORT,
-      base::Bind(&OnCopyProgress, profile_id, base::Unretained(operation_id)),
-      base::Bind(&OnCopyCompleted, profile_id, base::Owned(operation_id),
-                 source_url, destination_url));
-  return *operation_id;
-}
-
-void OnCopyCancelled(base::File::Error error) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  // We just ignore the status if the copy is actually cancelled or not,
-  // because failing cancellation means the operation is not running now.
-  DLOG_IF(WARNING, error != base::File::FILE_OK)
-      << "Failed to cancel copy: " << error;
-}
-
-// Cancels the running copy operation identified by |operation_id|.
-void CancelCopyOnIOThread(
-    scoped_refptr<storage::FileSystemContext> file_system_context,
-    storage::FileSystemOperationRunner::OperationID operation_id) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  file_system_context->operation_runner()->Cancel(
-      operation_id, base::Bind(&OnCopyCancelled));
-}
-
-// Converts a status code to a bool value and calls the |callback| with it.
-void StatusCallbackToResponseCallback(
-    const base::Callback<void(bool)>& callback,
-    base::File::Error result) {
-  callback.Run(result == base::File::FILE_OK);
-}
-
-// Calls a response callback (on the UI thread) with a file content hash
-// computed on the IO thread.
-void ComputeChecksumRespondOnUIThread(
-    const base::Callback<void(const std::string&)>& callback,
-    const std::string& hash) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
-                          base::BindOnce(callback, hash));
-}
-
-// Calls a response callback on the UI thread.
-void GetFileMetadataRespondOnUIThread(
-    const storage::FileSystemOperation::GetMetadataCallback& callback,
-    base::File::Error result,
-    const base::File::Info& file_info) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
-                          base::BindOnce(callback, result, file_info));
-}
-
-}  // namespace
-
-ExtensionFunction::ResponseAction
-FileManagerPrivateEnableExternalFileSchemeFunction::Run() {
-  ChildProcessSecurityPolicy::GetInstance()->GrantRequestScheme(
-      render_frame_host()->GetProcess()->GetID(), content::kExternalFileScheme);
-  return RespondNow(NoArguments());
-}
-
-FileManagerPrivateGrantAccessFunction::FileManagerPrivateGrantAccessFunction()
-    : chrome_details_(this) {
-}
-
-ExtensionFunction::ResponseAction FileManagerPrivateGrantAccessFunction::Run() {
-  using extensions::api::file_manager_private::GrantAccess::Params;
-  const std::unique_ptr<Params> params(Params::Create(*args_));
-  EXTENSION_FUNCTION_VALIDATE(params);
-
-  scoped_refptr<storage::FileSystemContext> file_system_context =
-      file_manager::util::GetFileSystemContextForRenderFrameHost(
-          chrome_details_.GetProfile(), render_frame_host());
-
-  storage::ExternalFileSystemBackend* const backend =
-      file_system_context->external_backend();
-  DCHECK(backend);
-
-  const std::vector<Profile*>& profiles =
-      g_browser_process->profile_manager()->GetLoadedProfiles();
-  for (auto* profile : profiles) {
-    if (profile->IsOffTheRecord())
-      continue;
-    const GURL site = util::GetSiteForExtensionId(extension_id(), profile);
-    storage::FileSystemContext* const context =
-        content::BrowserContext::GetStoragePartitionForSite(profile, site)
-            ->GetFileSystemContext();
-    for (const auto& url : params->entry_urls) {
-      const storage::FileSystemURL file_system_url =
-          context->CrackURL(GURL(url));
-      // Grant permissions only to valid urls backed by the external file system
-      // backend.
-      if (!file_system_url.is_valid() ||
-          file_system_url.mount_type() != storage::kFileSystemTypeExternal) {
-        continue;
-      }
-      backend->GrantFileAccessToExtension(extension_->id(),
-                                          file_system_url.virtual_path());
-      content::ChildProcessSecurityPolicy::GetInstance()
-          ->GrantCreateReadWriteFile(render_frame_host()->GetProcess()->GetID(),
-                                     file_system_url.path());
-    }
-  }
-  return RespondNow(NoArguments());
-}
-
-namespace {
-
-void PostResponseCallbackTaskToUIThread(
-    const FileWatchFunctionBase::ResponseCallback& callback,
-    bool success) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
-                          base::BindOnce(callback, success));
-}
-
-void PostNotificationCallbackTaskToUIThread(
-    const storage::WatcherManager::NotificationCallback& callback,
-    storage::WatcherManager::ChangeType type) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
-                          base::BindOnce(callback, type));
-}
-
-}  // namespace
-
-void FileWatchFunctionBase::Respond(bool success) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  SetResult(std::make_unique<base::Value>(success));
-  SendResponse(success);
-}
-
-bool FileWatchFunctionBase::RunAsync() {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  if (!render_frame_host() || !render_frame_host()->GetProcess())
-    return false;
-
-  // First param is url of a file to watch.
-  std::string url;
-  if (!args_->GetString(0, &url) || url.empty())
-    return false;
-
-  scoped_refptr<storage::FileSystemContext> file_system_context =
-      file_manager::util::GetFileSystemContextForRenderFrameHost(
-          GetProfile(), render_frame_host());
-
-  const FileSystemURL file_system_url =
-      file_system_context->CrackURL(GURL(url));
-  if (file_system_url.path().empty()) {
-    Respond(false);
-    return true;
-  }
-
-  file_manager::EventRouter* const event_router =
-      file_manager::EventRouterFactory::GetForProfile(GetProfile());
-
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&FileWatchFunctionBase::RunAsyncOnIOThread, this,
-                     file_system_context, file_system_url,
-                     event_router->GetWeakPtr()));
-  return true;
-}
-
-void FileWatchFunctionBase::RunAsyncOnIOThread(
-    scoped_refptr<storage::FileSystemContext> file_system_context,
-    const storage::FileSystemURL& file_system_url,
-    base::WeakPtr<file_manager::EventRouter> event_router) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  storage::WatcherManager* const watcher_manager =
-      file_system_context->GetWatcherManager(file_system_url.type());
-
-  if (!watcher_manager) {
-    BrowserThread::PostTask(
-        BrowserThread::UI, FROM_HERE,
-        base::BindOnce(
-            &FileWatchFunctionBase::PerformFallbackFileWatchOperationOnUIThread,
-            this, file_system_url, event_router));
-    return;
-  }
-
-  PerformFileWatchOperationOnIOThread(file_system_context, watcher_manager,
-                                      file_system_url, event_router);
-}
-
-void FileManagerPrivateInternalAddFileWatchFunction::
-    PerformFileWatchOperationOnIOThread(
-        scoped_refptr<storage::FileSystemContext> file_system_context,
-        storage::WatcherManager* watcher_manager,
-        const storage::FileSystemURL& file_system_url,
-        base::WeakPtr<file_manager::EventRouter> event_router) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  watcher_manager->AddWatcher(
-      file_system_url, false /* recursive */,
-      base::Bind(&StatusCallbackToResponseCallback,
-                 base::Bind(&PostResponseCallbackTaskToUIThread,
-                            base::Bind(&FileWatchFunctionBase::Respond, this))),
-      base::Bind(
-          &PostNotificationCallbackTaskToUIThread,
-          base::Bind(&file_manager::EventRouter::OnWatcherManagerNotification,
-                     event_router, file_system_url, extension_id())));
-}
-
-void FileManagerPrivateInternalAddFileWatchFunction::
-    PerformFallbackFileWatchOperationOnUIThread(
-        const storage::FileSystemURL& file_system_url,
-        base::WeakPtr<file_manager::EventRouter> event_router) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  DCHECK(event_router);
-
-  // Obsolete. Fallback code if storage::WatcherManager is not implemented.
-  event_router->AddFileWatch(file_system_url.path(),
-                             file_system_url.virtual_path(), extension_id(),
-                             base::Bind(&FileWatchFunctionBase::Respond, this));
-}
-
-void FileManagerPrivateInternalRemoveFileWatchFunction::
-    PerformFileWatchOperationOnIOThread(
-        scoped_refptr<storage::FileSystemContext> file_system_context,
-        storage::WatcherManager* watcher_manager,
-        const storage::FileSystemURL& file_system_url,
-        base::WeakPtr<file_manager::EventRouter> event_router) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  watcher_manager->RemoveWatcher(
-      file_system_url, false /* recursive */,
-      base::Bind(
-          &StatusCallbackToResponseCallback,
-          base::Bind(&PostResponseCallbackTaskToUIThread,
-                     base::Bind(&FileWatchFunctionBase::Respond, this))));
-}
-
-void FileManagerPrivateInternalRemoveFileWatchFunction::
-    PerformFallbackFileWatchOperationOnUIThread(
-        const storage::FileSystemURL& file_system_url,
-        base::WeakPtr<file_manager::EventRouter> event_router) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  DCHECK(event_router);
-
-  // Obsolete. Fallback code if storage::WatcherManager is not implemented.
-  event_router->RemoveFileWatch(file_system_url.path(), extension_id());
-  Respond(true);
-}
-
-bool FileManagerPrivateGetSizeStatsFunction::RunAsync() {
-  using extensions::api::file_manager_private::GetSizeStats::Params;
-  const std::unique_ptr<Params> params(Params::Create(*args_));
-  EXTENSION_FUNCTION_VALIDATE(params);
-
-  using file_manager::VolumeManager;
-  using file_manager::Volume;
-  VolumeManager* const volume_manager = VolumeManager::Get(GetProfile());
-  if (!volume_manager)
-    return false;
-
-  base::WeakPtr<Volume> volume =
-      volume_manager->FindVolumeById(params->volume_id);
-  if (!volume.get())
-    return false;
-
-  if (volume->type() == file_manager::VOLUME_TYPE_GOOGLE_DRIVE &&
-      !base::FeatureList::IsEnabled(chromeos::features::kDriveFs)) {
-    drive::FileSystemInterface* file_system =
-        drive::util::GetFileSystemByProfile(GetProfile());
-    if (!file_system) {
-      // |file_system| is NULL if Drive is disabled.
-      // If stats couldn't be gotten for drive, result should be left
-      // undefined. See comments in GetDriveAvailableSpaceCallback().
-      SendResponse(true);
-      return true;
-    }
-
-    file_system->GetAvailableSpace(base::Bind(
-        &FileManagerPrivateGetSizeStatsFunction::OnGetDriveAvailableSpace,
-        this));
-  } else if (volume->type() == file_manager::VOLUME_TYPE_MTP) {
-    // Resolve storage_name.
-    storage_monitor::StorageMonitor* storage_monitor =
-        storage_monitor::StorageMonitor::GetInstance();
-    storage_monitor::StorageInfo info;
-    storage_monitor->GetStorageInfoForPath(volume->mount_path(), &info);
-    std::string storage_name;
-    base::RemoveChars(info.location(), kRootPath, &storage_name);
-    DCHECK(!storage_name.empty());
-
-    // Get MTP StorageInfo.
-    auto* manager = storage_monitor->media_transfer_protocol_manager();
-    manager->GetStorageInfoFromDevice(
-        storage_name,
-        base::Bind(
-            &FileManagerPrivateGetSizeStatsFunction::OnGetMtpAvailableSpace,
-            this));
-  } else {
-    uint64_t* total_size = new uint64_t(0);
-    uint64_t* remaining_size = new uint64_t(0);
-    base::PostTaskWithTraitsAndReply(
-        FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_VISIBLE},
-        base::BindOnce(&GetSizeStatsAsync, volume->mount_path(), total_size,
-                       remaining_size),
-        base::BindOnce(&FileManagerPrivateGetSizeStatsFunction::OnGetSizeStats,
-                       this, base::Owned(total_size),
-                       base::Owned(remaining_size)));
-  }
-  return true;
-}
-
-void FileManagerPrivateGetSizeStatsFunction::OnGetDriveAvailableSpace(
-    drive::FileError error,
-    int64_t bytes_total,
-    int64_t bytes_used) {
-  if (error == drive::FILE_ERROR_OK) {
-    const uint64_t bytes_total_unsigned = bytes_total;
-    // bytes_used can be larger than bytes_total (over quota).
-    const uint64_t bytes_remaining_unsigned =
-        std::max(bytes_total - bytes_used, int64_t(0));
-    OnGetSizeStats(&bytes_total_unsigned, &bytes_remaining_unsigned);
-  } else {
-    // If stats couldn't be gotten for drive, result should be left undefined.
-    SendResponse(true);
-  }
-}
-
-void FileManagerPrivateGetSizeStatsFunction::OnGetMtpAvailableSpace(
-    device::mojom::MtpStorageInfoPtr mtp_storage_info,
-    const bool error) {
-  if (error) {
-    // If stats couldn't be gotten from MTP volume, result should be left
-    // undefined same as we do for Drive.
-    SendResponse(true);
-    return;
-  }
-
-  const uint64_t max_capacity = mtp_storage_info->max_capacity;
-  const uint64_t free_space_in_bytes = mtp_storage_info->free_space_in_bytes;
-  OnGetSizeStats(&max_capacity, &free_space_in_bytes);
-}
-
-void FileManagerPrivateGetSizeStatsFunction::OnGetSizeStats(
-    const uint64_t* total_size,
-    const uint64_t* remaining_size) {
-  std::unique_ptr<base::DictionaryValue> sizes(new base::DictionaryValue());
-
-  sizes->SetDouble("totalSize", static_cast<double>(*total_size));
-  sizes->SetDouble("remainingSize", static_cast<double>(*remaining_size));
-
-  SetResult(std::move(sizes));
-  SendResponse(true);
-}
-
-bool FileManagerPrivateInternalValidatePathNameLengthFunction::RunAsync() {
-  using extensions::api::file_manager_private_internal::ValidatePathNameLength::
-      Params;
-  const std::unique_ptr<Params> params(Params::Create(*args_));
-  EXTENSION_FUNCTION_VALIDATE(params);
-
-  scoped_refptr<storage::FileSystemContext> file_system_context =
-      file_manager::util::GetFileSystemContextForRenderFrameHost(
-          GetProfile(), render_frame_host());
-
-  const storage::FileSystemURL file_system_url(
-      file_system_context->CrackURL(GURL(params->parent_url)));
-  if (!chromeos::FileSystemBackend::CanHandleURL(file_system_url))
-    return false;
-
-  // No explicit limit on the length of Drive file names.
-  if (file_system_url.type() == storage::kFileSystemTypeDrive) {
-    SetResult(std::make_unique<base::Value>(true));
-    SendResponse(true);
-    return true;
-  }
-
-  base::PostTaskWithTraitsAndReplyWithResult(
-      FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_BLOCKING},
-      base::Bind(&GetFileNameMaxLengthAsync,
-                 file_system_url.path().AsUTF8Unsafe()),
-      base::Bind(&FileManagerPrivateInternalValidatePathNameLengthFunction::
-                     OnFilePathLimitRetrieved,
-                 this, params->name.size()));
-  return true;
-}
-
-void FileManagerPrivateInternalValidatePathNameLengthFunction::
-    OnFilePathLimitRetrieved(size_t current_length, size_t max_length) {
-  SetResult(std::make_unique<base::Value>(current_length <= max_length));
-  SendResponse(true);
-}
-
-bool FileManagerPrivateFormatVolumeFunction::RunAsync() {
-  using extensions::api::file_manager_private::FormatVolume::Params;
-  const std::unique_ptr<Params> params(Params::Create(*args_));
-  EXTENSION_FUNCTION_VALIDATE(params);
-
-  using file_manager::VolumeManager;
-  using file_manager::Volume;
-  VolumeManager* const volume_manager = VolumeManager::Get(GetProfile());
-  if (!volume_manager)
-    return false;
-
-  base::WeakPtr<Volume> volume =
-      volume_manager->FindVolumeById(params->volume_id);
-  if (!volume)
-    return false;
-
-  DiskMountManager::GetInstance()->FormatMountedDevice(
-      volume->mount_path().AsUTF8Unsafe());
-  SendResponse(true);
-  return true;
-}
-
-bool FileManagerPrivateRenameVolumeFunction::RunAsync() {
-  using extensions::api::file_manager_private::RenameVolume::Params;
-  const std::unique_ptr<Params> params(Params::Create(*args_));
-  EXTENSION_FUNCTION_VALIDATE(params);
-
-  using file_manager::VolumeManager;
-  using file_manager::Volume;
-  VolumeManager* const volume_manager = VolumeManager::Get(GetProfile());
-  if (!volume_manager)
-    return false;
-
-  base::WeakPtr<Volume> volume =
-      volume_manager->FindVolumeById(params->volume_id);
-  if (!volume)
-    return false;
-
-  DiskMountManager::GetInstance()->RenameMountedDevice(
-      volume->mount_path().AsUTF8Unsafe(), params->new_name);
-  SendResponse(true);
-  return true;
-}
-
-// Obtains file size of URL.
-void GetFileMetadataOnIOThread(
-    scoped_refptr<storage::FileSystemContext> file_system_context,
-    const FileSystemURL& url,
-    int fields,
-    const storage::FileSystemOperation::GetMetadataCallback& callback) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  file_system_context->operation_runner()->GetMetadata(
-      url, fields, base::Bind(&GetFileMetadataRespondOnUIThread, callback));
-}
-
-// Checks if the available space of the |path| is enough for required |bytes|.
-bool CheckLocalDiskSpace(const base::FilePath& path, int64_t bytes) {
-  return bytes <= base::SysInfo::AmountOfFreeDiskSpace(path) -
-                      cryptohome::kMinFreeSpaceInBytes;
-}
-
-bool FileManagerPrivateInternalStartCopyFunction::RunAsync() {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  using extensions::api::file_manager_private_internal::StartCopy::Params;
-  const std::unique_ptr<Params> params(Params::Create(*args_));
-  EXTENSION_FUNCTION_VALIDATE(params);
-
-  if (params->url.empty() || params->parent_url.empty() ||
-      params->new_name.empty()) {
-    // Error code in format of DOMError.name.
-    SetError("EncodingError");
-    return false;
-  }
-
-  scoped_refptr<storage::FileSystemContext> file_system_context =
-      file_manager::util::GetFileSystemContextForRenderFrameHost(
-          GetProfile(), render_frame_host());
-
-  // |parent| may have a trailing slash if it is a root directory.
-  std::string destination_url_string = params->parent_url;
-  if (destination_url_string.back() != '/')
-    destination_url_string += '/';
-  destination_url_string += net::EscapePath(params->new_name);
-
-  source_url_ = file_system_context->CrackURL(GURL(params->url));
-  destination_url_ =
-      file_system_context->CrackURL(GURL(destination_url_string));
-
-  if (!source_url_.is_valid() || !destination_url_.is_valid()) {
-    // Error code in format of DOMError.name.
-    SetError("EncodingError");
-    return false;
-  }
-
-  // Check if the destination directory is downloads. If so, secure available
-  // spece by freeing drive caches.
-  if (destination_url_.filesystem_id() ==
-      file_manager::util::GetDownloadsMountPointName(GetProfile())) {
-    return BrowserThread::PostTask(
-        BrowserThread::IO, FROM_HERE,
-        base::BindOnce(&GetFileMetadataOnIOThread, file_system_context,
-                       source_url_,
-                       storage::FileSystemOperation::GET_METADATA_FIELD_SIZE,
-                       base::Bind(&FileManagerPrivateInternalStartCopyFunction::
-                                      RunAfterGetFileMetadata,
-                                  this)));
-  }
-
-  return BrowserThread::PostTask(
-      BrowserThread::UI, FROM_HERE,
-      base::BindOnce(
-          &FileManagerPrivateInternalStartCopyFunction::RunAfterFreeDiskSpace,
-          this, true));
-}
-
-void FileManagerPrivateInternalStartCopyFunction::RunAfterGetFileMetadata(
-    base::File::Error result,
-    const base::File::Info& file_info) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  if (result != base::File::FILE_OK) {
-    SetError("NotFoundError");
-    SendResponse(false);
-    return;
-  }
-
-  drive::FileSystemInterface* const drive_file_system =
-      drive::util::GetFileSystemByProfile(GetProfile());
-  if (drive_file_system) {
-    drive_file_system->FreeDiskSpaceIfNeededFor(
-        file_info.size,
-        base::Bind(
-            &FileManagerPrivateInternalStartCopyFunction::RunAfterFreeDiskSpace,
-            this));
-  } else {
-    base::PostTaskWithTraitsAndReplyWithResult(
-        FROM_HERE, {base::MayBlock()},
-        base::BindOnce(
-            &CheckLocalDiskSpace,
-            file_manager::util::GetDownloadsFolderForProfile(GetProfile()),
-            file_info.size),
-        base::BindOnce(
-            &FileManagerPrivateInternalStartCopyFunction::RunAfterFreeDiskSpace,
-            this));
-  }
-}
-
-void FileManagerPrivateInternalStartCopyFunction::RunAfterFreeDiskSpace(
-    bool available) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  if (!available) {
-    SetError("QuotaExceededError");
-    SendResponse(false);
-    return;
-  }
-
-  scoped_refptr<storage::FileSystemContext> file_system_context =
-      file_manager::util::GetFileSystemContextForRenderFrameHost(
-          GetProfile(), render_frame_host());
-  const bool result = BrowserThread::PostTaskAndReplyWithResult(
-      BrowserThread::IO, FROM_HERE,
-      base::Bind(&StartCopyOnIOThread, GetProfile(), file_system_context,
-                 source_url_, destination_url_),
-      base::Bind(
-          &FileManagerPrivateInternalStartCopyFunction::RunAfterStartCopy,
-          this));
-  if (!result)
-    SendResponse(false);
-}
-
-void FileManagerPrivateInternalStartCopyFunction::RunAfterStartCopy(
-    int operation_id) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  SetResult(std::make_unique<base::Value>(operation_id));
-  SendResponse(true);
-}
-
-bool FileManagerPrivateCancelCopyFunction::RunAsync() {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  using extensions::api::file_manager_private::CancelCopy::Params;
-  const std::unique_ptr<Params> params(Params::Create(*args_));
-  EXTENSION_FUNCTION_VALIDATE(params);
-
-  scoped_refptr<storage::FileSystemContext> file_system_context =
-      file_manager::util::GetFileSystemContextForRenderFrameHost(
-          GetProfile(), render_frame_host());
-
-  // We don't much take care about the result of cancellation.
-  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
-                          base::BindOnce(&CancelCopyOnIOThread,
-                                         file_system_context, params->copy_id));
-  SendResponse(true);
-  return true;
-}
-
-bool FileManagerPrivateInternalResolveIsolatedEntriesFunction::RunAsync() {
-  using extensions::api::file_manager_private_internal::ResolveIsolatedEntries::
-      Params;
-  const std::unique_ptr<Params> params(Params::Create(*args_));
-  EXTENSION_FUNCTION_VALIDATE(params);
-
-  scoped_refptr<storage::FileSystemContext> file_system_context =
-      file_manager::util::GetFileSystemContextForRenderFrameHost(
-          GetProfile(), render_frame_host());
-  DCHECK(file_system_context.get());
-
-  const storage::ExternalFileSystemBackend* external_backend =
-      file_system_context->external_backend();
-  DCHECK(external_backend);
-
-  file_manager::util::FileDefinitionList file_definition_list;
-  for (size_t i = 0; i < params->urls.size(); ++i) {
-    const FileSystemURL file_system_url =
-        file_system_context->CrackURL(GURL(params->urls[i]));
-    DCHECK(external_backend->CanHandleType(file_system_url.type()))
-        << "GURL: " << file_system_url.ToGURL()
-        << "type: " << file_system_url.type();
-    FileDefinition file_definition;
-    const bool result =
-        file_manager::util::ConvertAbsoluteFilePathToRelativeFileSystemPath(
-            GetProfile(), extension_->id(), file_system_url.path(),
-            &file_definition.virtual_path);
-    if (!result)
-      continue;
-    // The API only supports isolated files. It still works for directories,
-    // as the value is ignored for existing entries.
-    file_definition.is_directory = false;
-    file_definition_list.push_back(file_definition);
-  }
-
-  file_manager::util::ConvertFileDefinitionListToEntryDefinitionList(
-      GetProfile(),
-      extension_->id(),
-      file_definition_list,  // Safe, since copied internally.
-      base::Bind(
-          &FileManagerPrivateInternalResolveIsolatedEntriesFunction::
-              RunAsyncAfterConvertFileDefinitionListToEntryDefinitionList,
-          this));
-  return true;
-}
-
-void FileManagerPrivateInternalResolveIsolatedEntriesFunction::
-    RunAsyncAfterConvertFileDefinitionListToEntryDefinitionList(
-        std::unique_ptr<file_manager::util::EntryDefinitionList>
-            entry_definition_list) {
-  using extensions::api::file_manager_private_internal::EntryDescription;
-  std::vector<EntryDescription> entries;
-
-  for (const auto& definition : *entry_definition_list) {
-    if (definition.error != base::File::FILE_OK)
-      continue;
-    EntryDescription entry;
-    entry.file_system_name = definition.file_system_name;
-    entry.file_system_root = definition.file_system_root_url;
-    entry.file_full_path = "/" + definition.full_path.AsUTF8Unsafe();
-    entry.file_is_directory = definition.is_directory;
-    entries.push_back(std::move(entry));
-  }
-
-  results_ = extensions::api::file_manager_private_internal::
-      ResolveIsolatedEntries::Results::Create(entries);
-  SendResponse(true);
-}
-
-FileManagerPrivateInternalComputeChecksumFunction::
-    FileManagerPrivateInternalComputeChecksumFunction()
-    : digester_(new drive::util::FileStreamMd5Digester()) {
-}
-
-FileManagerPrivateInternalComputeChecksumFunction::
-    ~FileManagerPrivateInternalComputeChecksumFunction() = default;
-
-bool FileManagerPrivateInternalComputeChecksumFunction::RunAsync() {
-  using extensions::api::file_manager_private_internal::ComputeChecksum::Params;
-  using drive::util::FileStreamMd5Digester;
-  const std::unique_ptr<Params> params(Params::Create(*args_));
-  EXTENSION_FUNCTION_VALIDATE(params);
-
-  if (params->url.empty()) {
-    SetError("File URL must be provided.");
-    return false;
-  }
-
-  scoped_refptr<storage::FileSystemContext> file_system_context =
-      file_manager::util::GetFileSystemContextForRenderFrameHost(
-          GetProfile(), render_frame_host());
-
-  FileSystemURL file_system_url(
-      file_system_context->CrackURL(GURL(params->url)));
-  if (!file_system_url.is_valid()) {
-    SetError("File URL was invalid");
-    return false;
-  }
-
-  std::unique_ptr<storage::FileStreamReader> reader =
-      file_system_context->CreateFileStreamReader(
-          file_system_url, 0, storage::kMaximumLength, base::Time());
-
-  FileStreamMd5Digester::ResultCallback result_callback = base::Bind(
-      &ComputeChecksumRespondOnUIThread,
-      base::Bind(&FileManagerPrivateInternalComputeChecksumFunction::Respond,
-                 this));
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&FileStreamMd5Digester::GetMd5Digest,
-                     base::Unretained(digester_.get()), base::Passed(&reader),
-                     result_callback));
-
-  return true;
-}
-
-void FileManagerPrivateInternalComputeChecksumFunction::Respond(
-    const std::string& hash) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  SetResult(std::make_unique<base::Value>(hash));
-  SendResponse(true);
-}
-
-bool FileManagerPrivateSearchFilesByHashesFunction::RunAsync() {
-  using api::file_manager_private::SearchFilesByHashes::Params;
-  const std::unique_ptr<Params> params(Params::Create(*args_));
-  EXTENSION_FUNCTION_VALIDATE(params);
-
-  // TODO(hirono): Check the volume ID and fail the function for volumes other
-  // than Drive.
-
-  drive::EventLogger* const logger =
-      file_manager::util::GetLogger(GetProfile());
-  if (logger) {
-    logger->Log(logging::LOG_INFO,
-                "%s[%d] called. (volume id: %s, number of hashes: %zd)", name(),
-                request_id(), params->volume_id.c_str(),
-                params->hash_list.size());
-  }
-  set_log_on_completion(true);
-
-  drive::FileSystemInterface* const file_system =
-      drive::util::GetFileSystemByProfile(GetProfile());
-  if (!file_system) {
-    // |file_system| is NULL if Drive is disabled.
-    return false;
-  }
-
-  std::set<std::string> hashes(params->hash_list.begin(),
-                               params->hash_list.end());
-  file_system->SearchByHashes(
-      hashes,
-      base::Bind(
-          &FileManagerPrivateSearchFilesByHashesFunction::OnSearchByHashes,
-          this, hashes));
-  return true;
-}
-
-void FileManagerPrivateSearchFilesByHashesFunction::OnSearchByHashes(
-    const std::set<std::string>& hashes,
-    drive::FileError error,
-    const std::vector<drive::HashAndFilePath>& search_results) {
-  if (error != drive::FileError::FILE_ERROR_OK) {
-    SendResponse(false);
-    return;
-  }
-
-  std::unique_ptr<base::DictionaryValue> result(new base::DictionaryValue());
-  for (const auto& hash : hashes) {
-    result->SetWithoutPathExpansion(hash, std::make_unique<base::ListValue>());
-  }
-
-  for (const auto& hashAndPath : search_results) {
-    DCHECK(result->HasKey(hashAndPath.hash));
-    base::ListValue* list;
-    result->GetListWithoutPathExpansion(hashAndPath.hash, &list);
-    list->AppendString(
-        file_manager::util::ConvertDrivePathToFileSystemUrl(
-            GetProfile(), hashAndPath.path, extension_id()).spec());
-  }
-  SetResult(std::move(result));
-  SendResponse(true);
-}
-
-ExtensionFunction::ResponseAction
-FileManagerPrivateIsUMAEnabledFunction::Run() {
-  return RespondNow(OneArgument(std::make_unique<base::Value>(
-      ChromeMetricsServiceAccessor::IsMetricsAndCrashReportingEnabled())));
-}
-
-FileManagerPrivateInternalSetEntryTagFunction::
-    FileManagerPrivateInternalSetEntryTagFunction()
-    : chrome_details_(this) {}
-
-ExtensionFunction::ResponseAction
-FileManagerPrivateInternalSetEntryTagFunction::Run() {
-  using extensions::api::file_manager_private_internal::SetEntryTag::Params;
-  const std::unique_ptr<Params> params(Params::Create(*args_));
-  EXTENSION_FUNCTION_VALIDATE(params);
-
-  const base::FilePath local_path = file_manager::util::GetLocalPathFromURL(
-      render_frame_host(), chrome_details_.GetProfile(), GURL(params->url));
-  const base::FilePath drive_path = drive::util::ExtractDrivePath(local_path);
-  if (drive_path.empty())
-    return RespondNow(Error("Only Drive files and directories are supported."));
-
-  drive::FileSystemInterface* const file_system =
-      drive::util::GetFileSystemByProfile(chrome_details_.GetProfile());
-  // |file_system| is NULL if Drive is disabled.
-  if (!file_system)
-    return RespondNow(Error("Drive is disabled."));
-
-  google_apis::drive::Property::Visibility visibility;
-  switch (params->visibility) {
-    case extensions::api::file_manager_private::ENTRY_TAG_VISIBILITY_PRIVATE:
-      visibility = google_apis::drive::Property::VISIBILITY_PRIVATE;
-      break;
-    case extensions::api::file_manager_private::ENTRY_TAG_VISIBILITY_PUBLIC:
-      visibility = google_apis::drive::Property::VISIBILITY_PUBLIC;
-      break;
-    default:
-      NOTREACHED();
-      return RespondNow(Error("Invalid visibility."));
-      break;
-  }
-
-  file_system->SetProperty(
-      drive_path, visibility, params->key, params->value,
-      base::Bind(&FileManagerPrivateInternalSetEntryTagFunction::
-                     OnSetEntryPropertyCompleted,
-                 this));
-  return RespondLater();
-}
-
-void FileManagerPrivateInternalSetEntryTagFunction::OnSetEntryPropertyCompleted(
-    drive::FileError result) {
-  Respond(result == drive::FILE_ERROR_OK ? NoArguments()
-                                         : Error("Failed to set a tag."));
-}
-
-bool FileManagerPrivateInternalGetDirectorySizeFunction::RunAsync() {
-  using extensions::api::file_manager_private_internal::GetDirectorySize::
-      Params;
-  const std::unique_ptr<Params> params(Params::Create(*args_));
-  EXTENSION_FUNCTION_VALIDATE(params);
-
-  if (params->url.empty()) {
-    SetError("File URL must be provided.");
-    return false;
-  }
-
-  scoped_refptr<storage::FileSystemContext> file_system_context =
-      file_manager::util::GetFileSystemContextForRenderFrameHost(
-          GetProfile(), render_frame_host());
-  const storage::FileSystemURL file_system_url(
-      file_system_context->CrackURL(GURL(params->url)));
-  if (!chromeos::FileSystemBackend::CanHandleURL(file_system_url)) {
-    SetError("FileSystemBackend failed to handle the entry's url.");
-    return false;
-  }
-  if (file_system_url.type() != storage::kFileSystemTypeNativeLocal) {
-    SetError("Only local directories are supported.");
-    return false;
-  }
-
-  const base::FilePath root_path = file_manager::util::GetLocalPathFromURL(
-      render_frame_host(), GetProfile(), GURL(params->url));
-  if (root_path.empty()) {
-    SetError("Failed to get a local path from the entry's url.");
-    return false;
-  }
-
-  base::PostTaskWithTraitsAndReplyWithResult(
-      FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_VISIBLE},
-      base::Bind(&base::ComputeDirectorySize, root_path),
-      base::Bind(&FileManagerPrivateInternalGetDirectorySizeFunction::
-                     OnDirectorySizeRetrieved,
-                 this));
-  return true;
-}
-
-void FileManagerPrivateInternalGetDirectorySizeFunction::
-    OnDirectorySizeRetrieved(int64_t size) {
-  SetResult(std::make_unique<base::Value>(static_cast<double>(size)));
-  SendResponse(true);
-}
-
-}  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_manager/private_api_strings.cc b/chrome/browser/extensions/api/file_manager/private_api_strings.cc
index 6b1f9197eabb2..753df7b346471 100644
--- a/chrome/browser/extensions/api/file_manager/private_api_strings.cc
+++ b/chrome/browser/extensions/api/file_manager/private_api_strings.cc
@@ -103,6 +103,7 @@ void AddStringsForFileTypes(base::DictionaryValue* dict) {
   SET_STRING("ZIP_ARCHIVE_FILE_TYPE", IDS_FILE_BROWSER_ZIP_ARCHIVE_FILE_TYPE);
 }
 
+#if defined(OS_CHROMEOS)
 void AddStringsForDrive(base::DictionaryValue* dict) {
   SET_STRING("DRIVE_BUY_MORE_SPACE", IDS_FILE_BROWSER_DRIVE_BUY_MORE_SPACE);
   SET_STRING("DRIVE_BUY_MORE_SPACE_LINK",
@@ -359,6 +360,7 @@ void AddStringsForCrUiMenuItemShortcuts(base::DictionaryValue* dict) {
   SET_STRING("SHORTCUT_SHIFT", IDS_FILE_BROWSER_SHORTCUT_SHIFT);
   SET_STRING("SHORTCUT_SPACE", IDS_FILE_BROWSER_SHORTCUT_SPACE);
 }
+#endif
 
 void AddStringsForFileErrors(base::DictionaryValue* dict) {
   SET_STRING("FILE_ERROR_GENERIC", IDS_FILE_BROWSER_FILE_ERROR_GENERIC);
@@ -377,6 +379,7 @@ void AddStringsForFileErrors(base::DictionaryValue* dict) {
   SET_STRING("FILE_ERROR_SECURITY", IDS_FILE_BROWSER_FILE_ERROR_SECURITY);
 }
 
+#if defined(OS_CHROMEOS)
 void AddStringsForZipArchiver(base::DictionaryValue* dict) {
   SET_STRING("ZIP_ARCHIVER_DESCRIPTION", IDS_ZIP_ARCHIVER_DESCRIPTION);
   SET_STRING("ZIP_ARCHIVER_MOUNTING_MESSAGE",
@@ -403,6 +406,7 @@ void AddStringsForZipArchiver(base::DictionaryValue* dict) {
   SET_STRING("ZIP_ARCHIVER_PASSPHRASE_TITLE",
              IDS_ZIP_ARCHIVER_PASSPHRASE_TITLE);
 }
+#endif
 
 }  // namespace
 
@@ -417,17 +421,19 @@ FileManagerPrivateGetStringsFunction::~FileManagerPrivateGetStringsFunction() =
 ExtensionFunction::ResponseAction FileManagerPrivateGetStringsFunction::Run() {
   std::unique_ptr<base::DictionaryValue> dict(new base::DictionaryValue());
 
+#if defined(OS_CHROMEOS)
   AddStringsForDrive(dict.get());
   AddStringsForMediaView(dict.get());
-  AddStringsForFileTypes(dict.get());
   AddStringsForGallery(dict.get());
   AddStringsForMediaPlayer(dict.get());
   AddStringsForVideoPlayer(dict.get());
   AddStringsForAudioPlayer(dict.get());
   AddStringsForCloudImport(dict.get());
   AddStringsForCrUiMenuItemShortcuts(dict.get());
-  AddStringsForFileErrors(dict.get());
   AddStringsForZipArchiver(dict.get());
+#endif
+  AddStringsForFileTypes(dict.get());
+  AddStringsForFileErrors(dict.get());
 
   SET_STRING("ADD_NEW_SERVICES_BUTTON_LABEL",
              IDS_FILE_BROWSER_ADD_NEW_SERVICES_BUTTON_LABEL);
@@ -478,6 +484,7 @@ ExtensionFunction::ResponseAction FileManagerPrivateGetStringsFunction::Run() {
   SET_STRING("DELETE_ITEMS_REMAINING", IDS_FILE_BROWSER_DELETE_ITEMS_REMAINING);
   SET_STRING("DELETE_PROGRESS_SUMMARY",
              IDS_FILE_BROWSER_DELETE_PROGRESS_SUMMARY);
+#if defined(OS_CHROMEOS)
   SET_STRING("DEVICE_HARD_UNPLUGGED_MESSAGE",
              IDS_DEVICE_HARD_UNPLUGGED_MESSAGE);
   SET_STRING("DEVICE_HARD_UNPLUGGED_TITLE", IDS_DEVICE_HARD_UNPLUGGED_TITLE);
@@ -492,6 +499,7 @@ ExtensionFunction::ResponseAction FileManagerPrivateGetStringsFunction::Run() {
              IDS_FILE_BROWSER_DROP_TARGET_DEVICE_WRITE_PROTECTED);
   SET_STRING("DEVICE_ACCESS_RESTRICTED",
              IDS_FILE_BROWSER_DROP_TARGET_ACCESS_RESTRICTED);
+#endif
   SET_STRING("DIRECTORY_ALREADY_EXISTS",
              IDS_FILE_BROWSER_DIRECTORY_ALREADY_EXISTS);
   SET_STRING("DISABLED_MOBILE_SYNC_NOTIFICATION_ENABLE_BUTTON",
@@ -512,8 +520,10 @@ ExtensionFunction::ResponseAction FileManagerPrivateGetStringsFunction::Run() {
              IDS_FILE_BROWSER_ERROR_INVALID_CHARACTER);
   SET_STRING("ERROR_EXTERNAL_DRIVE_INVALID_CHARACTER",
              IDS_FILE_BROWSER_ERROR_EXTERNAL_DRIVE_INVALID_CHARACTER);
+#if defined(OS_CHROMEOS)
   SET_STRING("ERROR_INVALID_WALLPAPER",
              IDS_WALLPAPER_MANAGER_INVALID_WALLPAPER);
+#endif
   SET_STRING("ERROR_LINUX_FILES_CONNECTION",
              IDS_FILE_BROWSER_ERROR_LINUX_FILES_CONNECTION);
   SET_STRING("ERROR_LONG_NAME", IDS_FILE_BROWSER_ERROR_LONG_NAME);
@@ -525,11 +535,14 @@ ExtensionFunction::ResponseAction FileManagerPrivateGetStringsFunction::Run() {
   SET_STRING("ERROR_RENAMING", IDS_FILE_BROWSER_ERROR_RENAMING);
   SET_STRING("ERROR_RESERVED_NAME", IDS_FILE_BROWSER_ERROR_RESERVED_NAME);
   SET_STRING("ERROR_WHITESPACE_NAME", IDS_FILE_BROWSER_ERROR_WHITESPACE_NAME);
+#if defined(OS_CHROMEOS)
   SET_STRING("EXTERNAL_STORAGE_DISABLED_MESSAGE",
              IDS_EXTERNAL_STORAGE_DISABLED_MESSAGE);
+#endif
   SET_STRING("FAILED_SPACE_INFO", IDS_FILE_BROWSER_FAILED_SPACE_INFO);
   SET_STRING("FILENAME_LABEL", IDS_FILE_BROWSER_FILENAME_LABEL);
   SET_STRING("FILE_ALREADY_EXISTS", IDS_FILE_BROWSER_FILE_ALREADY_EXISTS);
+#if defined(OS_CHROMEOS)
   SET_STRING("FORMATTING_FINISHED_FAILURE_MESSAGE",
              IDS_FORMATTING_FINISHED_FAILURE_MESSAGE);
   SET_STRING("FORMATTING_FINISHED_SUCCESS_MESSAGE",
@@ -547,6 +560,7 @@ ExtensionFunction::ResponseAction FileManagerPrivateGetStringsFunction::Run() {
              IDS_RENAMING_OF_DEVICE_FINISHED_FAILURE_MESSAGE);
   SET_STRING("RENAMING_OF_DEVICE_FAILED_TITLE",
              IDS_RENAMING_OF_DEVICE_FAILED_TITLE);
+#endif
   SET_STRING("FORMAT_DEVICE_BUTTON_LABEL",
              IDS_FILE_BROWSER_FORMAT_DEVICE_BUTTON_LABEL);
   SET_STRING("SHARE_BUTTON_TOOLTIP", IDS_FILE_BROWSER_SHARE_BUTTON_TOOLTIP);
@@ -630,10 +644,12 @@ ExtensionFunction::ResponseAction FileManagerPrivateGetStringsFunction::Run() {
   SET_STRING("MOVE_TARGET_EXISTS_ERROR",
              IDS_FILE_BROWSER_MOVE_TARGET_EXISTS_ERROR);
   SET_STRING("MOVE_UNEXPECTED_ERROR", IDS_FILE_BROWSER_MOVE_UNEXPECTED_ERROR);
+#if defined(OS_CHROMEOS)
   SET_STRING("MULTIPART_DEVICE_UNSUPPORTED_DEFAULT_MESSAGE",
              IDS_MULTIPART_DEVICE_UNSUPPORTED_DEFAULT_MESSAGE);
   SET_STRING("MULTIPART_DEVICE_UNSUPPORTED_MESSAGE",
              IDS_MULTIPART_DEVICE_UNSUPPORTED_MESSAGE);
+#endif
   SET_STRING("MULTI_PROFILE_SHARE_DIALOG_MESSAGE",
              IDS_FILE_BROWSER_MULTI_PROFILE_SHARE_DIALOG_MESSAGE);
   SET_STRING("MULTI_PROFILE_SHARE_DIALOG_MESSAGE_PLURAL",
@@ -693,6 +709,7 @@ ExtensionFunction::ResponseAction FileManagerPrivateGetStringsFunction::Run() {
   SET_STRING("QUICK_VIEW_TOGGLE_METADATA_BOX_BUTTON_LABEL",
              IDS_FILE_BROWSER_QUICK_VIEW_TOGGLE_METADATA_BOX_BUTTON_LABEL);
   SET_STRING("REFRESH_BUTTON_LABEL", IDS_FILE_BROWSER_REFRESH_BUTTON_LABEL);
+#if defined(OS_CHROMEOS)
   SET_STRING("REMOVABLE_DEVICE_DETECTION_TITLE",
              IDS_REMOVABLE_DEVICE_DETECTION_TITLE);
   SET_STRING("REMOVABLE_DEVICE_IMPORT_BUTTON_LABEL",
@@ -705,6 +722,7 @@ ExtensionFunction::ResponseAction FileManagerPrivateGetStringsFunction::Run() {
              IDS_REMOVABLE_DEVICE_NAVIGATION_MESSAGE);
   SET_STRING("REMOVABLE_DEVICE_NAVIGATION_MESSAGE_READONLY_POLICY",
              IDS_REMOVABLE_DEVICE_NAVIGATION_MESSAGE_READONLY_POLICY);
+#endif
   SET_STRING("REMOVE_FOLDER_SHORTCUT_BUTTON_LABEL",
              IDS_FILE_BROWSER_REMOVE_FOLDER_SHORTCUT_BUTTON_LABEL);
   SET_STRING("RENAME_BUTTON_LABEL", IDS_FILE_BROWSER_RENAME_BUTTON_LABEL);
@@ -815,8 +833,10 @@ ExtensionFunction::ResponseAction FileManagerPrivateGetStringsFunction::Run() {
                    file_manager::util::ShouldBeOpenedWithPlugin(
                        Profile::FromBrowserContext(browser_context()),
                        FILE_PATH_LITERAL(".swf")));
+#if defined(OS_CHROMEOS)
   dict->SetString("CHROMEOS_RELEASE_BOARD",
                   base::SysInfo::GetLsbReleaseBoard());
+#endif
   dict->SetString(
       "DOWNLOADS_LOW_SPACE_WARNING_HELP_URL",
       base::StringPrintf(kHelpURLFormat, kDownloadsLowSpaceWarningHelpNumber));
diff --git a/chrome/browser/extensions/api/file_manager/private_api_tasks.cc b/chrome/browser/extensions/api/file_manager/private_api_tasks.cc
index 9b00157054b5d..602921142b80a 100644
--- a/chrome/browser/extensions/api/file_manager/private_api_tasks.cc
+++ b/chrome/browser/extensions/api/file_manager/private_api_tasks.cc
@@ -186,7 +186,10 @@ void FileManagerPrivateInternalGetFileTasksFunction::
   }
 
   file_manager::file_tasks::FindAllTypesOfTasks(
-      GetProfile(), drive::util::GetDriveAppRegistryByProfile(GetProfile()),
+      GetProfile(),
+#if defined(OS_CHROMEOS)
+      drive::util::GetDriveAppRegistryByProfile(GetProfile()),
+#endif
       entries, urls_,
       base::Bind(
           &FileManagerPrivateInternalGetFileTasksFunction::OnFileTasksListed,
diff --git a/chrome/browser/extensions/api/file_manager/private_api_util.cc b/chrome/browser/extensions/api/file_manager/private_api_util.cc
index eb6b72ef74f6c..73c9a224c7934 100644
--- a/chrome/browser/extensions/api/file_manager/private_api_util.cc
+++ b/chrome/browser/extensions/api/file_manager/private_api_util.cc
@@ -14,8 +14,6 @@
 #include "base/macros.h"
 #include "base/single_thread_task_runner.h"
 #include "base/threading/thread_task_runner_handle.h"
-#include "chrome/browser/chromeos/drive/drive_integration_service.h"
-#include "chrome/browser/chromeos/drive/file_system_util.h"
 #include "chrome/browser/file_manager/app_id.h"
 #include "chrome/browser/file_manager/fileapi_util.h"
 #include "chrome/browser/file_manager/filesystem_api_util.h"
@@ -25,13 +23,17 @@
 #include "chrome/browser/fileapi/file_system_backend.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/common/extensions/api/file_manager_private.h"
-#include "components/drive/chromeos/file_system_interface.h"
-#include "components/drive/drive.pb.h"
-#include "components/drive/file_errors.h"
 #include "content/public/browser/child_process_security_policy.h"
 #include "storage/browser/fileapi/file_system_context.h"
 #include "storage/browser/fileapi/file_system_url.h"
 #include "ui/shell_dialogs/selected_file_info.h"
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/chromeos/drive/drive_integration_service.h"
+#include "chrome/browser/chromeos/drive/file_system_util.h"
+#include "components/drive/chromeos/file_system_interface.h"
+#include "components/drive/drive.pb.h"
+#include "components/drive/file_errors.h"
+#endif
 
 namespace file_manager_private = extensions::api::file_manager_private;
 
@@ -47,6 +49,7 @@ struct GetSelectedFileInfoParams {
   std::vector<ui::SelectedFileInfo> selected_files;
 };
 
+#if defined(OS_CHROMEOS)
 // The callback type for GetFileNativeLocalPathFor{Opening,Saving}. It receives
 // the resolved local path when successful, and receives empty path for failure.
 typedef base::Callback<void(const base::FilePath&)> LocalPathCallback;
@@ -111,6 +114,7 @@ void ContinueGetSelectedFileInfo(
     Profile* profile,
     std::unique_ptr<GetSelectedFileInfoParams> params,
     const base::FilePath& local_file_path);
+#endif
 
 // Part of GetSelectedFileInfo().
 void GetSelectedFileInfoInternal(
@@ -131,6 +135,7 @@ void GetSelectedFileInfoInternal(
           // Pass empty local path.
           params->selected_files.emplace_back(file_path, base::FilePath());
           break;
+#if defined(OS_CHROMEOS)
         case NEED_LOCAL_PATH_FOR_OPENING:
           GetFileNativeLocalPathForOpening(
               profile,
@@ -147,6 +152,9 @@ void GetSelectedFileInfoInternal(
                          profile,
                          base::Passed(&params)));
           return;  // Remaining work is done in ContinueGetSelectedFileInfo.
+#endif
+        default:
+          break;
       }
     } else {
       params->selected_files.emplace_back(file_path, file_path);
@@ -155,6 +163,7 @@ void GetSelectedFileInfoInternal(
   params->callback.Run(params->selected_files);
 }
 
+#if defined(OS_CHROMEOS)
 // Part of GetSelectedFileInfo().
 void ContinueGetSelectedFileInfo(
     Profile* profile,
@@ -169,9 +178,11 @@ void ContinueGetSelectedFileInfo(
   params->selected_files.emplace_back(file_path, local_path);
   GetSelectedFileInfoInternal(profile, std::move(params));
 }
+#endif
 
 }  // namespace
 
+#if defined(OS_CHROMEOS)
 void FillIconSet(file_manager_private::IconSet* output,
                  const chromeos::file_system_provider::IconSet& input) {
   DCHECK(output);
@@ -185,6 +196,7 @@ void FillIconSet(file_manager_private::IconSet* output,
         input.GetIcon(IconSet::IconSize::SIZE_32x32).spec());
   }
 }
+#endif
 
 void VolumeToVolumeMetadata(
     Profile* profile,
@@ -226,6 +238,7 @@ void VolumeToVolumeMetadata(
   volume_metadata->configurable = volume.configurable();
   volume_metadata->watchable = volume.watchable();
 
+#if defined(OS_CHROMEOS)
   if (volume.type() == VOLUME_TYPE_PROVIDED) {
     volume_metadata->provider_id =
         std::make_unique<std::string>(volume.provider_id().ToString());
@@ -234,6 +247,7 @@ void VolumeToVolumeMetadata(
   }
 
   FillIconSet(&volume_metadata->icon_set, volume.icon_set());
+#endif
 
   volume_metadata->volume_label =
       std::make_unique<std::string>(volume.volume_label());
@@ -282,6 +296,7 @@ void VolumeToVolumeMetadata(
       break;
   }
 
+#if defined(OS_CHROMEOS)
   // Fill device_type iff the volume is removable partition.
   if (volume.type() == VOLUME_TYPE_REMOVABLE_DISK_PARTITION) {
     switch (volume.device_type()) {
@@ -312,10 +327,12 @@ void VolumeToVolumeMetadata(
     volume_metadata->device_type =
         file_manager_private::DEVICE_TYPE_NONE;
   }
+#endif
 
   volume_metadata->is_read_only = volume.is_read_only();
   volume_metadata->has_media = volume.has_media();
 
+#if defined(OS_CHROMEOS)
   switch (volume.mount_condition()) {
     case chromeos::disks::MOUNT_CONDITION_NONE:
       volume_metadata->mount_condition =
@@ -342,6 +359,7 @@ void VolumeToVolumeMetadata(
     case MOUNT_CONTEXT_UNKNOWN:
       break;
   }
+#endif
 }
 
 base::FilePath GetLocalPathFromURL(content::RenderFrameHost* render_frame_host,
@@ -392,7 +410,9 @@ void GetSelectedFileInfo(content::RenderFrameHost* render_frame_host,
 void SetupProfileFileAccessPermissions(int render_view_process_id,
                                        Profile* profile) {
   const base::FilePath paths[] = {
+#if defined(OS_CHROMEOS)
     drive::util::GetDriveMountPointPath(profile),
+#endif
     util::GetDownloadsFolderForProfile(profile),
   };
   for (size_t i = 0; i < arraysize(paths); ++i) {
@@ -401,11 +421,13 @@ void SetupProfileFileAccessPermissions(int render_view_process_id,
   }
 }
 
+#if defined(OS_CHROMEOS)
 drive::EventLogger* GetLogger(Profile* profile) {
   drive::DriveIntegrationService* service =
       drive::DriveIntegrationServiceFactory::FindForProfile(profile);
   return service ? service->event_logger() : nullptr;
 }
+#endif
 
 }  // namespace util
 }  // namespace file_manager
diff --git a/chrome/browser/extensions/api/file_system/chrome_file_system_delegate.cc b/chrome/browser/extensions/api/file_system/chrome_file_system_delegate.cc
index e2db9cd71c515..c8da2639d6c2c 100644
--- a/chrome/browser/extensions/api/file_system/chrome_file_system_delegate.cc
+++ b/chrome/browser/extensions/api/file_system/chrome_file_system_delegate.cc
@@ -47,7 +47,7 @@
 #include "base/mac/foundation_util.h"
 #endif
 
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
 #include "chrome/browser/extensions/api/file_system/consent_provider.h"
 #include "chrome/browser/file_manager/volume_manager.h"
 #include "extensions/browser/event_router.h"
@@ -60,7 +60,7 @@ namespace extensions {
 
 namespace file_system = api::file_system;
 
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
 using file_system_api::ConsentProvider;
 using file_system_api::ConsentProviderDelegate;
 
@@ -75,6 +75,7 @@ const char kRequiresFileSystemWriteError[] =
 const char kSecurityError[] = "Security error.";
 const char kVolumeNotFoundError[] = "Volume not found.";
 
+#if defined(OS_CHROMEOS)
 // Fills a list of volumes mounted in the system.
 bool GetVolumeListForExtension(
     const std::vector<base::WeakPtr<file_manager::Volume>>& available_volumes,
@@ -200,6 +201,7 @@ void OnConsentReceived(
 
   success_callback.Run(file_system_id, register_name);
 }
+#endif
 
 }  // namespace
 
@@ -219,6 +221,7 @@ void DispatchVolumeListChangeEvent(content::BrowserContext* browser_context) {
       Profile::FromBrowserContext(browser_context));
   ConsentProvider consent_provider(&consent_provider_delegate);
 
+#if defined(OS_CHROMEOS)
   const std::vector<base::WeakPtr<file_manager::Volume>> volume_list =
       file_manager::VolumeManager::Get(browser_context)->GetVolumeList();
 
@@ -236,10 +239,11 @@ void DispatchVolumeListChangeEvent(content::BrowserContext* browser_context) {
             file_system::OnVolumeListChanged::kEventName,
             file_system::OnVolumeListChanged::Create(event_args)));
   }
+#endif
 }
 
 }  // namespace file_system_api
-#endif  // defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) && defined(USE_OZONE)
 
 ChromeFileSystemDelegate::ChromeFileSystemDelegate() {}
 
@@ -314,7 +318,7 @@ int ChromeFileSystemDelegate::GetDescriptionIdForAcceptType(
   return 0;
 }
 
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
 FileSystemDelegate::GrantVolumesMode
 ChromeFileSystemDelegate::GetGrantVolumesMode(
     content::BrowserContext* browser_context,
@@ -336,6 +340,7 @@ void ChromeFileSystemDelegate::RequestFileSystem(
     bool writable,
     const FileSystemCallback& success_callback,
     const ErrorCallback& error_callback) {
+#if defined(OS_CHROMEOS)
   ConsentProviderDelegate consent_provider_delegate(
       Profile::FromBrowserContext(browser_context));
   ConsentProvider consent_provider(&consent_provider_delegate);
@@ -391,6 +396,7 @@ void ChromeFileSystemDelegate::RequestFileSystem(
 
   consent_provider.RequestConsent(extension, requester->render_frame_host(),
                                   volume, writable, callback);
+#endif
 }
 
 void ChromeFileSystemDelegate::GetVolumeList(
@@ -398,6 +404,7 @@ void ChromeFileSystemDelegate::GetVolumeList(
     const Extension& extension,
     const VolumeListCallback& success_callback,
     const ErrorCallback& error_callback) {
+#if defined(OS_CHROMEOS)
   ConsentProviderDelegate consent_provider_delegate(
       Profile::FromBrowserContext(browser_context));
   ConsentProvider consent_provider(&consent_provider_delegate);
@@ -409,9 +416,10 @@ void ChromeFileSystemDelegate::GetVolumeList(
   GetVolumeListForExtension(volume_list, &consent_provider, extension,
                             &result_volume_list);
   success_callback.Run(result_volume_list);
+#endif
 }
 
-#endif  // defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) && defined(USE_OZONE)
 
 SavedFilesServiceInterface* ChromeFileSystemDelegate::GetSavedFilesService(
     content::BrowserContext* browser_context) {
diff --git a/chrome/browser/extensions/api/file_system/chrome_file_system_delegate.h b/chrome/browser/extensions/api/file_system/chrome_file_system_delegate.h
index 9dd8784bcebba..1537079458dfb 100644
--- a/chrome/browser/extensions/api/file_system/chrome_file_system_delegate.h
+++ b/chrome/browser/extensions/api/file_system/chrome_file_system_delegate.h
@@ -14,7 +14,7 @@
 
 namespace extensions {
 
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
 namespace file_system_api {
 
 // Dispatches an event about a mounted or unmounted volume in the system to
@@ -22,7 +22,7 @@ namespace file_system_api {
 void DispatchVolumeListChangeEvent(content::BrowserContext* browser_context);
 
 }  // namespace file_system_api
-#endif  // defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) && defined(USE_OZONE)
 
 class ChromeFileSystemDelegate : public FileSystemDelegate {
  public:
@@ -44,7 +44,7 @@ class ChromeFileSystemDelegate : public FileSystemDelegate {
                                        const base::Closure& on_accept,
                                        const base::Closure& on_cancel) override;
   int GetDescriptionIdForAcceptType(const std::string& accept_type) override;
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
   FileSystemDelegate::GrantVolumesMode GetGrantVolumesMode(
       content::BrowserContext* browser_context,
       content::RenderFrameHost* render_frame_host,
@@ -60,7 +60,7 @@ class ChromeFileSystemDelegate : public FileSystemDelegate {
                      const Extension& extension,
                      const VolumeListCallback& success_callback,
                      const ErrorCallback& error_callback) override;
-#endif  // defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) && defined(USE_OZONE)
   SavedFilesServiceInterface* GetSavedFilesService(
       content::BrowserContext* browser_context) override;
 
diff --git a/chrome/browser/extensions/api/file_system/consent_provider.cc b/chrome/browser/extensions/api/file_system/consent_provider.cc
index 698cbab114675..e090f809c45c8 100644
--- a/chrome/browser/extensions/api/file_system/consent_provider.cc
+++ b/chrome/browser/extensions/api/file_system/consent_provider.cc
@@ -10,7 +10,6 @@
 #include "base/bind.h"
 #include "base/logging.h"
 #include "base/threading/thread_task_runner_handle.h"
-#include "chrome/browser/chromeos/app_mode/kiosk_app_manager.h"
 #include "chrome/browser/extensions/api/file_system/request_file_system_notification.h"
 #include "chrome/browser/file_manager/app_id.h"
 #include "chrome/browser/file_manager/volume_manager.h"
@@ -24,6 +23,9 @@
 #include "extensions/common/api/file_system.h"
 #include "extensions/common/manifest_handlers/kiosk_mode_info.h"
 #include "extensions/common/permissions/permissions_data.h"
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/chromeos/app_mode/kiosk_app_manager.h"
+#endif
 
 namespace extensions {
 
@@ -52,6 +54,7 @@ content::WebContents* GetWebContentsForAppId(Profile* profile,
   return app_window ? app_window->web_contents() : nullptr;
 }
 
+#if defined(OS_CHROMEOS)
 // Converts the clicked button to a consent result and passes it via the
 // |callback|.
 void DialogResultToConsent(
@@ -69,6 +72,7 @@ void DialogResultToConsent(
       break;
   }
 }
+#endif
 
 }  // namespace
 
@@ -108,6 +112,7 @@ void ConsentProvider::RequestConsent(
     return;
   }
 
+#if defined(OS_CHROMEOS)
   // If auto-launched kiosk app, then no need to ask user either, but show the
   // notification.
   if (delegate_->IsAutoLaunched(extension)) {
@@ -125,6 +130,7 @@ void ConsentProvider::RequestConsent(
                           base::Bind(&DialogResultToConsent, callback));
     return;
   }
+#endif
 
   NOTREACHED() << "Cannot request consent for non-grantable extensions.";
 }
@@ -134,9 +140,13 @@ FileSystemDelegate::GrantVolumesMode ConsentProvider::GetGrantVolumesMode(
   const bool is_whitelisted_component =
       delegate_->IsWhitelistedComponent(extension);
 
+#if defined(OS_CHROMEOS)
   const bool is_running_in_kiosk_session =
       KioskModeInfo::IsKioskOnly(&extension) &&
       user_manager::UserManager::Get()->IsLoggedInAsKioskApp();
+#else
+  const bool is_running_in_kiosk_session = false;
+#endif
 
   if (is_whitelisted_component || is_running_in_kiosk_session) {
     return FileSystemDelegate::kGrantAll;
@@ -219,13 +229,16 @@ void ConsentProviderDelegate::ShowDialog(
     return;
   }
 
+#if defined(OS_CHROMEOS)
   RequestFileSystemDialogView::ShowDialog(
       web_contents, extension.name(),
       (volume->volume_label().empty() ? volume->volume_id()
                                       : volume->volume_label()),
       writable, callback);
+#endif
 }
 
+#if defined(OS_CHROMEOS)
 void ConsentProviderDelegate::ShowNotification(
     const Extension& extension,
     const base::WeakPtr<file_manager::Volume>& volume,
@@ -233,11 +246,16 @@ void ConsentProviderDelegate::ShowNotification(
   ShowNotificationForAutoGrantedRequestFileSystem(profile_, extension, volume,
                                                   writable);
 }
+#endif
 
 bool ConsentProviderDelegate::IsAutoLaunched(const Extension& extension) {
+#if defined(OS_CHROMEOS)
   chromeos::KioskAppManager::App app_info;
   return chromeos::KioskAppManager::Get()->GetApp(extension.id(), &app_info) &&
          app_info.was_auto_launched_with_zero_delay;
+#else
+  return false;
+#endif
 }
 
 bool ConsentProviderDelegate::IsWhitelistedComponent(
diff --git a/chrome/browser/extensions/api/file_system/consent_provider.h b/chrome/browser/extensions/api/file_system/consent_provider.h
index 0a7934ea59af0..a9152fd7cee95 100644
--- a/chrome/browser/extensions/api/file_system/consent_provider.h
+++ b/chrome/browser/extensions/api/file_system/consent_provider.h
@@ -52,11 +52,13 @@ class ConsentProvider {
                             bool writable,
                             const ShowDialogCallback& callback) = 0;
 
+#if defined(OS_CHROMEOS)
     // Shows a notification about permissions automatically granted access.
     virtual void ShowNotification(
         const Extension& extension,
         const base::WeakPtr<file_manager::Volume>& volume,
         bool writable) = 0;
+#endif
 
     // Checks if the extension was launched in auto-launch kiosk mode.
     virtual bool IsAutoLaunched(const Extension& extension) = 0;
@@ -116,9 +118,11 @@ class ConsentProviderDelegate : public ConsentProvider::DelegateInterface {
                   bool writable,
                   const file_system_api::ConsentProvider::ShowDialogCallback&
                       callback) override;
+#if defined(OS_CHROMEOS)
   void ShowNotification(const Extension& extension,
                         const base::WeakPtr<file_manager::Volume>& volume,
                         bool writable) override;
+#endif
   bool IsAutoLaunched(const Extension& extension) override;
   bool IsWhitelistedComponent(const Extension& extension) override;
   bool HasRequestDownloadsPermission(const Extension& extension) override;
diff --git a/extensions/browser/api/file_system/file_system_delegate.h b/extensions/browser/api/file_system/file_system_delegate.h
index f8f63c9b79731..a1c0948ef7529 100644
--- a/extensions/browser/api/file_system/file_system_delegate.h
+++ b/extensions/browser/api/file_system/file_system_delegate.h
@@ -73,7 +73,7 @@ class FileSystemDelegate {
   // string ID is found.
   virtual int GetDescriptionIdForAcceptType(const std::string& accept_type) = 0;
 
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
   // Checks whether the extension can be granted access.
   virtual GrantVolumesMode GetGrantVolumesMode(
       content::BrowserContext* browser_context,

From bc40bf465fd4484c7db1fe880016eb716cf6a326 Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Tue, 14 Aug 2018 20:28:59 +0900
Subject: [PATCH 30/32] Make file manager build on linux and ChromeOS

It adds build path for file manager for linux and
updates it for ChromeOS as well.
---
 chrome/browser/BUILD.gn                | 114 ++++++++++++++-----------
 chrome/browser/extensions/BUILD.gn     | 114 ++++++++++++++++---------
 content/public/common/url_constants.cc |   2 +-
 content/public/common/url_constants.h  |   2 +-
 4 files changed, 139 insertions(+), 93 deletions(-)

diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
index 2106fc7bb0293..6e3638de7964f 100644
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -3038,67 +3038,18 @@ jumbo_split_static_library("browser") {
       "download/notification/download_notification_manager.h",
       "feedback/feedback_util_chromeos.cc",
       "feedback/feedback_util_chromeos.h",
-      "file_manager/app_id.h",
       "file_manager/arc_file_tasks.cc",
       "file_manager/arc_file_tasks.h",
       "file_manager/crostini_file_tasks.cc",
       "file_manager/crostini_file_tasks.h",
-      "file_manager/file_browser_handlers.cc",
-      "file_manager/file_browser_handlers.h",
-      "file_manager/file_tasks.cc",
-      "file_manager/file_tasks.h",
-      "file_manager/file_watcher.cc",
-      "file_manager/file_watcher.h",
-      "file_manager/fileapi_util.cc",
-      "file_manager/fileapi_util.h",
-      "file_manager/filesystem_api_util.cc",
-      "file_manager/filesystem_api_util.h",
-      "file_manager/open_util.cc",
-      "file_manager/open_util.h",
-      "file_manager/open_with_browser.cc",
-      "file_manager/open_with_browser.h",
-      "file_manager/path_util.cc",
-      "file_manager/path_util.h",
-      "file_manager/select_file_dialog_util.cc",
-      "file_manager/select_file_dialog_util.h",
-      "file_manager/snapshot_manager.cc",
-      "file_manager/snapshot_manager.h",
-      "file_manager/url_util.cc",
-      "file_manager/url_util.h",
-      "file_manager/chromeos/volume_manager.cc",
-      "file_manager/chromeos/volume_manager.h",
-      "file_manager/volume_manager_factory.cc",
-      "file_manager/volume_manager_factory.h",
-      "file_manager/volume_manager_observer.h",
-      "fileapi/external_file_protocol_handler.cc",
-      "fileapi/external_file_protocol_handler.h",
-      "fileapi/external_file_url_request_job.cc",
-      "fileapi/external_file_url_request_job.h",
-      "fileapi/external_file_url_util.cc",
-      "fileapi/external_file_url_util.h",
-      "fileapi/file_access_permissions.cc",
-      "fileapi/file_access_permissions.h",
-      "fileapi/file_system_backend.cc",
-      "fileapi/file_system_backend.h",
-      "fileapi/file_system_backend_delegate.h",
       "fileapi/mtp_file_system_backend_delegate.cc",
       "fileapi/mtp_file_system_backend_delegate.h",
       "fileapi/mtp_watcher_manager.cc",
       "fileapi/mtp_watcher_manager.h",
       "fileapi/recent_arc_media_source.cc",
       "fileapi/recent_arc_media_source.h",
-      "fileapi/recent_download_source.cc",
-      "fileapi/recent_download_source.h",
       "fileapi/recent_drive_source.cc",
       "fileapi/recent_drive_source.h",
-      "fileapi/recent_file.cc",
-      "fileapi/recent_file.h",
-      "fileapi/recent_model.cc",
-      "fileapi/recent_model.h",
-      "fileapi/recent_model_factory.cc",
-      "fileapi/recent_model_factory.h",
-      "fileapi/recent_source.cc",
-      "fileapi/recent_source.h",
       "media/chromeos_login_media_access_handler.cc",
       "media/chromeos_login_media_access_handler.h",
       "media/public_session_media_access_handler.cc",
@@ -3190,6 +3141,71 @@ jumbo_split_static_library("browser") {
     ]
   }
 
+  if (use_ozone && is_linux) {
+    sources += [
+      "file_manager/app_id.h",
+      "file_manager/file_browser_handlers.cc",
+      "file_manager/file_browser_handlers.h",
+      "file_manager/file_tasks.cc",
+      "file_manager/file_tasks.h",
+      "file_manager/file_watcher.cc",
+      "file_manager/file_watcher.h",
+      "file_manager/fileapi_util.cc",
+      "file_manager/fileapi_util.h",
+      "file_manager/filesystem_api_util.cc",
+      "file_manager/filesystem_api_util.h",
+      "file_manager/open_util.cc",
+      "file_manager/open_util.h",
+      "file_manager/open_with_browser.cc",
+      "file_manager/open_with_browser.h",
+      "file_manager/path_util.cc",
+      "file_manager/path_util.h",
+      "file_manager/select_file_dialog_util.cc",
+      "file_manager/select_file_dialog_util.h",
+      "file_manager/snapshot_manager.cc",
+      "file_manager/snapshot_manager.h",
+      "file_manager/url_util.cc",
+      "file_manager/url_util.h",
+      "file_manager/volume_manager_factory.cc",
+      "file_manager/volume_manager_factory.h",
+      "file_manager/volume_manager_observer.h",
+      "fileapi/external_file_protocol_handler.cc",
+      "fileapi/external_file_protocol_handler.h",
+      "fileapi/external_file_url_request_job.cc",
+      "fileapi/external_file_url_request_job.h",
+      "fileapi/external_file_url_util.cc",
+      "fileapi/external_file_url_util.h",
+      "fileapi/file_access_permissions.cc",
+      "fileapi/file_access_permissions.h",
+      "fileapi/file_system_backend.cc",
+      "fileapi/file_system_backend.h",
+      "fileapi/file_system_backend_delegate.h",
+      "fileapi/recent_download_source.cc",
+      "fileapi/recent_download_source.h",
+      "fileapi/recent_file.cc",
+      "fileapi/recent_file.h",
+      "fileapi/recent_model.cc",
+      "fileapi/recent_model.h",
+      "fileapi/recent_model_factory.cc",
+      "fileapi/recent_model_factory.h",
+      "fileapi/recent_source.cc",
+      "fileapi/recent_source.h",
+    ]
+
+    if (is_chromeos) {
+      sources += [
+        "file_manager/chromeos/volume_manager.cc",
+        "file_manager/chromeos/volume_manager.h",
+      ]
+    } else {
+      sources += [
+        "file_manager/linux/volume_manager.cc",
+        "file_manager/linux/volume_manager.h",
+      ]
+    }
+    deps += [ "//ui/file_manager" ]
+  }
+
   if (is_win) {
     sources += [
       "downgrade/user_data_downgrade.cc",
diff --git a/chrome/browser/extensions/BUILD.gn b/chrome/browser/extensions/BUILD.gn
index 2eb3b30b790b7..e34c95e1beeca 100644
--- a/chrome/browser/extensions/BUILD.gn
+++ b/chrome/browser/extensions/BUILD.gn
@@ -170,8 +170,6 @@ jumbo_static_library("extensions") {
     "api/file_handlers/non_native_file_system_delegate_chromeos.h",
     "api/file_system/chrome_file_system_delegate.cc",
     "api/file_system/chrome_file_system_delegate.h",
-    "api/file_system/consent_provider.cc",
-    "api/file_system/consent_provider.h",
     "api/file_system/file_entry_picker.cc",
     "api/file_system/file_entry_picker.h",
     "api/font_settings/font_settings_api.cc",
@@ -943,45 +941,6 @@ jumbo_static_library("extensions") {
       "api/enterprise_platform_keys/enterprise_platform_keys_api.h",
       "api/enterprise_platform_keys_private/enterprise_platform_keys_private_api.cc",
       "api/enterprise_platform_keys_private/enterprise_platform_keys_private_api.h",
-      "api/file_manager/device_event_router.cc",
-      "api/file_manager/device_event_router.h",
-      "api/file_manager/drivefs_event_router.cc",
-      "api/file_manager/drivefs_event_router.h",
-      "api/file_manager/chromeos/event_router.cc",
-      "api/file_manager/chromeos/event_router.h",
-      "api/file_manager/event_router_factory.cc",
-      "api/file_manager/event_router_factory.h",
-      "api/file_manager/file_browser_handler_api.cc",
-      "api/file_manager/file_browser_handler_api.h",
-      "api/file_manager/file_manager_private_api_functions.h",
-      "api/file_manager/file_stream_md5_digester.cc",
-      "api/file_manager/file_stream_md5_digester.h",
-      "api/file_manager/job_event_router.cc",
-      "api/file_manager/job_event_router.h",
-      "api/file_manager/private_api_base.cc",
-      "api/file_manager/private_api_base.h",
-      "api/file_manager/private_api_dialog.cc",
-      "api/file_manager/private_api_dialog.h",
-      "api/file_manager/chromeos/private_api_drive.cc",
-      "api/file_manager/chromeos/private_api_drive.h",
-      "api/file_manager/chromeos/private_api_file_system.cc",
-      "api/file_manager/chromeos/private_api_file_system.h",
-      "api/file_manager/chromeos/private_api_misc.cc",
-      "api/file_manager/chromeos/private_api_misc.h",
-      "api/file_manager/chromeos/private_api_mount.cc",
-      "api/file_manager/chromeos/private_api_mount.h",
-      "api/file_manager/private_api_strings.cc",
-      "api/file_manager/private_api_strings.h",
-      "api/file_manager/private_api_tasks.cc",
-      "api/file_manager/private_api_tasks.h",
-      "api/file_manager/private_api_util.cc",
-      "api/file_manager/private_api_util.h",
-      "api/file_system/request_file_system_notification.cc",
-      "api/file_system/request_file_system_notification.h",
-      "api/file_system_provider/file_system_provider_api.cc",
-      "api/file_system_provider/file_system_provider_api.h",
-      "api/file_system_provider/provider_function.cc",
-      "api/file_system_provider/provider_function.h",
       "api/input_ime/input_ime_api.cc",
       "api/input_ime/input_ime_api.h",
       "api/input_ime/input_ime_api_chromeos.cc",
@@ -1052,7 +1011,6 @@ jumbo_static_library("extensions") {
       "//third_party/protobuf:protobuf_lite",
       "//ui/chromeos",
       "//ui/chromeos/events",
-      "//ui/file_manager",
       "//ui/keyboard",
       "//ui/keyboard:resources",
       "//ui/ozone",
@@ -1083,6 +1041,78 @@ jumbo_static_library("extensions") {
     }
   }
 
+  if (use_ozone && is_linux) {
+    sources += [
+      "api/file_manager/event_router_factory.cc",
+      "api/file_manager/event_router_factory.h",
+      "api/file_manager/file_browser_handler_api.cc",
+      "api/file_manager/file_browser_handler_api.h",
+      "api/file_manager/file_manager_private_api_functions.h",
+      "api/file_manager/file_stream_md5_digester.cc",
+      "api/file_manager/file_stream_md5_digester.h",
+      "api/file_manager/job_event_router.cc",
+      "api/file_manager/job_event_router.h",
+      "api/file_manager/private_api_base.cc",
+      "api/file_manager/private_api_base.h",
+      "api/file_manager/private_api_dialog.cc",
+      "api/file_manager/private_api_dialog.h",
+      "api/file_manager/private_api_strings.cc",
+      "api/file_manager/private_api_strings.h",
+      "api/file_manager/private_api_tasks.cc",
+      "api/file_manager/private_api_tasks.h",
+      "api/file_manager/private_api_util.cc",
+      "api/file_manager/private_api_util.h",
+      "api/file_system/consent_provider.cc",
+      "api/file_system/consent_provider.h",
+    ]
+
+    if (is_chromeos) {
+      sources += [
+        "api/file_manager/device_event_router.cc",
+        "api/file_manager/device_event_router.h",
+        "api/file_manager/drivefs_event_router.cc",
+        "api/file_manager/drivefs_event_router.h",
+        "api/file_manager/chromeos/event_router.cc",
+        "api/file_manager/chromeos/event_router.h",
+        "api/file_manager/chromeos/private_api_drive.cc",
+        "api/file_manager/chromeos/private_api_drive.h",
+        "api/file_manager/chromeos/private_api_file_system.cc",
+        "api/file_manager/chromeos/private_api_file_system.h",
+        "api/file_manager/chromeos/private_api_misc.cc",
+        "api/file_manager/chromeos/private_api_misc.h",
+        "api/file_manager/chromeos/private_api_mount.cc",
+        "api/file_manager/chromeos/private_api_mount.h",
+        "api/file_system_provider/chromeos/file_system_provider_api.cc",
+        "api/file_system_provider/chromeos/file_system_provider_api.h",
+        "api/file_system_provider/chromeos/provider_function.cc",
+        "api/file_system_provider/chromeos/provider_function.h",
+        "api/file_system/request_file_system_notification.cc",
+        "api/file_system/request_file_system_notification.h",
+      ]
+    } else {
+      sources += [
+        "api/file_manager/linux/event_router.cc",
+        "api/file_manager/linux/event_router.h",
+        "api/file_manager/linux/private_api_drive.cc",
+        "api/file_manager/linux/private_api_drive.h",
+        "api/file_manager/linux/private_api_file_system.cc",
+        "api/file_manager/linux/private_api_file_system.h",
+        "api/file_manager/linux/private_api_misc.cc",
+        "api/file_manager/linux/private_api_misc.h",
+        "api/file_manager/linux/private_api_mount.cc",
+        "api/file_manager/linux/private_api_mount.h",
+        "api/file_system_provider/linux/file_system_provider_api.cc",
+        "api/file_system_provider/linux/file_system_provider_api.h",
+        "api/file_system_provider/linux/provider_function.cc",
+        "api/file_system_provider/linux/provider_function.h",
+      ]
+    }
+
+    deps += [
+      "//ui/file_manager",
+    ]
+  }
+
   if (use_x11) {
     sources += [
       "global_shortcut_listener_x11.cc",
diff --git a/content/public/common/url_constants.cc b/content/public/common/url_constants.cc
index e4f7d81d65fa1..2b0cd04d63c59 100644
--- a/content/public/common/url_constants.cc
+++ b/content/public/common/url_constants.cc
@@ -14,7 +14,7 @@ const char kChromeErrorScheme[] = "chrome-error";
 const char kChromeUIScheme[] = "chrome";
 const char kGuestScheme[] = "chrome-guest";
 const char kViewSourceScheme[] = "view-source";
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
 const char kExternalFileScheme[] = "externalfile";
 #endif
 
diff --git a/content/public/common/url_constants.h b/content/public/common/url_constants.h
index d134378340f85..14d49771cbfad 100644
--- a/content/public/common/url_constants.h
+++ b/content/public/common/url_constants.h
@@ -22,7 +22,7 @@ CONTENT_EXPORT extern const char kChromeErrorScheme[];
 CONTENT_EXPORT extern const char kChromeUIScheme[];  // Used for WebUIs.
 CONTENT_EXPORT extern const char kGuestScheme[];
 CONTENT_EXPORT extern const char kViewSourceScheme[];
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
 CONTENT_EXPORT extern const char kExternalFileScheme[];
 #endif
 

From c732e88c157e77e7624a54884d88a4197bf48b48 Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Tue, 14 Aug 2018 20:50:11 +0900
Subject: [PATCH 31/32] Add bindings and manifest/idl/json

It bundles resources for fileSelectExtension into Linux/Ozone build
and opens file manager platform APIs not only ChromeOS but Linux.
---
 chrome/browser/extensions/BUILD.gn            |  2 +-
 .../api/file_manager/private_api_dialog.cc    | 15 +++++++++++++
 ...browser_context_keyed_service_factories.cc |  6 +++++-
 ...me_component_extension_resource_manager.cc | 10 ++++++---
 .../whitelist.cc                              | 13 +++++++-----
 chrome/browser/extensions/component_loader.cc | 13 +++++++-----
 chrome/chrome_paks.gni                        | 12 +++++++++--
 chrome/common/BUILD.gn                        | 13 +++++++-----
 chrome/common/extensions/api/BUILD.gn         |  8 ++++---
 .../extensions/api/_manifest_features.json    |  2 +-
 .../extensions/api/_permission_features.json  |  8 +++----
 chrome/common/extensions/api/api_sources.gni  | 15 ++++++++-----
 .../extensions/api/file_manager_private.idl   |  2 +-
 .../api/file_manager_private_internal.idl     |  2 +-
 .../extensions/chrome_manifest_handlers.cc    |  8 +++++--
 .../common/extensions/extension_constants.cc  |  5 ++++-
 .../common/extensions/extension_constants.h   |  7 +++++--
 chrome/renderer/BUILD.gn                      | 11 +++++++---
 .../chrome_extensions_dispatcher_delegate.cc  | 21 ++++++++++++-------
 .../file_browser_handler_custom_bindings.cc   |  2 +-
 .../renderer/resources/renderer_resources.grd |  8 ++++---
 .../chrome_apps/chrome_apps_resources.grd     |  2 +-
 extensions/common/manifest_constants.cc       |  4 ++++
 extensions/common/manifest_constants.h        |  4 ++++
 24 files changed, 135 insertions(+), 58 deletions(-)

diff --git a/chrome/browser/extensions/BUILD.gn b/chrome/browser/extensions/BUILD.gn
index e34c95e1beeca..022f356809dc2 100644
--- a/chrome/browser/extensions/BUILD.gn
+++ b/chrome/browser/extensions/BUILD.gn
@@ -999,7 +999,6 @@ jumbo_static_library("extensions") {
       "//chromeos/components/proximity_auth/logging",
       "//chromeos/services/ime/public/mojom",
       "//components/arc",
-      "//components/chrome_apps",
       "//components/constrained_window",
       "//components/cryptauth",
       "//components/drive",
@@ -1109,6 +1108,7 @@ jumbo_static_library("extensions") {
     }
 
     deps += [
+      "//components/chrome_apps",
       "//ui/file_manager",
     ]
   }
diff --git a/chrome/browser/extensions/api/file_manager/private_api_dialog.cc b/chrome/browser/extensions/api/file_manager/private_api_dialog.cc
index 19717c5893a9e..d953f213ed691 100644
--- a/chrome/browser/extensions/api/file_manager/private_api_dialog.cc
+++ b/chrome/browser/extensions/api/file_manager/private_api_dialog.cc
@@ -19,6 +19,7 @@ using content::BrowserThread;
 
 namespace extensions {
 
+#if defined(OS_CHROMEOS)
 namespace {
 
 // TODO(https://crbug.com/844654): This should be using something more
@@ -47,12 +48,18 @@ SelectFileDialogExtension::RoutingID GetFileDialogRoutingID(
 }
 
 }  // namespace
+#endif
 
 bool FileManagerPrivateCancelDialogFunction::RunAsync() {
+#if defined(OS_CHROMEOS)
   SelectFileDialogExtension::OnFileSelectionCanceled(
       GetFileDialogRoutingID(this));
   SendResponse(true);
   return true;
+#else
+  SendResponse(false);
+  return false;
+#endif
 }
 
 bool FileManagerPrivateSelectFileFunction::RunAsync() {
@@ -91,9 +98,13 @@ void FileManagerPrivateSelectFileFunction::GetSelectedFileInfoResponse(
     SendResponse(false);
     return;
   }
+#if defined(OS_CHROMEOS)
   SelectFileDialogExtension::OnFileSelected(GetFileDialogRoutingID(this),
                                             files[0], index);
   SendResponse(true);
+#else
+  SendResponse(false);
+#endif
 }
 
 bool FileManagerPrivateSelectFilesFunction::RunAsync() {
@@ -126,9 +137,13 @@ void FileManagerPrivateSelectFilesFunction::GetSelectedFileInfoResponse(
     return;
   }
 
+#if defined(OS_CHROMEOS)
   SelectFileDialogExtension::OnMultiFilesSelected(GetFileDialogRoutingID(this),
                                                   files);
   SendResponse(true);
+#else
+  SendResponse(false);
+#endif
 }
 
 }  // namespace extensions
diff --git a/chrome/browser/extensions/browser_context_keyed_service_factories.cc b/chrome/browser/extensions/browser_context_keyed_service_factories.cc
index 1edec6c65d7a5..1947383f0ac70 100644
--- a/chrome/browser/extensions/browser_context_keyed_service_factories.cc
+++ b/chrome/browser/extensions/browser_context_keyed_service_factories.cc
@@ -55,13 +55,17 @@
 #include "chrome/browser/chromeos/extensions/arc_apps_private_api.h"
 #include "chrome/browser/chromeos/extensions/input_method_api.h"
 #include "chrome/browser/chromeos/extensions/media_player_api.h"
-#include "chrome/browser/extensions/api/file_manager/event_router_factory.h"
 #include "chrome/browser/extensions/api/input_ime/input_ime_api.h"
 #include "chrome/browser/extensions/api/screenlock_private/screenlock_private_api.h"
 #elif defined(OS_LINUX) || defined(OS_WIN)
 #include "chrome/browser/extensions/api/input_ime/input_ime_api.h"
 #endif
 
+#if defined(OS_LINUX) && defined(USE_OZONE)
+#include "chrome/browser/extensions/api/file_manager/event_router_factory.h"
+#endif
+
+
 #if BUILDFLAG(ENABLE_SERVICE_DISCOVERY)
 #include "chrome/browser/extensions/api/mdns/mdns_api.h"
 #endif
diff --git a/chrome/browser/extensions/chrome_component_extension_resource_manager.cc b/chrome/browser/extensions/chrome_component_extension_resource_manager.cc
index cce474ce86ba1..f65108934f180 100644
--- a/chrome/browser/extensions/chrome_component_extension_resource_manager.cc
+++ b/chrome/browser/extensions/chrome_component_extension_resource_manager.cc
@@ -13,12 +13,14 @@
 #include "chrome/grit/component_extension_resources_map.h"
 #include "chrome/grit/theme_resources.h"
 
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
 #include "components/chrome_apps/chrome_apps_resource_util.h"
 #include "ui/file_manager/file_manager_resource_util.h"
 #include "ui/file_manager/grit/file_manager_resources.h"
+#if defined(OS_CHROMEOS)
 #include "ui/keyboard/keyboard_resource_util.h"
 #endif
+#endif
 
 namespace extensions {
 
@@ -29,7 +31,7 @@ ChromeComponentExtensionResourceManager() {
     {"web_store/webstore_icon_16.png", IDR_WEBSTORE_ICON_16},
     {"chrome_app/product_logo_128.png", IDR_PRODUCT_LOGO_128},
     {"chrome_app/product_logo_16.png", IDR_PRODUCT_LOGO_16},
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
     {"webstore_widget/app/icons/icon_16.png", IDR_WEBSTORE_ICON_16},
     {"webstore_widget/app/icons/icon_32.png", IDR_WEBSTORE_ICON_32},
     {"webstore_widget/app/icons/icon_128.png", IDR_WEBSTORE_ICON},
@@ -42,7 +44,7 @@ ChromeComponentExtensionResourceManager() {
   AddComponentResourceEntries(
       kExtraComponentExtensionResources,
       arraysize(kExtraComponentExtensionResources));
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
   size_t chrome_apps_resource_size;
   const GritResourceMap* chrome_apps_resources =
       chrome_apps::GetChromeAppsResources(&chrome_apps_resource_size);
@@ -57,6 +59,7 @@ ChromeComponentExtensionResourceManager() {
       file_manager_resources,
       file_manager_resource_size);
 
+#if defined(OS_CHROMEOS)
   size_t keyboard_resource_size;
   const GritResourceMap* keyboard_resources =
       keyboard::GetKeyboardExtensionResources(&keyboard_resource_size);
@@ -64,6 +67,7 @@ ChromeComponentExtensionResourceManager() {
       keyboard_resources,
       keyboard_resource_size);
 #endif
+#endif
 }
 
 ChromeComponentExtensionResourceManager::
diff --git a/chrome/browser/extensions/component_extensions_whitelist/whitelist.cc b/chrome/browser/extensions/component_extensions_whitelist/whitelist.cc
index dfc12043f6c68..ec1b9f02ca127 100644
--- a/chrome/browser/extensions/component_extensions_whitelist/whitelist.cc
+++ b/chrome/browser/extensions/component_extensions_whitelist/whitelist.cc
@@ -15,12 +15,14 @@
 #include "extensions/common/constants.h"
 #include "printing/buildflags/buildflags.h"
 
-#if defined(OS_CHROMEOS)
-#include "chrome/browser/chromeos/input_method/component_extension_ime_manager_impl.h"
+#if defined(OS_LINUX) && defined(USE_OZONE)
 #include "components/chrome_apps/grit/chrome_apps_resources.h"
 #include "ui/file_manager/grit/file_manager_resources.h"
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/chromeos/input_method/component_extension_ime_manager_impl.h"
 #include "ui/keyboard/grit/keyboard_resources.h"
 #endif
+#endif
 
 namespace extensions {
 
@@ -78,12 +80,14 @@ bool IsComponentExtensionWhitelisted(int manifest_resource_id) {
 #endif
     case IDR_NETWORK_SPEECH_SYNTHESIS_MANIFEST:
     case IDR_WEBSTORE_MANIFEST:
-
+#if defined(OS_LINUX) && defined(USE_OZONE)
+    case IDR_CHROME_APPS_WEBSTORE_WIDGET_MANIFEST:
+    case IDR_FILEMANAGER_MANIFEST:
+#endif
 #if defined(OS_CHROMEOS)
     // Separate ChromeOS list, as it is quite large.
     case IDR_ARC_SUPPORT_MANIFEST:
     case IDR_AUDIO_PLAYER_MANIFEST:
-    case IDR_CHROME_APPS_WEBSTORE_WIDGET_MANIFEST:
     case IDR_CONNECTIVITY_DIAGNOSTICS_LAUNCHER_MANIFEST:
     case IDR_CONNECTIVITY_DIAGNOSTICS_MANIFEST:
     case IDR_CROSH_BUILTIN_MANIFEST:
@@ -91,7 +95,6 @@ bool IsComponentExtensionWhitelisted(int manifest_resource_id) {
     case IDR_EASY_UNLOCK_MANIFEST:
     case IDR_EASY_UNLOCK_MANIFEST_SIGNIN:
     case IDR_ECHO_MANIFEST:
-    case IDR_FILEMANAGER_MANIFEST:
     case IDR_FIRST_RUN_DIALOG_MANIFEST:
     case IDR_GALLERY_MANIFEST:
     case IDR_KEYBOARD_MANIFEST:
diff --git a/chrome/browser/extensions/component_loader.cc b/chrome/browser/extensions/component_loader.cc
index fd88128379868..991e87be0da73 100644
--- a/chrome/browser/extensions/component_loader.cc
+++ b/chrome/browser/extensions/component_loader.cc
@@ -45,18 +45,21 @@
 
 #if defined(OS_CHROMEOS)
 #include "chromeos/chromeos_switches.h"
-#include "components/chrome_apps/grit/chrome_apps_resources.h"
 #include "components/user_manager/user_manager.h"
 #include "content/public/browser/site_instance.h"
 #include "content/public/browser/storage_partition.h"
 #include "extensions/browser/extensions_browser_client.h"
 #include "storage/browser/fileapi/file_system_context.h"
 #include "ui/chromeos/devicetype_utils.h"
-#include "ui/file_manager/grit/file_manager_resources.h"
 #include "ui/keyboard/grit/keyboard_resources.h"
 #include "ui/keyboard/keyboard_util.h"
 #endif
 
+#if defined(OS_LINUX) && defined(USE_OZONE)
+#include "components/chrome_apps/grit/chrome_apps_resources.h"
+#include "ui/file_manager/grit/file_manager_resources.h"
+#endif
+
 #if defined(GOOGLE_CHROME_BUILD)
 #include "chrome/browser/defaults.h"
 #endif
@@ -291,13 +294,13 @@ bool ComponentLoader::Exists(const std::string& id) const {
 }
 
 void ComponentLoader::AddFileManagerExtension() {
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
   AddWithNameAndDescription(
       IDR_FILEMANAGER_MANIFEST,
       base::FilePath(FILE_PATH_LITERAL("file_manager")),
       l10n_util::GetStringUTF8(IDS_FILEMANAGER_APP_NAME),
       l10n_util::GetStringUTF8(IDS_FILEMANAGER_APP_DESCRIPTION));
-#endif  // defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) && defined(USE_OZONE)
 }
 
 void ComponentLoader::AddVideoPlayerExtension() {
@@ -336,7 +339,7 @@ void ComponentLoader::AddZipArchiverExtension() {
 }
 
 void ComponentLoader::AddWebstoreWidgetExtension() {
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
   AddWithNameAndDescription(
       IDR_CHROME_APPS_WEBSTORE_WIDGET_MANIFEST,
       base::FilePath(FILE_PATH_LITERAL("webstore_widget")),
diff --git a/chrome/chrome_paks.gni b/chrome/chrome_paks.gni
index 8b3d1652ae289..78d7f92327985 100644
--- a/chrome/chrome_paks.gni
+++ b/chrome/chrome_paks.gni
@@ -154,17 +154,25 @@ template("chrome_extra_paks") {
         "$root_gen_dir/ash/public/cpp/resources/ash_public_unscaled_resources.pak",
         "$root_gen_dir/chrome/multidevice_setup_resources.pak",
         "$root_gen_dir/chromeos/chromeos_resources.pak",
-        "$root_gen_dir/components/chrome_apps/chrome_apps_resources.pak",
-        "$root_gen_dir/ui/file_manager/file_manager_resources.pak",
       ]
       deps += [
         "//ash/public/cpp/resources:ash_public_unscaled_resources",
         "//chrome/browser/resources/chromeos:multidevice_setup_resources",
         "//chromeos/resources",
+      ]
+    }
+
+    if (use_ozone && is_linux) {
+      sources += [
+        "$root_gen_dir/components/chrome_apps/chrome_apps_resources.pak",
+        "$root_gen_dir/ui/file_manager/file_manager_resources.pak",
+      ]
+      deps += [
         "//components/chrome_apps:resources",
         "//ui/file_manager:resources",
       ]
     }
+
     if (enable_extensions) {
       sources += [
         "$root_gen_dir/chrome/extensions_resources.pak",
diff --git a/chrome/common/BUILD.gn b/chrome/common/BUILD.gn
index a4e88f539f1a1..afef070a8b01b 100644
--- a/chrome/common/BUILD.gn
+++ b/chrome/common/BUILD.gn
@@ -388,17 +388,20 @@ static_library("common") {
     ]
     if (is_chromeos) {
       sources += [
-        "extensions/api/file_browser_handlers/file_browser_handler.cc",
-        "extensions/api/file_browser_handlers/file_browser_handler.h",
-        "extensions/api/file_system_provider_capabilities/file_system_provider_capabilities_handler.cc",
-        "extensions/api/file_system_provider_capabilities/file_system_provider_capabilities_handler.h",
         "extensions/api/input_ime/input_components_handler.cc",
         "extensions/api/input_ime/input_components_handler.h",
       ]
-
       # This dependency is for a header used only by extensions code.
       public_deps += [ "//ui/keyboard:keyboard" ]
     }
+    if (use_ozone && is_linux) {
+      sources += [
+        "extensions/api/file_browser_handlers/file_browser_handler.cc",
+        "extensions/api/file_browser_handlers/file_browser_handler.h",
+        "extensions/api/file_system_provider_capabilities/file_system_provider_capabilities_handler.cc",
+        "extensions/api/file_system_provider_capabilities/file_system_provider_capabilities_handler.h",
+      ]
+    }
   }
 
   if (is_mac) {
diff --git a/chrome/common/extensions/api/BUILD.gn b/chrome/common/extensions/api/BUILD.gn
index 6f90411fa1f46..6686798982452 100644
--- a/chrome/common/extensions/api/BUILD.gn
+++ b/chrome/common/extensions/api/BUILD.gn
@@ -34,9 +34,7 @@ generated_json_strings("generated_api_json_strings") {
     "tts_engine.json",
     "webstore.json",
   ]
-  if (is_chromeos) {
-    sources += [ "file_browser_handler.json" ]
-  } else {
+  if (!is_chromeos) {
     # On ChromeOS, input_method_private is fully compiled (as part of
     # schema_files), and so gets added to the bundle already. On other
     # platforms, we still need it added to the bundle.
@@ -44,6 +42,10 @@ generated_json_strings("generated_api_json_strings") {
     sources += [ "input_method_private.json" ]
   }
 
+  if (use_ozone && is_linux) {
+    sources += [ "file_browser_handler.json" ]
+  }
+
   root_namespace = chrome_extensions_api_root_namespace
   deps = [
     "//extensions/common/api",
diff --git a/chrome/common/extensions/api/_manifest_features.json b/chrome/common/extensions/api/_manifest_features.json
index 785d37905f3e6..ee9de93a20dc8 100644
--- a/chrome/common/extensions/api/_manifest_features.json
+++ b/chrome/common/extensions/api/_manifest_features.json
@@ -158,7 +158,7 @@
   }, {
     "channel": "stable",
     "extension_types": ["legacy_packaged_app"],
-    "platforms": ["chromeos"],
+    "platforms": ["chromeos", "linux"],
     "whitelist": [
       "0EA6B717932AD64C469C1CCB6911457733295907",  // http://crbug.com/673004
       "58B0C2968C335964D5433E89CA4D86628A0E3D4B"   // http://crbug.com/673004
diff --git a/chrome/common/extensions/api/_permission_features.json b/chrome/common/extensions/api/_permission_features.json
index 74ec02d3339a0..c2ae1524c7d02 100644
--- a/chrome/common/extensions/api/_permission_features.json
+++ b/chrome/common/extensions/api/_permission_features.json
@@ -336,12 +336,12 @@
   "fileBrowserHandler": {
     "channel": "stable",
     "extension_types": ["extension", "legacy_packaged_app", "platform_app"],
-    "platforms": ["chromeos"]
+    "platforms": ["chromeos", "linux"]
   },
   "fileManagerPrivate": {
     "channel": "stable",
     "extension_types": ["extension", "legacy_packaged_app", "platform_app"],
-    "platforms": ["chromeos"],
+    "platforms": ["chromeos", "linux"],
     "whitelist": [
       "74E2D32A61B08D29521A8C4E360F581DE78F5CA5",  // Image loader
       "A948368FC53BE437A55FEB414106E207925482F5",  // Files app
@@ -357,11 +357,11 @@
   "fileSystemProvider": [{
     "channel": "stable",
     "extension_types": ["extension", "platform_app"],
-    "platforms": ["chromeos"]
+    "platforms": ["chromeos", "linux"]
   }, {
     "channel": "stable",
     "extension_types": ["legacy_packaged_app"],
-    "platforms": ["chromeos"],
+    "platforms": ["chromeos", "linux"],
     "whitelist": [
       "0EA6B717932AD64C469C1CCB6911457733295907",  // http://crbug.com/673004
       "58B0C2968C335964D5433E89CA4D86628A0E3D4B"   // http://crbug.com/673004
diff --git a/chrome/common/extensions/api/api_sources.gni b/chrome/common/extensions/api/api_sources.gni
index ea34622b0a6f9..ecc6dc606b0d3 100644
--- a/chrome/common/extensions/api/api_sources.gni
+++ b/chrome/common/extensions/api/api_sources.gni
@@ -99,11 +99,6 @@ if (is_chromeos) {
     "enterprise_platform_keys.idl",
     "enterprise_platform_keys_internal.idl",
     "enterprise_platform_keys_private.json",
-    "file_browser_handler_internal.json",
-    "file_manager_private.idl",
-    "file_manager_private_internal.idl",
-    "file_system_provider.idl",
-    "file_system_provider_internal.idl",
     "first_run_private.json",
     "input_ime.json",
     "input_method_private.json",
@@ -121,6 +116,16 @@ if (is_chromeos) {
   schema_sources_ += [ "input_ime.json" ]
 }
 
+if (use_ozone && is_linux) {
+  schema_sources_ += [
+    "file_browser_handler_internal.json",
+    "file_manager_private.idl",
+    "file_manager_private_internal.idl",
+    "file_system_provider.idl",
+    "file_system_provider_internal.idl",
+  ]
+}
+
 if (!is_chromeos) {
   schema_sources_ += [ "enterprise_reporting_private.idl" ]
 }
diff --git a/chrome/common/extensions/api/file_manager_private.idl b/chrome/common/extensions/api/file_manager_private.idl
index eeb5a8279f08f..25d36897fa85f 100644
--- a/chrome/common/extensions/api/file_manager_private.idl
+++ b/chrome/common/extensions/api/file_manager_private.idl
@@ -4,7 +4,7 @@
 
 // fileManagerPrivate API.
 // This is a private API used by the file browser of ChromeOS.
-[platforms=("chromeos"),
+[platforms=("chromeos", "linux"),
  implemented_in="chrome/browser/extensions/api/file_manager/file_manager_private_api_functions.h"]
 namespace fileManagerPrivate {
 // Type of the mounted volume.
diff --git a/chrome/common/extensions/api/file_manager_private_internal.idl b/chrome/common/extensions/api/file_manager_private_internal.idl
index 0a936477b7ce6..7de29897c1380 100644
--- a/chrome/common/extensions/api/file_manager_private_internal.idl
+++ b/chrome/common/extensions/api/file_manager_private_internal.idl
@@ -3,7 +3,7 @@
 // found in the LICENSE file.
 
 // Internal, used by fileManagerPrivate's custom bindings.
-[platforms=("chromeos"),
+[platforms=("chromeos", "linux"),
  implemented_in="chrome/browser/extensions/api/file_manager/file_manager_private_api_functions.h"]
 namespace fileManagerPrivateInternal {
   // Entry information that renderers need to create an Entry instance.
diff --git a/chrome/common/extensions/chrome_manifest_handlers.cc b/chrome/common/extensions/chrome_manifest_handlers.cc
index bc1b4c0ef5e06..f532d3722a382 100644
--- a/chrome/common/extensions/chrome_manifest_handlers.cc
+++ b/chrome/common/extensions/chrome_manifest_handlers.cc
@@ -28,11 +28,13 @@
 #include "extensions/common/manifest_handlers/options_page_info.h"
 #include "extensions/common/manifest_url_handlers.h"
 
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
 #include "chrome/common/extensions/api/file_browser_handlers/file_browser_handler.h"
 #include "chrome/common/extensions/api/file_system_provider_capabilities/file_system_provider_capabilities_handler.h"
+#if defined(OS_CHROMEOS)
 #include "chrome/common/extensions/api/input_ime/input_components_handler.h"
 #endif
+#endif
 
 namespace extensions {
 
@@ -62,11 +64,13 @@ void RegisterChromeManifestHandlers() {
   (new UIOverridesHandler)->Register();
   (new UrlHandlersParser)->Register();
   (new URLOverridesHandler)->Register();
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
   (new FileBrowserHandlerParser)->Register();
   (new FileSystemProviderCapabilitiesHandler)->Register();
+#if defined(OS_CHROMEOS)
   (new InputComponentsHandler)->Register();
 #endif
+#endif
 }
 
 }  // namespace extensions
diff --git a/chrome/common/extensions/extension_constants.cc b/chrome/common/extensions/extension_constants.cc
index 0e69b2e67210b..9df6b71d049ce 100644
--- a/chrome/common/extensions/extension_constants.cc
+++ b/chrome/common/extensions/extension_constants.cc
@@ -69,12 +69,15 @@ const char kSpeechSynthesisExtensionPath[] =
 const char kSpeechSynthesisExtensionId[] =
     "gjjabgpgjpampikjhjpfhneeoapjbjaf";
 const char kWallpaperManagerId[] = "obklkkbkpaoaejdabbfldmcfplpdgolj";
-const char kWebstoreWidgetAppId[] = "fbjakikfhfdajcamjleinfciajelkpek";
 const char kZIPUnpackerExtensionId[] = "oedeeodfidgoollimchfdnbmhcpnklnd";
 const char kZipArchiverExtensionId[] = "dmboannefpncccogfdikhmhpmdnddgoe";
 const char kZipArchiverExtensionPath[] = "chromeos/zip_archiver";
 #endif
 
+#if defined(OS_LINUX) && defined(USE_OZONE)
+const char kWebstoreWidgetAppId[] = "fbjakikfhfdajcamjleinfciajelkpek";
+#endif
+
 const char kAppStateNotInstalled[] = "not_installed";
 const char kAppStateInstalled[] = "installed";
 const char kAppStateDisabled[] = "disabled";
diff --git a/chrome/common/extensions/extension_constants.h b/chrome/common/extensions/extension_constants.h
index 30e03cdd29c6c..1ba7f698a099a 100644
--- a/chrome/common/extensions/extension_constants.h
+++ b/chrome/common/extensions/extension_constants.h
@@ -236,8 +236,6 @@ extern const char kSpeechSynthesisExtensionPath[];
 extern const char kSpeechSynthesisExtensionId[];
 // The extension id of the wallpaper manager application.
 extern const char kWallpaperManagerId[];
-// The app id of the webstore widget component app.
-extern const char kWebstoreWidgetAppId[];
 // The extension id of the new ZIP unpacker extension.
 extern const char kZIPUnpackerExtensionId[];
 // The extension id of the zip archiver extension.
@@ -246,6 +244,11 @@ extern const char kZipArchiverExtensionId[];
 extern const char kZipArchiverExtensionPath[];
 #endif
 
+#if defined(OS_LINUX) && defined(USE_OZONE)
+// The app id of the webstore widget component app.
+extern const char kWebstoreWidgetAppId[];
+#endif
+
 // What causes an extension to be installed? Used in histograms, so don't
 // change existing values.
 enum CrxInstallCause {
diff --git a/chrome/renderer/BUILD.gn b/chrome/renderer/BUILD.gn
index bf218a3f098a6..c1dd7c69d51cd 100644
--- a/chrome/renderer/BUILD.gn
+++ b/chrome/renderer/BUILD.gn
@@ -392,14 +392,19 @@ jumbo_static_library("renderer") {
   }
 
   if (is_chromeos) {
+    sources += [
+      "extensions/platform_keys_natives.cc",
+      "extensions/platform_keys_natives.h",
+      "resources/extensions/certificate_provider_custom_bindings.js",
+    ]
+  }
+
+  if (use_ozone && is_linux) {
     sources += [
       "extensions/file_browser_handler_custom_bindings.cc",
       "extensions/file_browser_handler_custom_bindings.h",
       "extensions/file_manager_private_custom_bindings.cc",
       "extensions/file_manager_private_custom_bindings.h",
-      "extensions/platform_keys_natives.cc",
-      "extensions/platform_keys_natives.h",
-      "resources/extensions/certificate_provider_custom_bindings.js",
       "resources/extensions/file_browser_handler_custom_bindings.js",
       "resources/extensions/file_manager_private_custom_bindings.js",
       "resources/extensions/file_system_provider_custom_bindings.js",
diff --git a/chrome/renderer/extensions/chrome_extensions_dispatcher_delegate.cc b/chrome/renderer/extensions/chrome_extensions_dispatcher_delegate.cc
index e73071b686420..7fcd0140e7eb2 100644
--- a/chrome/renderer/extensions/chrome_extensions_dispatcher_delegate.cc
+++ b/chrome/renderer/extensions/chrome_extensions_dispatcher_delegate.cc
@@ -52,7 +52,7 @@
 #include "third_party/blink/public/platform/web_url.h"
 #include "third_party/blink/public/web/web_security_policy.h"
 
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
 #include "chrome/renderer/extensions/file_browser_handler_custom_bindings.h"
 #include "chrome/renderer/extensions/file_manager_private_custom_bindings.h"
 #include "chrome/renderer/extensions/platform_keys_natives.h"
@@ -106,7 +106,7 @@ void ChromeExtensionsDispatcherDelegate::RegisterNativeHandlers(
       "sync_file_system",
       std::unique_ptr<NativeHandler>(
           new extensions::SyncFileSystemCustomBindings(context)));
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
   module_system->RegisterNativeHandler(
       "file_browser_handler",
       std::unique_ptr<NativeHandler>(
@@ -115,6 +115,8 @@ void ChromeExtensionsDispatcherDelegate::RegisterNativeHandlers(
       "file_manager_private",
       std::unique_ptr<NativeHandler>(
           new extensions::FileManagerPrivateCustomBindings(context)));
+#endif
+#if defined(OS_CHROMEOS)
   module_system->RegisterNativeHandler(
       "platform_keys_natives",
       std::unique_ptr<NativeHandler>(
@@ -209,12 +211,6 @@ void ChromeExtensionsDispatcherDelegate::PopulateSourceMap(
                              IDR_ENTERPRISE_PLATFORM_KEYS_SUBTLE_CRYPTO_JS);
   source_map->RegisterSource("enterprise.platformKeys.Token",
                              IDR_ENTERPRISE_PLATFORM_KEYS_TOKEN_JS);
-  source_map->RegisterSource("fileBrowserHandler",
-                             IDR_FILE_BROWSER_HANDLER_CUSTOM_BINDINGS_JS);
-  source_map->RegisterSource("fileManagerPrivate",
-                             IDR_FILE_MANAGER_PRIVATE_CUSTOM_BINDINGS_JS);
-  source_map->RegisterSource("fileSystemProvider",
-                             IDR_FILE_SYSTEM_PROVIDER_CUSTOM_BINDINGS_JS);
   source_map->RegisterSource("platformKeys",
                              IDR_PLATFORM_KEYS_CUSTOM_BINDINGS_JS);
   source_map->RegisterSource("platformKeys.getPublicKey",
@@ -235,6 +231,15 @@ void ChromeExtensionsDispatcherDelegate::PopulateSourceMap(
                              IDR_IME_SERVICE_BINDINGS_JS);
 #endif  // defined(OS_CHROMEOS)
 
+#if defined(OS_LINUX) && defined(USE_OZONE)
+  source_map->RegisterSource("fileBrowserHandler",
+                             IDR_FILE_BROWSER_HANDLER_CUSTOM_BINDINGS_JS);
+  source_map->RegisterSource("fileManagerPrivate",
+                             IDR_FILE_MANAGER_PRIVATE_CUSTOM_BINDINGS_JS);
+  source_map->RegisterSource("fileSystemProvider",
+                             IDR_FILE_SYSTEM_PROVIDER_CUSTOM_BINDINGS_JS);
+#endif
+
   source_map->RegisterSource("cast.streaming.rtpStream",
                              IDR_CAST_STREAMING_RTP_STREAM_CUSTOM_BINDINGS_JS);
   source_map->RegisterSource("cast.streaming.session",
diff --git a/chrome/renderer/extensions/file_browser_handler_custom_bindings.cc b/chrome/renderer/extensions/file_browser_handler_custom_bindings.cc
index 960ebbed1907f..6eaa378b25862 100644
--- a/chrome/renderer/extensions/file_browser_handler_custom_bindings.cc
+++ b/chrome/renderer/extensions/file_browser_handler_custom_bindings.cc
@@ -32,7 +32,7 @@ void FileBrowserHandlerCustomBindings::GetExternalFileEntry(
     ScriptContext* context) {
 // TODO(zelidrag): Make this magic work on other platforms when file browser
 // matures enough on ChromeOS.
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
     CHECK(args.Length() == 1);
     CHECK(args[0]->IsObject());
     v8::Local<v8::Object> file_def = args[0].As<v8::Object>();
diff --git a/chrome/renderer/resources/renderer_resources.grd b/chrome/renderer/resources/renderer_resources.grd
index e738202076556..8f2f5a052b578 100644
--- a/chrome/renderer/resources/renderer_resources.grd
+++ b/chrome/renderer/resources/renderer_resources.grd
@@ -66,9 +66,6 @@
           <include name="IDR_ENTERPRISE_PLATFORM_KEYS_KEY_PAIR_JS" file="extensions\enterprise_platform_keys\key_pair.js" type="BINDATA" />
           <include name="IDR_ENTERPRISE_PLATFORM_KEYS_SUBTLE_CRYPTO_JS" file="extensions\enterprise_platform_keys\subtle_crypto.js" type="BINDATA" />
           <include name="IDR_ENTERPRISE_PLATFORM_KEYS_TOKEN_JS" file="extensions\enterprise_platform_keys\token.js" type="BINDATA" />
-          <include name="IDR_FILE_BROWSER_HANDLER_CUSTOM_BINDINGS_JS" file="extensions\file_browser_handler_custom_bindings.js" type="BINDATA" />
-          <include name="IDR_FILE_MANAGER_PRIVATE_CUSTOM_BINDINGS_JS" file="extensions\file_manager_private_custom_bindings.js" type="BINDATA" />
-          <include name="IDR_FILE_SYSTEM_PROVIDER_CUSTOM_BINDINGS_JS" file="extensions\file_system_provider_custom_bindings.js" type="BINDATA" />
           <include name="IDR_PLATFORM_KEYS_CUSTOM_BINDINGS_JS" file="extensions\platform_keys_custom_bindings.js" type="BINDATA" />
           <include name="IDR_PLATFORM_KEYS_GET_PUBLIC_KEY_JS" file="extensions\platform_keys\get_public_key.js" type="BINDATA" />
           <include name="IDR_PLATFORM_KEYS_INTERNAL_API_JS" file="extensions\platform_keys\internal_api.js" type="BINDATA" />
@@ -81,6 +78,11 @@
           <include name="IDR_IME_SERVICE_BINDINGS_JS" file="extensions\chromeos_ime_service_bindings.js" type="BINDATA" />
           <include name="IDR_IME_SERVICE_MOJOM_JS" file="${mojom_root}\chromeos/services/ime/public/mojom/input_engine.mojom.js" use_base_dir="false" type="BINDATA" />
         </if>
+        <if expr="is_linux">
+          <include name="IDR_FILE_BROWSER_HANDLER_CUSTOM_BINDINGS_JS" file="extensions\file_browser_handler_custom_bindings.js" type="BINDATA" />
+          <include name="IDR_FILE_MANAGER_PRIVATE_CUSTOM_BINDINGS_JS" file="extensions\file_manager_private_custom_bindings.js" type="BINDATA" />
+          <include name="IDR_FILE_SYSTEM_PROVIDER_CUSTOM_BINDINGS_JS" file="extensions\file_system_provider_custom_bindings.js" type="BINDATA" />
+        </if>
         <!-- Media Router Mojo service and bindings. -->
         <include name="IDR_MEDIA_CONTROLLER_MOJOM_JS" file="${mojom_root}\chrome\common\media_router\mojo\media_controller.mojom.js" use_base_dir="false" type="BINDATA" />
         <include name="IDR_MEDIA_ROUTER_MOJOM_JS" file="${mojom_root}\chrome\common\media_router\mojo\media_router.mojom.js" use_base_dir="false" type="BINDATA" />
diff --git a/components/chrome_apps/chrome_apps_resources.grd b/components/chrome_apps/chrome_apps_resources.grd
index 884eef6fb3081..ecb635785444a 100644
--- a/components/chrome_apps/chrome_apps_resources.grd
+++ b/components/chrome_apps/chrome_apps_resources.grd
@@ -11,7 +11,7 @@
   </outputs>
   <release seq="1">
     <includes>
-      <if expr="chromeos">
+      <if expr="is_linux">
         <part file="webstore_widget_resources.grdp" />
       </if>
     </includes>
diff --git a/extensions/common/manifest_constants.cc b/extensions/common/manifest_constants.cc
index 9a7c647809af8..ce096644752ad 100644
--- a/extensions/common/manifest_constants.cc
+++ b/extensions/common/manifest_constants.cc
@@ -189,6 +189,8 @@ const char kWebviewPartitions[] = "partitions";
 const char kActionHandlers[] = "action_handlers";
 const char kActionHandlerActionKey[] = "action";
 const char kActionHandlerEnabledOnLockScreenKey[] = "enabled_on_lock_screen";
+#endif
+#if defined(OS_LINUX) && defined(USE_OZONE)
 const char kFileSystemProviderCapabilities[] =
     "file_system_provider_capabilities";
 #endif
@@ -758,6 +760,8 @@ const char kInvalidActionHandlersActionType[] =
 const char kInvalidActionHandlersType[] =
     "Invalid value for 'action_handlers'. Value must be a list of strings or a "
     "dictionary with 'action' key.";
+#endif
+#if defined(OS_LINUX) && defined(USE_OZONE)
 const char kInvalidFileSystemProviderMissingCapabilities[] =
     "The 'fileSystemProvider' permission requires the "
     "'file_system_provider_capabilities' section to be specified in the "
diff --git a/extensions/common/manifest_constants.h b/extensions/common/manifest_constants.h
index 015ece2c1268f..91e63cd5faefa 100644
--- a/extensions/common/manifest_constants.h
+++ b/extensions/common/manifest_constants.h
@@ -192,6 +192,8 @@ extern const char kWebviewPartitions[];
 extern const char kActionHandlers[];
 extern const char kActionHandlerActionKey[];
 extern const char kActionHandlerEnabledOnLockScreenKey[];
+#endif
+#if defined(OS_LINUX) && defined(USE_OZONE)
 extern const char kFileSystemProviderCapabilities[];
 #endif
 }  // namespace manifest_keys
@@ -507,6 +509,8 @@ extern const char kIllegalPlugins[];
 extern const char kInvalidActionHandlerDictionary[];
 extern const char kInvalidActionHandlersActionType[];
 extern const char kInvalidActionHandlersType[];
+#endif
+#if defined(OS_LINUX) && defined(USE_OZONE)
 extern const char kInvalidFileSystemProviderMissingCapabilities[];
 extern const char kInvalidFileSystemProviderMissingPermission[];
 #endif

From c84fea745a182aaf9337de00271a4acf6103bdf0 Mon Sep 17 00:00:00 2001
From: Julie Jeongeun Kim <jkim@igalia.com>
Date: Tue, 14 Aug 2018 20:54:33 +0900
Subject: [PATCH 32/32] Implement SelectDialog with fileSelectionExtenson for
 Ozone build.

It registers SelectFileDialogExtensionFactory for SelectFileDialogFactory
for Ozone build.
---
 .../browser/chrome_content_browser_client.cc  | 11 +++++++---
 .../api/file_manager/private_api_dialog.cc    | 15 --------------
 .../chrome_file_system_delegate.cc            |  8 --------
 .../api/file_system/consent_provider.cc       |  2 --
 chrome/browser/ui/BUILD.gn                    | 20 ++++++++++++-------
 .../chrome_browser_main_extra_parts_views.cc  |  9 +++++++++
 .../ui/views/select_file_dialog_extension.cc  |  4 ++--
 content/browser/browser_context.cc            |  6 +++---
 .../api/file_system/file_system_api.cc        |  4 ++--
 .../browser/api/file_system/file_system_api.h |  2 +-
 10 files changed, 38 insertions(+), 43 deletions(-)

diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
index b691b9a3c6009..412f72d2c1ac1 100644
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -325,8 +325,6 @@
 #include "chrome/browser/chromeos/policy/browser_policy_connector_chromeos.h"
 #include "chrome/browser/chromeos/profiles/profile_helper.h"
 #include "chrome/browser/chromeos/system/input_device_settings.h"
-#include "chrome/browser/file_manager/app_id.h"
-#include "chrome/browser/fileapi/file_system_backend.h"
 #include "chrome/browser/fileapi/mtp_file_system_backend_delegate.h"
 #include "chrome/browser/ui/ash/chrome_browser_main_extra_parts_ash.h"
 #include "chrome/browser/ui/ash/tablet_mode_client.h"
@@ -370,6 +368,11 @@
 #include "chrome/browser/chrome_browser_main_posix.h"
 #endif
 
+#if defined(OS_LINUX) && defined(USE_OZONE)
+#include "chrome/browser/file_manager/app_id.h"
+#include "chrome/browser/fileapi/file_system_backend.h"
+#endif
+
 #if !defined(OS_ANDROID)
 #include "chrome/browser/devtools/chrome_devtools_manager_delegate.h"
 #include "chrome/browser/devtools/devtools_window.h"
@@ -3325,11 +3328,12 @@ void ChromeContentBrowserClient::GetAdditionalFileSystemBackends(
     const base::FilePath& storage_partition_path,
     std::vector<std::unique_ptr<storage::FileSystemBackend>>*
         additional_backends) {
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
   storage::ExternalMountPoints* external_mount_points =
       content::BrowserContext::GetMountPoints(browser_context);
   DCHECK(external_mount_points);
   auto backend = std::make_unique<chromeos::FileSystemBackend>(
+#if defined(OS_CHROMEOS)
       std::make_unique<drive::FileSystemBackendDelegate>(),
       std::make_unique<chromeos::file_system_provider::BackendDelegate>(),
       std::make_unique<chromeos::MTPFileSystemBackendDelegate>(
@@ -3337,6 +3341,7 @@ void ChromeContentBrowserClient::GetAdditionalFileSystemBackends(
       std::make_unique<arc::ArcContentFileSystemBackendDelegate>(),
       std::make_unique<arc::ArcDocumentsProviderBackendDelegate>(),
       std::make_unique<drive::DriveFsFileSystemBackendDelegate>(),
+#endif
       external_mount_points, storage::ExternalMountPoints::GetSystemInstance());
   backend->AddSystemMountPoints();
   DCHECK(backend->CanHandleType(storage::kFileSystemTypeExternal));
diff --git a/chrome/browser/extensions/api/file_manager/private_api_dialog.cc b/chrome/browser/extensions/api/file_manager/private_api_dialog.cc
index d953f213ed691..19717c5893a9e 100644
--- a/chrome/browser/extensions/api/file_manager/private_api_dialog.cc
+++ b/chrome/browser/extensions/api/file_manager/private_api_dialog.cc
@@ -19,7 +19,6 @@ using content::BrowserThread;
 
 namespace extensions {
 
-#if defined(OS_CHROMEOS)
 namespace {
 
 // TODO(https://crbug.com/844654): This should be using something more
@@ -48,18 +47,12 @@ SelectFileDialogExtension::RoutingID GetFileDialogRoutingID(
 }
 
 }  // namespace
-#endif
 
 bool FileManagerPrivateCancelDialogFunction::RunAsync() {
-#if defined(OS_CHROMEOS)
   SelectFileDialogExtension::OnFileSelectionCanceled(
       GetFileDialogRoutingID(this));
   SendResponse(true);
   return true;
-#else
-  SendResponse(false);
-  return false;
-#endif
 }
 
 bool FileManagerPrivateSelectFileFunction::RunAsync() {
@@ -98,13 +91,9 @@ void FileManagerPrivateSelectFileFunction::GetSelectedFileInfoResponse(
     SendResponse(false);
     return;
   }
-#if defined(OS_CHROMEOS)
   SelectFileDialogExtension::OnFileSelected(GetFileDialogRoutingID(this),
                                             files[0], index);
   SendResponse(true);
-#else
-  SendResponse(false);
-#endif
 }
 
 bool FileManagerPrivateSelectFilesFunction::RunAsync() {
@@ -137,13 +126,9 @@ void FileManagerPrivateSelectFilesFunction::GetSelectedFileInfoResponse(
     return;
   }
 
-#if defined(OS_CHROMEOS)
   SelectFileDialogExtension::OnMultiFilesSelected(GetFileDialogRoutingID(this),
                                                   files);
   SendResponse(true);
-#else
-  SendResponse(false);
-#endif
 }
 
 }  // namespace extensions
diff --git a/chrome/browser/extensions/api/file_system/chrome_file_system_delegate.cc b/chrome/browser/extensions/api/file_system/chrome_file_system_delegate.cc
index c8da2639d6c2c..94e9fe2e21ebf 100644
--- a/chrome/browser/extensions/api/file_system/chrome_file_system_delegate.cc
+++ b/chrome/browser/extensions/api/file_system/chrome_file_system_delegate.cc
@@ -75,7 +75,6 @@ const char kRequiresFileSystemWriteError[] =
 const char kSecurityError[] = "Security error.";
 const char kVolumeNotFoundError[] = "Volume not found.";
 
-#if defined(OS_CHROMEOS)
 // Fills a list of volumes mounted in the system.
 bool GetVolumeListForExtension(
     const std::vector<base::WeakPtr<file_manager::Volume>>& available_volumes,
@@ -201,7 +200,6 @@ void OnConsentReceived(
 
   success_callback.Run(file_system_id, register_name);
 }
-#endif
 
 }  // namespace
 
@@ -221,7 +219,6 @@ void DispatchVolumeListChangeEvent(content::BrowserContext* browser_context) {
       Profile::FromBrowserContext(browser_context));
   ConsentProvider consent_provider(&consent_provider_delegate);
 
-#if defined(OS_CHROMEOS)
   const std::vector<base::WeakPtr<file_manager::Volume>> volume_list =
       file_manager::VolumeManager::Get(browser_context)->GetVolumeList();
 
@@ -239,7 +236,6 @@ void DispatchVolumeListChangeEvent(content::BrowserContext* browser_context) {
             file_system::OnVolumeListChanged::kEventName,
             file_system::OnVolumeListChanged::Create(event_args)));
   }
-#endif
 }
 
 }  // namespace file_system_api
@@ -340,7 +336,6 @@ void ChromeFileSystemDelegate::RequestFileSystem(
     bool writable,
     const FileSystemCallback& success_callback,
     const ErrorCallback& error_callback) {
-#if defined(OS_CHROMEOS)
   ConsentProviderDelegate consent_provider_delegate(
       Profile::FromBrowserContext(browser_context));
   ConsentProvider consent_provider(&consent_provider_delegate);
@@ -396,7 +391,6 @@ void ChromeFileSystemDelegate::RequestFileSystem(
 
   consent_provider.RequestConsent(extension, requester->render_frame_host(),
                                   volume, writable, callback);
-#endif
 }
 
 void ChromeFileSystemDelegate::GetVolumeList(
@@ -404,7 +398,6 @@ void ChromeFileSystemDelegate::GetVolumeList(
     const Extension& extension,
     const VolumeListCallback& success_callback,
     const ErrorCallback& error_callback) {
-#if defined(OS_CHROMEOS)
   ConsentProviderDelegate consent_provider_delegate(
       Profile::FromBrowserContext(browser_context));
   ConsentProvider consent_provider(&consent_provider_delegate);
@@ -416,7 +409,6 @@ void ChromeFileSystemDelegate::GetVolumeList(
   GetVolumeListForExtension(volume_list, &consent_provider, extension,
                             &result_volume_list);
   success_callback.Run(result_volume_list);
-#endif
 }
 
 #endif  // defined(OS_LINUX) && defined(USE_OZONE)
diff --git a/chrome/browser/extensions/api/file_system/consent_provider.cc b/chrome/browser/extensions/api/file_system/consent_provider.cc
index e090f809c45c8..e6d0a5d8ffff5 100644
--- a/chrome/browser/extensions/api/file_system/consent_provider.cc
+++ b/chrome/browser/extensions/api/file_system/consent_provider.cc
@@ -229,13 +229,11 @@ void ConsentProviderDelegate::ShowDialog(
     return;
   }
 
-#if defined(OS_CHROMEOS)
   RequestFileSystemDialogView::ShowDialog(
       web_contents, extension.name(),
       (volume->volume_label().empty() ? volume->volume_id()
                                       : volume->volume_label()),
       writable, callback);
-#endif
 }
 
 #if defined(OS_CHROMEOS)
diff --git a/chrome/browser/ui/BUILD.gn b/chrome/browser/ui/BUILD.gn
index 92f8a396ae98a..052492bd41b36 100644
--- a/chrome/browser/ui/BUILD.gn
+++ b/chrome/browser/ui/BUILD.gn
@@ -1889,8 +1889,6 @@ jumbo_split_static_library("ui") {
       "views/apps/chrome_native_app_window_views_aura_ash.cc",
       "views/apps/chrome_native_app_window_views_aura_ash.h",
       "views/chrome_views_delegate_chromeos.cc",
-      "views/extensions/request_file_system_dialog_view.cc",
-      "views/extensions/request_file_system_dialog_view.h",
       "views/frame/browser_frame_ash.cc",
       "views/frame/browser_frame_ash.h",
       "views/frame/browser_frame_mash.cc",
@@ -1913,11 +1911,6 @@ jumbo_split_static_library("ui") {
       "views/platform_keys_certificate_selector_chromeos.cc",
       "views/platform_keys_certificate_selector_chromeos.h",
 
-      # On chromeos, file manager extension handles the file open/save dialog.
-      "views/select_file_dialog_extension.cc",
-      "views/select_file_dialog_extension.h",
-      "views/select_file_dialog_extension_factory.cc",
-      "views/select_file_dialog_extension_factory.h",
       "webui/chromeos/assistant_optin/assistant_optin_handler.cc",
       "webui/chromeos/assistant_optin/assistant_optin_handler.h",
       "webui/chromeos/assistant_optin/assistant_optin_screen_exit_code.h",
@@ -2204,6 +2197,19 @@ jumbo_split_static_library("ui") {
     }
   }
 
+  if (use_ozone && is_linux) {
+    assert(enable_extensions)
+    sources += [
+      # On chromeos and linux ozone, file manager extension handles the file open/save dialog.
+      "views/select_file_dialog_extension.cc",
+      "views/select_file_dialog_extension.h",
+      "views/select_file_dialog_extension_factory.cc",
+      "views/select_file_dialog_extension_factory.h",
+      "views/extensions/request_file_system_dialog_view.cc",
+      "views/extensions/request_file_system_dialog_view.h",
+    ]
+  }
+
   if (is_win || is_mac || is_desktop_linux || is_chromeos) {
     sources += [
       "signin_view_controller.cc",
diff --git a/chrome/browser/ui/views/chrome_browser_main_extra_parts_views.cc b/chrome/browser/ui/views/chrome_browser_main_extra_parts_views.cc
index dcbb4b65490cc..a5c40075945b6 100644
--- a/chrome/browser/ui/views/chrome_browser_main_extra_parts_views.cc
+++ b/chrome/browser/ui/views/chrome_browser_main_extra_parts_views.cc
@@ -51,6 +51,11 @@
 #include "ui/base/l10n/l10n_util.h"
 #endif  // defined(OS_LINUX) && !defined(OS_CHROMEOS)
 
+#if defined(OS_LINUX) && defined(USE_OZONE)
+#include "chrome/browser/ui/views/select_file_dialog_extension.h"
+#include "chrome/browser/ui/views/select_file_dialog_extension_factory.h"
+#endif
+
 ChromeBrowserMainExtraPartsViews::ChromeBrowserMainExtraPartsViews() {
 }
 
@@ -113,6 +118,10 @@ void ChromeBrowserMainExtraPartsViews::PreProfileInit() {
 #endif
 
 #if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(USE_OZONE)
+  ui::SelectFileDialog::SetFactory(new SelectFileDialogExtensionFactory);
+#endif
+
   // On the Linux desktop, we want to prevent the user from logging in as root,
   // so that we don't destroy the profile. Now that we have some minimal ui
   // initialized, check to see if we're running as root and bail if we are.
diff --git a/chrome/browser/ui/views/select_file_dialog_extension.cc b/chrome/browser/ui/views/select_file_dialog_extension.cc
index 0f3aac219fad4..8f335c3b9d61c 100644
--- a/chrome/browser/ui/views/select_file_dialog_extension.cc
+++ b/chrome/browser/ui/views/select_file_dialog_extension.cc
@@ -14,7 +14,6 @@
 #include "base/threading/thread_task_runner_handle.h"
 #include "chrome/browser/app_mode/app_mode_utils.h"
 #include "chrome/browser/apps/platform_apps/app_window_registry_util.h"
-#include "chrome/browser/chromeos/login/ui/login_web_dialog.h"
 #include "chrome/browser/extensions/extension_service.h"
 #include "chrome/browser/extensions/extension_view_host.h"
 #include "chrome/browser/file_manager/app_id.h"
@@ -42,6 +41,7 @@
 
 #if defined(OS_CHROMEOS)
 #include "chrome/browser/chromeos/login/ui/login_display_host.h"
+#include "chrome/browser/chromeos/login/ui/login_web_dialog.h"
 #include "chrome/browser/chromeos/login/ui/webui_login_view.h"
 #include "chrome/browser/chromeos/profiles/profile_helper.h"
 #endif
@@ -146,13 +146,13 @@ void FindRuntimeContext(gfx::NativeWindow owner_window,
     }
   }
 
+#if defined(OS_CHROMEOS)
   // In ChromeOS kiosk launch mode, we can still show file picker for
   // certificate manager dialog. There are no browser or webapp window
   // instances present in this case.
   if (chrome::IsRunningInForcedAppMode() && !(*web_contents))
     *web_contents = chromeos::LoginWebDialog::GetCurrentWebContents();
 
-#if defined(OS_CHROMEOS)
   // Check for a WebContents used for the Chrome OS WebUI login flow.
   if (!*web_contents)
     *web_contents = GetLoginWebContents();
diff --git a/content/browser/browser_context.cc b/content/browser/browser_context.cc
index 840cafc185f46..c8b484202fef4 100644
--- a/content/browser/browser_context.cc
+++ b/content/browser/browser_context.cc
@@ -113,9 +113,9 @@ const char kServiceUserId[] = "service-user-id";
 const char kStoragePartitionMapKeyName[] = "content_storage_partition_map";
 const char kVideoDecodePerfHistoryId[] = "video-decode-perf-history";
 
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
 const char kMountPointsKey[] = "mount_points";
-#endif  // defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) && defined(USE_OZONE)
 
 void RemoveBrowserContextFromUserIdMap(BrowserContext* browser_context) {
   ServiceUserIdHolder* holder = static_cast<ServiceUserIdHolder*>(
@@ -256,7 +256,7 @@ storage::ExternalMountPoints* BrowserContext::GetMountPoints(
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI) ||
          !BrowserThread::IsThreadInitialized(BrowserThread::UI));
 
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
   if (!context->GetUserData(kMountPointsKey)) {
     scoped_refptr<storage::ExternalMountPoints> mount_points =
         storage::ExternalMountPoints::CreateRefCounted();
diff --git a/extensions/browser/api/file_system/file_system_api.cc b/extensions/browser/api/file_system/file_system_api.cc
index 1620ea8c34537..38b88a7b06762 100644
--- a/extensions/browser/api/file_system/file_system_api.cc
+++ b/extensions/browser/api/file_system/file_system_api.cc
@@ -87,7 +87,7 @@ const char kRetainEntryError[] = "Could not retain file entry.";
 const char kRetainEntryIncognitoError[] =
     "Could not retain file entry in incognito mode";
 
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && defined(USE_OZONE)
 const char kNotSupportedOnNonKioskSessionError[] =
     "Operation only supported for kiosk apps running in a kiosk session.";
 #endif
@@ -929,7 +929,7 @@ ExtensionFunction::ResponseAction FileSystemGetObservedEntriesFunction::Run() {
   return RespondNow(Error(kUnknownIdError));
 }
 
-#if !defined(OS_CHROMEOS)
+#if !(defined(OS_LINUX) && defined(USE_OZONE))
 ExtensionFunction::ResponseAction FileSystemRequestFileSystemFunction::Run() {
   using file_system::RequestFileSystem::Params;
   const std::unique_ptr<Params> params(Params::Create(*args_));
diff --git a/extensions/browser/api/file_system/file_system_api.h b/extensions/browser/api/file_system/file_system_api.h
index efa3d0f80bc38..2145ee53d91b8 100644
--- a/extensions/browser/api/file_system/file_system_api.h
+++ b/extensions/browser/api/file_system/file_system_api.h
@@ -246,7 +246,7 @@ class FileSystemGetObservedEntriesFunction : public UIThreadExtensionFunction {
   ResponseAction Run() override;
 };
 
-#if !defined(OS_CHROMEOS)
+#if !(defined(OS_LINUX) && defined(USE_OZONE))
 // Stub for non Chrome OS operating systems.
 class FileSystemRequestFileSystemFunction : public UIThreadExtensionFunction {
  public:
