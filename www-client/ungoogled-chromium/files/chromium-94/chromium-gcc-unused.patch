--- chromium-64.0.3282.71/third_party/blink/renderer/platform/graphics/darkmode/darkmode_classifier.cc.gcc7	2018-01-04 00:06:32.000000000 +0100
+++ chromium-64.0.3282.71/third_party/blink/renderer/platform/graphics/darkmode/darkmode_classifier.cc	2018-01-07 22:06:16.757401299 +0100
@@ -1127,7 +1127,6 @@
     ,
     FixedAllocations* __restrict fixed) {
   const int32_t input0_shape[] = {1, 4};
-  int32_t logits_MatMul_merged_with_dnn_logits_BiasAdd0_shape[2];
 
   // dnn/hiddenlayer_0/MatMul_merged_with_dnn/hiddenlayer_0/BiasAdd
   FullyConnected<float>(input0_shape, input0,
@@ -1150,8 +1149,6 @@
       dnn_logits_weights_part_0.values, dnn_logits_biases_part_0_shape,
       dnn_logits_biases_part_0.values,
       logits_MatMul_merged_with_dnn_logits_BiasAdd0);
-  logits_MatMul_merged_with_dnn_logits_BiasAdd0_shape[0] = 1;
-  logits_MatMul_merged_with_dnn_logits_BiasAdd0_shape[1] = 1;
 }
 
 }  // namespace darkmode_tfnative_model
--- chromium-67.0.3396.10/third_party/blink/renderer/core/page/focus_controller.cc.gcc7	2018-04-18 21:05:40.000000000 +0200
+++ chromium-67.0.3396.10/third_party/blink/renderer/core/page/focus_controller.cc	2018-04-22 23:10:03.717765400 +0200
@@ -201,9 +201,6 @@ class ScopedFocusNavigation {
   static ScopedFocusNavigation OwnedByIFrame(const HTMLFrameOwnerElement&,
                                              FocusController::OwnerMap&);
   static HTMLSlotElement* FindFallbackScopeOwnerSlot(const Element&);
-  static bool IsSlotFallbackScoped(const Element&);
-  static bool IsSlotFallbackScopedForThisSlot(const HTMLSlotElement&,
-                                              const Element&);
 
  private:
   ScopedFocusNavigation(ContainerNode& scoping_root_node,
@@ -334,25 +331,6 @@ HTMLSlotElement* ScopedFocusNavigation::
   return nullptr;
 }
 
-bool ScopedFocusNavigation::IsSlotFallbackScoped(const Element& element) {
-  return ScopedFocusNavigation::FindFallbackScopeOwnerSlot(element);
-}
-
-bool ScopedFocusNavigation::IsSlotFallbackScopedForThisSlot(
-    const HTMLSlotElement& slot,
-    const Element& current) {
-  Element* parent = current.parentElement();
-  while (parent) {
-    auto* html_slot_element = DynamicTo<HTMLSlotElement>(parent);
-    if (html_slot_element && html_slot_element->AssignedNodes().IsEmpty()) {
-      return !SlotScopedTraversal::IsSlotScoped(current) &&
-             html_slot_element == slot;
-    }
-    parent = parent->parentElement();
-  }
-  return false;
-}
-
 inline void DispatchBlurEvent(const Document& document,
                               Element& focused_element) {
   focused_element.DispatchBlurEvent(nullptr, mojom::blink::FocusType::kPage);
--- chromium-69.0.3497.4/content/browser/renderer_host/input/mouse_wheel_event_queue.cc.gcc7	2018-07-21 09:13:03.000000000 +0200
+++ chromium-69.0.3497.4/content/browser/renderer_host/input/mouse_wheel_event_queue.cc	2018-07-21 23:53:41.085484269 +0200
@@ -178,13 +178,11 @@
     bool current_phase_ended = false;
     bool scroll_phase_ended = false;
     bool momentum_phase_ended = false;
-    bool has_phase_info = false;
 
     if (event_sent_for_gesture_ack_->event.phase !=
             blink::WebMouseWheelEvent::kPhaseNone ||
         event_sent_for_gesture_ack_->event.momentum_phase !=
             blink::WebMouseWheelEvent::kPhaseNone) {
-      has_phase_info = true;
       scroll_phase_ended = event_sent_for_gesture_ack_->event.phase ==
                                blink::WebMouseWheelEvent::kPhaseEnded ||
                            event_sent_for_gesture_ack_->event.phase ==
--- chromium-70.0.3528.4/content/browser/media/capture/mouse_cursor_overlay_controller_aura.cc.gcc8	2018-08-21 11:49:37.000000000 +0200
+++ chromium-70.0.3528.4/content/browser/media/capture/mouse_cursor_overlay_controller_aura.cc	2018-08-28 16:24:08.166914370 +0200
@@ -169,7 +169,7 @@ gfx::RectF MouseCursorOverlayController:
   if (auto* window = Observer::GetTargetWindow(observer_)) {
     const gfx::Size window_size = window->bounds().size();
     if (!window_size.IsEmpty()) {
-      if (auto* root_window = window->GetRootWindow()) {
+      if (window->GetRootWindow()) {
         const SkBitmap& bitmap = GetCursorBitmap(cursor);
         const float scale_factor = cursor.image_scale_factor();
         DCHECK_GT(scale_factor, 0.0f);
--- chromium-70.0.3538.22/components/viz/host/gpu_host_impl.cc.gcc8	2018-09-19 21:10:42.000000000 +0200
+++ chromium-70.0.3538.22/components/viz/host/gpu_host_impl.cc	2018-09-23 22:14:53.434515786 +0200
@@ -55,7 +55,6 @@ class FontRenderParams {
   friend class base::NoDestructor<FontRenderParams>;
 
   FontRenderParams();
-  ~FontRenderParams();
 
   THREAD_CHECKER(thread_checker_);
   absl::optional<gfx::FontRenderParams> params_;
@@ -80,10 +79,6 @@ const absl::optional<gfx::FontRenderPara
 
 FontRenderParams::FontRenderParams() = default;
 
-FontRenderParams::~FontRenderParams() {
-  NOTREACHED();
-}
-
 FontRenderParams& GetFontRenderParams() {
   static base::NoDestructor<FontRenderParams> instance;
   return *instance;
--- chromium-70.0.3538.22/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc.gcc8	2018-09-19 21:11:35.000000000 +0200
+++ chromium-70.0.3538.22/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc	2018-09-24 22:40:30.244928180 +0200
@@ -5534,10 +5534,6 @@ void WebGLRenderingContextBase::TexImage
     possible_direct_copy = Extensions3DUtil::CanUseCopyTextureCHROMIUM(target);
   }
 
-  GLint copy_x_offset = xoffset;
-  GLint copy_y_offset = yoffset;
-  GLenum copy_target = target;
-
   // if direct copy is not possible, create a temporary texture and then copy
   // from canvas to temporary texture to target texture.
   if (!possible_direct_copy) {
@@ -5553,9 +5549,6 @@ void WebGLRenderingContextBase::TexImage
                                GL_CLAMP_TO_EDGE);
     ContextGL()->TexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0,
                             GL_RGBA, GL_UNSIGNED_BYTE, nullptr);
-    copy_x_offset = 0;
-    copy_y_offset = 0;
-    copy_target = GL_TEXTURE_2D;
   }
 
   {
@@ -5921,12 +5914,6 @@ void WebGLRenderingContextBase::TexImage
     return;
   }
 
-  TexImageFunctionType function_type;
-  if (function_id == kTexImage2D || function_id == kTexImage3D)
-    function_type = kTexImage;
-  else
-    function_type = kTexSubImage;
-
   // The CopyTexImage fast paths can't handle orientation, so if a non-default
   // orientation is provided, we must disable them.
   const auto transform = media_video_frame->metadata().transformation.value_or(
--- chromium-72.0.3626.81/third_party/blink/renderer/core/editing/element_inner_text.cc.gcc8	2019-01-30 02:18:14.000000000 +0100
+++ chromium-72.0.3626.81/third_party/blink/renderer/core/editing/element_inner_text.cc	2019-02-03 17:03:47.484469962 +0100
@@ -52,7 +52,6 @@ class ElementInnerTextCollector final {
    public:
     Result() = default;
 
-    void EmitChar16(UChar code_point);
     void EmitNewline();
     void EmitRequiredLineBreak(int count);
     void EmitTab();
@@ -420,12 +405,6 @@ void ElementInnerTextCollector::ProcessT
 
 // ----
 
-void ElementInnerTextCollector::Result::EmitChar16(UChar code_point) {
-  FlushRequiredLineBreak();
-  DCHECK_EQ(required_line_break_count_, 0);
-  builder_.Append(code_point);
-}
-
 void ElementInnerTextCollector::Result::EmitNewline() {
   FlushRequiredLineBreak();
   builder_.Append(kNewlineCharacter);
--- chromium-73.0.3683.75/cc/trees/layer_tree_host.cc.gcc8	2019-03-11 23:00:52.000000000 +0100
+++ chromium-73.0.3683.75/cc/trees/layer_tree_host.cc	2019-03-17 19:34:15.025887235 +0100
@@ -1222,8 +1222,6 @@ void LayerTreeHost::SetViewportRectAndSc
     const gfx::Rect& device_viewport_rect,
     float device_scale_factor,
     const viz::LocalSurfaceId& local_surface_id_from_parent) {
-  const viz::LocalSurfaceId previous_local_surface_id =
-      local_surface_id_from_parent_;
   SetLocalSurfaceIdFromParent(local_surface_id_from_parent);
 
   TRACE_EVENT_NESTABLE_ASYNC_END0("cc", "LayerTreeHostSize",
--- chromium-74.0.3729.40/third_party/vulkan-deps/glslang/src/SPIRV/SpvPostProcess.cpp.gcc8	2019-03-27 19:52:46.000000000 +0100
+++ chromium-74.0.3729.40/third_party/vulkan-deps/glslang/src/SPIRV/SpvPostProcess.cpp	2019-03-30 19:37:45.068435622 +0100
@@ -256,9 +256,7 @@ void Builder::postProcess(Instruction& i
                     }
                 }
                 assert(inst.getNumOperands() >= 3);
-                unsigned int memoryAccess = inst.getImmediateOperand((inst.getOpCode() == OpStore) ? 2 : 1);
-                assert(memoryAccess & MemoryAccessAlignedMask);
-                static_cast<void>(memoryAccess);
+                assert(inst.getImmediateOperand((inst.getOpCode() == OpStore) ? 2 : 1) & MemoryAccessAlignedMask);
                 // Compute the index of the alignment operand.
                 int alignmentIdx = 2;
                 if (inst.getOpCode() == OpStore)
--- chromium-74.0.3729.40/third_party/nasm/asm/nasm.c.gcc8	2019-03-27 19:52:48.000000000 +0100
+++ chromium-74.0.3729.40/third_party/nasm/asm/nasm.c	2019-03-30 19:45:26.195518119 +0100
@@ -421,26 +421,6 @@ static void emit_dependencies(struct str
         fclose(deps);
 }
 
-/* Convert a struct tm to a POSIX-style time constant */
-static int64_t make_posix_time(const struct tm *tm)
-{
-    int64_t t;
-    int64_t y = tm->tm_year;
-
-    /* See IEEE 1003.1:2004, section 4.14 */
-
-    t = (y-70)*365 + (y-69)/4 - (y-1)/100 + (y+299)/400;
-    t += tm->tm_yday;
-    t *= 24;
-    t += tm->tm_hour;
-    t *= 60;
-    t += tm->tm_min;
-    t *= 60;
-    t += tm->tm_sec;
-
-    return t;
-}
-
 /*
  * Quote a filename string if and only if it is necessary.
  * It is considered necessary if any one of these is true:
--- chromium-75.0.3766.2/mojo/core/channel.cc.gcc8	2019-04-16 03:14:06.000000000 +0200
+++ chromium-75.0.3766.2/mojo/core/channel.cc	2019-04-21 07:15:42.489256150 +0200
@@ -640,8 +640,6 @@ Channel::DispatchResult Channel::TryDisp
   TRACE_EVENT(TRACE_DISABLED_BY_DEFAULT("toplevel.ipc"),
               "Mojo dispatch message");
 
-  bool did_consume_message = false;
-
   // We have at least enough data available for a LegacyHeader.
   const Message::LegacyHeader* legacy_header =
       reinterpret_cast<const Message::LegacyHeader*>(buffer.data());
@@ -716,12 +714,9 @@ Channel::DispatchResult Channel::TryDisp
                           std::move(handles))) {
       return DispatchResult::kError;
     }
-    did_consume_message = true;
   } else if (deferred) {
-    did_consume_message = true;
   } else if (delegate_) {
     delegate_->OnChannelMessage(payload, payload_size, std::move(handles));
-    did_consume_message = true;
   }
 
   *size_hint = legacy_header->num_bytes;
--- chromium-75.0.3766.2/third_party/blink/renderer/platform/loader/fetch/resource_load_scheduler.cc.gcc8	2019-04-16 03:14:09.000000000 +0200
+++ chromium-75.0.3766.2/third_party/blink/renderer/platform/loader/fetch/resource_load_scheduler.cc	2019-04-22 13:54:48.119685210 +0200
@@ -529,13 +529,10 @@ void ResourceLoadScheduler::ShowConsoleM
     return;
 
   const base::Time limit = clock_->Now() - base::TimeDelta::FromSeconds(60);
-  ThrottleOption target_option;
   if (pending_queue_update_times_[ThrottleOption::kThrottleable] < limit &&
       !IsPendingRequestEffectivelyEmpty(ThrottleOption::kThrottleable)) {
-    target_option = ThrottleOption::kThrottleable;
   } else if (pending_queue_update_times_[ThrottleOption::kStoppable] < limit &&
              !IsPendingRequestEffectivelyEmpty(ThrottleOption::kStoppable)) {
-    target_option = ThrottleOption::kStoppable;
   } else {
     // At least, one of the top requests in pending queues was handled in the
     // last 1 minutes, or there is no pending requests in the inactive queue.
--- chromium-76.0.3809.46/third_party/blink/renderer/core/editing/commands/insert_paragraph_separator_command.cc.gcc8	2019-06-27 23:59:38.000000000 +0200
+++ chromium-76.0.3809.46/third_party/blink/renderer/core/editing/commands/insert_paragraph_separator_command.cc	2019-07-02 23:33:01.266250287 +0200
@@ -596,8 +596,7 @@ void InsertParagraphSeparatorCommand::Do
                  ->CollapseWhiteSpace())
           << position_after_split;
       DeleteInsignificantTextDownstream(position_after_split);
-      if (auto* is_text_node =
-              DynamicTo<Text>(position_after_split.AnchorNode())) {
+      if (DynamicTo<Text>(position_after_split.AnchorNode())) {
         InsertTextIntoNode(
             To<Text>(position_after_split.ComputeContainerNode()), 0,
             NonBreakingSpaceString());
--- chromium-76.0.3809.46/third_party/blink/renderer/core/layout/layout_text.cc.gcc8	2019-06-27 23:59:38.000000000 +0200
+++ chromium-76.0.3809.46/third_party/blink/renderer/core/layout/layout_text.cc	2019-07-03 00:37:29.459935571 +0200
@@ -657,9 +657,6 @@ void LayoutText::AbsoluteQuadsForRange(V
 
     // Find fragments that have text for the specified range.
     DCHECK_LE(start, end);
-    const LayoutBlock* block_for_flipping = nullptr;
-    if (UNLIKELY(HasFlippedBlocksWritingMode()))
-      block_for_flipping = ContainingBlock();
     NGInlineCursor cursor;
     bool is_last_end_included = false;
     for (cursor.MoveTo(*this); cursor; cursor.MoveToNextForSameLayoutObject()) {
--- chromium-77.0.3865.10/base/task/sequence_manager/task_queue_impl.cc.gcc9	2019-08-06 13:56:01.000000000 +0200
+++ chromium-77.0.3865.10/base/task/sequence_manager/task_queue_impl.cc	2019-08-17 21:00:20.384139512 +0200
@@ -1298,11 +1298,9 @@ void TaskQueueImpl::MaybeReportIpcTaskQu
     return;
 
   base::TimeDelta time_since_disabled;
-  bool should_report = false;
   {
     base::internal::CheckedAutoLock lock(any_thread_lock_);
-    should_report =
-        ShouldReportIpcTaskQueuedFromAnyThreadLocked(&time_since_disabled);
+    (void)ShouldReportIpcTaskQueuedFromAnyThreadLocked(&time_since_disabled);
   }
 
   ReportIpcTaskQueued(pending_task, task_queue_name, time_since_disabled);
--- chromium-77.0.3865.10/third_party/webrtc/test/fake_encoder.cc.gcc9	2019-08-06 13:58:31.000000000 +0200
+++ chromium-77.0.3865.10/third_party/webrtc/test/fake_encoder.cc	2019-08-17 23:14:49.202586641 +0200
@@ -95,7 +95,6 @@ int32_t FakeEncoder::Encode(const VideoF
   SpatialLayer simulcast_streams[kMaxSimulcastStreams];
   EncodedImageCallback* callback;
   RateControlParameters rates;
-  VideoCodecMode mode;
   bool keyframe;
   uint32_t counter;
   absl::optional<int> qp;
@@ -108,7 +107,6 @@ int32_t FakeEncoder::Encode(const VideoF
     }
     callback = callback_;
     rates = current_rate_settings_;
-    mode = config_.mode;
     if (rates.framerate_fps <= 0.0) {
       rates.framerate_fps = max_framerate;
     }
--- chromium-77.0.3865.35/net/http/http_auth_cache.cc.gcc9	2019-08-15 00:02:10.000000000 +0200
+++ chromium-77.0.3865.35/net/http/http_auth_cache.cc	2019-08-18 02:50:38.419252330 +0200
@@ -166,7 +166,6 @@ HttpAuthCache::Entry* HttpAuthCache::Add
   HttpAuthCache::Entry* entry =
       Lookup(origin, target, realm, scheme, network_isolation_key);
   if (!entry) {
-    bool evicted = false;
     // Failsafe to prevent unbounded memory growth of the cache.
     //
     // Data was collected in June of 2019, before entries were keyed on either
@@ -178,7 +177,6 @@ HttpAuthCache::Entry* HttpAuthCache::Add
     if (entries_.size() >= kMaxNumRealmEntries) {
       DLOG(WARNING) << "Num auth cache entries reached limit -- evicting";
       EvictLeastRecentlyUsedEntry();
-      evicted = true;
     }
     entry = &(entries_
                   .emplace(std::make_pair(
@@ -244,7 +242,6 @@ void HttpAuthCache::Entry::AddPath(const
     // Remove any entries that have been subsumed by the new entry.
     base::EraseIf(paths_, IsEnclosedBy(parent_dir));
 
-    bool evicted = false;
     // Failsafe to prevent unbounded memory growth of the cache.
     //
     // Data collected on June of 2019 indicate that when we get here, the list
@@ -253,7 +250,6 @@ void HttpAuthCache::Entry::AddPath(const
       DLOG(WARNING) << "Num path entries for " << origin()
                     << " has grown too large -- evicting";
       paths_.pop_back();
-      evicted = true;
     }
 
     // Add new path.
--- chromium-77.0.3865.35/chrome/browser/download/download_offline_content_provider.cc.gcc9	2019-08-15 00:02:00.000000000 +0200
+++ chromium-77.0.3865.35/chrome/browser/download/download_offline_content_provider.cc	2019-08-18 20:59:18.412269604 +0200
@@ -92,10 +92,6 @@ class AllDownloadObserver
   DISALLOW_COPY_AND_ASSIGN(AllDownloadObserver);
 };
 
-AllDownloadObserver::AllDownloadObserver(
-    DownloadOfflineContentProvider* provider)
-    : provider_(provider) {}
-
 AllDownloadObserver::~AllDownloadObserver() {}
 
 void AllDownloadObserver::OnDownloadUpdated(
--- chromium-77.0.3865.35/third_party/blink/renderer/core/input/event_handler.cc.gcc7	2019-08-15 00:02:12.000000000 +0200
+++ chromium-77.0.3865.35/third_party/blink/renderer/core/input/event_handler.cc	2019-08-20 04:02:47.873682429 +0200
@@ -1387,13 +1387,6 @@ void EventHandler::ReleasePointerCapture
       LocalFrame* frame = frame_;
       LocalFrame* parent = DynamicTo<LocalFrame>(frame_->Tree().Parent());
       while (parent) {
-        Element* subframe_element = nullptr;
-        if (frame->OwnerLayoutObject() &&
-            frame->OwnerLayoutObject()->GetNode()) {
-          subframe_element =
-              DynamicTo<Element>(frame->OwnerLayoutObject()->GetNode());
-        }
-
         parent->GetEventHandler().capturing_subframe_element_ = nullptr;
         frame = parent;
         parent = DynamicTo<LocalFrame>(parent->Tree().Parent());
--- chromium-77.0.3865.35/third_party/blink/renderer/core/input/event_handler.cc.gcc9	2019-08-20 04:02:47.873682429 +0200
+++ chromium-77.0.3865.35/third_party/blink/renderer/core/input/event_handler.cc	2019-08-20 04:46:11.073469964 +0200
@@ -1384,11 +1384,9 @@ void EventHandler::ReleasePointerCapture
     // approach for removing mouse subframe capture. It must be re-write
     // before enable the flag.
     if (RuntimeEnabledFeatures::MouseSubframeNoImplicitCaptureEnabled()) {
-      LocalFrame* frame = frame_;
       LocalFrame* parent = DynamicTo<LocalFrame>(frame_->Tree().Parent());
       while (parent) {
         parent->GetEventHandler().capturing_subframe_element_ = nullptr;
-        frame = parent;
         parent = DynamicTo<LocalFrame>(parent->Tree().Parent());
       }
     }
--- chromium-78.0.3904.9/base/containers/intrusive_heap.h.gcc9	2019-09-12 05:02:49.000000000 +0200
+++ chromium-78.0.3904.9/base/containers/intrusive_heap.h	2019-09-13 06:34:33.055830792 +0200
@@ -458,7 +458,6 @@ class IntrusiveHeap {
   // General operations.
 
   void swap(IntrusiveHeap& other) noexcept;
-  friend void swap(IntrusiveHeap& lhs, IntrusiveHeap& rhs) { lhs.swap(rhs); }
 
   // Comparison operators. These check for exact equality. Two heaps that are
   // semantically equivalent (contain the same elements, but in different
--- chromium-79.0.3945.16/third_party/angle/src/libANGLE/renderer/vulkan/RenderbufferVk.cpp.gcc9	2019-10-29 23:03:40.000000000 +0100
+++ chromium-79.0.3945.16/third_party/angle/src/libANGLE/renderer/vulkan/RenderbufferVk.cpp	2019-11-03 19:12:07.291357114 +0100
@@ -206,14 +206,6 @@ angle::Result RenderbufferVk::setStorage
                                      rendererQueueFamilyIndex, commandBuffer);
     }
 
-    gl::TextureType viewType = imageVk->getImageTextureType();
-
-    if (imageVk->getImageTextureType() == gl::TextureType::CubeMap)
-    {
-        viewType = vk::Get2DTextureType(imageVk->getImage()->getLayerCount(),
-                                        imageVk->getImage()->getSamples());
-    }
-
     mRenderTarget.init(mImage, &mImageViews, nullptr, nullptr, imageVk->getImageLevel(),
                        imageVk->getImageLayer(), 1, RenderTargetTransience::Default);
 
--- chromium-79.0.3945.16/third_party/blink/renderer/core/css/style_engine.cc.gcc9	2019-10-29 23:02:05.000000000 +0100
+++ chromium-79.0.3945.16/third_party/blink/renderer/core/css/style_engine.cc	2019-11-06 22:56:38.979966457 +0100
@@ -1832,7 +1832,7 @@ void StyleEngine::UpdateStyleAndLayoutTr
 
   UpdateViewportStyle();
 
-  if (Element* document_element = GetDocument().documentElement()) {
+  if (GetDocument().documentElement()) {
     NthIndexCache nth_index_cache(GetDocument());
     if (NeedsStyleRecalc()) {
       TRACE_EVENT0("blink,blink_style", "Document::recalcStyle");
--- chromium-79.0.3945.16/third_party/blink/renderer/core/svg/svg_animate_element.cc.gcc9	2019-10-29 23:02:06.000000000 +0100
+++ chromium-79.0.3945.16/third_party/blink/renderer/core/svg/svg_animate_element.cc	2019-11-07 23:43:50.755662393 +0100
@@ -204,7 +204,7 @@ void SVGAnimateElement::ClearTargetPrope
 }
 
 void SVGAnimateElement::UpdateTargetProperty() {
-  if (SVGElement* target = targetElement())
+  if (targetElement())
     ResolveTargetProperty();
   else
     ClearTargetProperty();
--- chromium-80.0.3987.78/third_party/webrtc/modules/audio_processing/agc/legacy/digital_agc.cc.gcc9	2020-01-29 22:41:13.000000000 +0100
+++ chromium-80.0.3987.78/third_party/webrtc/modules/audio_processing/agc/legacy/digital_agc.cc	2020-02-02 00:30:40.476523534 +0100
@@ -288,15 +288,12 @@ int32_t WebRtcAgc_ComputeDigitalGains(Di
   int16_t gate, gain_adj;
   int16_t k;
   size_t n, L;
-  int16_t L2;  // samples/subframe
 
   // determine number of samples per ms
   if (FS == 8000) {
     L = 8;
-    L2 = 3;
   } else if (FS == 16000 || FS == 32000 || FS == 48000) {
     L = 16;
-    L2 = 4;
   } else {
     return -1;
   }
--- chromium-80.0.3987.78/components/sync/engine/net/sync_server_connection_manager.cc.gcc9	2020-01-29 22:39:37.000000000 +0100
+++ chromium-80.0.3987.78/components/sync/engine/net/sync_server_connection_manager.cc	2020-02-02 03:58:04.935282175 +0100
@@ -176,20 +176,6 @@ bool Connection::ReadBufferResponse(std:
   return true;
 }
 
-bool Connection::ReadDownloadResponse(HttpResponse* response,
-                                      std::string* buffer_out) {
-  const int64_t bytes_read =
-      ReadResponse(buffer_out, static_cast<int>(response->content_length));
-
-  if (bytes_read != response->content_length) {
-    LOG(ERROR) << "Mismatched content lengths, server claimed "
-               << response->content_length << ", but sent " << bytes_read;
-    response->server_status = HttpResponse::IO_ERROR;
-    return false;
-  }
-  return true;
-}
-
 int Connection::ReadResponse(std::string* out_buffer, int length) const {
   int bytes_read = buffer_.length();
   CHECK_LE(length, bytes_read);
--- chromium-81.0.4044.43/third_party/angle/src/libANGLE/renderer/vulkan/vk_cache_utils.cpp.gcc9	2020-03-09 18:39:40.384301268 +0100
+++ chromium-81.0.4044.43/third_party/angle/src/libANGLE/renderer/vulkan/vk_cache_utils.cpp	2020-03-09 19:23:20.074519726 +0100
@@ -1852,11 +1852,8 @@ angle::Result GraphicsPipelineDesc::init
         pNextPtr                       = &depthClipState.pNext;
     }
 
-    VkPipelineRasterizationStateStreamCreateInfoEXT rasterStreamState = {};
-    rasterStreamState.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT;
     if (contextVk->getFeatures().supportsTransformFeedbackExtension.enabled)
     {
-        rasterStreamState.rasterizationStream = 0;
         rasterState.pNext                     = &rasterLineState;
     }
 
--- chromium-83.0.4103.14/third_party/blink/renderer/core/display_lock/display_lock_context.cc.gcc9	2020-04-14 23:56:28.000000000 +0200
+++ chromium-83.0.4103.14/third_party/blink/renderer/core/display_lock/display_lock_context.cc	2020-04-19 21:30:04.769999443 +0200
@@ -1011,7 +1011,7 @@ bool DisplayLockContext::ForceUnlockIfNe
   // TODO(rakina): If this is after acquire's promise is resolved and update()
   // commit() isn't in progress, the web author won't know that the element
   // got unlocked. Figure out how to notify the author.
-  if (auto* reason = ShouldForceUnlock()) {
+  if (ShouldForceUnlock()) {
     if (IsLocked()) {
       Unlock();
       // If we forced unlocked, then there is a chance that layout containment
--- chromium-84.0.4147.89/ui/latency/latency_info.cc.gcc9	2020-07-13 20:41:37.000000000 +0200
+++ chromium-84.0.4147.89/ui/latency/latency_info.cc	2020-07-18 21:26:25.902621301 +0200
@@ -60,13 +60,9 @@ bool IsInputLatencyBeginComponent(ui::La
 class LatencyInfoTracedValue
     : public base::trace_event::ConvertableToTraceFormat {
  public:
-  static std::unique_ptr<ConvertableToTraceFormat> FromValue(
-      std::unique_ptr<base::Value> value);
-
   void AppendAsTraceFormat(std::string* out) const override;
 
  private:
-  explicit LatencyInfoTracedValue(base::Value* value);
   ~LatencyInfoTracedValue() override;
 
   std::unique_ptr<base::Value> value_;
@@ -74,12 +70,6 @@ class LatencyInfoTracedValue
   DISALLOW_COPY_AND_ASSIGN(LatencyInfoTracedValue);
 };
 
-std::unique_ptr<base::trace_event::ConvertableToTraceFormat>
-LatencyInfoTracedValue::FromValue(std::unique_ptr<base::Value> value) {
-  return std::unique_ptr<base::trace_event::ConvertableToTraceFormat>(
-      new LatencyInfoTracedValue(value.release()));
-}
-
 LatencyInfoTracedValue::~LatencyInfoTracedValue() {
 }
 
@@ -89,10 +79,6 @@ void LatencyInfoTracedValue::AppendAsTra
   *out += tmp;
 }
 
-LatencyInfoTracedValue::LatencyInfoTracedValue(base::Value* value)
-    : value_(value) {
-}
-
 constexpr const char kTraceCategoriesForAsyncEvents[] =
     "benchmark,latencyInfo,rail";
 
--- chromium-84.0.4147.89/content/browser/download/download_item_utils.cc.gcc10	2020-07-13 20:40:30.000000000 +0200
+++ chromium-84.0.4147.89/content/browser/download/download_item_utils.cc	2020-07-20 02:45:23.642661960 +0200
@@ -24,7 +24,6 @@ class DownloadItemData : public base::Su
                      BrowserContext* browser_context,
                      WebContents* web_contents);
   static DownloadItemData* Get(const download::DownloadItem* download_item);
-  static void Detach(download::DownloadItem* download_item);
 
   BrowserContext* browser_context() const { return browser_context_; }
 
@@ -58,11 +57,6 @@ DownloadItemData* DownloadItemData::Get(
   return static_cast<DownloadItemData*>(download_item->GetUserData(&kKey));
 }
 
-// static
-void DownloadItemData::Detach(download::DownloadItem* download_item) {
-  download_item->RemoveUserData(&kKey);
-}
-
 void DownloadItemData::WebContentsDestroyed() {
   Observe(nullptr);
 }
--- chromium-84.0.4147.89/third_party/blink/renderer/core/frame/local_frame_view.cc.gcc10	2020-07-18 05:58:51.507446199 +0200
+++ chromium-84.0.4147.89/third_party/blink/renderer/core/frame/local_frame_view.cc	2020-07-21 15:57:00.021529569 +0200
@@ -653,8 +653,7 @@ bool LocalFrameView::LayoutFromRootObjec
   if (!root.NeedsLayout())
     return false;
 
-  if (auto* locked_ancestor =
-          DisplayLockUtilities::LockedAncestorPreventingLayout(root)) {
+  if (DisplayLockUtilities::LockedAncestorPreventingLayout(root)) {
     // Note that since we're preventing the layout on a layout root, we have to
     // mark its ancestor chain for layout. The reason for this is that we will
     // clear the layout roots whether or not we have finished laying them out,
--- chromium-85.0.4183.83/third_party/angle/src/libANGLE/renderer/vulkan/ContextVk.cpp.gcc10	2020-08-30 21:27:12.520477768 +0200
+++ chromium-85.0.4183.83/third_party/angle/src/libANGLE/renderer/vulkan/ContextVk.cpp	2020-08-30 22:22:25.365489825 +0200
@@ -4011,15 +4011,6 @@ angle::Result ContextVk::getTimestamp(ui
     ANGLE_VK_TRY(this, fence.get().init(device, fenceInfo));
 
     // Submit the command buffer
-    VkSubmitInfo submitInfo         = {};
-    submitInfo.sType                = VK_STRUCTURE_TYPE_SUBMIT_INFO;
-    submitInfo.waitSemaphoreCount   = 0;
-    submitInfo.pWaitSemaphores      = nullptr;
-    submitInfo.pWaitDstStageMask    = nullptr;
-    submitInfo.commandBufferCount   = 1;
-    submitInfo.pCommandBuffers      = commandBuffer.ptr();
-    submitInfo.signalSemaphoreCount = 0;
-    submitInfo.pSignalSemaphores    = nullptr;
 
     Serial throwAwaySerial;
     ANGLE_TRY(mRenderer->queueSubmitOneOff(this, std::move(commandBuffer), mContextPriority,
--- chromium-85.0.4183.83/third_party/webrtc/video/video_stream_encoder.cc.gcc10	2020-08-30 21:27:11.384499105 +0200
+++ chromium-85.0.4183.83/third_party/webrtc/video/video_stream_encoder.cc	2020-08-31 03:32:30.910644231 +0200
@@ -1586,18 +1586,6 @@ EncodedImageCallback::Result VideoStream
   // running in parallel on different threads.
   encoder_stats_observer_->OnSendEncodedImage(image_copy, codec_specific_info);
 
-  // The simulcast id is signaled in the SpatialIndex. This makes it impossible
-  // to do simulcast for codecs that actually support spatial layers since we
-  // can't distinguish between an actual spatial layer and a simulcast stream.
-  // TODO(bugs.webrtc.org/10520): Signal the simulcast id explicitly.
-  int simulcast_id = 0;
-  if (codec_specific_info &&
-      (codec_specific_info->codecType == kVideoCodecVP8 ||
-       codec_specific_info->codecType == kVideoCodecH264 ||
-       codec_specific_info->codecType == kVideoCodecGeneric)) {
-    simulcast_id = encoded_image.SpatialIndex().value_or(0);
-  }
-
   EncodedImageCallback::Result result =
       sink_->OnEncodedImage(image_copy, codec_specific_info);
 
--- chromium-85.0.4183.83/gpu/ipc/service/gpu_init.cc.gcc10	2020-08-24 23:40:37.000000000 +0200
+++ chromium-85.0.4183.83/gpu/ipc/service/gpu_init.cc	2020-09-01 18:48:46.475436526 +0200
@@ -745,16 +745,6 @@ bool GpuInit::InitializeVulkan() {
   // Histogram GPU.SupportsVulkan and GPU.VulkanVersion were marked as expired.
   // TODO(magchen): Add back these two histograms here and re-enable them in
   // histograms.xml when we start Vulkan finch on Windows.
-  if (!vulkan_use_swiftshader) {
-    const bool supports_vulkan = !!vulkan_implementation_;
-    uint32_t vulkan_version = 0;
-    if (supports_vulkan) {
-      const auto& vulkan_info =
-          vulkan_implementation_->GetVulkanInstance()->vulkan_info();
-      vulkan_version = vulkan_info.used_api_version;
-    }
-  }
-
   if (!vulkan_implementation_)
     return false;
 
--- chromium-85.0.4183.83/services/cert_verifier/cert_verifier_creation.cc.gcc10	2020-08-24 23:40:41.000000000 +0200
+++ chromium-85.0.4183.83/services/cert_verifier/cert_verifier_creation.cc	2020-09-02 01:03:55.310781093 +0200
@@ -87,15 +87,12 @@ std::unique_ptr<net::CertVerifier> Creat
 
   std::unique_ptr<net::CertVerifier> cert_verifier;
 
-  bool use_builtin_cert_verifier;
 #if BUILDFLAG(BUILTIN_CERT_VERIFIER_FEATURE_SUPPORTED)
-  use_builtin_cert_verifier =
+  bool use_builtin_cert_verifier =
       creation_params
           ? UsingBuiltinCertVerifier(creation_params->use_builtin_cert_verifier)
           : UsingBuiltinCertVerifier(
                 mojom::CertVerifierCreationParams::CertVerifierImpl::kDefault);
-#else
-  use_builtin_cert_verifier = false;
 #endif
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
--- chromium-85.0.4183.83/third_party/blink/renderer/core/css/properties/longhands/longhands_custom.cc.gcc10	2020-08-24 23:40:43.000000000 +0200
+++ chromium-85.0.4183.83/third_party/blink/renderer/core/css/properties/longhands/longhands_custom.cc	2020-09-04 17:42:23.272705235 +0200
@@ -1639,7 +1639,7 @@
     ApplyInherit(state);
     return;
   }
-  if (auto* initial_color_value = DynamicTo<CSSInitialColorValue>(value)) {
+  if (DynamicTo<CSSInitialColorValue>(value)) {
     DCHECK_EQ(state.GetElement(), state.GetDocument().documentElement());
     state.Style()->SetColor(state.Style()->InitialColorForColorScheme());
     return;
@@ -3196,7 +3196,7 @@
     ApplyInherit(state);
     return;
   }
-  if (auto* initial_color_value = DynamicTo<CSSInitialColorValue>(value)) {
+  if (DynamicTo<CSSInitialColorValue>(value)) {
     DCHECK_EQ(state.GetElement(), state.GetDocument().documentElement());
     state.Style()->SetInternalVisitedColor(
         state.Style()->InitialColorForColorScheme());
@@ -4058,7 +4058,7 @@
     ApplyInherit(state);
     return;
   }
-  if (auto* initial_color_value = DynamicTo<CSSInitialColorValue>(value)) {
+  if (DynamicTo<CSSInitialColorValue>(value)) {
     DCHECK_EQ(state.GetElement(), state.GetDocument().documentElement());
     state.Style()->SetInternalForcedColor(
         ComputedStyleInitialValues::InitialInternalForcedColor());
@@ -4141,7 +4141,7 @@
     ApplyInherit(state);
     return;
   }
-  if (auto* initial_color_value = DynamicTo<CSSInitialColorValue>(value)) {
+  if (DynamicTo<CSSInitialColorValue>(value)) {
     DCHECK_EQ(state.GetElement(), state.GetDocument().documentElement());
     state.Style()->SetInternalForcedVisitedColor(
         ComputedStyleInitialValues::InitialInternalForcedVisitedColor());
--- chromium-87.0.4280.40/gpu/command_buffer/service/shared_image_backing_gl_image.cc.gcc10	2020-10-29 23:25:38.000000000 +0100
+++ chromium-87.0.4280.40/gpu/command_buffer/service/shared_image_backing_gl_image.cc	2020-11-01 01:28:46.681727224 +0100
@@ -394,7 +394,7 @@ void SharedImageBackingGLImage::OnMemory
   // Add a |service_guid| which expresses shared ownership between the
   // various GPU dumps.
   auto client_guid = GetSharedImageGUIDForTracing(mailbox());
-  if (auto service_id = GetGLServiceId()) {
+  if (GetGLServiceId()) {
     auto service_guid = gl::GetGLTextureServiceGUIDForTracing(GetGLServiceId());
     pmd->CreateSharedGlobalAllocatorDump(service_guid);
     // TODO(piman): coalesce constant with TextureManager::DumpTextureRef.
--- chromium-87.0.4280.40/third_party/blink/renderer/core/frame/remote_frame.cc.gcc10	2020-10-29 23:25:43.000000000 +0100
+++ chromium-87.0.4280.40/third_party/blink/renderer/core/frame/remote_frame.cc	2020-11-01 21:07:48.931576432 +0100
@@ -819,7 +819,7 @@ void RemoteFrame::DidUpdateFramePolicy(c
 
 void RemoteFrame::UpdateOpener(
     const absl::optional<blink::FrameToken>& opener_frame_token) {
-  if (auto* web_frame = WebFrame::FromCoreFrame(this)) {
+  if (WebFrame::FromCoreFrame(this)) {
     Frame* opener_frame = nullptr;
     if (opener_frame_token)
       opener_frame = Frame::ResolveFrame(opener_frame_token.value());
--- chromium-87.0.4280.40/third_party/blink/renderer/core/frame/local_frame.cc.gcc10	2020-10-31 11:39:36.707807448 +0100
+++ chromium-87.0.4280.40/third_party/blink/renderer/core/frame/local_frame.cc	2020-11-01 22:28:16.884978321 +0100
@@ -2044,7 +2044,7 @@ ContentCaptureManager* LocalFrame::GetCo
 
   // TODO(dcheng): Why does this function also Shutdown()? It seems rather
   // surprising...
-  if (auto* content_capture_client = Client()->GetWebContentCaptureClient()) {
+  if (Client()->GetWebContentCaptureClient()) {
     if (!content_capture_manager_) {
       content_capture_manager_ =
           MakeGarbageCollected<ContentCaptureManager>(*this);
@@ -3798,7 +3798,7 @@ void LocalFrame::BindReportingObserver(
 
 void LocalFrame::UpdateOpener(
     const absl::optional<blink::FrameToken>& opener_frame_token) {
-  if (auto* web_frame = WebFrame::FromCoreFrame(this)) {
+  if (WebFrame::FromCoreFrame(this)) {
     Frame* opener_frame = nullptr;
     if (opener_frame_token)
       opener_frame = Frame::ResolveFrame(opener_frame_token.value());
--- chromium-87.0.4280.40/third_party/blink/renderer/core/inspector/request_debug_header_scope.cc.gcc10	2020-10-29 23:25:43.000000000 +0100
+++ chromium-87.0.4280.40/third_party/blink/renderer/core/inspector/request_debug_header_scope.cc	2020-11-01 22:32:20.723530015 +0100
@@ -25,7 +25,7 @@ String RequestDebugHeaderScope::CaptureH
   ThreadDebugger* debugger = nullptr;
   if (auto* scope = DynamicTo<WorkerGlobalScope>(context))
     debugger = WorkerThreadDebugger::From(scope->GetThread()->GetIsolate());
-  else if (LocalDOMWindow* dom_window = DynamicTo<LocalDOMWindow>(context))
+  else if (DynamicTo<LocalDOMWindow>(context))
     debugger = MainThreadDebugger::Instance();
   if (!debugger)
     return String();
@@ -43,7 +43,7 @@ RequestDebugHeaderScope::RequestDebugHea
     return;
   if (auto* scope = DynamicTo<WorkerGlobalScope>(context))
     debugger_ = WorkerThreadDebugger::From(scope->GetThread()->GetIsolate());
-  else if (auto* window = DynamicTo<LocalDOMWindow>(context))
+  else if (DynamicTo<LocalDOMWindow>(context))
     debugger_ = MainThreadDebugger::Instance();
   if (debugger_)
     debugger_->ExternalAsyncTaskStarted(stack_trace_id_);
--- chromium-87.0.4280.40/third_party/blink/renderer/core/inspector/inspector_highlight.cc.gcc10	2020-10-29 23:25:43.000000000 +0100
+++ chromium-87.0.4280.40/third_party/blink/renderer/core/inspector/inspector_highlight.cc	2020-11-01 22:37:13.538194222 +0100
@@ -769,8 +769,7 @@ Vector<String> GetAuthoredGridTrackSizes
     return result;
 
   for (auto list_value : *value_list) {
-    if (auto* grid_auto_repeat_value =
-            DynamicTo<cssvalue::CSSGridAutoRepeatValue>(list_value.Get())) {
+    if (DynamicTo<cssvalue::CSSGridAutoRepeatValue>(list_value.Get())) {
       Vector<String> repeated_track_sizes;
       for (auto auto_repeat_value : To<CSSValueList>(*list_value)) {
         if (!auto_repeat_value->IsGridLineNamesValue())
--- chromium-87.0.4280.40/content/renderer/render_frame_impl.cc.gcc10	2020-10-29 23:25:37.000000000 +0100
+++ chromium-87.0.4280.40/content/renderer/render_frame_impl.cc	2020-11-01 22:53:00.955937974 +0100
@@ -2046,10 +2046,6 @@ void RenderFrameImpl::Initialize(blink::
   initialized_ = true;
   is_main_frame_ = !parent;
 
-  WebFrame* local_root = frame_;
-  if (parent && parent->IsWebLocalFrame()) {
-    local_root = parent->ToWebLocalFrame()->LocalRoot();
-  }
   bool is_tracing_rail = false;
   bool is_tracing_navigation = false;
   TRACE_EVENT_CATEGORY_GROUP_ENABLED("navigation", &is_tracing_navigation);
--- chromium-87.0.4280.40/third_party/blink/renderer/core/layout/ng/ng_fieldset_layout_algorithm.cc.gcc10	2020-10-29 23:25:43.000000000 +0100
+++ chromium-87.0.4280.40/third_party/blink/renderer/core/layout/ng/ng_fieldset_layout_algorithm.cc	2020-11-02 01:52:49.818593448 +0100
@@ -151,7 +151,7 @@ NGBreakStatus NGFieldsetLayoutAlgorithm:
   bool has_seen_all_children = false;
   if (const auto* token = BreakToken()) {
     const auto child_tokens = token->ChildBreakTokens();
-    if (wtf_size_t break_token_count = child_tokens.size()) {
+    if (child_tokens.size()) {
       scoped_refptr<const NGBlockBreakToken> child_token =
           To<NGBlockBreakToken>(child_tokens[0]);
       if (child_token) {
--- chromium-87.0.4280.40/third_party/blink/renderer/core/paint/paint_timing_detector.cc.gcc10	2020-10-29 23:25:44.000000000 +0100
+++ chromium-87.0.4280.40/third_party/blink/renderer/core/paint/paint_timing_detector.cc	2020-11-02 13:18:28.091382914 +0100
@@ -377,7 +377,7 @@ void PaintTimingDetector::UpdateLargestC
 }
 
 void PaintTimingDetector::ReportIgnoredContent() {
-  if (auto* text_timing_detector = GetTextPaintTimingDetector()) {
+  if (GetTextPaintTimingDetector()) {
     text_paint_timing_detector_->ReportLargestIgnoredText();
   }
   if (auto* image_timing_detector = GetImagePaintTimingDetector()) {
--- chromium-87.0.4280.40/third_party/blink/renderer/modules/accessibility/ax_object_cache_impl.cc.gcc10	2020-10-29 23:25:44.000000000 +0100
+++ chromium-87.0.4280.40/third_party/blink/renderer/modules/accessibility/ax_object_cache_impl.cc	2020-11-02 14:13:48.450225395 +0100
@@ -1206,7 +1206,7 @@ void AXObjectCacheImpl::DidInsertChildre
   // changed.
   DCHECK(node);
   while (node) {
-    if (AXObject* obj = Get(node)) {
+    if (Get(node)) {
       TextChanged(node);
       return;
     }
--- chromium-88.0.4324.41/ui/base/x/x11_user_input_monitor.cc.gcc10	2020-12-10 13:03:49.000000000 +0100
+++ chromium-88.0.4324.41/ui/base/x/x11_user_input_monitor.cc	2020-12-13 08:38:56.376451573 +0100
@@ -63,7 +63,7 @@ void XUserInputMonitor::StartMonitor(Wri
 
   if (!connection_) {
     // TODO(jamiewalch): We should pass the connection in.
-    if (auto* connection = x11::Connection::Get()) {
+    if (x11::Connection::Get()) {
       connection_ = x11::Connection::Get()->Clone();
     } else {
       LOG(ERROR) << "Couldn't open X connection";
--- chromium-88.0.4324.41/chrome/browser/ui/views/profiles/profile_menu_view_base.cc.gcc10	2020-12-13 06:30:18.366388670 +0100
+++ chromium-88.0.4324.41/chrome/browser/ui/views/profiles/profile_menu_view_base.cc	2020-12-13 11:56:29.596759569 +0100
@@ -766,16 +766,15 @@ void ProfileMenuViewBase::AddFeatureButt
         views::BoxLayout::Orientation::kVertical));
   }
 
-  views::View* button;
   if (&icon == &gfx::kNoneIcon) {
-    button = features_container_->AddChildView(std::make_unique<HoverButton>(
+    (void)features_container_->AddChildView(std::make_unique<HoverButton>(
         base::BindRepeating(&ProfileMenuViewBase::ButtonPressed,
                             base::Unretained(this), std::move(action)),
         text));
   } else {
     auto icon_view =
         std::make_unique<FeatureButtonIconView>(icon, icon_to_image_ratio);
-    button = features_container_->AddChildView(std::make_unique<HoverButton>(
+    (void)features_container_->AddChildView(std::make_unique<HoverButton>(
         base::BindRepeating(&ProfileMenuViewBase::ButtonPressed,
                             base::Unretained(this), std::move(action)),
         std::move(icon_view), text));
--- chromium-88.0.4324.41/third_party/blink/renderer/platform/heap/impl/persistent.h.gcc10	2020-12-10 13:03:05.000000000 +0100
+++ chromium-88.0.4324.41/third_party/blink/renderer/platform/heap/impl/persistent.h	2020-12-13 22:31:21.449926394 +0100
@@ -291,6 +291,7 @@ class PersistentBase {
   void AssignSafe(T* ptr) {
     typename PersistentMutexTraits<crossThreadnessConfiguration>::Locker lock;
     AssignUnsafe(ptr);
+    (void)lock;
   }
 
   NO_SANITIZE_ADDRESS
@@ -332,6 +333,7 @@ class PersistentBase {
                             &PersistentBase::TracePersistent>::Trampoline;
     typename PersistentMutexTraits<crossThreadnessConfiguration>::Locker lock;
     persistent_node_.Initialize(this, trace_callback);
+    (void)lock;
   }
 
   NO_SANITIZE_ADDRESS
@@ -350,6 +352,7 @@ class PersistentBase {
     if (persistent_node_.IsInitialized()) {
       typename PersistentMutexTraits<crossThreadnessConfiguration>::Locker lock;
       persistent_node_.Uninitialize();
+      (void)lock;
     }
   }
 
--- chromium-88.0.4324.41/third_party/blink/renderer/core/animation/document_animations.cc.gcc10	2020-12-10 13:03:03.000000000 +0100
+++ chromium-88.0.4324.41/third_party/blink/renderer/core/animation/document_animations.cc	2020-12-14 13:35:41.882160594 +0100
@@ -125,8 +125,7 @@ void DocumentAnimations::UpdateAnimation
 size_t DocumentAnimations::GetAnimationsCount() {
   wtf_size_t total_animations_count = 0;
   if (document_->View()) {
-    if (cc::AnimationHost* host =
-            document_->View()->GetCompositorAnimationHost()) {
+    if (document_->View()->GetCompositorAnimationHost()) {
       for (auto& timeline : timelines_) {
         if (timeline->HasAnimations())
           total_animations_count += timeline->AnimationsNeedingUpdateCount();
--- chromium-88.0.4324.41/third_party/blink/renderer/core/frame/event_handler_registry.cc.gcc10	2020-12-10 13:03:03.000000000 +0100
+++ chromium-88.0.4324.41/third_party/blink/renderer/core/frame/event_handler_registry.cc	2020-12-14 13:36:40.274090638 +0100
@@ -202,14 +202,10 @@ void EventHandlerRegistry::DidMoveOutOfP
 
 void EventHandlerRegistry::DidRemoveAllEventHandlers(EventTarget& target) {
   bool handlers_changed[kEventHandlerClassCount];
-  bool target_set_changed[kEventHandlerClassCount];
 
   for (int i = 0; i < kEventHandlerClassCount; ++i) {
     EventHandlerClass handler_class = static_cast<EventHandlerClass>(i);
 
-    EventTargetSet* targets = &targets_[handler_class];
-    target_set_changed[i] = targets->Contains(&target);
-
     handlers_changed[i] =
         UpdateEventHandlerInternal(kRemoveAll, handler_class, &target);
   }
--- chromium-88.0.4324.41/content/browser/bluetooth/bluetooth_blocklist.cc.gcc10	2020-12-10 13:02:54.000000000 +0100
+++ chromium-88.0.4324.41/content/browser/bluetooth/bluetooth_blocklist.cc	2020-12-14 14:50:46.327799260 +0100
@@ -44,8 +44,6 @@ void BluetoothBlocklist::Add(base::Strin
   if (blocklist_string.empty())
     return;
   base::StringPairs kv_pairs;
-  bool parsed_values = false;
-  bool invalid_values = false;
   base::SplitStringIntoKeyValuePairs(blocklist_string,
                                      ':',  // Key-value delimiter
                                      ',',  // Key-value pair delimiter
@@ -56,19 +54,15 @@ void BluetoothBlocklist::Add(base::Strin
       switch (pair.second[0]) {
         case 'e':
           Add(uuid, Value::EXCLUDE);
-          parsed_values = true;
           continue;
         case 'r':
           Add(uuid, Value::EXCLUDE_READS);
-          parsed_values = true;
           continue;
         case 'w':
           Add(uuid, Value::EXCLUDE_WRITES);
-          parsed_values = true;
           continue;
       }
     }
-    invalid_values = true;
   }
 }
 
--- chromium-88.0.4324.41/third_party/blink/renderer/core/layout/ng/table/ng_table_layout_algorithm_utils.cc.gcc10	2020-12-10 13:03:04.000000000 +0100
+++ chromium-88.0.4324.41/third_party/blink/renderer/core/layout/ng/table/ng_table_layout_algorithm_utils.cc	2020-12-14 16:05:33.424042657 +0100
@@ -210,7 +210,6 @@ NGTableTypes::Row ComputeMinimumRowBlock
   LayoutUnit max_cell_block_size;
   absl::optional<float> row_percent;
   bool is_constrained = false;
-  bool is_empty = true;
   bool has_rowspan_start = false;
   wtf_size_t start_cell_index = cell_block_constraints->size();
   NGRowBaselineTabulator row_baseline_tabulator;
@@ -218,7 +217,6 @@ NGTableTypes::Row ComputeMinimumRowBlock
   // Gather block sizes of all cells.
   for (NGBlockNode cell = To<NGBlockNode>(row.FirstChild()); cell;
        cell = To<NGBlockNode>(cell.NextSibling())) {
-    is_empty = false;
     colspan_cell_tabulator->FindNextFreeColumn();
     const ComputedStyle& cell_style = cell.Style();
     const NGBoxStrut cell_borders = table_borders.CellBorder(
--- chromium-89.0.4389.47/content/browser/webid/idp_network_request_manager.cc.gcc10	2021-02-11 00:04:00.000000000 +0100
+++ chromium-89.0.4389.47/content/browser/webid/idp_network_request_manager.cc	2021-02-16 22:15:37.147581604 +0100
@@ -414,10 +414,6 @@ void IdpNetworkRequestManager::OnWellKno
 
 void IdpNetworkRequestManager::OnSigninRequestResponse(
     std::unique_ptr<std::string> response_body) {
-  int response_code = -1;
-  if (url_loader_->ResponseInfo() && url_loader_->ResponseInfo()->headers)
-    response_code = url_loader_->ResponseInfo()->headers->response_code();
-
   url_loader_.reset();
 
   if (!response_body) {
@@ -476,10 +472,6 @@ void IdpNetworkRequestManager::OnSigninR
 
 void IdpNetworkRequestManager::OnAccountsRequestResponse(
     std::unique_ptr<std::string> response_body) {
-  int response_code = -1;
-  if (url_loader_->ResponseInfo() && url_loader_->ResponseInfo()->headers)
-    response_code = url_loader_->ResponseInfo()->headers->response_code();
-
   url_loader_.reset();
 
   if (!response_body) {
@@ -525,10 +517,6 @@ void IdpNetworkRequestManager::OnAccount
 
 void IdpNetworkRequestManager::OnTokenRequestResponse(
     std::unique_ptr<std::string> response_body) {
-  int response_code = -1;
-  if (url_loader_->ResponseInfo() && url_loader_->ResponseInfo()->headers)
-    response_code = url_loader_->ResponseInfo()->headers->response_code();
-
   url_loader_.reset();
 
   if (!response_body) {
@@ -573,10 +561,6 @@ void IdpNetworkRequestManager::OnTokenRe
 
 void IdpNetworkRequestManager::OnLogoutCompleted(
     std::unique_ptr<std::string> response_body) {
-  int response_code = -1;
-  if (url_loader_->ResponseInfo() && url_loader_->ResponseInfo()->headers)
-    response_code = url_loader_->ResponseInfo()->headers->response_code();
-
   url_loader_.reset();
 
   if (!response_body) {
--- chromium-89.0.4389.47/third_party/blink/renderer/core/events/simulated_event_util.cc.gcc10	2021-02-11 00:04:07.000000000 +0100
+++ chromium-89.0.4389.47/third_party/blink/renderer/core/events/simulated_event_util.cc	2021-02-17 17:14:47.896085084 +0100
@@ -133,7 +133,7 @@ MouseEvent* CreateMouseOrPointerEvent(
                                   ? underlying_event->PlatformTimeStamp()
                                   : base::TimeTicks::Now();
   MouseEvent::SyntheticEventType synthetic_type = MouseEvent::kPositionless;
-  if (const auto* mouse_event = DynamicTo<MouseEvent>(underlying_event)) {
+  if (DynamicTo<MouseEvent>(underlying_event)) {
     synthetic_type = MouseEvent::kRealOrIndistinguishable;
   }
   if (creation_scope == SimulatedClickCreationScope::kFromAccessibility &&
--- chromium-89.0.4389.47/third_party/blink/renderer/core/layout/ng/inline/ng_inline_layout_algorithm.cc.gcc10	2021-02-11 00:04:07.000000000 +0100
+++ chromium-89.0.4389.47/third_party/blink/renderer/core/layout/ng/inline/ng_inline_layout_algorithm.cc	2021-02-17 19:07:28.626911157 +0100
@@ -220,7 +220,6 @@ void NGInlineLayoutAlgorithm::CreateLine
   if (quirks_mode_ && line_style.Display() == EDisplay::kListItem)
     box->ComputeTextMetrics(line_style, *box->font, baseline_type_);
 
-  bool has_logical_text_items = false;
   for (NGInlineItemResult& item_result : *line_items) {
     DCHECK(item_result.item);
     const NGInlineItem& item = *item_result.item;
@@ -255,14 +254,12 @@ void NGInlineLayoutAlgorithm::CreateLine
                            box->text_top, item_result.inline_size,
                            box->text_height, item.BidiLevel());
       }
-      has_logical_text_items = true;
 
       // Text boxes always need full paint invalidations.
       item.GetLayoutObject()->ClearNeedsLayoutWithFullPaintInvalidation();
 
     } else if (item.Type() == NGInlineItem::kControl) {
       PlaceControlItem(item, *line_info, &item_result, line_box, box);
-      has_logical_text_items = true;
     } else if (item.Type() == NGInlineItem::kOpenTag) {
       box = HandleOpenTag(item, item_result, line_box, box_states_);
     } else if (item.Type() == NGInlineItem::kCloseTag) {
--- chromium-89.0.4389.47/third_party/blink/renderer/bindings/core/v8/serialization/serialized_color_params.cc.gcc10	2021-02-11 00:04:07.000000000 +0100
+++ chromium-89.0.4389.47/third_party/blink/renderer/bindings/core/v8/serialization/serialized_color_params.cc	2021-02-18 11:33:33.553446351 +0100
@@ -195,10 +195,6 @@ SkImageInfo SerializedImageBitmapSetting
     sk_alpha_type = kUnpremul_SkAlphaType;
   }
 
-  blink::OpacityMode opacity_mode = blink::kNonOpaque;
-  if (opacity_mode_ == SerializedOpacityMode::kOpaque)
-    opacity_mode = blink::kOpaque;
-
   return SkImageInfo::Make(width, height, sk_color_type, sk_alpha_type,
                            std::move(sk_color_space));
 }
--- chromium-90.0.4430.19/third_party/angle/src/compiler/translator/tree_ops/vulkan/ReplaceForShaderFramebufferFetch.cpp.gcc10	2021-03-09 19:42:36.000000000 +0100
+++ chromium-90.0.4430.19/third_party/angle/src/compiler/translator/tree_ops/vulkan/ReplaceForShaderFramebufferFetch.cpp	2021-03-15 11:55:35.968338954 +0100
@@ -439,7 +439,6 @@ class ReplaceSubpassInputUtils
                                              const TVariable *loadInputAttachmentDataVar);
 
     ImmutableString getInputAttachmentName(unsigned int index);
-    ImmutableString getInputAttachmentArrayName();
 
     TCompiler *mCompiler;
     TSymbolTable *mSymbolTable;
@@ -456,14 +455,6 @@ class ReplaceSubpassInputUtils
     std::map<unsigned int, const TVariable *> mDataLoadVarList;
 };
 
-ImmutableString ReplaceSubpassInputUtils::getInputAttachmentArrayName()
-{
-    constexpr ImmutableString suffix("Array");
-    std::stringstream nameStream = sh::InitializeStream<std::stringstream>();
-    nameStream << sh::vk::kInputAttachmentName << suffix << mInputAttachmentArrayIdSeq++;
-    return ImmutableString(nameStream.str());
-}
-
 ImmutableString ReplaceSubpassInputUtils::getInputAttachmentName(unsigned int index)
 {
     std::stringstream nameStream = sh::InitializeStream<std::stringstream>();
--- chromium-90.0.4430.19/third_party/tflite/src/tensorflow/lite/kernels/internal/optimized/optimized_ops.h.gcc10	2021-03-09 19:42:51.000000000 +0100
+++ chromium-90.0.4430.19/third_party/tflite/src/tensorflow/lite/kernels/internal/optimized/optimized_ops.h	2021-03-15 16:42:33.103604302 +0100
@@ -7879,8 +7879,7 @@ template <typename T>
 inline void Transpose3D(const TransposeParams& params,
                         const RuntimeShape& input_shape, const T* input_data,
                         const RuntimeShape& output_shape, T* output_data) {
-  int s1, s2, s3;
-  s1 = input_shape.Dims(0);
+  int s2, s3;
   s2 = input_shape.Dims(1);
   s3 = input_shape.Dims(2);
 
--- chromium-90.0.4430.19/third_party/tflite/src/tensorflow/lite/kernels/lstm.cc.gcc10	2021-03-09 19:42:51.000000000 +0100
+++ chromium-90.0.4430.19/third_party/tflite/src/tensorflow/lite/kernels/lstm.cc	2021-03-15 17:34:33.246026701 +0100
@@ -403,19 +403,8 @@ TfLiteStatus PopulateQuantizedLstmParams
   const TfLiteTensor* output_layer_norm_coefficients =
       GetOptionalInputTensor(context, node, kOutputLayerNormCoefficientsTensor);
 
-  const TfLiteTensor* input_gate_bias =
-      GetOptionalInputTensor(context, node, kInputGateBiasTensor);
-  const TfLiteTensor* forget_gate_bias =
-      GetInput(context, node, kForgetGateBiasTensor);
-  const TfLiteTensor* cell_gate_bias =
-      GetInput(context, node, kCellGateBiasTensor);
-  const TfLiteTensor* output_gate_bias =
-      GetInput(context, node, kOutputGateBiasTensor);
-
   const TfLiteTensor* projection_weights =
       GetOptionalInputTensor(context, node, kProjectionWeightsTensor);
-  const TfLiteTensor* projection_bias =
-      GetOptionalInputTensor(context, node, kProjectionBiasTensor);
 
   TfLiteTensor* output_state =
       GetVariableInput(context, node, kOutputStateTensor);
@@ -430,31 +419,6 @@ TfLiteStatus PopulateQuantizedLstmParams
   const bool is_layer_norm_lstm = (forget_layer_norm_coefficients != nullptr);
   const bool use_projection = (projection_weights != nullptr);
 
-  // Weights and states.
-  int8_t* input_to_input_weight_ptr = nullptr;
-  int8_t* recurrent_to_input_weight_ptr = nullptr;
-  int8_t* cell_to_input_weight_ptr = nullptr;
-  int8_t* input_to_forget_weight_ptr = nullptr;
-  int8_t* recurrent_to_forget_weight_ptr = nullptr;
-  int8_t* cell_to_forget_weight_ptr = nullptr;
-  int8_t* input_to_cell_weight_ptr = nullptr;
-  int8_t* recurrent_to_cell_weight_ptr = nullptr;
-  int8_t* input_to_output_weight_ptr = nullptr;
-  int8_t* recurrent_to_output_weight_ptr = nullptr;
-  int8_t* cell_to_output_weight_ptr = nullptr;
-  int8_t* projection_weight_ptr = nullptr;
-  int16_t* layer_norm_input_weight_ptr = nullptr;
-  int16_t* layer_norm_forget_weight_ptr = nullptr;
-  int16_t* layer_norm_cell_weight_ptr = nullptr;
-  int16_t* layer_norm_output_weight_ptr = nullptr;
-  int32_t* input_gate_bias_ptr = nullptr;
-  int32_t* forget_gate_bias_ptr = nullptr;
-  int32_t* cell_gate_bias_ptr = nullptr;
-  int32_t* output_gate_bias_ptr = nullptr;
-  int32_t* projection_bias_ptr = nullptr;
-  int16_t* cell_ptr = nullptr;
-  int8_t* output_state_ptr = nullptr;
-
   // Scales.
   const float default_scale = 1.0;
   float input_scale = default_scale;
@@ -490,72 +454,41 @@ TfLiteStatus PopulateQuantizedLstmParams
   float effective_cell_to_output_scale = default_scale;
   float effective_proj_scale = default_scale;
 
-  // Zero points
-  int input_zp = 0;
-  int output_state_zp = 0;
-
   // Populate all the values.
   if (!use_cifg) {
-    input_to_input_weight_ptr = input_to_input_weights->data.int8;
-    recurrent_to_input_weight_ptr = recurrent_to_input_weights->data.int8;
-    input_gate_bias_ptr = input_gate_bias->data.i32;
     input_to_input_weight_scale = input_to_input_weights->params.scale;
     recurrent_to_input_weight_scale = recurrent_to_input_weights->params.scale;
   }
 
   if (use_peephole) {
     if (!use_cifg) {
-      cell_to_input_weight_ptr = cell_to_input_weights->data.int8;
       cell_to_input_weight_scale = cell_to_input_weights->params.scale;
     }
-    cell_to_forget_weight_ptr = cell_to_forget_weights->data.int8;
-    cell_to_output_weight_ptr = cell_to_output_weights->data.int8;
     cell_to_forget_weight_scale = cell_to_forget_weights->params.scale;
     cell_to_output_weight_scale = cell_to_output_weights->params.scale;
   }
 
   if (is_layer_norm_lstm) {
     if (!use_cifg) {
-      layer_norm_input_weight_ptr = input_layer_norm_coefficients->data.i16;
       layer_norm_input_scale = input_layer_norm_coefficients->params.scale;
     }
-    layer_norm_forget_weight_ptr = forget_layer_norm_coefficients->data.i16;
     layer_norm_forget_scale = forget_layer_norm_coefficients->params.scale;
-    layer_norm_cell_weight_ptr = cell_layer_norm_coefficients->data.i16;
     layer_norm_cell_scale = cell_layer_norm_coefficients->params.scale;
-    layer_norm_output_weight_ptr = output_layer_norm_coefficients->data.i16;
     layer_norm_output_scale = output_layer_norm_coefficients->params.scale;
   }
 
   if (use_projection) {
-    projection_weight_ptr = projection_weights->data.int8;
     projection_weight_scale = projection_weights->params.scale;
-    if (projection_bias) {
-      projection_bias_ptr = projection_bias->data.i32;
-    }
   }
   output_state_scale = output_state->params.scale;
 
-  input_to_forget_weight_ptr = input_to_forget_weights->data.int8;
   input_to_forget_weight_scale = input_to_forget_weights->params.scale;
-  input_to_cell_weight_ptr = input_to_cell_weights->data.int8;
   input_to_cell_weight_scale = input_to_cell_weights->params.scale;
-  input_to_output_weight_ptr = input_to_output_weights->data.int8;
   input_to_output_weight_scale = input_to_output_weights->params.scale;
-  recurrent_to_forget_weight_ptr = recurrent_to_forget_weights->data.int8;
   recurrent_to_forget_weight_scale = recurrent_to_forget_weights->params.scale;
-  recurrent_to_cell_weight_ptr = recurrent_to_cell_weights->data.int8;
   recurrent_to_cell_weight_scale = recurrent_to_cell_weights->params.scale;
-  recurrent_to_output_weight_ptr = recurrent_to_output_weights->data.int8;
   recurrent_to_output_weight_scale = recurrent_to_output_weights->params.scale;
-  forget_gate_bias_ptr = forget_gate_bias->data.i32;
-  cell_gate_bias_ptr = cell_gate_bias->data.i32;
-  output_gate_bias_ptr = output_gate_bias->data.i32;
-  output_state_ptr = output_state->data.int8;
-  cell_ptr = cell_state->data.i16;
   input_scale = input->params.scale;
-  input_zp = input->params.zero_point;
-  output_state_zp = output_state->params.zero_point;
 
   std::vector<float> intermediate_scale;
   for (int i = 0; i < 12; ++i) {
--- chromium-90.0.4430.19/third_party/angle/src/libANGLE/renderer/vulkan/RendererVk.cpp.gcc10	2021-03-09 19:42:37.000000000 +0100
+++ chromium-90.0.4430.19/third_party/angle/src/libANGLE/renderer/vulkan/RendererVk.cpp	2021-03-15 18:44:25.546820078 +0100
@@ -1362,18 +1362,26 @@ angle::Result RendererVk::initializeDevi
     }
 
     // Enable VK_KHR_get_memory_requirements2, if supported
+#if !defined(ANGLE_SHARED_LIBVULKAN)
     bool hasGetMemoryRequirements2KHR = false;
+#endif
     if (ExtensionFound(VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME, deviceExtensionNames))
     {
         enabledDeviceExtensions.push_back(VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME);
+#if !defined(ANGLE_SHARED_LIBVULKAN)
         hasGetMemoryRequirements2KHR = true;
+#endif
     }
 
     // Enable VK_KHR_bind_memory2, if supported
+#if !defined(ANGLE_SHARED_LIBVULKAN)
     bool hasBindMemory2KHR = false;
+#endif
     if (ExtensionFound(VK_KHR_BIND_MEMORY_2_EXTENSION_NAME, deviceExtensionNames))
     {
+#if !defined(ANGLE_SHARED_LIBVULKAN)
         hasBindMemory2KHR = true;
+#endif
         enabledDeviceExtensions.push_back(VK_KHR_BIND_MEMORY_2_EXTENSION_NAME);
     }
 
--- chromium-90.0.4430.19/content/renderer/accessibility/blink_ax_tree_source.cc.gcc10	2021-03-09 19:39:36.000000000 +0100
+++ chromium-90.0.4430.19/content/renderer/accessibility/blink_ax_tree_source.cc	2021-03-16 15:13:06.605225002 +0100
@@ -385,10 +385,7 @@ void BlinkAXTreeSource::GetChildren(
     parent.LoadInlineTextBoxes();
   }
 
-  bool is_iframe = false;
   WebNode node = parent.GetNode();
-  if (!node.IsNull() && node.IsElementNode())
-    is_iframe = node.To<WebElement>().HasHTMLTagName("iframe");
 
   for (unsigned i = 0; i < parent.ChildCount(); i++) {
     WebAXObject child = parent.ChildAt(i);
@@ -524,10 +521,8 @@ void BlinkAXTreeSource::SerializeNode(We
   }
 
   WebNode node = src.GetNode();
-  bool is_iframe = false;
   if (!node.IsNull() && node.IsElementNode()) {
     WebElement element = node.To<WebElement>();
-    is_iframe = element.HasHTMLTagName("iframe");
   }
 
   if (dst->id == image_data_node_id_) {
--- chromium-90.0.4430.19/third_party/blink/renderer/core/dom/layout_tree_builder_traversal.cc.gcc10	2021-03-09 19:39:43.000000000 +0100
+++ chromium-90.0.4430.19/third_party/blink/renderer/core/dom/layout_tree_builder_traversal.cc	2021-03-16 22:48:52.310012617 +0100
@@ -51,7 +51,7 @@ ContainerNode* LayoutTreeBuilderTraversa
   // LayoutTreeBuilderTraversal::parent() is used only for a node which is
   // connected.
   // DCHECK(node.isConnected());
-  if (auto* element = DynamicTo<PseudoElement>(node)) {
+  if (DynamicTo<PseudoElement>(node)) {
     DCHECK(node.parentNode());
     return node.parentNode();
   }
--- chromium-91.0.4472.69/services/network/url_loader_factory.cc.gcc11	2021-05-20 04:17:12.000000000 +0200
+++ chromium-91.0.4472.69/services/network/url_loader_factory.cc	2021-05-23 21:27:52.243566115 +0200
@@ -180,40 +180,28 @@ void URLLoaderFactory::CreateLoaderAndSt
 
     keepalive_request_size = url_size + headers_size;
 
-    KeepaliveBlockStatus block_status = KeepaliveBlockStatus::kNotBlocked;
     const auto& top_frame_id = *params_->top_frame_id;
     const auto& recorder = *keepalive_statistics_recorder;
 
     if (!context_->CanCreateLoader(params_->process_id)) {
       // We already checked this, but we have this here for histogram.
       DCHECK(exhausted);
-      block_status = KeepaliveBlockStatus::kBlockedDueToCanCreateLoader;
     } else if (recorder.num_inflight_requests() >= kMaxKeepaliveConnections) {
       exhausted = true;
-      block_status = KeepaliveBlockStatus::kBlockedDueToNumberOfRequests;
     } else if (recorder.NumInflightRequestsPerTopLevelFrame(top_frame_id) >=
                kMaxKeepaliveConnectionsPerTopLevelFrame) {
       exhausted = true;
-      block_status =
-          KeepaliveBlockStatus::kBlockedDueToNumberOfRequestsPerTopLevelFrame;
     } else if (recorder.GetTotalRequestSizePerTopLevelFrame(top_frame_id) +
                    keepalive_request_size >
                kMaxTotalKeepaliveRequestSize) {
       exhausted = true;
-      block_status =
-          KeepaliveBlockStatus::kBlockedDueToTotalSizeOfUrlAndHeaders;
     } else if (recorder.GetTotalRequestSizePerTopLevelFrame(top_frame_id) +
                    keepalive_request_size >
                384 * 1024) {
-      block_status =
-          KeepaliveBlockStatus::kNotBlockedButUrlAndHeadersExceeds384kb;
     } else if (recorder.GetTotalRequestSizePerTopLevelFrame(top_frame_id) +
                    keepalive_request_size >
                256 * 1024) {
-      block_status =
-          KeepaliveBlockStatus::kNotBlockedButUrlAndHeadersExceeds256kb;
     } else {
-      block_status = KeepaliveBlockStatus::kNotBlocked;
     }
   }
 
--- chromium-91.0.4472.69/ppapi/proxy/ppb_x509_certificate_private_proxy.cc.gcc11	2021-05-20 04:17:11.000000000 +0200
+++ chromium-91.0.4472.69/ppapi/proxy/ppb_x509_certificate_private_proxy.cc	2021-05-24 10:04:26.300677113 +0200
@@ -25,7 +25,6 @@ class X509CertificatePrivate : public PP
                 PPB_X509Certificate_Fields* result) override;
 
  private:
-  void SendToBrowser(IPC::Message* msg);
 
   DISALLOW_COPY_AND_ASSIGN(X509CertificatePrivate);
 };
@@ -43,10 +42,6 @@ bool X509CertificatePrivate::ParseDER(co
                                                    result);
 }
 
-void X509CertificatePrivate::SendToBrowser(IPC::Message* msg) {
-  PluginGlobals::Get()->GetBrowserSender()->Send(msg);
-}
-
 }  // namespace
 
 //------------------------------------------------------------------------------
--- chromium-92.0.4515.51/third_party/blink/renderer/core/layout/ng/svg/ng_svg_text_layout_algorithm.cc.gcc11	2021-06-11 00:12:04.000000000 +0200
+++ chromium-92.0.4515.51/third_party/blink/renderer/core/layout/ng/svg/ng_svg_text_layout_algorithm.cc	2021-06-14 13:59:01.029797010 +0200
@@ -601,9 +601,7 @@ void NGSVGTextLayoutAlgorithm::ApplyAnch
                      [i](const auto& range) {
                        return range.start_index <= i && i <= range.end_index;
                      });
-    bool in_text_path = false;
     if (text_path_iter != text_path_ranges.end()) {
-      in_text_path = true;
       // Anchoring should be scoped within the <textPath>.
       // Non-anchored text following <textPath> will be handled in
       // PositionOnPath().
--- chromium-92.0.4515.51/third_party/blink/renderer/core/inspector/inspector_dom_agent.cc.gcc11	2021-06-11 00:12:04.000000000 +0200
+++ chromium-92.0.4515.51/third_party/blink/renderer/core/inspector/inspector_dom_agent.cc	2021-06-14 16:59:55.639162954 +0200
@@ -1633,7 +1633,7 @@ std::unique_ptr<protocol::DOM::Node> Ins
       force_push_children = true;
     }
 
-    if (auto* link_element = DynamicTo<HTMLLinkElement>(*element))
+    if (DynamicTo<HTMLLinkElement>(*element))
       force_push_children = true;
 
     if (auto* template_element = DynamicTo<HTMLTemplateElement>(*element)) {
--- chromium-92.0.4515.51/third_party/blink/renderer/modules/webtransport/web_transport.cc.gcc11	2021-06-11 00:12:05.000000000 +0200
+++ chromium-92.0.4515.51/third_party/blink/renderer/modules/webtransport/web_transport.cc	2021-06-15 04:48:58.436827526 +0200
@@ -451,13 +451,6 @@ ScriptPromise WebTransport::createBidire
     return ScriptPromise();
   }
 
-  MojoCreateDataPipeOptions options;
-  options.struct_size = sizeof(MojoCreateDataPipeOptions);
-  options.flags = MOJO_CREATE_DATA_PIPE_FLAG_NONE;
-  options.element_num_bytes = 1;
-  // TODO(ricea): Find an appropriate value for capacity_num_bytes.
-  options.capacity_num_bytes = 0;
-
   mojo::ScopedDataPipeProducerHandle outgoing_producer;
   mojo::ScopedDataPipeConsumerHandle outgoing_consumer;
   if (!CreateStreamDataPipe(&outgoing_producer, &outgoing_consumer,
--- chromium-92.0.4515.51/third_party/blink/renderer/platform/graphics/gpu/webgpu_resource_provider_cache.cc.gcc11	2021-06-11 00:12:05.000000000 +0200
+++ chromium-92.0.4515.51/third_party/blink/renderer/platform/graphics/gpu/webgpu_resource_provider_cache.cc	2021-06-15 12:24:48.967132580 +0200
@@ -166,9 +166,6 @@ void WebGPURecyclableResourceCache::Rele
   int stale_resource_count = 0;
   for (auto it = unused_providers_.rbegin(); it != unused_providers_.rend();
        ++it) {
-    auto timer_id_ = it->timer_id_;
-    int delta;
-    delta = current_timer_id_ - timer_id_;
     if ((current_timer_id_ - it->timer_id_) < kTimerIdDeltaForDeletion) {
       // These are the resources which are recycled and stay in the cache for
       // less than kCleanUpDelayInSeconds. They are not to be deleted this time.
--- chromium-92.0.4515.107/third_party/blink/renderer/modules/accessibility/ax_object.cc.gcc11	2021-07-21 03:14:37.900528137 +0200
+++ chromium-92.0.4515.107/third_party/blink/renderer/modules/accessibility/ax_object.cc	2021-07-21 23:53:27.391132233 +0200
@@ -2093,7 +2093,7 @@ void AXObject::UpdateCachedAttributeValu
   cached_aria_row_index_ = ComputeAriaRowIndex();
 
   if (included_in_tree_changed) {
-    if (AXObject* parent = CachedParentObject()) {
+    if (CachedParentObject()) {
       // TODO(aleventhal) Reenable DCHECK. It fails on PDF tests.
       // DCHECK(!ax_object_cache_->IsFrozen())
       // << "Attempting to change children on an ancestor is dangerous during "
