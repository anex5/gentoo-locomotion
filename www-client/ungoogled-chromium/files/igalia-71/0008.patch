--- a/ui/aura/BUILD.gn	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/aura/BUILD.gn	2019-01-24 15:42:46.168000000 +0300
@@ -176,6 +176,7 @@
     "//services/ws/public/mojom",
     "//skia",
     "//ui/base",
+    "//ui/base/clipboard",
     "//ui/base/ime",
     "//ui/display",
     "//ui/events",
@@ -404,6 +405,7 @@
     "//testing/gtest",
     "//ui/aura_extra",
     "//ui/base:test_support",
+    "//ui/base/clipboard:clipboard_types",
     "//ui/compositor:test_support",
     "//ui/compositor_extra",
     "//ui/display:test_support",
--- a/ui/aura/mus/os_exchange_data_provider_mus.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/aura/mus/os_exchange_data_provider_mus.cc	2019-01-24 15:42:46.724000000 +0300
@@ -15,6 +15,7 @@
 #include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "net/base/filename_util.h"
+#include "ui/base/clipboard/clipboard_constants.h"
 #include "ui/base/dragdrop/file_info.h"
 #include "ui/base/mojo/clipboard.mojom.h"
 #include "url/gurl.h"
@@ -87,8 +88,7 @@
   if (HasString())
     return;
 
-  mime_data_[ui::Clipboard::kMimeTypeText] =
-      FromString(base::UTF16ToUTF8(data));
+  mime_data_[ui::kMimeTypeText] = FromString(base::UTF16ToUTF8(data));
 }
 
 void OSExchangeDataProviderMus::SetURL(const GURL& url,
@@ -98,10 +98,10 @@
   AddString16ToVector(spec, &data);
   AddString16ToVector(base::ASCIIToUTF16("\n"), &data);
   AddString16ToVector(title, &data);
-  mime_data_[ui::Clipboard::kMimeTypeMozillaURL] = std::move(data);
+  mime_data_[ui::kMimeTypeMozillaURL] = std::move(data);
 
-  if (!base::ContainsKey(mime_data_, ui::Clipboard::kMimeTypeText))
-    mime_data_[ui::Clipboard::kMimeTypeText] = FromString(url.spec());
+  if (!base::ContainsKey(mime_data_, ui::kMimeTypeText))
+    mime_data_[ui::kMimeTypeText] = FromString(url.spec());
 }
 
 void OSExchangeDataProviderMus::SetFilename(const base::FilePath& path) {
@@ -120,11 +120,11 @@
   }
 
   std::string joined_data = base::JoinString(paths, "\n");
-  mime_data_[ui::Clipboard::kMimeTypeURIList] = FromString(joined_data);
+  mime_data_[ui::kMimeTypeURIList] = FromString(joined_data);
 }
 
 void OSExchangeDataProviderMus::SetPickledData(
-    const ui::Clipboard::FormatType& format,
+    const ui::ClipboardFormatType& format,
     const base::Pickle& pickle) {
   const unsigned char* bytes =
       reinterpret_cast<const unsigned char*>(pickle.data());
@@ -134,7 +134,7 @@
 }
 
 bool OSExchangeDataProviderMus::GetString(base::string16* data) const {
-  auto it = mime_data_.find(ui::Clipboard::kMimeTypeText);
+  auto it = mime_data_.find(ui::kMimeTypeText);
   if (it != mime_data_.end())
     *data = base::UTF8ToUTF16(ToString(it->second));
   return it != mime_data_.end();
@@ -144,7 +144,7 @@
     ui::OSExchangeData::FilenameToURLPolicy policy,
     GURL* url,
     base::string16* title) const {
-  auto it = mime_data_.find(ui::Clipboard::kMimeTypeMozillaURL);
+  auto it = mime_data_.find(ui::kMimeTypeMozillaURL);
   if (it == mime_data_.end()) {
     title->clear();
     return GetPlainTextURL(url) ||
@@ -177,7 +177,7 @@
 
 bool OSExchangeDataProviderMus::GetFilenames(
     std::vector<ui::FileInfo>* file_names) const {
-  auto it = mime_data_.find(ui::Clipboard::kMimeTypeURIList);
+  auto it = mime_data_.find(ui::kMimeTypeURIList);
   if (it == mime_data_.end())
     return false;
 
@@ -193,7 +193,7 @@
 }
 
 bool OSExchangeDataProviderMus::GetPickledData(
-    const ui::Clipboard::FormatType& format,
+    const ui::ClipboardFormatType& format,
     base::Pickle* data) const {
   auto it = mime_data_.find(format.Serialize());
   if (it == mime_data_.end())
@@ -207,15 +207,15 @@
 }
 
 bool OSExchangeDataProviderMus::HasString() const {
-  return base::ContainsKey(mime_data_, ui::Clipboard::kMimeTypeText);
+  return base::ContainsKey(mime_data_, ui::kMimeTypeText);
 }
 
 bool OSExchangeDataProviderMus::HasURL(
     ui::OSExchangeData::FilenameToURLPolicy policy) const {
-  if (base::ContainsKey(mime_data_, ui::Clipboard::kMimeTypeMozillaURL))
+  if (base::ContainsKey(mime_data_, ui::kMimeTypeMozillaURL))
     return true;
 
-  auto it = mime_data_.find(ui::Clipboard::kMimeTypeURIList);
+  auto it = mime_data_.find(ui::kMimeTypeURIList);
   if (it == mime_data_.end())
     return false;
 
@@ -230,7 +230,7 @@
 }
 
 bool OSExchangeDataProviderMus::HasFile() const {
-  auto it = mime_data_.find(ui::Clipboard::kMimeTypeURIList);
+  auto it = mime_data_.find(ui::kMimeTypeURIList);
   if (it == mime_data_.end())
     return false;
 
@@ -245,7 +245,7 @@
 }
 
 bool OSExchangeDataProviderMus::HasCustomFormat(
-    const ui::Clipboard::FormatType& format) const {
+    const ui::ClipboardFormatType& format) const {
   return base::ContainsKey(mime_data_, format.Serialize());
 }
 
@@ -281,12 +281,12 @@
   bytes.push_back(0xFF);
   bytes.push_back(0xFE);
   AddString16ToVector(html, &bytes);
-  mime_data_[ui::Clipboard::kMimeTypeHTML] = bytes;
+  mime_data_[ui::kMimeTypeHTML] = bytes;
 }
 
 bool OSExchangeDataProviderMus::GetHtml(base::string16* html,
                                         GURL* base_url) const {
-  auto it = mime_data_.find(ui::Clipboard::kMimeTypeHTML);
+  auto it = mime_data_.find(ui::kMimeTypeHTML);
   if (it == mime_data_.end())
     return false;
 
@@ -313,7 +313,7 @@
 }
 
 bool OSExchangeDataProviderMus::HasHtml() const {
-  return base::ContainsKey(mime_data_, ui::Clipboard::kMimeTypeHTML);
+  return base::ContainsKey(mime_data_, ui::kMimeTypeHTML);
 }
 #endif
 
--- a/ui/aura/mus/os_exchange_data_provider_mus.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/aura/mus/os_exchange_data_provider_mus.h	2019-01-24 15:42:46.724000000 +0300
@@ -46,7 +46,7 @@
   void SetURL(const GURL& url, const base::string16& title) override;
   void SetFilename(const base::FilePath& path) override;
   void SetFilenames(const std::vector<ui::FileInfo>& file_names) override;
-  void SetPickledData(const ui::Clipboard::FormatType& format,
+  void SetPickledData(const ui::ClipboardFormatType& format,
                       const base::Pickle& data) override;
 
   bool GetString(base::string16* data) const override;
@@ -55,13 +55,13 @@
                       base::string16* title) const override;
   bool GetFilename(base::FilePath* path) const override;
   bool GetFilenames(std::vector<ui::FileInfo>* file_names) const override;
-  bool GetPickledData(const ui::Clipboard::FormatType& format,
+  bool GetPickledData(const ui::ClipboardFormatType& format,
                       base::Pickle* data) const override;
 
   bool HasString() const override;
   bool HasURL(ui::OSExchangeData::FilenameToURLPolicy policy) const override;
   bool HasFile() const override;
-  bool HasCustomFormat(const ui::Clipboard::FormatType& format) const override;
+  bool HasCustomFormat(const ui::ClipboardFormatType& format) const override;
 
 // Provider doesn't have a consistent interface between operating systems;
 // this wasn't seen as a problem when there was a single Provider subclass
--- a/ui/aura/mus/os_exchange_data_provider_mus_unittest.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/aura/mus/os_exchange_data_provider_mus_unittest.cc	2019-01-24 15:42:46.724000000 +0300
@@ -171,8 +171,8 @@
 }
 
 TEST_F(OSExchangeDataProviderMusTest, TestPickledData) {
-  const Clipboard::FormatType kTestFormat =
-      Clipboard::GetFormatType("application/vnd.chromium.test");
+  const ui::ClipboardFormatType kTestFormat =
+      ui::GetClipboardFormatType("application/vnd.chromium.test");
 
   base::Pickle saved_pickle;
   saved_pickle.WriteInt(1);
--- a/ui/base/BUILD.gn	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/BUILD.gn	2019-01-24 15:42:48.060000000 +0300
@@ -79,18 +79,6 @@
     "accelerators/platform_accelerator_cocoa.mm",
     "class_property.cc",
     "class_property.h",
-    "clipboard/clipboard_android.cc",
-    "clipboard/clipboard_android.h",
-    "clipboard/clipboard_mac.h",
-    "clipboard/clipboard_mac.mm",
-    "clipboard/clipboard_types.h",
-    "clipboard/clipboard_util_mac.h",
-    "clipboard/clipboard_util_mac.mm",
-    "clipboard/clipboard_util_win.cc",
-    "clipboard/clipboard_util_win.h",
-    "clipboard/clipboard_win.cc",
-    "clipboard/clipboard_win.h",
-    "clipboard/custom_data_helper_mac.mm",
     "cocoa/animation_utils.h",
     "cocoa/appkit_utils.h",
     "cocoa/appkit_utils.mm",
@@ -327,16 +315,6 @@
       "accelerators/accelerator_manager.h",
       "base_window.cc",
       "base_window.h",
-      "clipboard/clipboard.cc",
-      "clipboard/clipboard.h",
-      "clipboard/clipboard_constants.cc",
-      "clipboard/clipboard_monitor.cc",
-      "clipboard/clipboard_monitor.h",
-      "clipboard/clipboard_observer.h",
-      "clipboard/custom_data_helper.cc",
-      "clipboard/custom_data_helper.h",
-      "clipboard/scoped_clipboard_writer.cc",
-      "clipboard/scoped_clipboard_writer.h",
       "cocoa/bubble_closer.h",
       "cocoa/bubble_closer.mm",
       "cursor/cursor_util.cc",
@@ -425,6 +403,7 @@
     "//net",
     "//third_party/icu",
     "//third_party/zlib:zlib",
+    "//ui/base/clipboard:clipboard_types",
     "//ui/display",
     "//ui/events",
     "//ui/events/devices",
@@ -537,6 +516,10 @@
     ]
   }
 
+  if (is_win || is_ios) {
+    deps += [ "//ui/base/clipboard:clipboard_util" ]
+  }
+
   libs = []
   if (is_win) {
     sources += [
@@ -637,20 +620,6 @@
   }
 
   if (use_aura) {
-    # Aura clipboard.
-    if (use_x11 && is_desktop_linux) {
-      sources += [
-        "clipboard/clipboard_aurax11.cc",
-        "clipboard/clipboard_aurax11.h",
-      ]
-    } else if (!is_win) {
-      # This file is used for all non-X11, non-Windows aura Builds.
-      sources += [
-        "clipboard/clipboard_aura.cc",
-        "clipboard/clipboard_aura.h",
-      ]
-    }
-
     # Cursor
     sources += [
       "cursor/cursors_aura.cc",
@@ -697,8 +666,6 @@
       "test/scoped_fake_nswindow_fullscreen.mm",
       "test/scoped_preferred_scroller_style_mac.h",
       "test/scoped_preferred_scroller_style_mac.mm",
-      "test/test_clipboard.cc",
-      "test/test_clipboard.h",
       "test/view_tree_validator.h",
       "test/view_tree_validator.mm",
       "test/windowed_nsnotification_observer.h",
@@ -799,8 +766,6 @@
 test("ui_base_unittests") {
   sources = [
     "class_property_unittest.cc",
-    "clipboard/clipboard_mac_unittest.mm",
-    "clipboard/clipboard_util_mac_unittest.mm",
     "l10n/l10n_util_mac_unittest.mm",
     "l10n/l10n_util_unittest.cc",
     "l10n/time_format_unittest.cc",
@@ -822,7 +787,6 @@
   if (!is_ios) {
     sources += [
       "test/scoped_fake_nswindow_fullscreen_unittest.mm",
-      "test/test_clipboard_unittest.cc",
       "test/view_tree_validator_unittest.mm",
     ]
   }
@@ -850,7 +814,6 @@
       "accelerators/menu_label_accelerator_util_linux_unittest.cc",
       "accelerators/menu_label_accelerator_util_unittest.cc",
       "accelerators/platform_accelerator_cocoa_unittest.mm",
-      "clipboard/custom_data_helper_unittest.cc",
       "cocoa/base_view_unittest.mm",
       "cocoa/bubble_closer_unittest.mm",
       "cocoa/cocoa_base_utils_unittest.mm",
@@ -915,6 +878,7 @@
     "//ui/base",
     "//ui/base:test_support",
     "//ui/base:ui_data_pack",
+    "//ui/base/clipboard:clipboard_test",
     "//ui/display",
     "//ui/events:events_base",
     "//ui/events:test_support",
--- a/ui/base/clipboard/clipboard_android.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard_android.cc	2019-01-24 15:42:48.076000000 +0300
@@ -42,15 +42,6 @@
 
 namespace {
 
-// Various formats we support.
-const char kURLFormat[] = "url";
-const char kPlainTextFormat[] = "text";
-const char kHTMLFormat[] = "html";
-const char kRTFFormat[] = "rtf";
-const char kBitmapFormat[] = "bitmap";
-const char kWebKitSmartPasteFormat[] = "webkit_smart";
-const char kBookmarkFormat[] = "bookmark";
-
 class ClipboardMap {
  public:
   ClipboardMap();
@@ -144,22 +135,23 @@
 void ClipboardMap::CommitToAndroidClipboard() {
   JNIEnv* env = AttachCurrentThread();
   base::AutoLock lock(lock_);
-  if (base::ContainsKey(map_, kHTMLFormat)) {
+  if (base::ContainsKey(map_, GetHtmlClipboardFormatType().ToString())) {
     // Android's API for storing HTML content on the clipboard requires a plain-
     // text representation to be available as well.
-    if (!base::ContainsKey(map_, kPlainTextFormat))
+    if (!base::ContainsKey(map_, GetPlainTextClipboardFormatType().ToString()))
       return;
 
-    ScopedJavaLocalRef<jstring> html =
-        ConvertUTF8ToJavaString(env, map_[kHTMLFormat]);
-    ScopedJavaLocalRef<jstring> text =
-        ConvertUTF8ToJavaString(env, map_[kPlainTextFormat]);
+    ScopedJavaLocalRef<jstring> html = ConvertUTF8ToJavaString(
+        env, map_[GetHtmlClipboardFormatType().ToString()]);
+    ScopedJavaLocalRef<jstring> text = ConvertUTF8ToJavaString(
+        env, map_[GetPlainTextClipboardFormatType().ToString()]);
 
     DCHECK(html.obj() && text.obj());
     Java_Clipboard_setHTMLText(env, clipboard_manager_, html, text);
-  } else if (base::ContainsKey(map_, kPlainTextFormat)) {
-    ScopedJavaLocalRef<jstring> str =
-        ConvertUTF8ToJavaString(env, map_[kPlainTextFormat]);
+  } else if (base::ContainsKey(map_,
+                               GetPlainTextClipboardFormatType().ToString())) {
+    ScopedJavaLocalRef<jstring> str = ConvertUTF8ToJavaString(
+        env, map_[GetPlainTextClipboardFormatType().ToString()]);
     DCHECK(str.obj());
     Java_Clipboard_setText(env, clipboard_manager_, str);
   } else {
@@ -224,104 +216,16 @@
   ScopedJavaLocalRef<jstring> jhtml =
       Java_Clipboard_getHTMLText(env, clipboard_manager_);
 
-  JNI_Clipboard_AddMapEntry(env, &map_, kPlainTextFormat, jtext);
-  JNI_Clipboard_AddMapEntry(env, &map_, kHTMLFormat, jhtml);
+  JNI_Clipboard_AddMapEntry(
+      env, &map_, GetPlainTextClipboardFormatType().ToString(), jtext);
+  JNI_Clipboard_AddMapEntry(env, &map_, GetHtmlClipboardFormatType().ToString(),
+                            jhtml);
 
   map_state_ = MapState::kUpToDate;
 }
 
 }  // namespace
 
-// Clipboard::FormatType implementation.
-Clipboard::FormatType::FormatType() {
-}
-
-Clipboard::FormatType::FormatType(const std::string& native_format)
-    : data_(native_format) {
-}
-
-Clipboard::FormatType::~FormatType() {
-}
-
-std::string Clipboard::FormatType::Serialize() const {
-  return data_;
-}
-
-// static
-Clipboard::FormatType Clipboard::FormatType::Deserialize(
-    const std::string& serialization) {
-  return FormatType(serialization);
-}
-
-bool Clipboard::FormatType::operator<(const FormatType& other) const {
-  return data_ < other.data_;
-}
-
-bool Clipboard::FormatType::Equals(const FormatType& other) const {
-  return data_ == other.data_;
-}
-
-// Various predefined FormatTypes.
-// static
-Clipboard::FormatType Clipboard::GetFormatType(
-    const std::string& format_string) {
-  return FormatType::Deserialize(format_string);
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetUrlWFormatType() {
-  static base::NoDestructor<FormatType> type(kURLFormat);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextFormatType() {
-  static base::NoDestructor<FormatType> type(kPlainTextFormat);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextWFormatType() {
-  static base::NoDestructor<FormatType> type(kPlainTextFormat);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebKitSmartPasteFormatType() {
-  static base::NoDestructor<FormatType> type(kWebKitSmartPasteFormat);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetHtmlFormatType() {
-  static base::NoDestructor<FormatType> type(kHTMLFormat);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetRtfFormatType() {
-  static base::NoDestructor<FormatType> type(kRTFFormat);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetBitmapFormatType() {
-  static base::NoDestructor<FormatType> type(kBitmapFormat);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebCustomDataFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeWebCustomData);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPepperCustomDataFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypePepperCustomData);
-  return *type;
-}
-
 // Clipboard factory method.
 // static
 Clipboard* Clipboard::Create() {
@@ -360,7 +264,7 @@
   return g_map.Get().GetSequenceNumber();
 }
 
-bool ClipboardAndroid::IsFormatAvailable(const Clipboard::FormatType& format,
+bool ClipboardAndroid::IsFormatAvailable(const ClipboardFormatType& format,
                                          ClipboardType type) const {
   DCHECK(CalledOnValidThread());
   DCHECK_EQ(type, CLIPBOARD_TYPE_COPY_PASTE);
@@ -388,16 +292,16 @@
 
   // would be nice to ask the ClipboardMap to enumerate the types it supports,
   // rather than hardcode the list here.
-  if (IsFormatAvailable(Clipboard::GetPlainTextFormatType(), type))
+  if (IsFormatAvailable(GetPlainTextClipboardFormatType(), type))
     types->push_back(base::UTF8ToUTF16(kMimeTypeText));
-  if (IsFormatAvailable(Clipboard::GetHtmlFormatType(), type))
+  if (IsFormatAvailable(GetHtmlClipboardFormatType(), type))
     types->push_back(base::UTF8ToUTF16(kMimeTypeHTML));
 
   // these formats aren't supported by the ClipboardMap currently, but might
   // be one day?
-  if (IsFormatAvailable(Clipboard::GetRtfFormatType(), type))
+  if (IsFormatAvailable(GetRtfClipboardFormatType(), type))
     types->push_back(base::UTF8ToUTF16(kMimeTypeRTF));
-  if (IsFormatAvailable(Clipboard::GetBitmapFormatType(), type))
+  if (IsFormatAvailable(GetBitmapClipboardFormatType(), type))
     types->push_back(base::UTF8ToUTF16(kMimeTypePNG));
   *contains_filenames = false;
 }
@@ -415,7 +319,7 @@
                                      std::string* result) const {
   DCHECK(CalledOnValidThread());
   DCHECK_EQ(type, CLIPBOARD_TYPE_COPY_PASTE);
-  *result = g_map.Get().Get(kPlainTextFormat);
+  *result = g_map.Get().Get(GetPlainTextClipboardFormatType().ToString());
 }
 
 // Note: |b_url| isn't really used. It is only implemented in Windows
@@ -429,7 +333,7 @@
   if (b_url)
     b_url->clear();
 
-  std::string input = g_map.Get().Get(kHTMLFormat);
+  std::string input = g_map.Get().Get(GetHtmlClipboardFormatType().ToString());
   *markup = base::UTF8ToUTF16(input);
 
   *fragment_start = 0;
@@ -444,7 +348,8 @@
 SkBitmap ClipboardAndroid::ReadImage(ClipboardType type) const {
   DCHECK(CalledOnValidThread());
   DCHECK_EQ(type, CLIPBOARD_TYPE_COPY_PASTE);
-  std::string input = g_map.Get().Get(kBitmapFormat);
+  std::string input =
+      g_map.Get().Get(GetBitmapClipboardFormatType().ToString());
 
   SkBitmap bmp;
   if (!input.empty()) {
@@ -474,7 +379,7 @@
   NOTIMPLEMENTED();
 }
 
-void ClipboardAndroid::ReadData(const Clipboard::FormatType& format,
+void ClipboardAndroid::ReadData(const ClipboardFormatType& format,
                                 std::string* result) const {
   DCHECK(CalledOnValidThread());
   *result = g_map.Get().Get(format.ToString());
@@ -506,14 +411,16 @@
 }
 
 void ClipboardAndroid::WriteText(const char* text_data, size_t text_len) {
-  g_map.Get().Set(kPlainTextFormat, std::string(text_data, text_len));
+  g_map.Get().Set(GetPlainTextClipboardFormatType().ToString(),
+                  std::string(text_data, text_len));
 }
 
 void ClipboardAndroid::WriteHTML(const char* markup_data,
                                  size_t markup_len,
                                  const char* url_data,
                                  size_t url_len) {
-  g_map.Get().Set(kHTMLFormat, std::string(markup_data, markup_len));
+  g_map.Get().Set(GetHtmlClipboardFormatType().ToString(),
+                  std::string(markup_data, markup_len));
 }
 
 void ClipboardAndroid::WriteRTF(const char* rtf_data, size_t data_len) {
@@ -526,13 +433,15 @@
                                      size_t title_len,
                                      const char* url_data,
                                      size_t url_len) {
-  g_map.Get().Set(kBookmarkFormat, std::string(url_data, url_len));
+  g_map.Get().Set(GetBookmarkClipboardFormatType().ToString(),
+                  std::string(url_data, url_len));
 }
 
 // Write an extra flavor that signifies WebKit was the last to modify the
 // pasteboard. This flavor has no data.
 void ClipboardAndroid::WriteWebSmartPaste() {
-  g_map.Get().Set(kWebKitSmartPasteFormat, std::string());
+  g_map.Get().Set(GetWebKitSmartPasteClipboardFormatType().ToString(),
+                  std::string());
 }
 
 // Note: we implement this to pass all unit tests but it is currently unclear
@@ -543,10 +452,10 @@
   std::string packed(reinterpret_cast<const char*>(&size), sizeof(size));
   packed += std::string(static_cast<const char*>(bitmap.getPixels()),
                         bitmap.computeByteSize());
-  g_map.Get().Set(kBitmapFormat, packed);
+  g_map.Get().Set(GetBitmapClipboardFormatType().ToString(), packed);
 }
 
-void ClipboardAndroid::WriteData(const Clipboard::FormatType& format,
+void ClipboardAndroid::WriteData(const ClipboardFormatType& format,
                                  const char* data_data,
                                  size_t data_len) {
   g_map.Get().Set(format.ToString(), std::string(data_data, data_len));
--- a/ui/base/clipboard/clipboard_android.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard_android.h	2019-01-24 15:42:48.076000000 +0300
@@ -30,10 +30,10 @@
                             const base::android::JavaParamRef<jobject>& obj);
 
   // Sets the callback called whenever the clipboard is modified.
-  UI_BASE_EXPORT void SetModifiedCallback(ModifiedCallback cb);
+  UI_BASE_CLIPBOARD_EXPORT void SetModifiedCallback(ModifiedCallback cb);
 
   // Sets the last modified time without calling the above callback.
-  UI_BASE_EXPORT void SetLastModifiedTimeWithoutRunningCallback(
+  UI_BASE_CLIPBOARD_EXPORT void SetLastModifiedTimeWithoutRunningCallback(
       base::Time time);
 
  private:
@@ -45,7 +45,7 @@
   // Clipboard overrides:
   void OnPreShutdown() override;
   uint64_t GetSequenceNumber(ClipboardType type) const override;
-  bool IsFormatAvailable(const FormatType& format,
+  bool IsFormatAvailable(const ClipboardFormatType& format,
                          ClipboardType type) const override;
   void Clear(ClipboardType type) override;
   void ReadAvailableTypes(ClipboardType type,
@@ -64,7 +64,8 @@
                       const base::string16& type,
                       base::string16* result) const override;
   void ReadBookmark(base::string16* title, std::string* url) const override;
-  void ReadData(const FormatType& format, std::string* result) const override;
+  void ReadData(const ClipboardFormatType& format,
+                std::string* result) const override;
   base::Time GetLastModifiedTime() const override;
   void ClearLastModifiedTime() override;
   void WriteObjects(ClipboardType type, const ObjectMap& objects) override;
@@ -80,7 +81,7 @@
                      size_t url_len) override;
   void WriteWebSmartPaste() override;
   void WriteBitmap(const SkBitmap& bitmap) override;
-  void WriteData(const FormatType& format,
+  void WriteData(const ClipboardFormatType& format,
                  const char* data_data,
                  size_t data_len) override;
 
--- a/ui/base/clipboard/clipboard_aura.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard_aura.cc	2019-01-24 15:42:48.076000000 +0300
@@ -18,6 +18,8 @@
 #include "base/no_destructor.h"
 #include "base/strings/utf_string_conversions.h"
 #include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/clipboard/clipboard_constants.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/clipboard/clipboard_monitor.h"
 #include "ui/base/clipboard/custom_data_helper.h"
 #include "ui/gfx/geometry/size.h"
@@ -26,8 +28,6 @@
 
 namespace {
 
-const char kMimeTypeFilename[] = "chromium/filename";
-const char kMimeTypeBitmap[] = "image/bmp";
 const size_t kMaxClipboardSize = 1;
 
 // Clipboard data format used by AuraClipboard.
@@ -416,117 +416,6 @@
 
 }  // namespace
 
-// Clipboard::FormatType implementation.
-Clipboard::FormatType::FormatType() {
-}
-
-Clipboard::FormatType::FormatType(const std::string& native_format)
-    : data_(native_format) {
-}
-
-Clipboard::FormatType::~FormatType() {
-}
-
-std::string Clipboard::FormatType::Serialize() const {
-  return data_;
-}
-
-// static
-Clipboard::FormatType Clipboard::FormatType::Deserialize(
-    const std::string& serialization) {
-  return FormatType(serialization);
-}
-
-bool Clipboard::FormatType::operator<(const FormatType& other) const {
-  return data_ < other.data_;
-}
-
-bool Clipboard::FormatType::Equals(const FormatType& other) const {
-  return data_ == other.data_;
-}
-
-// Various predefined FormatTypes.
-// static
-Clipboard::FormatType Clipboard::GetFormatType(
-    const std::string& format_string) {
-  return FormatType::Deserialize(format_string);
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetUrlFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeURIList);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetUrlWFormatType() {
-  return GetUrlFormatType();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetMozUrlFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeMozillaURL);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeText);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextWFormatType() {
-  return GetPlainTextFormatType();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFilenameFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeFilename);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFilenameWFormatType() {
-  return Clipboard::GetFilenameFormatType();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetHtmlFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeHTML);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetRtfFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeRTF);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetBitmapFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeBitmap);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebKitSmartPasteFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeWebkitSmartPaste);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebCustomDataFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeWebCustomData);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPepperCustomDataFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypePepperCustomData);
-  return *type;
-}
-
 // Clipboard factory method.
 Clipboard* Clipboard::Create() {
   return new ClipboardAura;
@@ -551,23 +440,22 @@
   return GetClipboard()->sequence_number();
 }
 
-bool ClipboardAura::IsFormatAvailable(const FormatType& format,
+bool ClipboardAura::IsFormatAvailable(const ClipboardFormatType& format,
                                       ClipboardType type) const {
   DCHECK(CalledOnValidThread());
   DCHECK(IsSupportedClipboardType(type));
-  AuraClipboard* clipboard = GetClipboard();
-  if (GetPlainTextFormatType().Equals(format) ||
-      GetUrlFormatType().Equals(format))
-    return clipboard->IsFormatAvailable(TEXT);
-  if (GetHtmlFormatType().Equals(format))
-    return clipboard->IsFormatAvailable(HTML);
-  if (GetRtfFormatType().Equals(format))
-    return clipboard->IsFormatAvailable(RTF);
-  if (GetBitmapFormatType().Equals(format))
-    return clipboard->IsFormatAvailable(BITMAP);
-  if (GetWebKitSmartPasteFormatType().Equals(format))
-    return clipboard->IsFormatAvailable(WEB);
-  const ClipboardData* data = clipboard->GetData();
+  if (GetPlainTextClipboardFormatType().Equals(format) ||
+      GetUrlClipboardFormatType().Equals(format))
+    return clipboard_internal_->IsFormatAvailable(TEXT);
+  if (GetHtmlClipboardFormatType().Equals(format))
+    return clipboard_internal_->IsFormatAvailable(HTML);
+  if (GetRtfClipboardFormatType().Equals(format))
+    return clipboard_internal_->IsFormatAvailable(RTF);
+  if (GetBitmapClipboardFormatType().Equals(format))
+    return clipboard_internal_->IsFormatAvailable(BITMAP);
+  if (GetWebKitSmartPasteClipboardFormatType().Equals(format))
+    return clipboard_internal_->IsFormatAvailable(WEB);
+  const ClipboardData* data = clipboard_internal_->GetData();
   return data && data->custom_data_format() == format.ToString();
 }
 
@@ -589,13 +477,15 @@
 
   types->clear();
   *contains_filenames = false;
-  if (IsFormatAvailable(GetPlainTextFormatType(), type))
-    types->push_back(base::UTF8ToUTF16(GetPlainTextFormatType().ToString()));
-  if (IsFormatAvailable(GetHtmlFormatType(), type))
-    types->push_back(base::UTF8ToUTF16(GetHtmlFormatType().ToString()));
-  if (IsFormatAvailable(GetRtfFormatType(), type))
-    types->push_back(base::UTF8ToUTF16(GetRtfFormatType().ToString()));
-  if (IsFormatAvailable(GetBitmapFormatType(), type))
+  if (IsFormatAvailable(GetPlainTextClipboardFormatType(), type))
+    types->push_back(
+        base::UTF8ToUTF16(GetPlainTextClipboardFormatType().ToString()));
+  if (IsFormatAvailable(GetHtmlClipboardFormatType(), type))
+    types->push_back(
+        base::UTF8ToUTF16(GetHtmlClipboardFormatType().ToString()));
+  if (IsFormatAvailable(GetRtfClipboardFormatType(), type))
+    types->push_back(base::UTF8ToUTF16(GetRtfClipboardFormatType().ToString()));
+  if (IsFormatAvailable(GetBitmapClipboardFormatType(), type))
     types->push_back(base::UTF8ToUTF16(kMimeTypePNG));
 
   AuraClipboard* clipboard = GetClipboard();
@@ -648,7 +538,7 @@
   GetClipboard()->ReadBookmark(title, url);
 }
 
-void ClipboardAura::ReadData(const FormatType& format,
+void ClipboardAura::ReadData(const ClipboardFormatType& format,
                              std::string* result) const {
   DCHECK(CalledOnValidThread());
   GetClipboard()->ReadData(format.ToString(), result);
@@ -694,7 +584,7 @@
   ClipboardDataBuilder::WriteBitmap(bitmap);
 }
 
-void ClipboardAura::WriteData(const FormatType& format,
+void ClipboardAura::WriteData(const ClipboardFormatType& format,
                               const char* data_data,
                               size_t data_len) {
   ClipboardDataBuilder::WriteData(format.ToString(), data_data, data_len);
--- a/ui/base/clipboard/clipboard_aura.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard_aura.h	2019-01-24 15:42:48.080000000 +0300
@@ -23,7 +23,7 @@
   // Clipboard overrides:
   void OnPreShutdown() override;
   uint64_t GetSequenceNumber(ClipboardType type) const override;
-  bool IsFormatAvailable(const FormatType& format,
+  bool IsFormatAvailable(const ClipboardFormatType& format,
                          ClipboardType type) const override;
   void Clear(ClipboardType type) override;
   void ReadAvailableTypes(ClipboardType type,
@@ -42,7 +42,8 @@
                       const base::string16& type,
                       base::string16* result) const override;
   void ReadBookmark(base::string16* title, std::string* url) const override;
-  void ReadData(const FormatType& format, std::string* result) const override;
+  void ReadData(const ClipboardFormatType& format,
+                std::string* result) const override;
   void WriteObjects(ClipboardType type, const ObjectMap& objects) override;
   void WriteText(const char* text_data, size_t text_len) override;
   void WriteHTML(const char* markup_data,
@@ -56,7 +57,7 @@
                      size_t url_len) override;
   void WriteWebSmartPaste() override;
   void WriteBitmap(const SkBitmap& bitmap) override;
-  void WriteData(const FormatType& format,
+  void WriteData(const ClipboardFormatType& format,
                  const char* data_data,
                  size_t data_len) override;
 
--- a/ui/base/clipboard/clipboard_aurax11.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard_aurax11.cc	2019-01-24 15:42:48.080000000 +0300
@@ -21,6 +21,7 @@
 #include "base/stl_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/clipboard/clipboard_constants.h"
 #include "ui/base/clipboard/clipboard_monitor.h"
 #include "ui/base/clipboard/custom_data_helper.h"
 #include "ui/base/x/selection_owner.h"
@@ -42,7 +43,6 @@
 
 const char kClipboard[] = "CLIPBOARD";
 const char kClipboardManager[] = "CLIPBOARD_MANAGER";
-const char kMimeTypeFilename[] = "chromium/filename";
 
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -135,7 +135,7 @@
   const AtomVector& target_list() { return target_list_; }
 
   bool ContainsText() const;
-  bool ContainsFormat(const Clipboard::FormatType& format_type) const;
+  bool ContainsFormat(const ClipboardFormatType& format_type) const;
   bool ContainsAtom(::Atom atom) const;
 
  private:
@@ -156,8 +156,7 @@
   return false;
 }
 
-bool TargetList::ContainsFormat(
-    const Clipboard::FormatType& format_type) const {
+bool TargetList::ContainsFormat(const ClipboardFormatType& format_type) const {
   ::Atom atom = gfx::GetAtom(format_type.ToString().c_str());
   return ContainsAtom(atom);
 }
@@ -170,41 +169,6 @@
 }  // namespace
 
 ///////////////////////////////////////////////////////////////////////////////
-
-// I would love for the FormatType to really be a wrapper around an X11 ::Atom,
-// but there are a few problems. Chromeos unit tests spawn a new X11 server for
-// each test, so Atom numeric values don't persist across tests. We could still
-// maybe deal with that if we didn't have static accessor methods everywhere.
-
-Clipboard::FormatType::FormatType() {
-}
-
-Clipboard::FormatType::FormatType(const std::string& native_format)
-    : data_(native_format) {
-}
-
-Clipboard::FormatType::~FormatType() {
-}
-
-std::string Clipboard::FormatType::Serialize() const {
-  return data_;
-}
-
-// static
-Clipboard::FormatType Clipboard::FormatType::Deserialize(
-    const std::string& serialization) {
-  return FormatType(serialization);
-}
-
-bool Clipboard::FormatType::operator<(const FormatType& other) const {
-  return data_ < other.data_;
-}
-
-bool Clipboard::FormatType::Equals(const FormatType& other) const {
-  return data_ == other.data_;
-}
-
-///////////////////////////////////////////////////////////////////////////////
 // ClipboardAuraX11::AuraX11Details
 
 // Private implementation of our X11 integration. Keeps X11 headers out of the
@@ -260,7 +224,7 @@
   std::vector< ::Atom> GetTextAtoms() const;
 
   // Returns a vector with a |format| converted to an X11 atom.
-  std::vector< ::Atom> GetAtomsForFormat(const Clipboard::FormatType& format);
+  std::vector<::Atom> GetAtomsForFormat(const ClipboardFormatType& format);
 
   // Clears a certain clipboard type, whether we own it or not.
   void Clear(ClipboardType type);
@@ -454,7 +418,7 @@
 }
 
 std::vector<::Atom> ClipboardAuraX11::AuraX11Details::GetAtomsForFormat(
-    const Clipboard::FormatType& format) {
+    const ClipboardFormatType& format) {
   std::vector< ::Atom> atoms;
   atoms.push_back(gfx::GetAtom(format.ToString().c_str()));
   return atoms;
@@ -547,89 +511,6 @@
 }
 
 ///////////////////////////////////////////////////////////////////////////////
-// Various predefined FormatTypes.
-// static
-Clipboard::FormatType Clipboard::GetFormatType(
-    const std::string& format_string) {
-  return FormatType::Deserialize(format_string);
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetUrlFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeURIList);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetUrlWFormatType() {
-  return GetUrlFormatType();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetMozUrlFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeMozillaURL);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeText);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextWFormatType() {
-  return GetPlainTextFormatType();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFilenameFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeFilename);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFilenameWFormatType() {
-  return Clipboard::GetFilenameFormatType();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetHtmlFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeHTML);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetRtfFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeRTF);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetBitmapFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypePNG);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebKitSmartPasteFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeWebkitSmartPaste);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebCustomDataFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypeWebCustomData);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPepperCustomDataFormatType() {
-  static base::NoDestructor<FormatType> type(kMimeTypePepperCustomData);
-  return *type;
-}
-
-///////////////////////////////////////////////////////////////////////////////
 // Clipboard factory method.
 Clipboard* Clipboard::Create() {
   return new ClipboardAuraX11;
@@ -659,14 +540,14 @@
     return SelectionChangeObserver::GetInstance()->primary_sequence_number();
 }
 
-bool ClipboardAuraX11::IsFormatAvailable(const FormatType& format,
+bool ClipboardAuraX11::IsFormatAvailable(const ClipboardFormatType& format,
                                          ClipboardType type) const {
   DCHECK(CalledOnValidThread());
   DCHECK(IsSupportedClipboardType(type));
 
   TargetList target_list = aurax11_details_->WaitAndGetTargetsList(type);
-  if (format.Equals(GetPlainTextFormatType()) ||
-      format.Equals(GetUrlFormatType())) {
+  if (format.Equals(GetPlainTextClipboardFormatType()) ||
+      format.Equals(GetUrlClipboardFormatType())) {
     return target_list.ContainsText();
   }
   return target_list.ContainsFormat(format);
@@ -693,16 +574,17 @@
 
   if (target_list.ContainsText())
     types->push_back(base::UTF8ToUTF16(kMimeTypeText));
-  if (target_list.ContainsFormat(GetHtmlFormatType()))
+  if (target_list.ContainsFormat(GetHtmlClipboardFormatType()))
     types->push_back(base::UTF8ToUTF16(kMimeTypeHTML));
-  if (target_list.ContainsFormat(GetRtfFormatType()))
+  if (target_list.ContainsFormat(GetRtfClipboardFormatType()))
     types->push_back(base::UTF8ToUTF16(kMimeTypeRTF));
-  if (target_list.ContainsFormat(GetBitmapFormatType()))
+  if (target_list.ContainsFormat(GetBitmapClipboardFormatType()))
     types->push_back(base::UTF8ToUTF16(kMimeTypePNG));
   *contains_filenames = false;
 
   SelectionData data(aurax11_details_->RequestAndWaitForTypes(
-      type, aurax11_details_->GetAtomsForFormat(GetWebCustomDataFormatType())));
+      type, aurax11_details_->GetAtomsForFormat(
+                GetWebCustomDataClipboardFormatType())));
   if (data.IsValid())
     ReadCustomDataTypes(data.GetData(), data.GetSize(), types);
 }
@@ -744,7 +626,7 @@
   *fragment_end = 0;
 
   SelectionData data(aurax11_details_->RequestAndWaitForTypes(
-      type, aurax11_details_->GetAtomsForFormat(GetHtmlFormatType())));
+      type, aurax11_details_->GetAtomsForFormat(GetHtmlClipboardFormatType())));
   if (data.IsValid()) {
     *markup = data.GetHtml();
 
@@ -758,7 +640,7 @@
   DCHECK(CalledOnValidThread());
 
   SelectionData data(aurax11_details_->RequestAndWaitForTypes(
-      type, aurax11_details_->GetAtomsForFormat(GetRtfFormatType())));
+      type, aurax11_details_->GetAtomsForFormat(GetRtfClipboardFormatType())));
   if (data.IsValid())
     data.AssignTo(result);
 }
@@ -767,7 +649,8 @@
   DCHECK(CalledOnValidThread());
 
   SelectionData data(aurax11_details_->RequestAndWaitForTypes(
-      type, aurax11_details_->GetAtomsForFormat(GetBitmapFormatType())));
+      type,
+      aurax11_details_->GetAtomsForFormat(GetBitmapClipboardFormatType())));
   if (data.IsValid()) {
     SkBitmap bitmap;
     if (gfx::PNGCodec::Decode(data.GetData(), data.GetSize(), &bitmap))
@@ -783,8 +666,8 @@
   DCHECK(CalledOnValidThread());
 
   SelectionData data(aurax11_details_->RequestAndWaitForTypes(
-      clipboard_type,
-      aurax11_details_->GetAtomsForFormat(GetWebCustomDataFormatType())));
+      clipboard_type, aurax11_details_->GetAtomsForFormat(
+                          GetWebCustomDataClipboardFormatType())));
   if (data.IsValid())
     ReadCustomDataForType(data.GetData(), data.GetSize(), type, result);
 }
@@ -796,7 +679,7 @@
   NOTIMPLEMENTED();
 }
 
-void ClipboardAuraX11::ReadData(const FormatType& format,
+void ClipboardAuraX11::ReadData(const ClipboardFormatType& format,
                                 std::string* result) const {
   DCHECK(CalledOnValidThread());
 
@@ -861,7 +744,7 @@
 }
 
 void ClipboardAuraX11::WriteRTF(const char* rtf_data, size_t data_len) {
-  WriteData(GetRtfFormatType(), rtf_data, data_len);
+  WriteData(GetRtfClipboardFormatType(), rtf_data, data_len);
 }
 
 void ClipboardAuraX11::WriteBookmark(const char* title_data,
@@ -902,12 +785,12 @@
   }
 }
 
-void ClipboardAuraX11::WriteData(const FormatType& format,
+void ClipboardAuraX11::WriteData(const ClipboardFormatType& format,
                                  const char* data_data,
                                  size_t data_len) {
   // We assume that certain mapping types are only written by trusted code.
   // Therefore we must upkeep their integrity.
-  if (format.Equals(GetBitmapFormatType()))
+  if (format.Equals(GetBitmapClipboardFormatType()))
     return;
 
   std::vector<unsigned char> bytes(data_data, data_data + data_len);
--- a/ui/base/clipboard/clipboard_aurax11.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard_aurax11.h	2019-01-24 15:42:48.080000000 +0300
@@ -25,7 +25,7 @@
   // Clipboard overrides:
   void OnPreShutdown() override;
   uint64_t GetSequenceNumber(ClipboardType type) const override;
-  bool IsFormatAvailable(const FormatType& format,
+  bool IsFormatAvailable(const ClipboardFormatType& format,
                          ClipboardType type) const override;
   void Clear(ClipboardType type) override;
   void ReadAvailableTypes(ClipboardType type,
@@ -44,7 +44,8 @@
                       const base::string16& type,
                       base::string16* result) const override;
   void ReadBookmark(base::string16* title, std::string* url) const override;
-  void ReadData(const FormatType& format, std::string* result) const override;
+  void ReadData(const ClipboardFormatType& format,
+                std::string* result) const override;
   void WriteObjects(ClipboardType type, const ObjectMap& objects) override;
   void WriteText(const char* text_data, size_t text_len) override;
   void WriteHTML(const char* markup_data,
@@ -58,7 +59,7 @@
                      size_t url_len) override;
   void WriteWebSmartPaste() override;
   void WriteBitmap(const SkBitmap& bitmap) override;
-  void WriteData(const FormatType& format,
+  void WriteData(const ClipboardFormatType& format,
                  const char* data_data,
                  size_t data_len) override;
 
--- a/ui/base/clipboard/clipboard.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard.cc	2019-01-24 15:42:48.076000000 +0300
@@ -138,11 +138,9 @@
     }
 
     case CBF_DATA:
-      WriteData(
-          FormatType::Deserialize(
+      WriteData(ClipboardFormatType::Deserialize(
               std::string(&(params[0].front()), params[0].size())),
-          &(params[1].front()),
-          params[1].size());
+                &(params[1].front()), params[1].size());
       break;
 
     default:
--- a/ui/base/clipboard/clipboard_constants.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard_constants.cc	2019-01-24 15:42:48.080000000 +0300
@@ -2,21 +2,20 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/clipboard_constants.h"
 
 namespace ui {
 
-const char Clipboard::kMimeTypeText[] = "text/plain";
-const char Clipboard::kMimeTypeURIList[] = "text/uri-list";
-const char Clipboard::kMimeTypeMozillaURL[] = "text/x-moz-url";
-const char Clipboard::kMimeTypeDownloadURL[] = "downloadurl";
-const char Clipboard::kMimeTypeHTML[] = "text/html";
-const char Clipboard::kMimeTypeRTF[] = "text/rtf";
-const char Clipboard::kMimeTypePNG[] = "image/png";
+const char kMimeTypeText[] = "text/plain";
+const char kMimeTypeURIList[] = "text/uri-list";
+const char kMimeTypeMozillaURL[] = "text/x-moz-url";
+const char kMimeTypeDownloadURL[] = "downloadurl";
+const char kMimeTypeHTML[] = "text/html";
+const char kMimeTypeRTF[] = "text/rtf";
+const char kMimeTypePNG[] = "image/png";
 // TODO(dcheng): This name is temporary. See crbug.com/106449.
-const char Clipboard::kMimeTypeWebCustomData[] = "chromium/x-web-custom-data";
-const char Clipboard::kMimeTypeWebkitSmartPaste[] = "chromium/x-webkit-paste";
-const char Clipboard::kMimeTypePepperCustomData[] =
-    "chromium/x-pepper-custom-data";
+const char kMimeTypeWebCustomData[] = "chromium/x-web-custom-data";
+const char kMimeTypeWebkitSmartPaste[] = "chromium/x-webkit-paste";
+const char kMimeTypePepperCustomData[] = "chromium/x-pepper-custom-data";
 
 }  // namespace ui
--- a/ui/base/clipboard/clipboard.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard.h	2019-01-24 15:42:48.076000000 +0300
@@ -24,8 +24,9 @@
 #include "base/threading/thread_checker.h"
 #include "base/time/time.h"
 #include "build/build_config.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/clipboard/clipboard_types.h"
-#include "ui/base/ui_base_export.h"
+#include "ui/base/clipboard/ui_base_clipboard_export.h"
 
 #if defined(OS_WIN)
 #include <objidl.h>
@@ -43,74 +44,8 @@
 class TestClipboard;
 class ScopedClipboardWriter;
 
-class UI_BASE_EXPORT Clipboard : public base::ThreadChecker {
+class UI_BASE_CLIPBOARD_EXPORT Clipboard : public base::ThreadChecker {
  public:
-  // MIME type constants.
-  static const char kMimeTypeText[];
-  static const char kMimeTypeURIList[];
-  static const char kMimeTypeDownloadURL[];
-  static const char kMimeTypeMozillaURL[];
-  static const char kMimeTypeHTML[];
-  static const char kMimeTypeRTF[];
-  static const char kMimeTypePNG[];
-  static const char kMimeTypeWebCustomData[];
-  static const char kMimeTypeWebkitSmartPaste[];
-  static const char kMimeTypePepperCustomData[];
-
-  // Platform neutral holder for native data representation of a clipboard type.
-  struct UI_BASE_EXPORT FormatType {
-    FormatType();
-    ~FormatType();
-
-    // Serializes and deserializes a FormatType for use in IPC messages.
-    std::string Serialize() const;
-    static FormatType Deserialize(const std::string& serialization);
-
-    // FormatType can be used in a set on some platforms.
-    bool operator<(const FormatType& other) const;
-
-#if defined(OS_WIN)
-    const FORMATETC& ToFormatEtc() const { return data_; }
-#elif defined(USE_AURA) || defined(OS_ANDROID) || defined(OS_FUCHSIA)
-    const std::string& ToString() const { return data_; }
-#elif defined(OS_MACOSX)
-    NSString* ToNSString() const { return data_; }
-    // Custom copy and assignment constructor to handle NSString.
-    FormatType(const FormatType& other);
-    FormatType& operator=(const FormatType& other);
-#endif
-
-    bool Equals(const FormatType& other) const;
-
-   private:
-    friend class base::NoDestructor<FormatType>;
-    friend class Clipboard;
-
-    // Platform-specific glue used internally by the Clipboard class. Each
-    // plaform should define,at least one of each of the following:
-    // 1. A constructor that wraps that native clipboard format descriptor.
-    // 2. An accessor to retrieve the wrapped descriptor.
-    // 3. A data member to hold the wrapped descriptor.
-    //
-    // Note that in some cases, the accessor for the wrapped descriptor may be
-    // public, as these format types can be used by drag and drop code as well.
-#if defined(OS_WIN)
-    explicit FormatType(UINT native_format);
-    FormatType(UINT native_format, LONG index);
-    FORMATETC data_;
-#elif defined(USE_AURA) || defined(OS_ANDROID) || defined(OS_FUCHSIA)
-    explicit FormatType(const std::string& native_format);
-    std::string data_;
-#elif defined(OS_MACOSX)
-    explicit FormatType(NSString* native_format);
-    NSString* data_;
-#else
-#error No FormatType definition.
-#endif
-
-    // Copyable and assignable, since this is essentially an opaque value type.
-  };
-
   static bool IsSupportedClipboardType(int32_t type) {
     switch (type) {
       case CLIPBOARD_TYPE_COPY_PASTE:
@@ -162,7 +97,7 @@
   virtual uint64_t GetSequenceNumber(ClipboardType type) const = 0;
 
   // Tests whether the clipboard contains a certain format
-  virtual bool IsFormatAvailable(const FormatType& format,
+  virtual bool IsFormatAvailable(const ClipboardFormatType& format,
                                  ClipboardType type) const = 0;
 
   // Clear the clipboard data.
@@ -204,7 +139,7 @@
 
   // Reads raw data from the clipboard with the given format type. Stores result
   // as a byte vector.
-  virtual void ReadData(const FormatType& format,
+  virtual void ReadData(const ClipboardFormatType& format,
                         std::string* result) const = 0;
 
   // Returns an estimate of the time the clipboard was last updated.  If the
@@ -214,38 +149,6 @@
   // Resets the clipboard last modified time to Time::Time().
   virtual void ClearLastModifiedTime();
 
-  // Gets the FormatType corresponding to an arbitrary format string,
-  // registering it with the system if needed. Due to Windows/Linux
-  // limitiations, |format_string| must never be controlled by the user.
-  static FormatType GetFormatType(const std::string& format_string);
-
-  // Get format identifiers for various types.
-  static const FormatType& GetUrlFormatType();
-  static const FormatType& GetUrlWFormatType();
-  static const FormatType& GetMozUrlFormatType();
-  static const FormatType& GetPlainTextFormatType();
-  static const FormatType& GetPlainTextWFormatType();
-  static const FormatType& GetFilenameFormatType();
-  static const FormatType& GetFilenameWFormatType();
-  static const FormatType& GetWebKitSmartPasteFormatType();
-  // Win: MS HTML Format, Other: Generic HTML format
-  static const FormatType& GetHtmlFormatType();
-  static const FormatType& GetRtfFormatType();
-  static const FormatType& GetBitmapFormatType();
-  // TODO(raymes): Unify web custom data and pepper custom data:
-  // crbug.com/158399.
-  static const FormatType& GetWebCustomDataFormatType();
-  static const FormatType& GetPepperCustomDataFormatType();
-
-#if defined(OS_WIN)
-  // Firefox text/html
-  static const FormatType& GetTextHtmlFormatType();
-  static const FormatType& GetCFHDropFormatType();
-  static const FormatType& GetFileDescriptorFormatType();
-  static const FormatType& GetFileContentZeroFormatType();
-  static const FormatType& GetIDListFormatType();
-#endif
-
  protected:
   static Clipboard* Create();
 
@@ -254,10 +157,10 @@
 
   // ObjectType designates the type of data to be stored in the clipboard. This
   // designation is shared across all OSes. The system-specific designation
-  // is defined by FormatType. A single ObjectType might be represented by
-  // several system-specific FormatTypes. For example, on Linux the CBF_TEXT
-  // ObjectType maps to "text/plain", "STRING", and several other formats. On
-  // windows it maps to CF_UNICODETEXT.
+  // is defined by ClipboardFormatType. A single ObjectType might be represented
+  // by several system-specific ClipboardFormatTypes. For example, on Linux the
+  // CBF_TEXT ObjectType maps to "text/plain", "STRING", and several other
+  // formats. On windows it maps to CF_UNICODETEXT.
   //
   // The order below is the order in which data will be written to the
   // clipboard, so more specific types must be listed before less specific
@@ -322,7 +225,7 @@
 
   virtual void WriteBitmap(const SkBitmap& bitmap) = 0;
 
-  virtual void WriteData(const FormatType& format,
+  virtual void WriteData(const ClipboardFormatType& format,
                          const char* data_data,
                          size_t data_len) = 0;
 
--- a/ui/base/clipboard/clipboard_mac.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard_mac.h	2019-01-24 15:42:48.080000000 +0300
@@ -11,13 +11,13 @@
 #include "base/gtest_prod_util.h"
 #include "base/macros.h"
 #include "ui/base/clipboard/clipboard.h"
-#include "ui/base/ui_base_export.h"
+#include "ui/base/ui_base_clipboard_export.h"
 
 @class NSPasteboard;
 
 namespace ui {
 
-class UI_BASE_EXPORT ClipboardMac : public Clipboard {
+class UI_BASE_CLIPBOARD_EXPORT ClipboardMac : public Clipboard {
  private:
   FRIEND_TEST_ALL_PREFIXES(ClipboardMacTest, ReadImageRetina);
   FRIEND_TEST_ALL_PREFIXES(ClipboardMacTest, ReadImageNonRetina);
@@ -31,7 +31,7 @@
   // Clipboard overrides:
   void OnPreShutdown() override;
   uint64_t GetSequenceNumber(ClipboardType type) const override;
-  bool IsFormatAvailable(const FormatType& format,
+  bool IsFormatAvailable(const ClipboardFormatType& format,
                          ClipboardType type) const override;
   void Clear(ClipboardType type) override;
   void ReadAvailableTypes(ClipboardType type,
@@ -51,7 +51,8 @@
                       const base::string16& type,
                       base::string16* result) const override;
   void ReadBookmark(base::string16* title, std::string* url) const override;
-  void ReadData(const FormatType& format, std::string* result) const override;
+  void ReadData(const ClipboardFormatType& format,
+                std::string* result) const override;
   void WriteObjects(ClipboardType type, const ObjectMap& objects) override;
   void WriteText(const char* text_data, size_t text_len) override;
   void WriteHTML(const char* markup_data,
@@ -65,7 +66,7 @@
                      size_t url_len) override;
   void WriteWebSmartPaste() override;
   void WriteBitmap(const SkBitmap& bitmap) override;
-  void WriteData(const FormatType& format,
+  void WriteData(const ClipboardFormatType& format,
                  const char* data_data,
                  size_t data_len) override;
 
--- a/ui/base/clipboard/clipboard_mac.mm	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard_mac.mm	2019-01-24 15:42:48.856000000 +0300
@@ -22,6 +22,7 @@
 #import "third_party/mozilla/NSPasteboard+Utils.h"
 #include "third_party/skia/include/core/SkBitmap.h"
 #include "ui/base/clipboard/clipboard_util_mac.h"
+#include "ui/base/clipboard/clipboard_utils.h"
 #include "ui/base/clipboard/custom_data_helper.h"
 #include "ui/gfx/canvas.h"
 #include "ui/gfx/geometry/size.h"
@@ -31,14 +32,6 @@
 
 namespace {
 
-// Tells us if WebKit was the last to write to the pasteboard. There's no
-// actual data associated with this type.
-NSString* const kWebSmartPastePboardType = @"NeXT smart paste pasteboard type";
-
-// Pepper custom data format type.
-NSString* const kPepperCustomDataPboardType =
-    @"org.chromium.pepper-custom-data";
-
 NSPasteboard* GetPasteboard() {
   // The pasteboard can always be nil, since there is a finite amount of storage
   // that must be shared between all pasteboards.
@@ -48,125 +41,6 @@
 
 }  // namespace
 
-// Clipboard::FormatType implementation.
-Clipboard::FormatType::FormatType() : data_(nil) {
-}
-
-Clipboard::FormatType::FormatType(NSString* native_format)
-    : data_([native_format retain]) {
-}
-
-Clipboard::FormatType::FormatType(const FormatType& other)
-    : data_([other.data_ retain]) {
-}
-
-Clipboard::FormatType& Clipboard::FormatType::operator=(
-    const FormatType& other) {
-  if (this != &other) {
-    [data_ release];
-    data_ = [other.data_ retain];
-  }
-  return *this;
-}
-
-bool Clipboard::FormatType::Equals(const FormatType& other) const {
-  return [data_ isEqualToString:other.data_];
-}
-
-Clipboard::FormatType::~FormatType() {
-  [data_ release];
-}
-
-std::string Clipboard::FormatType::Serialize() const {
-  return base::SysNSStringToUTF8(data_);
-}
-
-// static
-Clipboard::FormatType Clipboard::FormatType::Deserialize(
-    const std::string& serialization) {
-  return FormatType(base::SysUTF8ToNSString(serialization));
-}
-
-bool Clipboard::FormatType::operator<(const FormatType& other) const {
-  return [data_ compare:other.data_] == NSOrderedAscending;
-}
-
-// Various predefined FormatTypes.
-// static
-Clipboard::FormatType Clipboard::GetFormatType(
-    const std::string& format_string) {
-  return FormatType::Deserialize(format_string);
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetUrlFormatType() {
-  static base::NoDestructor<FormatType> type(NSURLPboardType);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetUrlWFormatType() {
-  return GetUrlFormatType();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextFormatType() {
-  static base::NoDestructor<FormatType> type(NSPasteboardTypeString);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextWFormatType() {
-  return GetPlainTextFormatType();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFilenameFormatType() {
-  static base::NoDestructor<FormatType> type(NSFilenamesPboardType);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFilenameWFormatType() {
-  return GetFilenameFormatType();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetHtmlFormatType() {
-  static base::NoDestructor<FormatType> type(NSHTMLPboardType);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetRtfFormatType() {
-  static base::NoDestructor<FormatType> type(NSRTFPboardType);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetBitmapFormatType() {
-  static base::NoDestructor<FormatType> type(NSTIFFPboardType);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebKitSmartPasteFormatType() {
-  static base::NoDestructor<FormatType> type(kWebSmartPastePboardType);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebCustomDataFormatType() {
-  static base::NoDestructor<FormatType> type(kWebCustomDataPboardType);
-  return *type;
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPepperCustomDataFormatType() {
-  static base::NoDestructor<FormatType> type(kPepperCustomDataPboardType);
-  return *type;
-}
-
 // Clipboard factory method.
 // static
 Clipboard* Clipboard::Create() {
@@ -192,7 +66,7 @@
   return [pb changeCount];
 }
 
-bool ClipboardMac::IsFormatAvailable(const FormatType& format,
+bool ClipboardMac::IsFormatAvailable(const ClipboardFormatType& format,
                                      ClipboardType type) const {
   DCHECK(CalledOnValidThread());
   DCHECK_EQ(type, CLIPBOARD_TYPE_COPY_PASTE);
@@ -222,11 +96,11 @@
                                       bool* contains_filenames) const {
   DCHECK(CalledOnValidThread());
   types->clear();
-  if (IsFormatAvailable(Clipboard::GetPlainTextFormatType(), type))
+  if (IsFormatAvailable(Clipboard::GetPlainTextClipboardFormatType(), type))
     types->push_back(base::UTF8ToUTF16(kMimeTypeText));
-  if (IsFormatAvailable(Clipboard::GetHtmlFormatType(), type))
+  if (IsFormatAvailable(Clipboard::GetHtmlClipboardFormatType(), type))
     types->push_back(base::UTF8ToUTF16(kMimeTypeHTML));
-  if (IsFormatAvailable(Clipboard::GetRtfFormatType(), type))
+  if (IsFormatAvailable(Clipboard::GetRtfClipboardFormatType(), type))
     types->push_back(base::UTF8ToUTF16(kMimeTypeRTF));
 
   NSPasteboard* pb = GetPasteboard();
@@ -298,7 +172,7 @@
   DCHECK(CalledOnValidThread());
   DCHECK_EQ(type, CLIPBOARD_TYPE_COPY_PASTE);
 
-  return ReadData(GetRtfFormatType(), result);
+  return ReadData(GetRtfClipboardFormatType(), result);
 }
 
 SkBitmap ClipboardMac::ReadImage(ClipboardType type, NSPasteboard* pb) const {
@@ -386,7 +260,7 @@
   }
 }
 
-void ClipboardMac::ReadData(const FormatType& format,
+void ClipboardMac::ReadData(const ClipboardFormatType& format,
                             std::string* result) const {
   DCHECK(CalledOnValidThread());
   NSPasteboard* pb = GetPasteboard();
@@ -432,7 +306,7 @@
 }
 
 void ClipboardMac::WriteRTF(const char* rtf_data, size_t data_len) {
-  WriteData(GetRtfFormatType(), rtf_data, data_len);
+  WriteData(GetRtfClipboardFormatType(), rtf_data, data_len);
 }
 
 void ClipboardMac::WriteBookmark(const char* title_data,
@@ -464,7 +338,7 @@
   }
 }
 
-void ClipboardMac::WriteData(const FormatType& format,
+void ClipboardMac::WriteData(const ClipboardFormatType& format,
                              const char* data_data,
                              size_t data_len) {
   NSPasteboard* pb = GetPasteboard();
@@ -477,7 +351,7 @@
 // pasteboard. This flavor has no data.
 void ClipboardMac::WriteWebSmartPaste() {
   NSPasteboard* pb = GetPasteboard();
-  NSString* format = GetWebKitSmartPasteFormatType().ToNSString();
+  NSString* format = GetWebKitSmartPasteClipboardFormatType().ToNSString();
   [pb addTypes:[NSArray arrayWithObject:format] owner:nil];
   [pb setData:nil forType:format];
 }
--- a/ui/base/clipboard/clipboard_monitor.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard_monitor.h	2019-01-24 15:42:48.856000000 +0300
@@ -9,7 +9,7 @@
 #include "base/no_destructor.h"
 #include "base/observer_list.h"
 #include "base/threading/thread_checker.h"
-#include "ui/base/ui_base_export.h"
+#include "ui/base/clipboard/ui_base_clipboard_export.h"
 
 namespace ui {
 
@@ -17,7 +17,7 @@
 
 // A singleton instance to monitor and notify ClipboardObservers for clipboard
 // changes.
-class UI_BASE_EXPORT ClipboardMonitor {
+class UI_BASE_CLIPBOARD_EXPORT ClipboardMonitor {
  public:
   static ClipboardMonitor* GetInstance();
 
--- a/ui/base/clipboard/clipboard_observer.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard_observer.h	2019-01-24 15:42:48.856000000 +0300
@@ -6,12 +6,12 @@
 #define UI_BASE_CLIPBOARD_CLIPBOARD_OBSERVER_H_
 
 #include "base/macros.h"
-#include "ui/base/ui_base_export.h"
+#include "ui/base/clipboard/ui_base_clipboard_export.h"
 
 namespace ui {
 
 // Observer that receives the notifications of clipboard change events.
-class UI_BASE_EXPORT ClipboardObserver {
+class UI_BASE_CLIPBOARD_EXPORT ClipboardObserver {
  public:
   // Called when clipboard data is changed.
   virtual void OnClipboardDataChanged() = 0;
--- a/ui/base/clipboard/clipboard_test_template.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard_test_template.h	2019-01-24 15:42:50.496000000 +0300
@@ -31,8 +31,9 @@
 #include "third_party/skia/include/core/SkScalar.h"
 #include "third_party/skia/include/core/SkUnPreMultiply.h"
 #include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/clipboard_constants.h"
 #include "ui/base/clipboard/scoped_clipboard_writer.h"
-#include "ui/base/test/test_clipboard.h"
+#include "ui/base/clipboard/test/test_clipboard.h"
 #include "ui/gfx/geometry/size.h"
 
 #if defined(OS_WIN)
@@ -105,9 +106,9 @@
 
   EXPECT_TRUE(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE).empty());
   EXPECT_FALSE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextWFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      GetPlainTextWClipboardFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
   EXPECT_FALSE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      GetPlainTextClipboardFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
 }
 
 TYPED_TEST(ClipboardTest, TextTest) {
@@ -120,11 +121,11 @@
   }
 
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeText)));
+              Contains(ASCIIToUTF16(kMimeTypeText)));
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextWFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      GetPlainTextWClipboardFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      GetPlainTextClipboardFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
   this->clipboard().ReadText(CLIPBOARD_TYPE_COPY_PASTE, &text_result);
 
   EXPECT_EQ(text, text_result);
@@ -144,9 +145,9 @@
   }
 
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeHTML)));
-  EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetHtmlFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+              Contains(ASCIIToUTF16(kMimeTypeHTML)));
+  EXPECT_TRUE(this->clipboard().IsFormatAvailable(GetHtmlClipboardFormatType(),
+                                                  CLIPBOARD_TYPE_COPY_PASTE));
   uint32_t fragment_start;
   uint32_t fragment_end;
   this->clipboard().ReadHTML(CLIPBOARD_TYPE_COPY_PASTE, &markup_result,
@@ -173,16 +174,16 @@
   }
 
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeRTF)));
-  EXPECT_TRUE(this->clipboard().IsFormatAvailable(Clipboard::GetRtfFormatType(),
+              Contains(ASCIIToUTF16(kMimeTypeRTF)));
+  EXPECT_TRUE(this->clipboard().IsFormatAvailable(GetRtfClipboardFormatType(),
                                                   CLIPBOARD_TYPE_COPY_PASTE));
   std::string result;
   this->clipboard().ReadRTF(CLIPBOARD_TYPE_COPY_PASTE, &result);
   EXPECT_EQ(rtf, result);
 }
 
-// TODO(dnicoara) Enable test once Ozone implements clipboard support:
-// crbug.com/361707
+// TODO(msisov, tonikitoo): Enable test once ClipboardOzone implements
+// selection support. https://crbug.com/911992
 #if defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(USE_OZONE)
 TYPED_TEST(ClipboardTest, MultipleBufferTest) {
   base::string16 text(ASCIIToUTF16("Standard")), text_result;
@@ -200,19 +201,19 @@
   }
 
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeText)));
+              Contains(ASCIIToUTF16(kMimeTypeText)));
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_SELECTION),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeHTML)));
+              Contains(ASCIIToUTF16(kMimeTypeHTML)));
 
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      GetPlainTextClipboardFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
   EXPECT_FALSE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextFormatType(), CLIPBOARD_TYPE_SELECTION));
+      GetPlainTextClipboardFormatType(), CLIPBOARD_TYPE_SELECTION));
 
-  EXPECT_FALSE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetHtmlFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
-  EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetHtmlFormatType(), CLIPBOARD_TYPE_SELECTION));
+  EXPECT_FALSE(this->clipboard().IsFormatAvailable(GetHtmlClipboardFormatType(),
+                                                   CLIPBOARD_TYPE_COPY_PASTE));
+  EXPECT_TRUE(this->clipboard().IsFormatAvailable(GetHtmlClipboardFormatType(),
+                                                  CLIPBOARD_TYPE_SELECTION));
 
   this->clipboard().ReadText(CLIPBOARD_TYPE_COPY_PASTE, &text_result);
   EXPECT_EQ(text, text_result);
@@ -241,9 +242,9 @@
   }
 
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeHTML)));
-  EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetHtmlFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+              Contains(ASCIIToUTF16(kMimeTypeHTML)));
+  EXPECT_TRUE(this->clipboard().IsFormatAvailable(GetHtmlClipboardFormatType(),
+                                                  CLIPBOARD_TYPE_COPY_PASTE));
   uint32_t fragment_start;
   uint32_t fragment_end;
   this->clipboard().ReadHTML(CLIPBOARD_TYPE_COPY_PASTE, &markup_result,
@@ -271,9 +272,9 @@
   }
 
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeHTML)));
-  EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetHtmlFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+              Contains(ASCIIToUTF16(kMimeTypeHTML)));
+  EXPECT_TRUE(this->clipboard().IsFormatAvailable(GetHtmlClipboardFormatType(),
+                                                  CLIPBOARD_TYPE_COPY_PASTE));
   uint32_t fragment_start;
   uint32_t fragment_end;
   this->clipboard().ReadHTML(CLIPBOARD_TYPE_COPY_PASTE, &markup_result,
@@ -297,8 +298,8 @@
     clipboard_writer.WriteBookmark(title, url);
   }
 
-  EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetUrlWFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+  EXPECT_TRUE(this->clipboard().IsFormatAvailable(GetUrlWClipboardFormatType(),
+                                                  CLIPBOARD_TYPE_COPY_PASTE));
   this->clipboard().ReadBookmark(&title_result, &url_result);
   EXPECT_EQ(title, title_result);
   EXPECT_EQ(url, url_result);
@@ -318,15 +319,15 @@
   }
 
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeHTML)));
+              Contains(ASCIIToUTF16(kMimeTypeHTML)));
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeText)));
-  EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetHtmlFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+              Contains(ASCIIToUTF16(kMimeTypeText)));
+  EXPECT_TRUE(this->clipboard().IsFormatAvailable(GetHtmlClipboardFormatType(),
+                                                  CLIPBOARD_TYPE_COPY_PASTE));
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextWFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      GetPlainTextWClipboardFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      GetPlainTextClipboardFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
   uint32_t fragment_start;
   uint32_t fragment_end;
   this->clipboard().ReadHTML(CLIPBOARD_TYPE_COPY_PASTE, &markup_result,
@@ -354,11 +355,11 @@
   }
 
   EXPECT_THAT(this->GetAvailableTypes(CLIPBOARD_TYPE_COPY_PASTE),
-              Contains(ASCIIToUTF16(Clipboard::kMimeTypeText)));
+              Contains(ASCIIToUTF16(kMimeTypeText)));
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextWFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      GetPlainTextWClipboardFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetPlainTextFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      GetPlainTextClipboardFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
   base::string16 text_result;
   this->clipboard().ReadText(CLIPBOARD_TYPE_COPY_PASTE, &text_result);
 
@@ -368,8 +369,10 @@
   this->clipboard().ReadAsciiText(CLIPBOARD_TYPE_COPY_PASTE, &ascii_text);
   EXPECT_EQ(UTF16ToUTF8(url), ascii_text);
 
+// TODO(tonikitoo, msisov): enable back for ClipboardOzone implements
+// selection support. https://crbug.com/911992
 #if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_ANDROID) && \
-    !defined(OS_CHROMEOS)
+    !defined(OS_CHROMEOS) && !defined(USE_OZONE)
   ascii_text.clear();
   this->clipboard().ReadAsciiText(CLIPBOARD_TYPE_SELECTION, &ascii_text);
   EXPECT_EQ(UTF16ToUTF8(url), ascii_text);
@@ -389,7 +392,7 @@
     scw.WriteImage(bitmap);
   }
 
-  EXPECT_TRUE(clipboard->IsFormatAvailable(Clipboard::GetBitmapFormatType(),
+  EXPECT_TRUE(clipboard->IsFormatAvailable(GetBitmapClipboardFormatType(),
                                            CLIPBOARD_TYPE_COPY_PASTE));
   const SkBitmap& image = clipboard->ReadImage(CLIPBOARD_TYPE_COPY_PASTE);
   EXPECT_EQ(size, gfx::Size(image.width(), image.height()));
@@ -430,8 +433,8 @@
 }
 
 TYPED_TEST(ClipboardTest, DataTest) {
-  const ui::Clipboard::FormatType kFormat =
-      ui::Clipboard::GetFormatType("chromium/x-test-format");
+  const ui::ClipboardFormatType kFormat =
+      ui::GetClipboardFormatType("chromium/x-test-format");
   std::string payload("test string");
   base::Pickle write_pickle;
   write_pickle.WriteString(payload);
@@ -455,14 +458,14 @@
 }
 
 TYPED_TEST(ClipboardTest, MultipleDataTest) {
-  const ui::Clipboard::FormatType kFormat1 =
-      ui::Clipboard::GetFormatType("chromium/x-test-format1");
+  const ui::ClipboardFormatType kFormat1 =
+      ui::GetClipboardFormatType("chromium/x-test-format1");
   std::string payload1("test string1");
   base::Pickle write_pickle1;
   write_pickle1.WriteString(payload1);
 
-  const ui::Clipboard::FormatType kFormat2 =
-      ui::Clipboard::GetFormatType("chromium/x-test-format2");
+  const ui::ClipboardFormatType kFormat2 =
+      ui::GetClipboardFormatType("chromium/x-test-format2");
   std::string payload2("test string2");
   base::Pickle write_pickle2;
   write_pickle2.WriteString(payload2);
@@ -525,8 +528,8 @@
     clipboard_writer.WriteHyperlink(ASCIIToUTF16(kTitle), kUrl);
   }
 
-  EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetHtmlFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+  EXPECT_TRUE(this->clipboard().IsFormatAvailable(GetHtmlClipboardFormatType(),
+                                                  CLIPBOARD_TYPE_COPY_PASTE));
   uint32_t fragment_start;
   uint32_t fragment_end;
   this->clipboard().ReadHTML(CLIPBOARD_TYPE_COPY_PASTE, &html_result,
@@ -544,7 +547,7 @@
   }
 
   EXPECT_TRUE(this->clipboard().IsFormatAvailable(
-      Clipboard::GetWebKitSmartPasteFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
+      GetWebKitSmartPasteClipboardFormatType(), CLIPBOARD_TYPE_COPY_PASTE));
 }
 
 #if defined(OS_WIN)  // Windows only tests.
@@ -665,7 +668,7 @@
 
 TYPED_TEST(ClipboardTest, WritePickledData) {
   ScopedClipboardWriter scw(CLIPBOARD_TYPE_COPY_PASTE);
-  scw.WritePickledData(base::Pickle(), Clipboard::GetPlainTextFormatType());
+  scw.WritePickledData(base::Pickle(), GetPlainTextClipboardFormatType());
 }
 
 TYPED_TEST(ClipboardTest, WriteImageEmptyParams) {
--- a/ui/base/clipboard/clipboard_util_mac.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard_util_mac.h	2019-01-24 15:42:52.528000000 +0300
@@ -10,15 +10,15 @@
 #include "base/mac/scoped_nsobject.h"
 #include "base/memory/ref_counted.h"
 #include "ui/base/clipboard/clipboard_types.h"
-#include "ui/base/ui_base_export.h"
+#include "ui/base/ui_base_clipboard_export.h"
 
 namespace ui {
 
 // A publicly-used UTI for the name of a URL. It really should be in a system
 // header but isn't.
-UI_BASE_EXPORT extern NSString* const kUTTypeURLName;
+UI_BASE_CLIPBOARD_EXPORT extern NSString* const kUTTypeURLName;
 
-class UI_BASE_EXPORT UniquePasteboard
+class UI_BASE_CLIPBOARD_EXPORT UniquePasteboard
     : public base::RefCounted<UniquePasteboard> {
  public:
   UniquePasteboard();
@@ -31,7 +31,7 @@
   base::scoped_nsobject<NSPasteboard> pasteboard_;
 };
 
-class UI_BASE_EXPORT ClipboardUtil {
+class UI_BASE_CLIPBOARD_EXPORT ClipboardUtil {
  public:
   // Returns an NSPasteboardItem that represents the given |url|.
   // |url| must not be nil.
--- a/ui/base/clipboard/clipboard_util_win.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard_util_win.cc	2019-01-24 15:42:54.436000000 +0300
@@ -25,13 +25,13 @@
 
 namespace {
 
-bool HasData(IDataObject* data_object, const Clipboard::FormatType& format) {
+bool HasData(IDataObject* data_object, const ClipboardFormatType& format) {
   FORMATETC format_etc = format.ToFormatEtc();
   return SUCCEEDED(data_object->QueryGetData(&format_etc));
 }
 
 bool GetData(IDataObject* data_object,
-             const Clipboard::FormatType& format,
+             const ClipboardFormatType& format,
              STGMEDIUM* medium) {
   FORMATETC format_etc = format.ToFormatEtc();
   return SUCCEEDED(data_object->GetData(&format_etc, medium));
@@ -44,7 +44,8 @@
 
   bool success = false;
   STGMEDIUM medium;
-  if (!GetData(data_object, Clipboard::GetCFHDropFormatType(), &medium))
+  if (!GetData(data_object, Clipboard::GetCFHDropClipboardFormatType(),
+               &medium))
     return false;
 
   {
@@ -93,34 +94,35 @@
 
 bool ClipboardUtil::HasUrl(IDataObject* data_object, bool convert_filenames) {
   DCHECK(data_object);
-  return HasData(data_object, Clipboard::GetMozUrlFormatType()) ||
-         HasData(data_object, Clipboard::GetUrlWFormatType()) ||
-         HasData(data_object, Clipboard::GetUrlFormatType()) ||
+  return HasData(data_object, Clipboard::GetMozUrlClipboardFormatType()) ||
+         HasData(data_object, Clipboard::GetUrlWClipboardFormatType()) ||
+         HasData(data_object, Clipboard::GetUrlClipboardFormatType()) ||
          (convert_filenames && HasFilenames(data_object));
 }
 
 bool ClipboardUtil::HasFilenames(IDataObject* data_object) {
   DCHECK(data_object);
-  return HasData(data_object, Clipboard::GetCFHDropFormatType()) ||
-         HasData(data_object, Clipboard::GetFilenameWFormatType()) ||
-         HasData(data_object, Clipboard::GetFilenameFormatType());
+  return HasData(data_object, Clipboard::GetCFHDropClipboardFormatType()) ||
+         HasData(data_object, Clipboard::GetFilenameWClipboardFormatType()) ||
+         HasData(data_object, Clipboard::GetFilenameClipboardFormatType());
 }
 
 bool ClipboardUtil::HasFileContents(IDataObject* data_object) {
   DCHECK(data_object);
-  return HasData(data_object, Clipboard::GetFileContentZeroFormatType());
+  return HasData(data_object,
+                 Clipboard::GetFileContentZeroClipboardFormatType());
 }
 
 bool ClipboardUtil::HasHtml(IDataObject* data_object) {
   DCHECK(data_object);
-  return HasData(data_object, Clipboard::GetHtmlFormatType()) ||
-         HasData(data_object, Clipboard::GetTextHtmlFormatType());
+  return HasData(data_object, Clipboard::GetHtmlClipboardFormatType()) ||
+         HasData(data_object, Clipboard::GetTextHtmlClipboardFormatType());
 }
 
 bool ClipboardUtil::HasPlainText(IDataObject* data_object) {
   DCHECK(data_object);
-  return HasData(data_object, Clipboard::GetPlainTextWFormatType()) ||
-         HasData(data_object, Clipboard::GetPlainTextFormatType());
+  return HasData(data_object, Clipboard::GetPlainTextWClipboardFormatType()) ||
+         HasData(data_object, Clipboard::GetPlainTextClipboardFormatType());
 }
 
 bool ClipboardUtil::GetUrl(IDataObject* data_object,
@@ -136,8 +138,8 @@
   if (GetUrlFromHDrop(data_object, url, title))
     return true;
 
-  if (GetData(data_object, Clipboard::GetMozUrlFormatType(), &store) ||
-      GetData(data_object, Clipboard::GetUrlWFormatType(), &store)) {
+  if (GetData(data_object, Clipboard::GetMozUrlClipboardFormatType(), &store) ||
+      GetData(data_object, Clipboard::GetUrlWClipboardFormatType(), &store)) {
     {
       // Mozilla URL format or unicode URL
       base::win::ScopedHGlobal<wchar_t*> data(store.hGlobal);
@@ -147,7 +149,7 @@
     return url->is_valid();
   }
 
-  if (GetData(data_object, Clipboard::GetUrlFormatType(), &store)) {
+  if (GetData(data_object, Clipboard::GetUrlClipboardFormatType(), &store)) {
     {
       // URL using ascii
       base::win::ScopedHGlobal<char*> data(store.hGlobal);
@@ -176,7 +178,8 @@
     return false;
 
   STGMEDIUM medium;
-  if (GetData(data_object, Clipboard::GetCFHDropFormatType(), &medium)) {
+  if (GetData(data_object, Clipboard::GetCFHDropClipboardFormatType(),
+              &medium)) {
     {
       base::win::ScopedHGlobal<HDROP> hdrop(medium.hGlobal);
       if (!hdrop.get())
@@ -195,7 +198,8 @@
     return !filenames->empty();
   }
 
-  if (GetData(data_object, Clipboard::GetFilenameWFormatType(), &medium)) {
+  if (GetData(data_object, Clipboard::GetFilenameWClipboardFormatType(),
+              &medium)) {
     {
       // filename using unicode
       base::win::ScopedHGlobal<wchar_t*> data(medium.hGlobal);
@@ -206,7 +210,8 @@
     return true;
   }
 
-  if (GetData(data_object, Clipboard::GetFilenameFormatType(), &medium)) {
+  if (GetData(data_object, Clipboard::GetFilenameClipboardFormatType(),
+              &medium)) {
     {
       // filename using ascii
       base::win::ScopedHGlobal<char*> data(medium.hGlobal);
@@ -227,7 +232,8 @@
     return false;
 
   STGMEDIUM store;
-  if (GetData(data_object, Clipboard::GetPlainTextWFormatType(), &store)) {
+  if (GetData(data_object, Clipboard::GetPlainTextWClipboardFormatType(),
+              &store)) {
     {
       // Unicode text
       base::win::ScopedHGlobal<wchar_t*> data(store.hGlobal);
@@ -237,7 +243,8 @@
     return true;
   }
 
-  if (GetData(data_object, Clipboard::GetPlainTextFormatType(), &store)) {
+  if (GetData(data_object, Clipboard::GetPlainTextClipboardFormatType(),
+              &store)) {
     {
       // ascii text
       base::win::ScopedHGlobal<char*> data(store.hGlobal);
@@ -263,8 +270,8 @@
   DCHECK(data_object && html && base_url);
 
   STGMEDIUM store;
-  if (HasData(data_object, Clipboard::GetHtmlFormatType()) &&
-      GetData(data_object, Clipboard::GetHtmlFormatType(), &store)) {
+  if (HasData(data_object, Clipboard::GetHtmlClipboardFormatType()) &&
+      GetData(data_object, Clipboard::GetHtmlClipboardFormatType(), &store)) {
     {
       // MS CF html
       base::win::ScopedHGlobal<char*> data(store.hGlobal);
@@ -277,10 +284,11 @@
     return true;
   }
 
-  if (!HasData(data_object, Clipboard::GetTextHtmlFormatType()))
+  if (!HasData(data_object, Clipboard::GetTextHtmlClipboardFormatType()))
     return false;
 
-  if (!GetData(data_object, Clipboard::GetTextHtmlFormatType(), &store))
+  if (!GetData(data_object, Clipboard::GetTextHtmlClipboardFormatType(),
+               &store))
     return false;
 
   {
@@ -295,15 +303,16 @@
 bool ClipboardUtil::GetFileContents(IDataObject* data_object,
     base::string16* filename, std::string* file_contents) {
   DCHECK(data_object && filename && file_contents);
-  if (!HasData(data_object, Clipboard::GetFileContentZeroFormatType()) &&
-      !HasData(data_object, Clipboard::GetFileDescriptorFormatType()))
+  if (!HasData(data_object,
+               Clipboard::GetFileContentZeroClipboardFormatType()) &&
+      !HasData(data_object, Clipboard::GetFileDescriptorClipboardFormatType()))
     return false;
 
   STGMEDIUM content;
   // The call to GetData can be very slow depending on what is in
   // |data_object|.
-  if (GetData(
-          data_object, Clipboard::GetFileContentZeroFormatType(), &content)) {
+  if (GetData(data_object, Clipboard::GetFileContentZeroClipboardFormatType(),
+              &content)) {
     if (TYMED_HGLOBAL == content.tymed) {
       base::win::ScopedHGlobal<char*> data(content.hGlobal);
       file_contents->assign(data.get(), data.Size());
@@ -312,8 +321,7 @@
   }
 
   STGMEDIUM description;
-  if (GetData(data_object,
-              Clipboard::GetFileDescriptorFormatType(),
+  if (GetData(data_object, Clipboard::GetFileDescriptorClipboardFormatType(),
               &description)) {
     {
       base::win::ScopedHGlobal<FILEGROUPDESCRIPTOR*> fgd(description.hGlobal);
@@ -331,11 +339,12 @@
     std::unordered_map<base::string16, base::string16>* custom_data) {
   DCHECK(data_object && custom_data);
 
-  if (!HasData(data_object, Clipboard::GetWebCustomDataFormatType()))
+  if (!HasData(data_object, Clipboard::GetWebCustomDataClipboardFormatType()))
     return false;
 
   STGMEDIUM store;
-  if (GetData(data_object, Clipboard::GetWebCustomDataFormatType(), &store)) {
+  if (GetData(data_object, Clipboard::GetWebCustomDataClipboardFormatType(),
+              &store)) {
     {
       base::win::ScopedHGlobal<char*> data(store.hGlobal);
       ReadCustomDataIntoMap(data.get(), data.Size(), custom_data);
--- a/ui/base/clipboard/clipboard_util_win.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard_util_win.h	2019-01-24 15:42:54.440000000 +0300
@@ -14,13 +14,13 @@
 #include <vector>
 
 #include "base/strings/string16.h"
-#include "ui/base/ui_base_export.h"
+#include "ui/base/ui_base_clipboard_export.h"
 
 class GURL;
 
 namespace ui {
 
-class UI_BASE_EXPORT ClipboardUtil {
+class UI_BASE_CLIPBOARD_EXPORT ClipboardUtil {
  public:
   /////////////////////////////////////////////////////////////////////////////
   // These methods check to see if |data_object| has the requested type.
--- a/ui/base/clipboard/clipboard_win.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard_win.cc	2019-01-24 15:42:54.444000000 +0300
@@ -28,6 +28,7 @@
 #include "skia/ext/skia_utils_win.h"
 #include "third_party/skia/include/core/SkBitmap.h"
 #include "ui/base/clipboard/clipboard_util_win.h"
+#include "ui/base/clipboard/clipboard_utils.h"
 #include "ui/base/clipboard/custom_data_helper.h"
 #include "ui/gfx/canvas.h"
 #include "ui/gfx/geometry/size.h"
@@ -219,201 +220,6 @@
 
 }  // namespace
 
-// Clipboard::FormatType implementation.
-Clipboard::FormatType::FormatType() : data_() {}
-
-Clipboard::FormatType::FormatType(UINT native_format) : data_() {
-  // There's no good way to actually initialize this in the constructor in
-  // C++03.
-  data_.cfFormat = static_cast<CLIPFORMAT>(native_format);
-  data_.dwAspect = DVASPECT_CONTENT;
-  data_.lindex = -1;
-  data_.tymed = TYMED_HGLOBAL;
-}
-
-Clipboard::FormatType::FormatType(UINT native_format, LONG index) : data_() {
-  // There's no good way to actually initialize this in the constructor in
-  // C++03.
-  data_.cfFormat = static_cast<CLIPFORMAT>(native_format);
-  data_.dwAspect = DVASPECT_CONTENT;
-  data_.lindex = index;
-  data_.tymed = TYMED_HGLOBAL;
-}
-
-Clipboard::FormatType::~FormatType() {
-}
-
-std::string Clipboard::FormatType::Serialize() const {
-  return base::IntToString(data_.cfFormat);
-}
-
-// static
-Clipboard::FormatType Clipboard::FormatType::Deserialize(
-    const std::string& serialization) {
-  int clipboard_format = -1;
-  if (!base::StringToInt(serialization, &clipboard_format)) {
-    NOTREACHED();
-    return FormatType();
-  }
-  return FormatType(clipboard_format);
-}
-
-bool Clipboard::FormatType::operator<(const FormatType& other) const {
-  return data_.cfFormat < other.data_.cfFormat;
-}
-
-bool Clipboard::FormatType::Equals(const FormatType& other) const {
-  return data_.cfFormat == other.data_.cfFormat;
-}
-
-// Various predefined FormatTypes.
-// static
-Clipboard::FormatType Clipboard::GetFormatType(
-    const std::string& format_string) {
-  return FormatType(
-      ::RegisterClipboardFormat(base::ASCIIToUTF16(format_string).c_str()));
-}
-
-// The following formats can be referenced by ClipboardUtilWin::GetPlainText.
-// For reasons (COM), they must be initialized in a thread-safe manner.
-// TODO(dcheng): We probably need to make static initialization of "known"
-// FormatTypes thread-safe on all platforms.
-#define CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(name, ...) \
-  struct FormatTypeArgumentForwarder : public FormatType { \
-    FormatTypeArgumentForwarder() : FormatType(__VA_ARGS__) { } \
-  }; \
-  static base::LazyInstance<FormatTypeArgumentForwarder>::Leaky name = \
-      LAZY_INSTANCE_INITIALIZER
-// static
-const Clipboard::FormatType& Clipboard::GetUrlFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-    type, ::RegisterClipboardFormat(CFSTR_INETURLA));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetUrlWFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(CFSTR_INETURLW));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetMozUrlFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(L"text/x-moz-url"));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type, CF_TEXT);
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPlainTextWFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type, CF_UNICODETEXT);
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFilenameFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(CFSTR_FILENAMEA));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFilenameWFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(CFSTR_FILENAMEW));
-  return type.Get();
-}
-
-// MS HTML Format
-// static
-const Clipboard::FormatType& Clipboard::GetHtmlFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(L"HTML Format"));
-  return type.Get();
-}
-
-// MS RTF Format
-// static
-const Clipboard::FormatType& Clipboard::GetRtfFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(L"Rich Text Format"));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetBitmapFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type, CF_BITMAP);
-  return type.Get();
-}
-
-// Firefox text/html
-// static
-const Clipboard::FormatType& Clipboard::GetTextHtmlFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(L"text/html"));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetCFHDropFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type, CF_HDROP);
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFileDescriptorFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(CFSTR_FILEDESCRIPTOR));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetFileContentZeroFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(CFSTR_FILECONTENTS), 0);
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetIDListFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type, ::RegisterClipboardFormat(CFSTR_SHELLIDLIST));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebKitSmartPasteFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type,
-      ::RegisterClipboardFormat(L"WebKit Smart Paste Format"));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetWebCustomDataFormatType() {
-  // TODO(dcheng): This name is temporary. See http://crbug.com/106449.
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type,
-      ::RegisterClipboardFormat(L"Chromium Web Custom MIME Data Format"));
-  return type.Get();
-}
-
-// static
-const Clipboard::FormatType& Clipboard::GetPepperCustomDataFormatType() {
-  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
-      type,
-      ::RegisterClipboardFormat(L"Chromium Pepper MIME Data Format"));
-  return type.Get();
-}
-#undef CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE
-
 // Clipboard factory method.
 // static
 Clipboard* Clipboard::Create() {
@@ -436,7 +242,7 @@
   return ::GetClipboardSequenceNumber();
 }
 
-bool ClipboardWin::IsFormatAvailable(const Clipboard::FormatType& format,
+bool ClipboardWin::IsFormatAvailable(const ClipboardFormatType& format,
                                      ClipboardType type) const {
   DCHECK_EQ(type, CLIPBOARD_TYPE_COPY_PASTE);
   return ::IsClipboardFormatAvailable(format.ToFormatEtc().cfFormat) != FALSE;
@@ -461,11 +267,13 @@
 
   types->clear();
   if (::IsClipboardFormatAvailable(
-          GetPlainTextFormatType().ToFormatEtc().cfFormat))
+          GetPlainTextClipboardFormatType().ToFormatEtc().cfFormat))
     types->push_back(base::UTF8ToUTF16(kMimeTypeText));
-  if (::IsClipboardFormatAvailable(GetHtmlFormatType().ToFormatEtc().cfFormat))
+  if (::IsClipboardFormatAvailable(
+          GetHtmlClipboardFormatType().ToFormatEtc().cfFormat))
     types->push_back(base::UTF8ToUTF16(kMimeTypeHTML));
-  if (::IsClipboardFormatAvailable(GetRtfFormatType().ToFormatEtc().cfFormat))
+  if (::IsClipboardFormatAvailable(
+          GetRtfClipboardFormatType().ToFormatEtc().cfFormat))
     types->push_back(base::UTF8ToUTF16(kMimeTypeRTF));
   if (::IsClipboardFormatAvailable(CF_DIB))
     types->push_back(base::UTF8ToUTF16(kMimeTypePNG));
@@ -476,8 +284,8 @@
   if (!clipboard.Acquire(GetClipboardWindow()))
     return;
 
-  HANDLE hdata =
-      ::GetClipboardData(GetWebCustomDataFormatType().ToFormatEtc().cfFormat);
+  HANDLE hdata = ::GetClipboardData(
+      GetWebCustomDataClipboardFormatType().ToFormatEtc().cfFormat);
   if (!hdata)
     return;
 
@@ -554,7 +362,8 @@
   if (!clipboard.Acquire(GetClipboardWindow()))
     return;
 
-  HANDLE data = ::GetClipboardData(GetHtmlFormatType().ToFormatEtc().cfFormat);
+  HANDLE data =
+      ::GetClipboardData(GetHtmlClipboardFormatType().ToFormatEtc().cfFormat);
   if (!data)
     return;
 
@@ -593,7 +402,7 @@
 void ClipboardWin::ReadRTF(ClipboardType type, std::string* result) const {
   DCHECK_EQ(type, CLIPBOARD_TYPE_COPY_PASTE);
 
-  ReadData(GetRtfFormatType(), result);
+  ReadData(GetRtfClipboardFormatType(), result);
   TrimAfterNull(result);
 }
 
@@ -689,8 +498,8 @@
   if (!clipboard.Acquire(GetClipboardWindow()))
     return;
 
-  HANDLE hdata =
-      ::GetClipboardData(GetWebCustomDataFormatType().ToFormatEtc().cfFormat);
+  HANDLE hdata = ::GetClipboardData(
+      GetWebCustomDataClipboardFormatType().ToFormatEtc().cfFormat);
   if (!hdata)
     return;
 
@@ -710,7 +519,8 @@
   if (!clipboard.Acquire(GetClipboardWindow()))
     return;
 
-  HANDLE data = ::GetClipboardData(GetUrlWFormatType().ToFormatEtc().cfFormat);
+  HANDLE data =
+      ::GetClipboardData(GetUrlWClipboardFormatType().ToFormatEtc().cfFormat);
   if (!data)
     return;
 
@@ -722,7 +532,7 @@
   ParseBookmarkClipboardFormat(bookmark, title, url);
 }
 
-void ClipboardWin::ReadData(const FormatType& format,
+void ClipboardWin::ReadData(const ClipboardFormatType& format,
                             std::string* result) const {
   if (!result) {
     NOTREACHED();
@@ -778,11 +588,12 @@
   std::string html_fragment = ClipboardUtil::HtmlToCFHtml(markup, url);
   HGLOBAL glob = CreateGlobalData(html_fragment);
 
-  WriteToClipboard(Clipboard::GetHtmlFormatType().ToFormatEtc().cfFormat, glob);
+  WriteToClipboard(
+      Clipboard::GetHtmlClipboardFormatType().ToFormatEtc().cfFormat, glob);
 }
 
 void ClipboardWin::WriteRTF(const char* rtf_data, size_t data_len) {
-  WriteData(GetRtfFormatType(), rtf_data, data_len);
+  WriteData(GetRtfClipboardFormatType(), rtf_data, data_len);
 }
 
 void ClipboardWin::WriteBookmark(const char* title_data,
@@ -796,13 +607,13 @@
   base::string16 wide_bookmark = base::UTF8ToUTF16(bookmark);
   HGLOBAL glob = CreateGlobalData(wide_bookmark);
 
-  WriteToClipboard(GetUrlWFormatType().ToFormatEtc().cfFormat, glob);
+  WriteToClipboard(GetUrlWClipboardFormatType().ToFormatEtc().cfFormat, glob);
 }
 
 void ClipboardWin::WriteWebSmartPaste() {
   DCHECK(clipboard_owner_->hwnd() != NULL);
-  ::SetClipboardData(GetWebKitSmartPasteFormatType().ToFormatEtc().cfFormat,
-                     NULL);
+  ::SetClipboardData(
+      GetWebKitSmartPasteClipboardFormatType().ToFormatEtc().cfFormat, NULL);
 }
 
 void ClipboardWin::WriteBitmap(const SkBitmap& bitmap) {
@@ -841,7 +652,7 @@
   ::ReleaseDC(NULL, dc);
 }
 
-void ClipboardWin::WriteData(const FormatType& format,
+void ClipboardWin::WriteData(const ClipboardFormatType& format,
                              const char* data_data,
                              size_t data_len) {
   HGLOBAL hdata = ::GlobalAlloc(GMEM_MOVEABLE, data_len);
--- a/ui/base/clipboard/clipboard_win.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/clipboard_win.h	2019-01-24 15:42:54.444000000 +0300
@@ -35,7 +35,7 @@
   // Clipboard overrides:
   void OnPreShutdown() override;
   uint64_t GetSequenceNumber(ClipboardType type) const override;
-  bool IsFormatAvailable(const FormatType& format,
+  bool IsFormatAvailable(const ClipboardFormatType& format,
                          ClipboardType type) const override;
   void Clear(ClipboardType type) override;
   void ReadAvailableTypes(ClipboardType type,
@@ -54,7 +54,8 @@
                       const base::string16& type,
                       base::string16* result) const override;
   void ReadBookmark(base::string16* title, std::string* url) const override;
-  void ReadData(const FormatType& format, std::string* result) const override;
+  void ReadData(const ClipboardFormatType& format,
+                std::string* result) const override;
   void WriteObjects(ClipboardType type, const ObjectMap& objects) override;
   void WriteText(const char* text_data, size_t text_len) override;
   void WriteHTML(const char* markup_data,
@@ -68,7 +69,7 @@
                      size_t url_len) override;
   void WriteWebSmartPaste() override;
   void WriteBitmap(const SkBitmap& bitmap) override;
-  void WriteData(const FormatType& format,
+  void WriteData(const ClipboardFormatType& format,
                  const char* data_data,
                  size_t data_len) override;
 
--- a/ui/base/clipboard/custom_data_helper.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/custom_data_helper.h	2019-01-24 15:42:55.784000000 +0300
@@ -18,7 +18,7 @@
 #include "base/containers/flat_map.h"
 #include "base/strings/string16.h"
 #include "build/build_config.h"
-#include "ui/base/ui_base_export.h"
+#include "ui/base/clipboard/ui_base_clipboard_export.h"
 
 namespace base {
 class Pickle;
@@ -35,26 +35,27 @@
 namespace ui {
 
 #if defined(OS_MACOSX) && !defined(USE_AURA)
-UI_BASE_EXPORT extern NSString* const kWebCustomDataPboardType;
+UI_BASE_CLIPBOARD_EXPORT extern NSString* const kWebCustomDataPboardType;
 #endif
 
-UI_BASE_EXPORT void ReadCustomDataTypes(const void* data,
+UI_BASE_CLIPBOARD_EXPORT void ReadCustomDataTypes(
+    const void* data,
                                         size_t data_length,
                                         std::vector<base::string16>* types);
-UI_BASE_EXPORT void ReadCustomDataForType(const void* data,
+UI_BASE_CLIPBOARD_EXPORT void ReadCustomDataForType(const void* data,
                                           size_t data_length,
                                           const base::string16& type,
                                           base::string16* result);
-UI_BASE_EXPORT void ReadCustomDataIntoMap(
+UI_BASE_CLIPBOARD_EXPORT void ReadCustomDataIntoMap(
     const void* data,
     size_t data_length,
     std::unordered_map<base::string16, base::string16>* result);
 
-UI_BASE_EXPORT void WriteCustomDataToPickle(
+UI_BASE_CLIPBOARD_EXPORT void WriteCustomDataToPickle(
     const std::unordered_map<base::string16, base::string16>& data,
     base::Pickle* pickle);
 
-UI_BASE_EXPORT void WriteCustomDataToPickle(
+UI_BASE_CLIPBOARD_EXPORT void WriteCustomDataToPickle(
     const base::flat_map<base::string16, base::string16>& data,
     base::Pickle* pickle);
 
--- a/ui/base/clipboard/DEPS	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/DEPS	2019-01-24 15:42:48.076000000 +0300
@@ -1,4 +1,7 @@
 include_rules = [
+  "-ui/ozone/*",
   "+jni",
   "+third_party/mozilla",
+  "+ui/ozone/public/ozone_platform.h",
+  "+ui/ozone/public/platform_clipboard.h",
 ]
--- a/ui/base/clipboard/scoped_clipboard_writer.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/scoped_clipboard_writer.cc	2019-01-24 15:42:55.784000000 +0300
@@ -11,6 +11,7 @@
 #include "base/pickle.h"
 #include "base/strings/utf_string_conversions.h"
 #include "net/base/escape.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/gfx/geometry/size.h"
 
 namespace ui {
@@ -105,7 +106,7 @@
 
 void ScopedClipboardWriter::WritePickledData(
     const base::Pickle& pickle,
-    const Clipboard::FormatType& format) {
+    const ClipboardFormatType& format) {
   std::string format_string = format.Serialize();
   Clipboard::ObjectMapParam format_parameter(format_string.begin(),
                                              format_string.end());
--- a/ui/base/clipboard/scoped_clipboard_writer.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/clipboard/scoped_clipboard_writer.h	2019-01-24 15:42:55.784000000 +0300
@@ -17,7 +17,7 @@
 #include "base/strings/string16.h"
 #include "third_party/skia/include/core/SkBitmap.h"
 #include "ui/base/clipboard/clipboard.h"
-#include "ui/base/ui_base_export.h"
+#include "ui/base/clipboard/ui_base_clipboard_export.h"
 
 namespace base {
 class Pickle;
@@ -27,7 +27,7 @@
 
 // This class is a wrapper for |Clipboard| that handles packing data
 // into a Clipboard::ObjectMap.
-class UI_BASE_EXPORT ScopedClipboardWriter {
+class UI_BASE_CLIPBOARD_EXPORT ScopedClipboardWriter {
  public:
   // Create an instance that is a simple wrapper around the clipboard of the
   // given type.
@@ -59,7 +59,7 @@
 
   // Adds arbitrary pickled data to clipboard.
   void WritePickledData(const base::Pickle& pickle,
-                        const Clipboard::FormatType& format);
+                        const ClipboardFormatType& format);
 
   // Adds custom data to clipboard.
   void WriteData(const std::string& type, const std::string& data);
--- a/ui/base/dragdrop/os_exchange_data.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data.cc	2019-01-24 15:42:58.948000000 +0300
@@ -56,7 +56,7 @@
   provider_->SetFilenames(filenames);
 }
 
-void OSExchangeData::SetPickledData(const Clipboard::FormatType& format,
+void OSExchangeData::SetPickledData(const ClipboardFormatType& format,
                                     const base::Pickle& data) {
   provider_->SetPickledData(format, data);
 }
@@ -79,7 +79,7 @@
   return provider_->GetFilenames(filenames);
 }
 
-bool OSExchangeData::GetPickledData(const Clipboard::FormatType& format,
+bool OSExchangeData::GetPickledData(const ClipboardFormatType& format,
                                     base::Pickle* data) const {
   return provider_->GetPickledData(format, data);
 }
@@ -96,14 +96,13 @@
   return provider_->HasFile();
 }
 
-bool OSExchangeData::HasCustomFormat(
-    const Clipboard::FormatType& format) const {
+bool OSExchangeData::HasCustomFormat(const ClipboardFormatType& format) const {
   return provider_->HasCustomFormat(format);
 }
 
 bool OSExchangeData::HasAnyFormat(
     int formats,
-    const std::set<Clipboard::FormatType>& format_types) const {
+    const std::set<ClipboardFormatType>& format_types) const {
   if ((formats & STRING) != 0 && HasString())
     return true;
   if ((formats & URL) != 0 && HasURL(CONVERT_FILENAMES))
--- a/ui/base/dragdrop/os_exchange_data.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data.h	2019-01-24 15:42:58.948000000 +0300
@@ -17,7 +17,7 @@
 
 #include "base/files/file_path.h"
 #include "base/macros.h"
-#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/dragdrop/download_file_interface.h"
 #include "ui/base/ui_base_export.h"
 
@@ -96,7 +96,7 @@
     virtual void SetURL(const GURL& url, const base::string16& title) = 0;
     virtual void SetFilename(const base::FilePath& path) = 0;
     virtual void SetFilenames(const std::vector<FileInfo>& file_names) = 0;
-    virtual void SetPickledData(const Clipboard::FormatType& format,
+    virtual void SetPickledData(const ClipboardFormatType& format,
                                 const base::Pickle& data) = 0;
 
     virtual bool GetString(base::string16* data) const = 0;
@@ -105,13 +105,13 @@
                                 base::string16* title) const = 0;
     virtual bool GetFilename(base::FilePath* path) const = 0;
     virtual bool GetFilenames(std::vector<FileInfo>* file_names) const = 0;
-    virtual bool GetPickledData(const Clipboard::FormatType& format,
+    virtual bool GetPickledData(const ClipboardFormatType& format,
                                 base::Pickle* data) const = 0;
 
     virtual bool HasString() const = 0;
     virtual bool HasURL(FilenameToURLPolicy policy) const = 0;
     virtual bool HasFile() const = 0;
-    virtual bool HasCustomFormat(const Clipboard::FormatType& format) const = 0;
+    virtual bool HasCustomFormat(const ClipboardFormatType& format) const = 0;
 
 #if defined(USE_X11) || defined(OS_WIN)
     virtual void SetFileContents(const base::FilePath& filename,
@@ -174,7 +174,7 @@
   void SetFilenames(
       const std::vector<FileInfo>& file_names);
   // Adds pickled data of the specified format.
-  void SetPickledData(const Clipboard::FormatType& format,
+  void SetPickledData(const ClipboardFormatType& format,
                       const base::Pickle& data);
 
   // These functions retrieve data of the specified type. If data exists, the
@@ -190,7 +190,7 @@
   // Return the path of a file, if available.
   bool GetFilename(base::FilePath* path) const;
   bool GetFilenames(std::vector<FileInfo>* file_names) const;
-  bool GetPickledData(const Clipboard::FormatType& format,
+  bool GetPickledData(const ClipboardFormatType& format,
                       base::Pickle* data) const;
 
   // Test whether or not data of certain types is present, without actually
@@ -198,12 +198,12 @@
   bool HasString() const;
   bool HasURL(FilenameToURLPolicy policy) const;
   bool HasFile() const;
-  bool HasCustomFormat(const Clipboard::FormatType& format) const;
+  bool HasCustomFormat(const ClipboardFormatType& format) const;
 
   // Returns true if this OSExchangeData has data in any of the formats in
   // |formats| or any custom format in |custom_formats|.
   bool HasAnyFormat(int formats,
-                    const std::set<Clipboard::FormatType>& types) const;
+                    const std::set<ClipboardFormatType>& types) const;
 
 #if defined(OS_WIN)
   // Adds the bytes of a file (CFSTR_FILECONTENTS and CFSTR_FILEDESCRIPTOR on
--- a/ui/base/dragdrop/os_exchange_data_provider_aura.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_provider_aura.cc	2019-01-24 15:42:59.400000000 +0300
@@ -8,8 +8,6 @@
 #include "base/memory/ptr_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "net/base/filename_util.h"
-#include "ui/base/clipboard/clipboard.h"
-#include "ui/base/clipboard/scoped_clipboard_writer.h"
 #include "ui/base/dragdrop/file_info.h"
 
 namespace ui {
@@ -75,7 +73,7 @@
 }
 
 void OSExchangeDataProviderAura::SetPickledData(
-    const Clipboard::FormatType& format,
+    const ClipboardFormatType& format,
     const base::Pickle& data) {
   pickle_data_[format] = data;
   formats_ |= OSExchangeData::PICKLED_DATA;
@@ -123,7 +121,7 @@
 }
 
 bool OSExchangeDataProviderAura::GetPickledData(
-    const Clipboard::FormatType& format,
+    const ClipboardFormatType& format,
     base::Pickle* data) const {
   PickleData::const_iterator i = pickle_data_.find(format);
   if (i == pickle_data_.end())
@@ -152,7 +150,7 @@
 }
 
 bool OSExchangeDataProviderAura::HasCustomFormat(
-    const Clipboard::FormatType& format) const {
+    const ClipboardFormatType& format) const {
   return pickle_data_.find(format) != pickle_data_.end();
 }
 
--- a/ui/base/dragdrop/os_exchange_data_provider_aura.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_provider_aura.h	2019-01-24 15:42:59.400000000 +0300
@@ -10,6 +10,7 @@
 #include "base/files/file_path.h"
 #include "base/macros.h"
 #include "base/pickle.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/dragdrop/os_exchange_data.h"
 #include "ui/gfx/geometry/vector2d.h"
 #include "ui/gfx/image/image_skia.h"
@@ -17,8 +18,6 @@
 
 namespace ui {
 
-class Clipboard;
-
 // OSExchangeData::Provider implementation for aura on linux.
 class UI_BASE_EXPORT OSExchangeDataProviderAura
     : public OSExchangeData::Provider {
@@ -34,7 +33,7 @@
   void SetURL(const GURL& url, const base::string16& title) override;
   void SetFilename(const base::FilePath& path) override;
   void SetFilenames(const std::vector<FileInfo>& filenames) override;
-  void SetPickledData(const Clipboard::FormatType& format,
+  void SetPickledData(const ClipboardFormatType& format,
                       const base::Pickle& data) override;
   bool GetString(base::string16* data) const override;
   bool GetURLAndTitle(OSExchangeData::FilenameToURLPolicy policy,
@@ -42,13 +41,12 @@
                       base::string16* title) const override;
   bool GetFilename(base::FilePath* path) const override;
   bool GetFilenames(std::vector<FileInfo>* filenames) const override;
-  bool GetPickledData(const Clipboard::FormatType& format,
+  bool GetPickledData(const ClipboardFormatType& format,
                       base::Pickle* data) const override;
   bool HasString() const override;
   bool HasURL(OSExchangeData::FilenameToURLPolicy policy) const override;
   bool HasFile() const override;
-  bool HasCustomFormat(const Clipboard::FormatType& format) const
-      override;
+  bool HasCustomFormat(const ClipboardFormatType& format) const override;
 
   void SetHtml(const base::string16& html, const GURL& base_url) override;
   bool GetHtml(base::string16* html, GURL* base_url) const override;
@@ -59,7 +57,7 @@
   gfx::Vector2d GetDragImageOffset() const override;
 
  private:
-  typedef std::map<Clipboard::FormatType, base::Pickle> PickleData;
+  typedef std::map<ClipboardFormatType, base::Pickle> PickleData;
 
   // Returns true if |formats_| contains a file format and the file name can be
   // parsed as a URL.
--- a/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc	2019-01-24 15:42:59.400000000 +0300
@@ -12,8 +12,8 @@
 #include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "net/base/filename_util.h"
-#include "ui/base/clipboard/clipboard.h"
-#include "ui/base/clipboard/scoped_clipboard_writer.h"
+#include "ui/base/clipboard/clipboard_constants.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/dragdrop/file_info.h"
 #include "ui/base/x/selection_utils.h"
 #include "ui/events/platform/platform_event_source.h"
@@ -117,7 +117,7 @@
   scoped_refptr<base::RefCountedMemory> mem(
       base::RefCountedString::TakeString(&utf8));
 
-  format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeText), mem);
+  format_map_.Insert(gfx::GetAtom(kMimeTypeText), mem);
   format_map_.Insert(gfx::GetAtom(kText), mem);
   format_map_.Insert(gfx::GetAtom(kString), mem);
   format_map_.Insert(gfx::GetAtom(kUtf8String), mem);
@@ -138,7 +138,7 @@
     scoped_refptr<base::RefCountedMemory> mem(
         base::RefCountedBytes::TakeVector(&data));
 
-    format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeMozillaURL), mem);
+    format_map_.Insert(gfx::GetAtom(kMimeTypeMozillaURL), mem);
 
     // Set a string fallback as well.
     SetString(spec);
@@ -182,11 +182,11 @@
   std::string joined_data = base::JoinString(paths, "\n");
   scoped_refptr<base::RefCountedMemory> mem(
       base::RefCountedString::TakeString(&joined_data));
-  format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeURIList), mem);
+  format_map_.Insert(gfx::GetAtom(kMimeTypeURIList), mem);
 }
 
 void OSExchangeDataProviderAuraX11::SetPickledData(
-    const Clipboard::FormatType& format,
+    const ClipboardFormatType& format,
     const base::Pickle& pickle) {
   const unsigned char* data =
       reinterpret_cast<const unsigned char*>(pickle.data());
@@ -235,7 +235,7 @@
     // but that doesn't match the assumptions of the rest of the system which
     // expect single types.
 
-    if (data.GetType() == gfx::GetAtom(Clipboard::kMimeTypeMozillaURL)) {
+    if (data.GetType() == gfx::GetAtom(kMimeTypeMozillaURL)) {
       // Mozilla URLs are (UTF16: URL, newline, title).
       base::string16 unparsed;
       data.AssignTo(&unparsed);
@@ -252,7 +252,7 @@
         *url = GURL(tokens[0]);
         return true;
       }
-    } else if (data.GetType() == gfx::GetAtom(Clipboard::kMimeTypeURIList)) {
+    } else if (data.GetType() == gfx::GetAtom(kMimeTypeURIList)) {
       std::vector<std::string> tokens = ui::ParseURIList(data);
       for (std::vector<std::string>::const_iterator it = tokens.begin();
            it != tokens.end(); ++it) {
@@ -304,7 +304,7 @@
 }
 
 bool OSExchangeDataProviderAuraX11::GetPickledData(
-    const Clipboard::FormatType& format,
+    const ClipboardFormatType& format,
     base::Pickle* pickle) const {
   std::vector< ::Atom> requested_types;
   requested_types.push_back(gfx::GetAtom(format.ToString().c_str()));
@@ -341,11 +341,10 @@
   // Windows does and stuffs all the data into one mime type.
   ui::SelectionData data(format_map_.GetFirstOf(requested_types));
   if (data.IsValid()) {
-    if (data.GetType() == gfx::GetAtom(Clipboard::kMimeTypeMozillaURL)) {
+    if (data.GetType() == gfx::GetAtom(kMimeTypeMozillaURL)) {
       // File managers shouldn't be using this type, so this is a URL.
       return true;
-    } else if (data.GetType() ==
-               gfx::GetAtom(ui::Clipboard::kMimeTypeURIList)) {
+    } else if (data.GetType() == gfx::GetAtom(ui::kMimeTypeURIList)) {
       std::vector<std::string> tokens = ui::ParseURIList(data);
       for (std::vector<std::string>::const_iterator it = tokens.begin();
            it != tokens.end(); ++it) {
@@ -388,7 +387,7 @@
 }
 
 bool OSExchangeDataProviderAuraX11::HasCustomFormat(
-    const Clipboard::FormatType& format) const {
+    const ClipboardFormatType& format) const {
   std::vector< ::Atom> url_atoms;
   url_atoms.push_back(gfx::GetAtom(format.ToString().c_str()));
   std::vector< ::Atom> requested_types;
@@ -402,7 +401,7 @@
     const std::string& file_contents) {
   DCHECK(!filename.empty());
   DCHECK(format_map_.end() ==
-         format_map_.find(gfx::GetAtom(Clipboard::kMimeTypeMozillaURL)));
+         format_map_.find(gfx::GetAtom(kMimeTypeMozillaURL)));
 
   file_contents_name_ = filename;
 
@@ -443,13 +442,13 @@
   scoped_refptr<base::RefCountedMemory> mem(
       base::RefCountedBytes::TakeVector(&bytes));
 
-  format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeHTML), mem);
+  format_map_.Insert(gfx::GetAtom(kMimeTypeHTML), mem);
 }
 
 bool OSExchangeDataProviderAuraX11::GetHtml(base::string16* html,
                                             GURL* base_url) const {
   std::vector< ::Atom> url_atoms;
-  url_atoms.push_back(gfx::GetAtom(Clipboard::kMimeTypeHTML));
+  url_atoms.push_back(gfx::GetAtom(kMimeTypeHTML));
   std::vector< ::Atom> requested_types;
   GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
 
@@ -465,7 +464,7 @@
 
 bool OSExchangeDataProviderAuraX11::HasHtml() const {
   std::vector< ::Atom> url_atoms;
-  url_atoms.push_back(gfx::GetAtom(Clipboard::kMimeTypeHTML));
+  url_atoms.push_back(gfx::GetAtom(kMimeTypeHTML));
   std::vector< ::Atom> requested_types;
   GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
 
--- a/ui/base/dragdrop/os_exchange_data_provider_aurax11.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_provider_aurax11.h	2019-01-24 15:42:59.400000000 +0300
@@ -23,7 +23,6 @@
 
 namespace ui {
 
-class Clipboard;
 class OSExchangeDataProviderAuraX11Test;
 
 // OSExchangeData::Provider implementation for aura on linux.
@@ -65,7 +64,7 @@
   void SetURL(const GURL& url, const base::string16& title) override;
   void SetFilename(const base::FilePath& path) override;
   void SetFilenames(const std::vector<FileInfo>& filenames) override;
-  void SetPickledData(const Clipboard::FormatType& format,
+  void SetPickledData(const ClipboardFormatType& format,
                       const base::Pickle& pickle) override;
   bool GetString(base::string16* data) const override;
   bool GetURLAndTitle(OSExchangeData::FilenameToURLPolicy policy,
@@ -73,12 +72,12 @@
                       base::string16* title) const override;
   bool GetFilename(base::FilePath* path) const override;
   bool GetFilenames(std::vector<FileInfo>* filenames) const override;
-  bool GetPickledData(const Clipboard::FormatType& format,
+  bool GetPickledData(const ClipboardFormatType& format,
                       base::Pickle* pickle) const override;
   bool HasString() const override;
   bool HasURL(OSExchangeData::FilenameToURLPolicy policy) const override;
   bool HasFile() const override;
-  bool HasCustomFormat(const Clipboard::FormatType& format) const override;
+  bool HasCustomFormat(const ClipboardFormatType& format) const override;
 
   void SetFileContents(const base::FilePath& filename,
                        const std::string& file_contents) override;
@@ -97,7 +96,7 @@
 
  private:
   friend class OSExchangeDataProviderAuraX11Test;
-  typedef std::map<Clipboard::FormatType, base::Pickle> PickleData;
+  typedef std::map<ClipboardFormatType, base::Pickle> PickleData;
 
   // Returns true if |formats_| contains a string format and the string can be
   // parsed as a URL.
--- a/ui/base/dragdrop/os_exchange_data_provider_aurax11_unittest.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_provider_aurax11_unittest.cc	2019-01-24 15:42:59.400000000 +0300
@@ -9,6 +9,7 @@
 #include "base/test/scoped_task_environment.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/base/dragdrop/file_info.h"
+#include "ui/base/clipboard/clipboard_constants.h"
 #include "ui/events/platform/x11/x11_event_source_glib.h"
 #include "ui/gfx/x/x11_atom_cache.h"
 #include "url/gurl.h"
@@ -32,7 +33,7 @@
     scoped_refptr<base::RefCountedMemory> mem(
         base::RefCountedString::TakeString(&contents_copy));
 
-    provider.format_map_.Insert(gfx::GetAtom(ui::Clipboard::kMimeTypeURIList),
+    provider.format_map_.Insert(gfx::GetAtom(ui::kMimeTypeURIList),
                                 mem);
   }
 
--- a/ui/base/dragdrop/os_exchange_data_provider_mac.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_provider_mac.h	2019-01-24 15:42:59.400000000 +0300
@@ -35,7 +35,7 @@
   void SetURL(const GURL& url, const base::string16& title) override;
   void SetFilename(const base::FilePath& path) override;
   void SetFilenames(const std::vector<FileInfo>& filenames) override;
-  void SetPickledData(const Clipboard::FormatType& format,
+  void SetPickledData(const ClipboardFormatType& format,
                       const base::Pickle& data) override;
   bool GetString(base::string16* data) const override;
   bool GetURLAndTitle(OSExchangeData::FilenameToURLPolicy policy,
@@ -43,12 +43,12 @@
                       base::string16* title) const override;
   bool GetFilename(base::FilePath* path) const override;
   bool GetFilenames(std::vector<FileInfo>* filenames) const override;
-  bool GetPickledData(const Clipboard::FormatType& format,
+  bool GetPickledData(const ClipboardFormatType& format,
                       base::Pickle* data) const override;
   bool HasString() const override;
   bool HasURL(OSExchangeData::FilenameToURLPolicy policy) const override;
   bool HasFile() const override;
-  bool HasCustomFormat(const Clipboard::FormatType& format) const override;
+  bool HasCustomFormat(const ClipboardFormatType& format) const override;
   void SetDragImage(const gfx::ImageSkia& image,
                     const gfx::Vector2d& cursor_offset) override;
   gfx::ImageSkia GetDragImage() const override;
--- a/ui/base/dragdrop/os_exchange_data_provider_mac.mm	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_provider_mac.mm	2019-01-24 15:42:59.400000000 +0300
@@ -78,7 +78,7 @@
 }
 
 void OSExchangeDataProviderMac::SetPickledData(
-    const Clipboard::FormatType& format,
+    const ClipboardFormatType& format,
     const base::Pickle& data) {
   NSData* ns_data = [NSData dataWithBytes:data.data() length:data.size()];
   [pasteboard_->get() setData:ns_data forType:format.ToNSString()];
@@ -160,7 +160,7 @@
 }
 
 bool OSExchangeDataProviderMac::GetPickledData(
-    const Clipboard::FormatType& format,
+    const ClipboardFormatType& format,
     base::Pickle* data) const {
   DCHECK(data);
   NSData* ns_data = [pasteboard_->get() dataForType:format.ToNSString()];
@@ -189,7 +189,7 @@
 }
 
 bool OSExchangeDataProviderMac::HasCustomFormat(
-    const Clipboard::FormatType& format) const {
+    const ClipboardFormatType& format) const {
   return [[pasteboard_->get() types] containsObject:format.ToNSString()];
 }
 
--- a/ui/base/dragdrop/os_exchange_data_provider_win.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_provider_win.cc	2019-01-24 15:42:59.400000000 +0300
@@ -26,7 +26,7 @@
 #include "net/base/filename_util.h"
 #include "skia/ext/skia_utils_win.h"
 #include "third_party/skia/include/core/SkBitmap.h"
-#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/clipboard/clipboard_util_win.h"
 #include "ui/base/dragdrop/file_info.h"
 #include "ui/base/l10n/l10n_util.h"
@@ -38,9 +38,9 @@
 
 namespace ui {
 
-static const Clipboard::FormatType& GetRendererTaintFormatType() {
-  static base::NoDestructor<Clipboard::FormatType> format(
-      ui::Clipboard::GetFormatType("chromium/x-renderer-taint"));
+static const ClipboardFormatType& GetRendererTaintClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> format(
+      ui::GetClipboardFormatType("chromium/x-renderer-taint"));
   return *format;
 }
 
@@ -296,22 +296,22 @@
 void OSExchangeDataProviderWin::MarkOriginatedFromRenderer() {
   STGMEDIUM* storage = GetStorageForString(std::string());
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      GetRendererTaintFormatType().ToFormatEtc(), storage));
+      GetRendererTaintClipboardFormatType().ToFormatEtc(), storage));
 }
 
 bool OSExchangeDataProviderWin::DidOriginateFromRenderer() const {
-  return HasCustomFormat(GetRendererTaintFormatType());
+  return HasCustomFormat(GetRendererTaintClipboardFormatType());
 }
 
 void OSExchangeDataProviderWin::SetString(const base::string16& data) {
   STGMEDIUM* storage = GetStorageForString(data);
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetPlainTextWFormatType().ToFormatEtc(), storage));
+      GetPlainTextWClipboardFormatType().ToFormatEtc(), storage));
 
   // Also add the UTF8-encoded version.
   storage = GetStorageForString(base::UTF16ToUTF8(data));
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetPlainTextFormatType().ToFormatEtc(), storage));
+      GetPlainTextClipboardFormatType().ToFormatEtc(), storage));
 }
 
 void OSExchangeDataProviderWin::SetURL(const GURL& url,
@@ -328,7 +328,7 @@
   x_moz_url_str += title;
   STGMEDIUM* storage = GetStorageForString(x_moz_url_str);
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetMozUrlFormatType().ToFormatEtc(), storage));
+      GetMozUrlClipboardFormatType().ToFormatEtc(), storage));
 
   // Add a .URL shortcut file for dragging to Explorer.
   base::string16 valid_file_name;
@@ -340,10 +340,10 @@
   // Add a UniformResourceLocator link for apps like IE and Word.
   storage = GetStorageForString(base::UTF8ToUTF16(url.spec()));
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetUrlWFormatType().ToFormatEtc(), storage));
+      GetUrlWClipboardFormatType().ToFormatEtc(), storage));
   storage = GetStorageForString(url.spec());
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetUrlFormatType().ToFormatEtc(), storage));
+      GetUrlClipboardFormatType().ToFormatEtc(), storage));
 
   // TODO(beng): add CF_HTML.
   // http://code.google.com/p/chromium/issues/detail?id=6767GetIDListStorageForFileName
@@ -360,7 +360,7 @@
   if (!storage)
     return;
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetIDListFormatType().ToFormatEtc(), storage));
+      GetIDListClipboardFormatType().ToFormatEtc(), storage));
 }
 
 void OSExchangeDataProviderWin::SetFilenames(
@@ -370,11 +370,11 @@
     return;
 
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetCFHDropFormatType().ToFormatEtc(), storage));
+      GetCFHDropClipboardFormatType().ToFormatEtc(), storage));
 }
 
 void OSExchangeDataProviderWin::SetPickledData(
-    const Clipboard::FormatType& format,
+    const ClipboardFormatType& format,
     const base::Pickle& data) {
   STGMEDIUM* storage = GetStorageForBytes(data.data(), data.size());
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
@@ -387,12 +387,12 @@
   // Add CFSTR_FILEDESCRIPTOR
   STGMEDIUM* storage = GetStorageForFileDescriptor(filename);
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetFileDescriptorFormatType().ToFormatEtc(), storage));
+      GetFileDescriptorClipboardFormatType().ToFormatEtc(), storage));
 
   // Add CFSTR_FILECONTENTS
   storage = GetStorageForBytes(file_contents.data(), file_contents.length());
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetFileContentZeroFormatType().ToFormatEtc(), storage));
+      GetFileContentZeroClipboardFormatType().ToFormatEtc(), storage));
 }
 
 void OSExchangeDataProviderWin::SetHtml(const base::string16& html,
@@ -404,12 +404,12 @@
   std::string cf_html = ClipboardUtil::HtmlToCFHtml(utf8_html, url);
   STGMEDIUM* storage = GetStorageForBytes(cf_html.c_str(), cf_html.size());
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetHtmlFormatType().ToFormatEtc(), storage));
+      GetHtmlClipboardFormatType().ToFormatEtc(), storage));
 
   STGMEDIUM* storage_plain = GetStorageForBytes(utf8_html.c_str(),
                                                 utf8_html.size());
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetTextHtmlFormatType().ToFormatEtc(), storage_plain));
+      GetTextHtmlClipboardFormatType().ToFormatEtc(), storage_plain));
 }
 
 bool OSExchangeDataProviderWin::GetString(base::string16* data) const {
@@ -459,7 +459,7 @@
 }
 
 bool OSExchangeDataProviderWin::GetPickledData(
-    const Clipboard::FormatType& format,
+    const ClipboardFormatType& format,
     base::Pickle* data) const {
   DCHECK(data);
   bool success = false;
@@ -523,7 +523,7 @@
 }
 
 bool OSExchangeDataProviderWin::HasCustomFormat(
-    const Clipboard::FormatType& format) const {
+    const ClipboardFormatType& format) const {
   FORMATETC format_etc = format.ToFormatEtc();
   return (source_object_->QueryGetData(&format_etc) == S_OK);
 }
@@ -540,7 +540,7 @@
 
   // Add CF_HDROP.
   auto info = std::make_unique<DataObjectImpl::StoredDataInfo>(
-      Clipboard::GetCFHDropFormatType().ToFormatEtc(), storage);
+      GetCFHDropClipboardFormatType().ToFormatEtc(), storage);
   info->downloader = download.downloader;
   data_->contents_.push_back(std::move(info));
 
--- a/ui/base/dragdrop/os_exchange_data_provider_win.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_provider_win.h	2019-01-24 15:42:59.400000000 +0300
@@ -154,7 +154,7 @@
   void SetURL(const GURL& url, const base::string16& title) override;
   void SetFilename(const base::FilePath& path) override;
   void SetFilenames(const std::vector<FileInfo>& filenames) override;
-  void SetPickledData(const Clipboard::FormatType& format,
+  void SetPickledData(const ClipboardFormatType& format,
                       const base::Pickle& data) override;
   void SetFileContents(const base::FilePath& filename,
                        const std::string& file_contents) override;
@@ -166,7 +166,7 @@
                       base::string16* title) const override;
   bool GetFilename(base::FilePath* path) const override;
   bool GetFilenames(std::vector<FileInfo>* filenames) const override;
-  bool GetPickledData(const Clipboard::FormatType& format,
+  bool GetPickledData(const ClipboardFormatType& format,
                       base::Pickle* data) const override;
   bool GetFileContents(base::FilePath* filename,
                        std::string* file_contents) const override;
@@ -176,7 +176,7 @@
   bool HasFile() const override;
   bool HasFileContents() const override;
   bool HasHtml() const override;
-  bool HasCustomFormat(const Clipboard::FormatType& format) const override;
+  bool HasCustomFormat(const ClipboardFormatType& format) const override;
   void SetDownloadFileInfo(
       const OSExchangeData::DownloadFileInfo& download_info) override;
   void SetDragImage(const gfx::ImageSkia& image_skia,
--- a/ui/base/dragdrop/os_exchange_data_unittest.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_unittest.cc	2019-01-24 15:42:59.400000000 +0300
@@ -142,8 +142,8 @@
 }
 
 TEST_F(OSExchangeDataTest, TestPickledData) {
-  const Clipboard::FormatType kTestFormat =
-      Clipboard::GetFormatType("application/vnd.chromium.test");
+  const ui::ClipboardFormatType kTestFormat =
+      ui::GetClipboardFormatType("application/vnd.chromium.test");
 
   base::Pickle saved_pickle;
   saved_pickle.WriteInt(1);
--- a/ui/base/dragdrop/os_exchange_data_win_unittest.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/dragdrop/os_exchange_data_win_unittest.cc	2019-01-24 15:42:59.412000000 +0300
@@ -10,7 +10,7 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/win/scoped_hglobal.h"
 #include "testing/gtest/include/gtest/gtest.h"
-#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/dragdrop/file_info.h"
 #include "ui/base/dragdrop/os_exchange_data_provider_win.h"
 #include "url/gurl.h"
@@ -322,7 +322,7 @@
   expected_cf_html += base::WideToUTF8(html);
   expected_cf_html.append("<!--EndFragment-->\r\n</body>\r\n</html>");
 
-  FORMATETC format = Clipboard::GetHtmlFormatType().ToFormatEtc();
+  FORMATETC format = GetHtmlClipboardFormatType().ToFormatEtc();
   STGMEDIUM medium;
   IDataObject* data_object = OSExchangeDataProviderWin::GetIDataObject(data);
   EXPECT_EQ(S_OK, data_object->GetData(&format, &medium));
--- a/ui/base/mojo/BUILD.gn	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/mojo/BUILD.gn	2019-01-24 15:43:04.576000000 +0300
@@ -32,5 +32,6 @@
     "//base",
     "//mojo/public/cpp/bindings",
     "//ui/base",
+    "//ui/base/clipboard",
   ]
 }
--- a/ui/base/mojo/clipboard_client.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/mojo/clipboard_client.cc	2019-01-24 15:43:04.916000000 +0300
@@ -29,7 +29,7 @@
   return sequence_number;
 }
 
-bool ClipboardClient::IsFormatAvailable(const FormatType& format,
+bool ClipboardClient::IsFormatAvailable(const ClipboardFormatType& format,
                                         ClipboardType type) const {
   mojo::SyncCallRestrictions::ScopedAllowSyncCall allow_sync_call;
   bool result = false;
@@ -95,7 +95,7 @@
   clipboard_->ReadBookmark(title, url);
 }
 
-void ClipboardClient::ReadData(const FormatType& format,
+void ClipboardClient::ReadData(const ClipboardFormatType& format,
                                std::string* result) const {
   mojo::SyncCallRestrictions::ScopedAllowSyncCall allow_sync_call;
   clipboard_->ReadData(format.Serialize(), result);
@@ -151,7 +151,7 @@
   clipboard_->WriteBitmap(bitmap);
 }
 
-void ClipboardClient::WriteData(const FormatType& format,
+void ClipboardClient::WriteData(const ClipboardFormatType& format,
                                 const char* data_data,
                                 size_t data_len) {
   mojo::SyncCallRestrictions::ScopedAllowSyncCall allow_sync_call;
--- a/ui/base/mojo/clipboard_client.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/mojo/clipboard_client.h	2019-01-24 15:43:04.916000000 +0300
@@ -22,7 +22,7 @@
   // Clipboard overrides:
   void OnPreShutdown() override;
   uint64_t GetSequenceNumber(ClipboardType type) const override;
-  bool IsFormatAvailable(const FormatType& format,
+  bool IsFormatAvailable(const ClipboardFormatType& format,
                          ClipboardType type) const override;
   void Clear(ClipboardType type) override;
   void ReadAvailableTypes(ClipboardType type,
@@ -41,7 +41,8 @@
                       const base::string16& type,
                       base::string16* result) const override;
   void ReadBookmark(base::string16* title, std::string* url) const override;
-  void ReadData(const FormatType& format, std::string* result) const override;
+  void ReadData(const ClipboardFormatType& format,
+                std::string* result) const override;
   void WriteObjects(ClipboardType type, const ObjectMap& objects) override;
   void WriteText(const char* text_data, size_t text_len) override;
   void WriteHTML(const char* markup_data,
@@ -55,7 +56,7 @@
                      size_t url_len) override;
   void WriteWebSmartPaste() override;
   void WriteBitmap(const SkBitmap& bitmap) override;
-  void WriteData(const FormatType& format,
+  void WriteData(const ClipboardFormatType& format,
                  const char* data_data,
                  size_t data_len) override;
 
--- a/ui/base/mojo/clipboard_host.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/mojo/clipboard_host.cc	2019-01-24 15:43:04.916000000 +0300
@@ -33,7 +33,7 @@
 void ClipboardHost::IsFormatAvailable(const std::string& format,
                                       ClipboardType type,
                                       IsFormatAvailableCallback callback) {
-  auto format_type = Clipboard::FormatType::Deserialize(format);
+  auto format_type = ClipboardFormatType::Deserialize(format);
   bool result = clipboard_->IsFormatAvailable(format_type, type);
   std::move(callback).Run(result);
 }
@@ -52,10 +52,9 @@
 
 void ClipboardHost::ReadText(ClipboardType type, ReadTextCallback callback) {
   base::string16 result;
-  if (clipboard_->IsFormatAvailable(Clipboard::GetPlainTextWFormatType(),
-                                    type)) {
+  if (clipboard_->IsFormatAvailable(GetPlainTextWClipboardFormatType(), type)) {
     clipboard_->ReadText(type, &result);
-  } else if (clipboard_->IsFormatAvailable(Clipboard::GetPlainTextFormatType(),
+  } else if (clipboard_->IsFormatAvailable(GetPlainTextClipboardFormatType(),
                                            type)) {
     std::string ascii;
     clipboard_->ReadAsciiText(type, &ascii);
@@ -111,7 +110,7 @@
 void ClipboardHost::ReadData(const std::string& format,
                              ReadDataCallback callback) {
   std::string result;
-  clipboard_->ReadData(Clipboard::FormatType::Deserialize(format), &result);
+  clipboard_->ReadData(ClipboardFormatType::Deserialize(format), &result);
   std::move(callback).Run(std::move(result));
 }
 
--- a/ui/base/x/selection_utils.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/x/selection_utils.cc	2019-01-24 15:43:06.264000000 +0300
@@ -14,7 +14,7 @@
 #include "base/strings/string_split.h"
 #include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversions.h"
-#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/clipboard_constants.h"
 #include "ui/gfx/x/x11_atom_cache.h"
 
 namespace ui {
@@ -37,14 +37,14 @@
 
 std::vector<::Atom> GetURLAtomsFrom() {
   std::vector< ::Atom> atoms;
-  atoms.push_back(gfx::GetAtom(Clipboard::kMimeTypeURIList));
-  atoms.push_back(gfx::GetAtom(Clipboard::kMimeTypeMozillaURL));
+  atoms.push_back(gfx::GetAtom(kMimeTypeURIList));
+  atoms.push_back(gfx::GetAtom(kMimeTypeMozillaURL));
   return atoms;
 }
 
 std::vector<::Atom> GetURIListAtomsFrom() {
   std::vector< ::Atom> atoms;
-  atoms.push_back(gfx::GetAtom(Clipboard::kMimeTypeURIList));
+  atoms.push_back(gfx::GetAtom(kMimeTypeURIList));
   return atoms;
 }
 
@@ -198,7 +198,7 @@
 base::string16 SelectionData::GetHtml() const {
   base::string16 markup;
 
-  if (type_ == gfx::GetAtom(Clipboard::kMimeTypeHTML)) {
+  if (type_ == gfx::GetAtom(kMimeTypeHTML)) {
     const unsigned char* data = GetData();
     size_t size = GetSize();
 
--- a/ui/base/x/selection_utils.h	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/base/x/selection_utils.h	2019-01-24 15:43:06.644000000 +0300
@@ -9,7 +9,6 @@
 #include <map>
 
 #include "base/memory/ref_counted_memory.h"
-#include "ui/base/clipboard/clipboard.h"
 #include "ui/base/ui_base_export.h"
 #include "ui/gfx/x/x11.h"
 
--- a/ui/compositor/test/test_compositor_host_ozone.cc	2018-12-13 00:56:27.000000000 +0300
+++ b/ui/compositor/test/test_compositor_host_ozone.cc	2019-01-24 15:43:09.260000000 +0300
@@ -87,7 +87,11 @@
                   false /* enable_surface_synchronization */,
                   false /* enable_pixel_canvas */) {}
 
-TestCompositorHostOzone::~TestCompositorHostOzone() {}
+TestCompositorHostOzone::~TestCompositorHostOzone() {
+  // |window_| should be destroyed earlier than |window_delegate_| as it refers
+  // to its delegate on destroying.
+  window_.reset();
+}
 
 void TestCompositorHostOzone::Show() {
   ui::PlatformWindowInitProperties properties;
--- a/ui/gfx/BUILD.gn	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/gfx/BUILD.gn	2019-01-28 13:41:00.940000000 +0300
@@ -539,7 +539,7 @@
       "linux/native_pixmap_dmabuf.h",
     ]
 
-    deps += [ "//third_party/libdrm" ]
+    deps += [ "//build/config/linux/libdrm" ]
   }
 
   if (is_linux || is_android) {
--- a/ui/gfx/client_native_pixmap_factory.h	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/gfx/client_native_pixmap_factory.h	2019-01-24 15:43:13.000000000 +0300
@@ -25,13 +25,6 @@
  public:
   virtual ~ClientNativePixmapFactory();
 
-  // Returns true if format/usage configuration is supported.
-  virtual bool IsConfigurationSupported(gfx::BufferFormat format,
-                                        gfx::BufferUsage usage) const = 0;
-
-  // TODO(dshwang): implement it. crbug.com/475633
-  // Import the native pixmap from |handle| to be used in non-GPU processes.
-  // This function takes ownership of any file descriptors in |handle|.
   virtual std::unique_ptr<ClientNativePixmap> ImportFromHandle(
       const gfx::NativePixmapHandle& handle,
       const gfx::Size& size,
--- a/ui/gfx/linux/client_native_pixmap_dmabuf.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/gfx/linux/client_native_pixmap_dmabuf.cc	2019-01-24 15:43:13.548000000 +0300
@@ -16,6 +16,7 @@
 #include "base/process/memory.h"
 #include "base/strings/stringprintf.h"
 #include "base/trace_event/trace_event.h"
+#include "build/build_config.h"
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
 #include <linux/dma-buf.h>
@@ -59,6 +60,68 @@
 }  // namespace
 
 // static
+bool ClientNativePixmapDmaBuf::IsConfigurationSupported(
+    gfx::BufferFormat format,
+    gfx::BufferUsage usage) {
+  switch (usage) {
+    case gfx::BufferUsage::GPU_READ:
+      return format == gfx::BufferFormat::BGR_565 ||
+             format == gfx::BufferFormat::RGBA_8888 ||
+             format == gfx::BufferFormat::RGBX_8888 ||
+             format == gfx::BufferFormat::BGRA_8888 ||
+             format == gfx::BufferFormat::BGRX_8888 ||
+             format == gfx::BufferFormat::YVU_420;
+    case gfx::BufferUsage::SCANOUT:
+      return format == gfx::BufferFormat::BGRX_8888 ||
+             format == gfx::BufferFormat::RGBX_8888 ||
+             format == gfx::BufferFormat::RGBA_8888 ||
+             format == gfx::BufferFormat::BGRA_8888;
+    case gfx::BufferUsage::SCANOUT_CPU_READ_WRITE:
+      return
+#if defined(ARCH_CPU_X86_FAMILY)
+          // Currently only Intel driver (i.e. minigbm and Mesa) supports R_8
+          // RG_88, NV12 and XB30. https://crbug.com/356871
+          format == gfx::BufferFormat::R_8 ||
+          format == gfx::BufferFormat::RG_88 ||
+          format == gfx::BufferFormat::YUV_420_BIPLANAR ||
+          format == gfx::BufferFormat::RGBX_1010102 ||
+#endif
+
+          format == gfx::BufferFormat::BGRX_8888 ||
+          format == gfx::BufferFormat::BGRA_8888 ||
+          format == gfx::BufferFormat::RGBX_8888 ||
+          format == gfx::BufferFormat::RGBA_8888;
+    case gfx::BufferUsage::SCANOUT_VDA_WRITE:
+      return false;
+
+    case gfx::BufferUsage::GPU_READ_CPU_READ_WRITE:
+    case gfx::BufferUsage::GPU_READ_CPU_READ_WRITE_PERSISTENT:
+      return
+#if defined(ARCH_CPU_X86_FAMILY)
+          // Currently only Intel driver (i.e. minigbm and
+          // Mesa) supports R_8 RG_88 and NV12.
+          // https://crbug.com/356871
+          format == gfx::BufferFormat::R_8 ||
+          format == gfx::BufferFormat::RG_88 ||
+          format == gfx::BufferFormat::YUV_420_BIPLANAR ||
+#endif
+          format == gfx::BufferFormat::BGRA_8888;
+    case gfx::BufferUsage::SCANOUT_CAMERA_READ_WRITE:
+      // Each platform only supports one camera buffer type. We list the
+      // supported buffer formats on all platforms here. When allocating a
+      // camera buffer the caller is responsible for making sure a buffer is
+      // successfully allocated. For example, allocating YUV420_BIPLANAR
+      // for SCANOUT_CAMERA_READ_WRITE may only work on Intel boards.
+      return format == gfx::BufferFormat::YUV_420_BIPLANAR;
+    case gfx::BufferUsage::CAMERA_AND_CPU_READ_WRITE:
+      // R_8 is used as the underlying pixel format for BLOB buffers.
+      return format == gfx::BufferFormat::R_8;
+  }
+  NOTREACHED();
+  return false;
+}
+
+// static
 std::unique_ptr<gfx::ClientNativePixmap>
 ClientNativePixmapDmaBuf::ImportFromDmabuf(
     const gfx::NativePixmapHandle& handle,
--- a/ui/gfx/linux/client_native_pixmap_dmabuf.h	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/gfx/linux/client_native_pixmap_dmabuf.h	2019-01-24 15:43:13.548000000 +0300
@@ -11,14 +11,19 @@
 
 #include "base/files/scoped_file.h"
 #include "base/macros.h"
+#include "ui/gfx/buffer_types.h"
 #include "ui/gfx/client_native_pixmap.h"
 #include "ui/gfx/geometry/size.h"
+#include "ui/gfx/gfx_export.h"
 #include "ui/gfx/native_pixmap_handle.h"
 
 namespace gfx {
 
 class ClientNativePixmapDmaBuf : public gfx::ClientNativePixmap {
  public:
+  static GFX_EXPORT bool IsConfigurationSupported(gfx::BufferFormat format,
+                                                  gfx::BufferUsage usage);
+
   static std::unique_ptr<gfx::ClientNativePixmap> ImportFromDmabuf(
       const gfx::NativePixmapHandle& handle,
       const gfx::Size& size);
--- a/ui/gfx/linux/client_native_pixmap_factory_dmabuf.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/gfx/linux/client_native_pixmap_factory_dmabuf.cc	2019-01-24 15:43:13.548000000 +0300
@@ -12,12 +12,10 @@
 #include "build/build_config.h"
 #include "ui/gfx/native_pixmap_handle.h"
 
-#if defined(OS_CHROMEOS)
-// This can be enabled on all linux but it is not a requirement to support
-// glCreateImageChromium+Dmabuf since it uses gfx::BufferUsage::SCANOUT and
-// the pixmap does not need to be mappable on the client side.
+// Although, it's compiled for all linux platforms, it does not mean dmabuf
+// will work there. Check the comment below in the
+// ClientNativePixmapFactoryDmabuf for more details.
 #include "ui/gfx/linux/client_native_pixmap_dmabuf.h"
-#endif
 
 namespace gfx {
 
@@ -47,82 +45,9 @@
 
 class ClientNativePixmapFactoryDmabuf : public ClientNativePixmapFactory {
  public:
-  ClientNativePixmapFactoryDmabuf() {}
+  explicit ClientNativePixmapFactoryDmabuf() {}
   ~ClientNativePixmapFactoryDmabuf() override {}
 
-  // ClientNativePixmapFactory:
-  bool IsConfigurationSupported(gfx::BufferFormat format,
-                                gfx::BufferUsage usage) const override {
-    switch (usage) {
-      case gfx::BufferUsage::GPU_READ:
-        return format == gfx::BufferFormat::BGR_565 ||
-               format == gfx::BufferFormat::RGBA_8888 ||
-               format == gfx::BufferFormat::RGBX_8888 ||
-               format == gfx::BufferFormat::BGRA_8888 ||
-               format == gfx::BufferFormat::BGRX_8888 ||
-               format == gfx::BufferFormat::YVU_420;
-      case gfx::BufferUsage::SCANOUT:
-        return format == gfx::BufferFormat::BGRX_8888 ||
-               format == gfx::BufferFormat::RGBX_8888 ||
-               format == gfx::BufferFormat::RGBA_8888 ||
-               format == gfx::BufferFormat::BGRA_8888;
-      case gfx::BufferUsage::SCANOUT_CPU_READ_WRITE:
-        return
-#if defined(ARCH_CPU_X86_FAMILY)
-            // Currently only Intel driver (i.e. minigbm and Mesa) supports R_8
-            // RG_88, NV12 and XB30. https://crbug.com/356871
-            format == gfx::BufferFormat::R_8 ||
-            format == gfx::BufferFormat::RG_88 ||
-            format == gfx::BufferFormat::YUV_420_BIPLANAR ||
-            format == gfx::BufferFormat::RGBX_1010102 ||
-#endif
-
-            format == gfx::BufferFormat::BGRX_8888 ||
-            format == gfx::BufferFormat::BGRA_8888 ||
-            format == gfx::BufferFormat::RGBX_8888 ||
-            format == gfx::BufferFormat::RGBA_8888;
-      case gfx::BufferUsage::SCANOUT_VDA_WRITE:
-        return false;
-      case gfx::BufferUsage::GPU_READ_CPU_READ_WRITE:
-      case gfx::BufferUsage::GPU_READ_CPU_READ_WRITE_PERSISTENT: {
-#if defined(OS_CHROMEOS)
-        return
-#if defined(ARCH_CPU_X86_FAMILY)
-            // Currently only Intel driver (i.e. minigbm and Mesa) supports R_8
-            // RG_88 and NV12. https://crbug.com/356871
-            format == gfx::BufferFormat::R_8 ||
-            format == gfx::BufferFormat::RG_88 ||
-            format == gfx::BufferFormat::YUV_420_BIPLANAR ||
-#endif
-            format == gfx::BufferFormat::BGRA_8888;
-#else
-        return false;
-#endif
-      }
-      case gfx::BufferUsage::SCANOUT_CAMERA_READ_WRITE: {
-#if defined(OS_CHROMEOS)
-        // Each platform only supports one camera buffer type. We list the
-        // supported buffer formats on all platforms here. When allocating a
-        // camera buffer the caller is responsible for making sure a buffer is
-        // successfully allocated. For example, allocating YUV420_BIPLANAR
-        // for SCANOUT_CAMERA_READ_WRITE may only work on Intel boards.
-        return format == gfx::BufferFormat::YUV_420_BIPLANAR;
-#else
-        return false;
-#endif
-      }
-      case gfx::BufferUsage::CAMERA_AND_CPU_READ_WRITE: {
-#if defined(OS_CHROMEOS)
-        // R_8 is used as the underlying pixel format for BLOB buffers.
-        return format == gfx::BufferFormat::R_8;
-#else
-        return false;
-#endif
-      }
-    }
-    NOTREACHED();
-    return false;
-  }
   std::unique_ptr<ClientNativePixmap> ImportFromHandle(
       const gfx::NativePixmapHandle& handle,
       const gfx::Size& size,
@@ -134,12 +59,7 @@
       case gfx::BufferUsage::GPU_READ_CPU_READ_WRITE_PERSISTENT:
       case gfx::BufferUsage::SCANOUT_CAMERA_READ_WRITE:
       case gfx::BufferUsage::CAMERA_AND_CPU_READ_WRITE:
-#if defined(OS_CHROMEOS)
         return ClientNativePixmapDmaBuf::ImportFromDmabuf(handle, size);
-#else
-        NOTREACHED();
-        return nullptr;
-#endif
       case gfx::BufferUsage::GPU_READ:
       case gfx::BufferUsage::SCANOUT:
       case gfx::BufferUsage::SCANOUT_VDA_WRITE:
@@ -152,6 +72,7 @@
     return nullptr;
   }
 
+ private:
   DISALLOW_COPY_AND_ASSIGN(ClientNativePixmapFactoryDmabuf);
 };
 
--- a/ui/ozone/BUILD.gn	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/BUILD.gn	2019-01-24 15:43:16.260000000 +0300
@@ -72,7 +72,6 @@
 jumbo_component("ozone_base") {
   sources = [
     "ozone_base_export.h",
-    "public/clipboard_delegate.h",
     "public/cursor_factory_ozone.cc",
     "public/cursor_factory_ozone.h",
     "public/gl_ozone.h",
@@ -91,6 +90,7 @@
     "public/overlay_surface_candidate.h",
     "public/ozone_switches.cc",
     "public/ozone_switches.h",
+    "public/platform_clipboard.h",
     "public/platform_screen.h",
     "public/surface_factory_ozone.cc",
     "public/surface_factory_ozone.h",
--- a/ui/ozone/common/linux/BUILD.gn	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/common/linux/BUILD.gn	2019-01-28 13:41:01.172000000 +0300
@@ -7,18 +7,30 @@
 
 assert(ozone_platform_gbm || ozone_platform_wayland)
 
-source_set("linux") {
+source_set("drm") {
   sources = [
     "drm_util_linux.cc",
     "drm_util_linux.h",
+  ]
+
+  deps = [
+    "//base:base",
+    "//build/config/linux/libdrm",
+    "//ui/gfx:buffer_types",
+  ]
+}
+
+source_set("gbm") {
+  sources = [
     "gbm_buffer.h",
     "gbm_device.h",
     "gbm_wrapper.cc",
   ]
 
   deps = [
+    ":drm",
     "//base:base",
-    "//third_party/libdrm",
+    "//build/config/linux/libdrm",
     "//third_party/minigbm",
     "//ui/gfx:buffer_types",
     "//ui/gfx:memory_buffer",
--- a/ui/ozone/common/linux/drm_util_linux.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/common/linux/drm_util_linux.cc	2019-01-24 15:43:16.264000000 +0300
@@ -75,19 +75,19 @@
 }
 
 bool IsValidBufferFormat(uint32_t current_format) {
-  switch (GetBufferFormatFromFourCCFormat(current_format)) {
-    case gfx::BufferFormat::R_8:
-    case gfx::BufferFormat::RG_88:
-    case gfx::BufferFormat::RGBA_8888:
-    case gfx::BufferFormat::RGBX_8888:
-    case gfx::BufferFormat::BGRA_8888:
-    case gfx::BufferFormat::BGRX_8888:
-    case gfx::BufferFormat::BGRX_1010102:
-    case gfx::BufferFormat::RGBX_1010102:
-    case gfx::BufferFormat::BGR_565:
-    case gfx::BufferFormat::UYVY_422:
-    case gfx::BufferFormat::YUV_420_BIPLANAR:
-    case gfx::BufferFormat::YVU_420:
+  switch (current_format) {
+    case DRM_FORMAT_R8:
+    case DRM_FORMAT_GR88:
+    case DRM_FORMAT_ABGR8888:
+    case DRM_FORMAT_XBGR8888:
+    case DRM_FORMAT_ARGB8888:
+    case DRM_FORMAT_XRGB8888:
+    case DRM_FORMAT_XRGB2101010:
+    case DRM_FORMAT_XBGR2101010:
+    case DRM_FORMAT_RGB565:
+    case DRM_FORMAT_UYVY:
+    case DRM_FORMAT_NV12:
+    case DRM_FORMAT_YVU420:
       return true;
     default:
       return false;
--- a/ui/ozone/common/linux/gbm_wrapper.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/common/linux/gbm_wrapper.cc	2019-01-24 15:43:16.264000000 +0300
@@ -15,6 +15,14 @@
 
 namespace gbm_wrapper {
 
+namespace {
+
+// Temporary defines while we migrate to GBM_BO_IMPORT_FD_MODIFIER.
+#define GBM_BO_IMPORT_FD_PLANAR_5504 0x5504
+#define GBM_BO_IMPORT_FD_PLANAR_5505 0x5505
+
+}  // namespace
+
 class Buffer final : public ui::GbmBuffer {
  public:
   Buffer(struct gbm_bo* bo,
@@ -238,11 +246,18 @@
 
     // The fd passed to gbm_bo_import is not ref-counted and need to be
     // kept open for the lifetime of the buffer.
-    bo = gbm_bo_import(device_, GBM_BO_IMPORT_FD_PLANAR, &fd_data, gbm_flags);
+    //
+    // See the comment regarding the GBM_BO_IMPORT_FD_PLANAR_550X above.
+    bo = gbm_bo_import(device_, GBM_BO_IMPORT_FD_PLANAR_5505, &fd_data,
+                       gbm_flags);
+    if (!bo) {
+      bo = gbm_bo_import(device_, GBM_BO_IMPORT_FD_PLANAR_5504, &fd_data,
+                         gbm_flags);
     if (!bo) {
       LOG(ERROR) << "nullptr returned from gbm_bo_import";
       return nullptr;
     }
+    }
 
     return std::make_unique<Buffer>(bo, format, gbm_flags, planes[0].modifier,
                                     std::move(fds), size, std::move(planes));
--- a/ui/ozone/common/stub_client_native_pixmap_factory.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/common/stub_client_native_pixmap_factory.cc	2019-01-24 15:43:16.264000000 +0300
@@ -15,10 +15,6 @@
   ~StubClientNativePixmapFactory() override {}
 
   // ClientNativePixmapFactory:
-  bool IsConfigurationSupported(gfx::BufferFormat format,
-                                gfx::BufferUsage usage) const override {
-    return false;
-  }
   std::unique_ptr<gfx::ClientNativePixmap> ImportFromHandle(
       const gfx::NativePixmapHandle& handle,
       const gfx::Size& size,
--- a/ui/ozone/platform/cast/client_native_pixmap_factory_cast.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/cast/client_native_pixmap_factory_cast.cc	2019-01-24 15:43:16.280000000 +0300
@@ -36,12 +36,6 @@
 class ClientNativePixmapFactoryCast : public gfx::ClientNativePixmapFactory {
  public:
   // ClientNativePixmapFactoryCast implementation:
-  bool IsConfigurationSupported(gfx::BufferFormat format,
-                                gfx::BufferUsage usage) const override {
-    return format == gfx::BufferFormat::BGRA_8888 &&
-           usage == gfx::BufferUsage::SCANOUT;
-  }
-
   std::unique_ptr<gfx::ClientNativePixmap> ImportFromHandle(
       const gfx::NativePixmapHandle& handle,
       const gfx::Size& size,
--- a/ui/ozone/platform/cast/ozone_platform_cast.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/cast/ozone_platform_cast.cc	2019-01-24 15:43:16.280000000 +0300
@@ -102,6 +102,11 @@
     // On Cast platform the display is initialized by low-level non-Ozone code.
     return nullptr;
   }
+  bool IsNativePixmapConfigSupported(gfx::BufferFormat format,
+                                     gfx::BufferUsage usage) const override {
+    return format == gfx::BufferFormat::BGRA_8888 &&
+           usage == gfx::BufferUsage::SCANOUT;
+  }
 
   void InitializeUI(const InitParams& params) override {
     device_manager_ = CreateDeviceManager();
--- a/ui/ozone/platform/drm/BUILD.gn	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/drm/BUILD.gn	2019-01-28 13:41:01.340000000 +0300
@@ -3,8 +3,8 @@
 # found in the LICENSE file.
 
 import("//build/config/linux/pkg_config.gni")
-import("//ui/ozone/ozone.gni")
 import("//gpu/vulkan/features.gni")
+import("//ui/ozone/ozone.gni")
 
 visibility = [ "//ui/ozone/*" ]
 
@@ -120,13 +120,13 @@
 
   deps = [
     "//base",
+    "//build/config/linux/libdrm",
     "//gpu/vulkan:buildflags",
     "//ipc",
     "//mojo/public/cpp/system",
     "//services/service_manager/public/cpp",
     "//services/ws/public/mojom:constants",
     "//skia",
-    "//third_party/libdrm",
     "//third_party/libsync",
     "//third_party/minigbm",
     "//ui/base",
@@ -144,7 +144,8 @@
     "//ui/gl",
     "//ui/ozone:ozone_base",
     "//ui/ozone/common",
-    "//ui/ozone/common/linux",
+    "//ui/ozone/common/linux:drm",
+    "//ui/ozone/common/linux:gbm",
     "//ui/ozone/public/interfaces",
     "//ui/platform_window",
   ]
@@ -185,13 +186,14 @@
   deps = [
     ":gbm",
     "//base/test:test_support",
+    "//build/config/linux/libdrm",
     "//skia",
     "//testing/gtest",
-    "//third_party/libdrm",
     "//ui/gfx",
     "//ui/ozone:platform",
     "//ui/ozone/common",
-    "//ui/ozone/common/linux",
+    "//ui/ozone/common/linux:drm",
+    "//ui/ozone/common/linux:gbm",
   ]
 
   if (drm_commit_properties_on_page_flip) {
--- a/ui/ozone/platform/drm/ozone_platform_gbm.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/drm/ozone_platform_gbm.cc	2019-01-24 15:43:16.304000000 +0300
@@ -23,6 +23,7 @@
 #include "ui/events/ozone/device/device_manager.h"
 #include "ui/events/ozone/evdev/event_factory_evdev.h"
 #include "ui/events/ozone/layout/keyboard_layout_engine_manager.h"
+#include "ui/gfx/linux/client_native_pixmap_dmabuf.h"
 #include "ui/ozone/platform/drm/common/drm_util.h"
 #include "ui/ozone/platform/drm/gpu/drm_device_generator.h"
 #include "ui/ozone/platform/drm/gpu/drm_device_manager.h"
@@ -172,6 +173,12 @@
     return std::make_unique<DrmNativeDisplayDelegate>(display_manager_.get());
   }
 
+  bool IsNativePixmapConfigSupported(gfx::BufferFormat format,
+                                     gfx::BufferUsage usage) const override {
+    return gfx::ClientNativePixmapDmaBuf::IsConfigurationSupported(format,
+                                                                   usage);
+  }
+
   void InitializeUI(const InitParams& args) override {
     // Ozone drm can operate in four modes configured at
     // runtime. Three process modes:
@@ -185,12 +192,13 @@
     //
     // and 2 connection modes
     //   a. Viz is launched via content::GpuProcessHost and it notifies the
-    //   ozone host when Viz becomes available. b. The ozone host uses a service
-    //   manager to launch and connect to Viz.
+    //   ozone host when Viz becomes available. b. The ozone host uses a
+    //   service manager to launch and connect to Viz.
     //
     // Combinations 1a, 2b, and 3a, and 3b are supported and expected to work.
     // Combination 1a will hopefully be deprecated and replaced with 3a.
-    // Combination 2b adds undesirable code-debt and the intent is to remove it.
+    // Combination 2b adds undesirable code-debt and the intent is to remove
+    // it.
 
     single_process_ = args.single_process;
     using_mojo_ = args.using_mojo || args.connector != nullptr;
--- a/ui/ozone/platform/scenic/ozone_platform_scenic.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/scenic/ozone_platform_scenic.cc	2019-01-24 15:43:16.312000000 +0300
@@ -34,12 +34,11 @@
 
 namespace {
 
-const OzonePlatform::PlatformProperties kScenicPlatformProperties(
-    /*needs_view_owner_request=*/true,
+constexpr OzonePlatform::PlatformProperties kScenicPlatformProperties{
+    /*needs_view_token=*/true,
     /*custom_frame_pref_default=*/false,
     /*use_system_title_bar=*/false,
-    /*requires_mojo=*/false,
-    std::vector<gfx::BufferFormat>());
+    /*requires_mojo=*/false};
 
 class ScenicPlatformEventSource : public ui::PlatformEventSource {
  public:
--- a/ui/ozone/platform/wayland/BUILD.gn	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/wayland/BUILD.gn	2019-01-28 13:41:01.660000000 +0300
@@ -88,9 +88,9 @@
 
   deps = [
     "//base",
+    "//build/config/linux/libdrm",
     "//mojo/public/cpp/bindings",
     "//skia",
-    "//third_party/libdrm",
     "//third_party/minigbm",
     "//third_party/wayland:wayland_client",
     "//third_party/wayland-protocols:linux_dmabuf_protocol",
@@ -113,7 +113,7 @@
     "//ui/gfx/geometry",
     "//ui/ozone:ozone_base",
     "//ui/ozone/common",
-    "//ui/ozone/common/linux",
+    "//ui/ozone/common/linux:drm",
     "//ui/ozone/public/interfaces/wayland:wayland_interfaces",
     "//ui/platform_window",
     "//ui/platform_window/platform_window_handler",
@@ -135,10 +135,9 @@
     ]
 
     deps += [
-      "//third_party/libdrm",
-      "//third_party/minigbm",
+      "//build/config/linux/libdrm",
       "//ui/gfx:memory_buffer",
-      "//ui/ozone/common/linux",
+      "//ui/ozone/common/linux:gbm",
     ]
   }
 
--- a/ui/ozone/platform/wayland/client_native_pixmap_factory_wayland.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/wayland/client_native_pixmap_factory_wayland.cc	2019-01-24 15:43:16.312000000 +0300
@@ -4,49 +4,15 @@
 
 #include "ui/ozone/platform/wayland/client_native_pixmap_factory_wayland.h"
 
-#include "ui/gfx/linux/client_native_pixmap_dmabuf.h"
 #include "ui/gfx/linux/client_native_pixmap_factory_dmabuf.h"
 #include "ui/ozone/common/stub_client_native_pixmap_factory.h"
 #include "ui/ozone/public/ozone_platform.h"
 
 namespace ui {
 
-// Implements ClientNativePixmapFactory to provide a more accurate buffer format
-// support when Wayland dmabuf is used.
-class ClientNativePixmapFactoryWayland : public gfx::ClientNativePixmapFactory {
- public:
-  ClientNativePixmapFactoryWayland() {
-    dmabuf_factory_.reset(gfx::CreateClientNativePixmapFactoryDmabuf());
-  }
-  ~ClientNativePixmapFactoryWayland() override {}
-
-  // ClientNativePixmapFactory overrides:
-  bool IsConfigurationSupported(gfx::BufferFormat format,
-                                gfx::BufferUsage usage) const override {
-    OzonePlatform::PlatformProperties properties =
-        OzonePlatform::GetInstance()->GetPlatformProperties();
-    for (auto buffer_format : properties.supported_buffer_formats) {
-      if (buffer_format == format)
-        return dmabuf_factory_->IsConfigurationSupported(format, usage);
-    }
-    return false;
-  }
-
-  std::unique_ptr<gfx::ClientNativePixmap> ImportFromHandle(
-      const gfx::NativePixmapHandle& handle,
-      const gfx::Size& size,
-      gfx::BufferUsage usage) override {
-    return dmabuf_factory_->ImportFromHandle(handle, size, usage);
-  }
-
- private:
-  std::unique_ptr<ClientNativePixmapFactory> dmabuf_factory_;
-  DISALLOW_COPY_AND_ASSIGN(ClientNativePixmapFactoryWayland);
-};
-
 gfx::ClientNativePixmapFactory* CreateClientNativePixmapFactoryWayland() {
 #if defined(WAYLAND_GBM)
-  return new ClientNativePixmapFactoryWayland();
+  return gfx::CreateClientNativePixmapFactoryDmabuf();
 #else
   return CreateStubClientNativePixmapFactory();
 #endif
--- a/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.cc	2019-01-24 15:43:16.316000000 +0300
@@ -37,7 +37,7 @@
 bool GbmPixmapWayland::InitializeBuffer(gfx::Size size,
                                         gfx::BufferFormat format,
                                         gfx::BufferUsage usage) {
-  TRACE_EVENT1("Wayland", "GbmPixmapWayland::InitializeBuffer", "size",
+  TRACE_EVENT1("wayland", "GbmPixmapWayland::InitializeBuffer", "size",
                size.ToString());
   uint32_t flags = 0;
   switch (usage) {
@@ -58,13 +58,7 @@
       break;
     case gfx::BufferUsage::GPU_READ_CPU_READ_WRITE:
     case gfx::BufferUsage::GPU_READ_CPU_READ_WRITE_PERSISTENT:
-      // mmap cannot be used with gbm buffers on a different process. That is,
-      // Linux disallows this and "permission denied" is returned. To overcome
-      // this and make software rasterization working, buffers must be created
-      // on the browser process and gbm_bo_map must be used.
-      // TODO(msisov): add support fir these two buffer usage cases.
-      // https://crbug.com/864914
-      LOG(FATAL) << "This scenario is not supported in Wayland now";
+      flags = GBM_BO_USE_LINEAR;
       break;
     default:
       NOTREACHED() << "Not supported buffer format";
--- a/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h	2019-01-24 15:43:16.316000000 +0300
@@ -15,7 +15,7 @@
 #include "ui/ozone/public/interfaces/wayland/wayland_connection.mojom.h"
 
 #if defined(WAYLAND_GBM)
-#include "ui/ozone/common/linux/gbm_device.h"
+#include "ui/ozone/common/linux/gbm_device.h"  // nogncheck
 #endif
 
 struct wl_shm;
--- a/ui/ozone/platform/wayland/ozone_platform_wayland.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/wayland/ozone_platform_wayland.cc	2019-01-24 15:43:16.316000000 +0300
@@ -10,6 +10,7 @@
 #include "ui/display/manager/fake_display_delegate.h"
 #include "ui/events/ozone/layout/keyboard_layout_engine_manager.h"
 #include "ui/events/system_input_injector.h"
+#include "ui/gfx/linux/client_native_pixmap_dmabuf.h"
 #include "ui/ozone/common/stub_overlay_manager.h"
 #include "ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h"
 #include "ui/ozone/platform/wayland/wayland_connection.h"
@@ -21,7 +22,6 @@
 #include "ui/ozone/public/gpu_platform_support_host.h"
 #include "ui/ozone/public/input_controller.h"
 #include "ui/ozone/public/ozone_platform.h"
-#include "ui/ozone/public/platform_screen.h"
 #include "ui/platform_window/platform_window_init_properties.h"
 
 #if BUILDFLAG(USE_XKBCOMMON)
@@ -42,21 +42,25 @@
 
 namespace {
 
-class OzonePlatformWayland : public OzonePlatform {
- public:
-  OzonePlatformWayland() {
+constexpr OzonePlatform::PlatformProperties kWaylandPlatformProperties = {
+    /*needs_view_token=*/false,
+
     // Supporting server-side decorations requires a support of xdg-decorations.
     // But this protocol has been accepted into the upstream recently, and it
     // will take time before it is taken by compositors. For now, always use
     // custom frames and disallow switching to server-side frames.
     // https://github.com/wayland-project/wayland-protocols/commit/76d1ae8c65739eff3434ef219c58a913ad34e988
-    properties_.custom_frame_pref_default = true;
-    properties_.use_system_title_bar = false;
+    /*custom_frame_pref_default=*/true,
+    /*use_system_title_bar=*/false,
+
     // Ozone/Wayland relies on the mojo communication when running in
     // !single_process.
     // TODO(msisov, rjkroege): Remove after http://crbug.com/806092.
-    properties_.requires_mojo = true;
-  }
+    /*requires_mojo=*/true};
+
+class OzonePlatformWayland : public OzonePlatform {
+ public:
+  OzonePlatformWayland() {}
   ~OzonePlatformWayland() override {}
 
   // OzonePlatform
@@ -114,6 +118,23 @@
     return connection_->wayland_output_manager()->CreateWaylandScreen();
   }
 
+  PlatformClipboard* GetPlatformClipboard() override {
+    DCHECK(connection_);
+    return connection_->GetPlatformClipboard();
+  }
+
+  bool IsNativePixmapConfigSupported(gfx::BufferFormat format,
+                                     gfx::BufferUsage usage) const override {
+    if (std::find(supported_buffer_formats_.begin(),
+                  supported_buffer_formats_.end(),
+                  format) == supported_buffer_formats_.end()) {
+      return false;
+    }
+
+    return gfx::ClientNativePixmapDmaBuf::IsConfigurationSupported(format,
+                                                                   usage);
+  }
+
   void InitializeUI(const InitParams& args) override {
 #if BUILDFLAG(USE_XKBCOMMON)
     KeyboardLayoutEngineManager::SetKeyboardLayoutEngine(
@@ -136,6 +157,7 @@
     overlay_manager_.reset(new StubOverlayManager);
     input_controller_ = CreateStubInputController();
     gpu_platform_support_host_.reset(CreateStubGpuPlatformSupportHost());
+    supported_buffer_formats_ = connection_->GetSupportedBufferFormats();
   }
 
   void InitializeGPU(const InitParams& args) override {
@@ -164,11 +186,7 @@
   }
 
   const PlatformProperties& GetPlatformProperties() override {
-    if (connection_ && properties_.supported_buffer_formats.empty()) {
-      properties_.supported_buffer_formats =
-          connection_->GetSupportedBufferFormats();
-    }
-    return properties_;
+    return kWaylandPlatformProperties;
   }
 
   void AddInterfaces(service_manager::BinderRegistry* registry) override {
@@ -200,7 +218,7 @@
   std::unique_ptr<WaylandConnectionProxy> proxy_;
   std::unique_ptr<WaylandConnectionConnector> connector_;
 
-  PlatformProperties properties_;
+  std::vector<gfx::BufferFormat> supported_buffer_formats_;
 
   DISALLOW_COPY_AND_ASSIGN(OzonePlatformWayland);
 };
--- a/ui/ozone/platform/wayland/wayland_buffer_manager.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_buffer_manager.cc	2019-01-24 15:43:16.316000000 +0300
@@ -77,7 +77,7 @@
                                         const std::vector<uint64_t>& modifiers,
                                         uint32_t planes_count,
                                         uint32_t buffer_id) {
-  TRACE_EVENT2("Wayland", "WaylandBufferManager::CreateZwpLinuxDmabuf",
+  TRACE_EVENT2("wayland", "WaylandBufferManager::CreateZwpLinuxDmabuf",
                "Format", format, "Buffer id", buffer_id);
 
   static const struct zwp_linux_buffer_params_v1_listener params_listener = {
@@ -121,7 +121,7 @@
                                               uint32_t buffer_id,
                                               const gfx::Rect& damage_region,
                                               wl::BufferSwapCallback callback) {
-  TRACE_EVENT1("Wayland", "WaylandBufferManager::ScheduleSwapBuffer",
+  TRACE_EVENT1("wayland", "WaylandBufferManager::ScheduleSwapBuffer",
                "Buffer id", buffer_id);
 
   if (!ValidateDataFromGpu(widget, buffer_id))
@@ -152,7 +152,7 @@
 }
 
 bool WaylandBufferManager::DestroyBuffer(uint32_t buffer_id) {
-  TRACE_EVENT1("Wayland", "WaylandBufferManager::DestroyZwpLinuxDmabuf",
+  TRACE_EVENT1("wayland", "WaylandBufferManager::DestroyZwpLinuxDmabuf",
                "Buffer id", buffer_id);
 
   auto it = buffers_.find(buffer_id);
@@ -181,7 +181,7 @@
 
 // TODO(msisov): handle buffer swap failure or success.
 bool WaylandBufferManager::SwapBuffer(Buffer* buffer) {
-  TRACE_EVENT1("Wayland", "WaylandBufferManager::SwapBuffer", "Buffer id",
+  TRACE_EVENT1("wayland", "WaylandBufferManager::SwapBuffer", "Buffer id",
                buffer->buffer_id);
 
   WaylandWindow* window = connection_->GetWindow(buffer->widget);
@@ -313,7 +313,11 @@
     }
   }
 
-  DCHECK(buffer);
+  // It can happen that buffer was destroyed by a client while the Wayland
+  // compositor was processing a request to create a wl_buffer.
+  if (!buffer)
+    return;
+
   buffer->wl_buffer.reset(new_buffer);
   buffer->params = nullptr;
   zwp_linux_buffer_params_v1_destroy(params);
@@ -328,6 +332,21 @@
       .Run(buffer->swap_result, std::move(buffer->feedback));
 }
 
+void WaylandBufferManager::AddSupportedFourCCFormat(uint32_t fourcc_format) {
+  // Return on not the supported fourcc format.
+  if (!IsValidBufferFormat(fourcc_format))
+    return;
+
+  // It can happen that ::Format or ::Modifiers call can have already added such
+  // a format. Thus, we can ignore that format.
+  gfx::BufferFormat format = GetBufferFormatFromFourCCFormat(fourcc_format);
+  auto it = std::find(supported_buffer_formats_.begin(),
+                      supported_buffer_formats_.end(), format);
+  if (it != supported_buffer_formats_.end())
+    return;
+  supported_buffer_formats_.push_back(format);
+}
+
 // static
 void WaylandBufferManager::Modifiers(
     void* data,
@@ -335,7 +354,9 @@
     uint32_t format,
     uint32_t modifier_hi,
     uint32_t modifier_lo) {
-  NOTIMPLEMENTED();
+  WaylandBufferManager* self = static_cast<WaylandBufferManager*>(data);
+  if (self)
+    self->AddSupportedFourCCFormat(format);
 }
 
 // static
@@ -343,11 +364,8 @@
                                   struct zwp_linux_dmabuf_v1* zwp_linux_dmabuf,
                                   uint32_t format) {
   WaylandBufferManager* self = static_cast<WaylandBufferManager*>(data);
-  // Return on not the supported ARGB format.
-  if (format == DRM_FORMAT_ARGB2101010)
-    return;
-  self->supported_buffer_formats_.push_back(
-      GetBufferFormatFromFourCCFormat(format));
+  if (self)
+    self->AddSupportedFourCCFormat(format);
 }
 
 // static
--- a/ui/ozone/platform/wayland/wayland_buffer_manager.h	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_buffer_manager.h	2019-01-24 15:43:16.316000000 +0300
@@ -151,6 +151,8 @@
 
   void OnBufferSwapped(Buffer* buffer);
 
+  void AddSupportedFourCCFormat(uint32_t fourcc_format);
+
   // zwp_linux_dmabuf_v1_listener
   static void Modifiers(void* data,
                         struct zwp_linux_dmabuf_v1* zwp_linux_dmabuf,
--- a/ui/ozone/platform/wayland/wayland_connection.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_connection.cc	2019-01-24 15:43:16.316000000 +0300
@@ -27,7 +27,7 @@
 
 namespace {
 constexpr uint32_t kMaxCompositorVersion = 4;
-constexpr uint32_t kMaxLinuxDmabufVersion = 1;
+constexpr uint32_t kMaxLinuxDmabufVersion = 3;
 constexpr uint32_t kMaxSeatVersion = 4;
 constexpr uint32_t kMaxShmVersion = 1;
 constexpr uint32_t kMaxXdgShellVersion = 1;
@@ -203,13 +203,13 @@
   }
 }
 
-ClipboardDelegate* WaylandConnection::GetClipboardDelegate() {
+PlatformClipboard* WaylandConnection::GetPlatformClipboard() {
   return this;
 }
 
 void WaylandConnection::OfferClipboardData(
-    const ClipboardDelegate::DataMap& data_map,
-    ClipboardDelegate::OfferDataClosure callback) {
+    const PlatformClipboard::DataMap& data_map,
+    PlatformClipboard::OfferDataClosure callback) {
   if (!data_source_) {
     data_source_ = CreateWaylandDataSource(data_device_manager_.get(), this);
     data_source_->WriteToClipboard(data_map);
@@ -220,8 +220,8 @@
 
 void WaylandConnection::RequestClipboardData(
     const std::string& mime_type,
-    ClipboardDelegate::DataMap* data_map,
-    ClipboardDelegate::RequestDataClosure callback) {
+    PlatformClipboard::DataMap* data_map,
+    PlatformClipboard::RequestDataClosure callback) {
   read_clipboard_closure_ = std::move(callback);
 
   DCHECK(data_map);
@@ -289,7 +289,7 @@
 }
 
 void WaylandConnection::GetAvailableMimeTypes(
-    ClipboardDelegate::GetMimeTypesClosure callback) {
+    PlatformClipboard::GetMimeTypesClosure callback) {
   std::move(callback).Run(data_device_->GetAvailableMimeTypes());
 }
 
--- a/ui/ozone/platform/wayland/wayland_connection.h	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_connection.h	2019-01-24 15:43:16.316000000 +0300
@@ -21,8 +21,8 @@
 #include "ui/ozone/platform/wayland/wayland_output.h"
 #include "ui/ozone/platform/wayland/wayland_pointer.h"
 #include "ui/ozone/platform/wayland/wayland_touch.h"
-#include "ui/ozone/public/clipboard_delegate.h"
 #include "ui/ozone/public/interfaces/wayland/wayland_connection.mojom.h"
+#include "ui/ozone/public/platform_clipboard.h"
 
 namespace ui {
 
@@ -30,8 +30,9 @@
 class WaylandOutputManager;
 class WaylandWindow;
 
+// TODO: factor out PlatformClipboard to a separate class.
 class WaylandConnection : public PlatformEventSource,
-                          public ClipboardDelegate,
+                          public PlatformClipboard,
                           public ozone::mojom::WaylandConnection,
                           public base::MessagePumpLibevent::FdWatcher {
  public:
@@ -105,21 +106,21 @@
   }
 
   // Clipboard implementation.
-  ClipboardDelegate* GetClipboardDelegate();
+  PlatformClipboard* GetPlatformClipboard();
   void DataSourceCancelled();
   void SetClipboardData(const std::string& contents,
                         const std::string& mime_type);
 
-  // ClipboardDelegate.
+  // PlatformClipboard.
   void OfferClipboardData(
-      const ClipboardDelegate::DataMap& data_map,
-      ClipboardDelegate::OfferDataClosure callback) override;
+      const PlatformClipboard::DataMap& data_map,
+      PlatformClipboard::OfferDataClosure callback) override;
   void RequestClipboardData(
       const std::string& mime_type,
-      ClipboardDelegate::DataMap* data_map,
-      ClipboardDelegate::RequestDataClosure callback) override;
+      PlatformClipboard::DataMap* data_map,
+      PlatformClipboard::RequestDataClosure callback) override;
   void GetAvailableMimeTypes(
-      ClipboardDelegate::GetMimeTypesClosure callback) override;
+      PlatformClipboard::GetMimeTypesClosure callback) override;
   bool IsSelectionOwner() override;
 
   // Returns bound pointer to own mojo interface.
@@ -222,7 +223,7 @@
 
   // Holds a temporary instance of the client's clipboard content
   // so that we can asynchronously write to it.
-  ClipboardDelegate::DataMap* data_map_ = nullptr;
+  PlatformClipboard::DataMap* data_map_ = nullptr;
 
   // Stores the callback to be invoked upon data reading from clipboard.
   RequestDataClosure read_clipboard_closure_;
--- a/ui/ozone/platform/wayland/wayland_data_device_unittest.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_data_device_unittest.cc	2019-01-24 15:43:16.320000000 +0300
@@ -10,23 +10,23 @@
 #include "ui/events/base_event_utils.h"
 #include "ui/ozone/platform/wayland/fake_server.h"
 #include "ui/ozone/platform/wayland/wayland_test.h"
-#include "ui/ozone/public/clipboard_delegate.h"
+#include "ui/ozone/public/platform_clipboard.h"
 
 namespace ui {
 
 // This class mocks how a real clipboard/ozone client would
-// hook to ClipboardDelegate, with one difference: real clients
+// hook to PlatformClipboard, with one difference: real clients
 // have no access to the WaylandConnection instance like this
 // MockClipboardClient impl does. Instead, clients and ozone gets
 // plumbbed up by calling the appropriated Ozone API,
-// OzonePlatform::GetClipboardDelegate.
+// OzonePlatform::GetPlatformClipboard.
 class MockClipboardClient {
  public:
   MockClipboardClient(WaylandConnection* connection) {
     DCHECK(connection);
     // See comment above for reasoning to access the WaylandConnection
     // directly from here.
-    delegate_ = connection->GetClipboardDelegate();
+    delegate_ = connection->GetPlatformClipboard();
 
     DCHECK(delegate_);
   }
@@ -35,7 +35,7 @@
   // Fill the clipboard backing store with sample data.
   void SetData(const std::string& utf8_text,
                const std::string& mime_type,
-               ClipboardDelegate::OfferDataClosure callback) {
+               PlatformClipboard::OfferDataClosure callback) {
     // This mimics how Mus' ClipboardImpl writes data to the DataMap.
     std::vector<char> object_map(utf8_text.begin(), utf8_text.end());
     char* object_data = &object_map.front();
@@ -46,7 +46,7 @@
   }
 
   void ReadData(const std::string& mime_type,
-                ClipboardDelegate::RequestDataClosure callback) {
+                PlatformClipboard::RequestDataClosure callback) {
     delegate_->RequestClipboardData(mime_type, &data_types_,
                                     std::move(callback));
   }
@@ -54,8 +54,8 @@
   bool IsSelectionOwner() { return delegate_->IsSelectionOwner(); }
 
  private:
-  ClipboardDelegate* delegate_ = nullptr;
-  ClipboardDelegate::DataMap data_types_;
+  PlatformClipboard* delegate_ = nullptr;
+  PlatformClipboard::DataMap data_types_;
 
   DISALLOW_COPY_AND_ASSIGN(MockClipboardClient);
 };
--- a/ui/ozone/platform/wayland/wayland_data_source.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_data_source.cc	2019-01-24 15:43:16.320000000 +0300
@@ -27,7 +27,7 @@
 WaylandDataSource::~WaylandDataSource() = default;
 
 void WaylandDataSource::WriteToClipboard(
-    const ClipboardDelegate::DataMap& data_map) {
+    const PlatformClipboard::DataMap& data_map) {
   for (const auto& data : data_map) {
     wl_data_source_offer(data_source_.get(), data.first.c_str());
     if (strcmp(data.first.c_str(), kTextMimeType) == 0)
@@ -40,7 +40,7 @@
 }
 
 void WaylandDataSource::UpdataDataMap(
-    const ClipboardDelegate::DataMap& data_map) {
+    const PlatformClipboard::DataMap& data_map) {
   data_map_ = data_map;
 }
 
--- a/ui/ozone/platform/wayland/wayland_data_source.h	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_data_source.h	2019-01-24 15:43:16.320000000 +0300
@@ -15,7 +15,7 @@
 #include "base/macros.h"
 #include "base/optional.h"
 #include "ui/ozone/platform/wayland/wayland_object.h"
-#include "ui/ozone/public/clipboard_delegate.h"
+#include "ui/ozone/public/platform_clipboard.h"
 
 namespace ui {
 
@@ -42,8 +42,8 @@
     connection_ = connection;
   }
 
-  void WriteToClipboard(const ClipboardDelegate::DataMap& data_map);
-  void UpdataDataMap(const ClipboardDelegate::DataMap& data_map);
+  void WriteToClipboard(const PlatformClipboard::DataMap& data_map);
+  void UpdataDataMap(const PlatformClipboard::DataMap& data_map);
   void Offer(const ui::OSExchangeData& data);
   void SetAction(int operation);
   void SetDragData(const DragDataMap& data_map);
@@ -71,7 +71,7 @@
   WaylandConnection* connection_ = nullptr;
   WaylandWindow* source_window_ = nullptr;
 
-  ClipboardDelegate::DataMap data_map_;
+  PlatformClipboard::DataMap data_map_;
   DragDataMap drag_data_map_;
   // Action selected by the compositor
   uint32_t dnd_action_;
--- a/ui/ozone/platform/wayland/wayland_surface_factory.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_surface_factory.cc	2019-01-24 15:43:16.324000000 +0300
@@ -11,6 +11,7 @@
 #include "base/memory/ptr_util.h"
 #include "base/memory/shared_memory.h"
 #include "third_party/skia/include/core/SkSurface.h"
+#include "ui/gfx/linux/client_native_pixmap_dmabuf.h"
 #include "ui/gfx/vsync_provider.h"
 #include "ui/ozone/common/egl_util.h"
 #include "ui/ozone/common/gl_ozone_egl.h"
--- a/ui/ozone/platform/wayland/wayland_window.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_window.cc	2019-01-24 15:43:16.324000000 +0300
@@ -8,6 +8,7 @@
 
 #include "base/bind.h"
 #include "ui/base/cursor/ozone/bitmap_cursor_factory_ozone.h"
+#include "ui/base/dragdrop/drag_drop_types.h"
 #include "ui/base/dragdrop/os_exchange_data.h"
 #include "ui/base/hit_test.h"
 #include "ui/events/event.h"
@@ -74,13 +75,22 @@
     : delegate_(delegate),
       connection_(connection),
       xdg_shell_objects_factory_(new XDGShellObjectFactory()),
-      state_(PlatformWindowState::PLATFORM_WINDOW_STATE_NORMAL) {
+      state_(PlatformWindowState::PLATFORM_WINDOW_STATE_NORMAL),
+      pending_state_(PlatformWindowState::PLATFORM_WINDOW_STATE_UNKNOWN) {
   // Set a class property key, which allows |this| to be used for interactive
   // events, e.g. move or resize.
   SetWmMoveResizeHandler(this, AsWmMoveResizeHandler());
+
+  // Set a class property key, which allows |this| to be used for drag action.
+  SetWmDragHandler(this, this);
 }
 
 WaylandWindow::~WaylandWindow() {
+  if (drag_closed_callback_) {
+    std::move(drag_closed_callback_)
+        .Run(DragDropTypes::DragOperation::DRAG_NONE);
+  }
+
   PlatformEventSource::GetInstance()->RemovePlatformEventDispatcher(this);
   connection_->RemoveWindow(surface_.id());
 
@@ -215,6 +225,15 @@
   connection_->ScheduleFlush();
 }
 
+void WaylandWindow::StartDrag(const ui::OSExchangeData& data,
+                              int operation,
+                              gfx::NativeCursor cursor,
+                              base::OnceCallback<void(int)> callback) {
+  DCHECK(!drag_closed_callback_);
+  drag_closed_callback_ = std::move(callback);
+  connection_->StartDrag(data, operation);
+}
+
 void WaylandWindow::Show() {
   if (!is_tooltip_)  // Tooltip windows should not get keyboard focus
     set_keyboard_focus(true);
@@ -296,6 +315,17 @@
 void WaylandWindow::ToggleFullscreen() {
   DCHECK(xdg_surface_);
 
+  // There are some cases, when Chromium triggers a fullscreen state change
+  // before the surface is activated. In such cases, Wayland may ignore state
+  // changes and such flags as --kiosk or --start-fullscreen will be ignored.
+  // To overcome this, set a pending state, and once the surface is activated,
+  // trigger the change.
+  if (!is_active_) {
+    DCHECK(!IsFullscreen());
+    pending_state_ = PlatformWindowState::PLATFORM_WINDOW_STATE_FULLSCREEN;
+    return;
+  }
+
   // TODO(msisov, tonikitoo): add multiscreen support. As the documentation says
   // if xdg_surface_set_fullscreen() is not provided with wl_output, it's up to
   // the compositor to choose which display will be used to map this surface.
@@ -468,7 +498,7 @@
 
   // Ensure that manually handled state changes to fullscreen correspond to the
   // configuration events from a compositor.
-  DCHECK(is_fullscreen == IsFullscreen());
+  DCHECK_EQ(is_fullscreen, IsFullscreen());
 
   // There are two cases, which must be handled for the minimized state.
   // The first one is the case, when the surface goes into the minimized state
@@ -525,6 +555,8 @@
 
   if (did_active_change)
     delegate_->OnActivationChanged(is_active_);
+
+  MaybeTriggerPendingStateChange();
 }
 
 void WaylandWindow::OnCloseRequest() {
@@ -556,7 +588,7 @@
 }
 
 void WaylandWindow::OnDragSessionClose(uint32_t dnd_action) {
-  NOTIMPLEMENTED_LOG_ONCE();
+  std::move(drag_closed_callback_).Run(dnd_action);
 }
 
 bool WaylandWindow::IsMinimized() const {
@@ -571,6 +603,16 @@
   return state_ == PlatformWindowState::PLATFORM_WINDOW_STATE_FULLSCREEN;
 }
 
+void WaylandWindow::MaybeTriggerPendingStateChange() {
+  if (pending_state_ == PlatformWindowState::PLATFORM_WINDOW_STATE_UNKNOWN ||
+      !is_active_)
+    return;
+  DCHECK_EQ(pending_state_,
+            PlatformWindowState::PLATFORM_WINDOW_STATE_FULLSCREEN);
+  pending_state_ = PlatformWindowState::PLATFORM_WINDOW_STATE_UNKNOWN;
+  ToggleFullscreen();
+}
+
 WaylandWindow* WaylandWindow::GetParentWindow(
     gfx::AcceleratedWidget parent_widget) {
   WaylandWindow* parent_window = connection_->GetWindow(parent_widget);
--- a/ui/ozone/platform/wayland/wayland_window.h	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_window.h	2019-01-24 15:43:16.324000000 +0300
@@ -5,6 +5,7 @@
 #ifndef UI_OZONE_PLATFORM_WAYLAND_WAYLAND_WINDOW_H_
 #define UI_OZONE_PLATFORM_WAYLAND_WAYLAND_WINDOW_H_
 
+#include "base/callback.h"
 #include "base/memory/ref_counted.h"
 #include "ui/events/platform/platform_event_dispatcher.h"
 #include "ui/gfx/geometry/rect.h"
@@ -12,6 +13,7 @@
 #include "ui/ozone/platform/wayland/wayland_object.h"
 #include "ui/platform_window/platform_window.h"
 #include "ui/platform_window/platform_window_delegate.h"
+#include "ui/platform_window/platform_window_handler/wm_drag_handler.h"
 #include "ui/platform_window/platform_window_handler/wm_move_resize_handler.h"
 
 namespace gfx {
@@ -35,7 +37,8 @@
 
 class WaylandWindow : public PlatformWindow,
                       public PlatformEventDispatcher,
-                      public WmMoveResizeHandler {
+                      public WmMoveResizeHandler,
+                      public WmDragHandler {
  public:
   WaylandWindow(PlatformWindowDelegate* delegate,
                 WaylandConnection* connection);
@@ -81,6 +84,12 @@
       int hittest,
       const gfx::Point& pointer_location) override;
 
+  // WmDragHandler
+  void StartDrag(const ui::OSExchangeData& data,
+                 int operation,
+                 gfx::NativeCursor cursor,
+                 base::OnceCallback<void(int)> callback) override;
+
   // PlatformWindow
   void Show() override;
   void Hide() override;
@@ -129,6 +138,8 @@
   bool IsMaximized() const;
   bool IsFullscreen() const;
 
+  void MaybeTriggerPendingStateChange();
+
   // Creates a popup window, which is visible as a menu window.
   void CreateXdgPopup();
   // Creates a surface window, which is visible as a main window.
@@ -160,6 +171,8 @@
   // The current cursor bitmap (immutable).
   scoped_refptr<BitmapCursorOzone> bitmap_;
 
+  base::OnceCallback<void(int)> drag_closed_callback_;
+
   gfx::Rect bounds_;
   gfx::Rect pending_bounds_;
   // The bounds of our window before we were maximized or fullscreen.
@@ -171,6 +184,9 @@
 
   // Stores current states of the window.
   ui::PlatformWindowState state_;
+  // Stores a pending state of the window, which is used before the surface is
+  // activated.
+  ui::PlatformWindowState pending_state_;
 
   bool is_active_ = false;
   bool is_minimizing_ = false;
--- a/ui/ozone/platform/wayland/wayland_window_unittest.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/platform/wayland/wayland_window_unittest.cc	2019-01-24 15:43:16.324000000 +0300
@@ -219,6 +219,8 @@
   EXPECT_EQ(PLATFORM_WINDOW_STATE_NORMAL, window_->GetPlatformWindowState());
 
   ScopedWlArray states = InitializeWlArrayWithActivatedState();
+  SendConfigureEvent(0, 0, 1, states.get());
+  Sync();
 
   AddStateToWlArray(XDG_SURFACE_STATE_FULLSCREEN, states.get());
 
@@ -230,7 +232,7 @@
   // comment in the WaylandWindow::ToggleFullscreen.
   EXPECT_EQ(window_->GetPlatformWindowState(),
             PLATFORM_WINDOW_STATE_FULLSCREEN);
-  SendConfigureEvent(0, 0, 1, states.get());
+  SendConfigureEvent(0, 0, 2, states.get());
   Sync();
 
   EXPECT_CALL(*GetXdgSurface(), UnsetFullscreen());
@@ -240,7 +242,45 @@
   EXPECT_EQ(window_->GetPlatformWindowState(), PLATFORM_WINDOW_STATE_UNKNOWN);
   // Reinitialize wl_array, which removes previous old states.
   states = InitializeWlArrayWithActivatedState();
+  SendConfigureEvent(0, 0, 3, states.get());
+  Sync();
+}
+
+TEST_P(WaylandWindowTest, StartWithFullscreen) {
+  // Make sure the window is initialized to normal state from the beginning.
+  EXPECT_EQ(PLATFORM_WINDOW_STATE_NORMAL, window_->GetPlatformWindowState());
+
+  // The state must not be changed to the fullscreen before the surface is
+  // activated.
+  EXPECT_CALL(*GetXdgSurface(), SetFullscreen()).Times(0);
+  EXPECT_CALL(delegate_, OnWindowStateChanged(_)).Times(0);
+  window_->ToggleFullscreen();
+  // The state of the window must still be a normal one.
+  EXPECT_EQ(window_->GetPlatformWindowState(), PLATFORM_WINDOW_STATE_NORMAL);
+
+  Sync();
+
+  // Once the surface will be activated, the window will automatically trigger
+  // the state change.
+  EXPECT_CALL(*GetXdgSurface(), SetFullscreen());
+  EXPECT_CALL(delegate_,
+              OnWindowStateChanged(Eq(PLATFORM_WINDOW_STATE_FULLSCREEN)));
+
+  // Activate the surface.
+  ScopedWlArray states = InitializeWlArrayWithActivatedState();
+  SendConfigureEvent(0, 0, 1, states.get());
+
+  Sync();
+
+  // The wayland window manually handles the fullscreen state changes, and it
+  // must change to a fullscreen before the state change is confirmed by the
+  // wayland. See comment in the WaylandWindow::ToggleFullscreen.
+  EXPECT_EQ(window_->GetPlatformWindowState(),
+            PLATFORM_WINDOW_STATE_FULLSCREEN);
+
+  AddStateToWlArray(XDG_SURFACE_STATE_FULLSCREEN, states.get());
   SendConfigureEvent(0, 0, 2, states.get());
+
   Sync();
 }
 
@@ -314,6 +354,8 @@
   const gfx::Rect current_bounds = window_->GetBounds();
 
   ScopedWlArray states = InitializeWlArrayWithActivatedState();
+  SendConfigureEvent(0, 0, 1, states.get());
+  Sync();
 
   gfx::Rect restored_bounds = window_->GetRestoredBoundsInPixels();
   EXPECT_EQ(restored_bounds, gfx::Rect());
@@ -323,7 +365,7 @@
   EXPECT_CALL(delegate_, OnBoundsChanged(Eq(fullscreen_bounds)));
   window_->ToggleFullscreen();
   AddStateToWlArray(XDG_SURFACE_STATE_FULLSCREEN, states.get());
-  SendConfigureEvent(fullscreen_bounds.width(), fullscreen_bounds.height(), 1,
+  SendConfigureEvent(fullscreen_bounds.width(), fullscreen_bounds.height(), 2,
                      states.get());
   Sync();
   restored_bounds = window_->GetRestoredBoundsInPixels();
@@ -338,7 +380,7 @@
   window_->Restore();
   // Reinitialize wl_array, which removes previous old states.
   states = InitializeWlArrayWithActivatedState();
-  SendConfigureEvent(0, 0, 2, states.get());
+  SendConfigureEvent(0, 0, 3, states.get());
   Sync();
   bounds = window_->GetBounds();
   EXPECT_EQ(bounds, restored_bounds);
--- a/ui/ozone/public/ozone_platform.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/public/ozone_platform.cc	2019-01-24 15:43:16.336000000 +0300
@@ -35,25 +35,6 @@
 
 }  // namespace
 
-OzonePlatform::PlatformProperties::PlatformProperties() = default;
-
-OzonePlatform::PlatformProperties::PlatformProperties(
-    bool needs_request,
-    bool custom_frame_default,
-    bool can_use_system_title_bar,
-    bool requires_mojo_for_ipc,
-    std::vector<gfx::BufferFormat> buffer_formats)
-    : needs_view_owner_request(needs_request),
-      custom_frame_pref_default(custom_frame_default),
-      use_system_title_bar(can_use_system_title_bar),
-      requires_mojo(requires_mojo_for_ipc),
-      supported_buffer_formats(buffer_formats) {}
-
-OzonePlatform::PlatformProperties::~PlatformProperties() = default;
-
-OzonePlatform::PlatformProperties::PlatformProperties(
-    const PlatformProperties& other) = default;
-
 OzonePlatform::OzonePlatform() {
   GetOzoneInstanceLock().AssertAcquired();
   DCHECK(!g_instance) << "There should only be a single OzonePlatform.";
@@ -141,6 +122,18 @@
   return nullptr;
 }
 
+PlatformClipboard* OzonePlatform::GetPlatformClipboard() {
+  // Platforms that support system clipboard must override this method.
+  return nullptr;
+}
+
+bool OzonePlatform::IsNativePixmapConfigSupported(
+    gfx::BufferFormat format,
+    gfx::BufferUsage usage) const {
+  // Platform that support NativePixmap must override this method.
+  return false;
+}
+
 const OzonePlatform::PlatformProperties&
 OzonePlatform::GetPlatformProperties() {
   static const base::NoDestructor<OzonePlatform::PlatformProperties> properties;
--- a/ui/ozone/public/ozone_platform.h	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/ozone/public/ozone_platform.h	2019-01-24 15:43:16.336000000 +0300
@@ -40,6 +40,7 @@
 class PlatformWindowDelegate;
 class SurfaceFactoryOzone;
 class SystemInputInjector;
+class PlatformClipboard;
 
 struct PlatformWindowInitProperties;
 
@@ -87,19 +88,9 @@
 
   // Struct used to indicate platform properties.
   struct PlatformProperties {
-    PlatformProperties();
-    PlatformProperties(bool needs_request,
-                       bool custom_frame_default,
-                       bool can_use_system_title_bar,
-                       bool requires_mojo_for_ipc,
-                       std::vector<gfx::BufferFormat> buffer_formats);
-    ~PlatformProperties();
-    PlatformProperties(const PlatformProperties& other);
-
-    // Fuchsia only: set to true when the platforms requires
-    // |view_owner_request| field in PlatformWindowInitProperties when creating
-    // a window.
-    bool needs_view_owner_request = false;
+    // Fuchsia only: set to true when the platforms requires |view_token| field
+    // in PlatformWindowInitProperties when creating a window.
+    bool needs_view_token = false;
 
     // Determine whether we should default to native decorations or the custom
     // frame based on the currently-running window manager.
@@ -112,9 +103,6 @@
     // Determines if the platform requires mojo communication for the IPC.
     // Currently used only by the Ozone/Wayland platform.
     bool requires_mojo = false;
-
-    // Wayland only: carries buffer formats supported by a Wayland server.
-    std::vector<gfx::BufferFormat> supported_buffer_formats;
   };
 
   using StartupCallback = base::OnceCallback<void(OzonePlatform*)>;
@@ -161,6 +149,11 @@
   virtual std::unique_ptr<display::NativeDisplayDelegate>
   CreateNativeDisplayDelegate() = 0;
   virtual std::unique_ptr<PlatformScreen> CreateScreen();
+  virtual PlatformClipboard* GetPlatformClipboard();
+
+  // Returns true if the specified buffer format is supported.
+  virtual bool IsNativePixmapConfigSupported(gfx::BufferFormat format,
+                                             gfx::BufferUsage usage) const;
 
   // Returns a struct that contains configuration and requirements for the
   // current platform implementation.
--- a/ui/platform_window/platform_window_handler/BUILD.gn	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/platform_window/platform_window_handler/BUILD.gn	2019-01-24 15:43:16.344000000 +0300
@@ -8,6 +8,8 @@
   output_name = "platform_window_handler_libs"
 
   sources = [
+    "wm_drag_handler.cc",
+    "wm_drag_handler.h",
     "wm_move_resize_handler.cc",
     "wm_move_resize_handler.h",
     "wm_platform_export.h",
--- a/ui/views/BUILD.gn	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/views/BUILD.gn	2019-01-24 15:43:20.088000000 +0300
@@ -490,6 +490,7 @@
     "//skia",
     "//third_party/icu",
     "//ui/accessibility",
+    "//ui/base/clipboard",
     "//ui/display",
     "//ui/native_theme",
     "//ui/native_theme:native_theme_browser",
@@ -505,6 +506,7 @@
     "//components/vector_icons",
     "//ui/accessibility:ax_enums_mojo",
     "//ui/base",
+    "//ui/base/clipboard",
     "//ui/base/ime",
     "//ui/compositor",
     "//ui/display",
@@ -715,8 +717,12 @@
         ]
         deps += [ "//ui/events:dom_keyboard_layout" ]
       } else if (use_ozone) {
-        public += [ "widget/desktop_aura/desktop_screen_ozone.h" ]
-        sources += [ "widget/desktop_aura/desktop_screen_ozone.cc" ]
+        sources += [
+          "widget/desktop_aura/desktop_drag_drop_client_ozone.cc",
+          "widget/desktop_aura/desktop_drag_drop_client_ozone.h",
+          "widget/desktop_aura/desktop_screen_ozone.cc",
+          "widget/desktop_aura/desktop_screen_ozone.h",
+        ]
       }
       if (is_linux) {
         sources += [
@@ -864,6 +870,7 @@
     "//testing/gtest",
     "//ui/base",
     "//ui/base:test_support",
+    "//ui/base/clipboard:clipboard_test_support",
     "//ui/base/ime",
     "//ui/compositor",
     "//ui/compositor:test_support",
@@ -1045,6 +1052,7 @@
     "//ui/accessibility",
     "//ui/base",
     "//ui/base:test_support",
+    "//ui/base/clipboard",
     "//ui/base/ime",
     "//ui/compositor:test_support",
     "//ui/events:dom_keycode_converter",
@@ -1168,8 +1176,10 @@
   }
 
   if (is_linux && !is_chromeos && !use_x11) {
-    sources +=
-        [ "widget/desktop_aura/desktop_window_tree_host_platform_unittest.cc" ]
+    sources += [
+      "widget/desktop_aura/desktop_drag_drop_client_ozone_unittest.cc",
+      "widget/desktop_aura/desktop_window_tree_host_platform_unittest.cc",
+    ]
   }
 
   if (!is_chromeos) {
@@ -1180,6 +1190,7 @@
     ":test_support",
     ":views_unittests_sources",
     "//mojo/core/embedder",
+    "//ui/platform_window/platform_window_handler",
   ]
 }
 
--- a/ui/views/cocoa/drag_drop_client_mac_unittest.mm	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/views/cocoa/drag_drop_client_mac_unittest.mm	2019-01-24 15:43:20.728000000 +0300
@@ -130,7 +130,7 @@
   // View:
   bool GetDropFormats(
       int* formats,
-      std::set<ui::Clipboard::FormatType>* format_types) override {
+      std::set<ui::ClipboardFormatType>* format_types) override {
     *formats |= formats_;
     return true;
   }
--- a/ui/views/controls/menu/menu_controller.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/views/controls/menu/menu_controller.cc	2019-01-24 15:43:20.740000000 +0300
@@ -921,7 +921,7 @@
 bool MenuController::GetDropFormats(
     SubmenuView* source,
     int* formats,
-    std::set<ui::Clipboard::FormatType>* format_types) {
+    std::set<ui::ClipboardFormatType>* format_types) {
   return source->GetMenuItem()->GetDelegate()->GetDropFormats(
       source->GetMenuItem(), formats, format_types);
 }
--- a/ui/views/controls/menu/menu_controller.h	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/views/controls/menu/menu_controller.h	2019-01-24 15:43:20.740000000 +0300
@@ -163,7 +163,7 @@
 
   bool GetDropFormats(SubmenuView* source,
                       int* formats,
-                      std::set<ui::Clipboard::FormatType>* format_types);
+                      std::set<ui::ClipboardFormatType>* format_types);
   bool AreDropTypesRequired(SubmenuView* source);
   bool CanDrop(SubmenuView* source, const ui::OSExchangeData& data);
   void OnDragEntered(SubmenuView* source, const ui::DropTargetEvent& event);
--- a/ui/views/controls/menu/menu_delegate.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/views/controls/menu/menu_delegate.cc	2019-01-24 15:43:21.076000000 +0300
@@ -81,7 +81,7 @@
 bool MenuDelegate::GetDropFormats(
     MenuItemView* menu,
     int* formats,
-    std::set<ui::Clipboard::FormatType>* format_types) {
+    std::set<ui::ClipboardFormatType>* format_types) {
   return false;
 }
 
--- a/ui/views/controls/menu/menu_delegate.h	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/views/controls/menu/menu_delegate.h	2019-01-24 15:43:21.076000000 +0300
@@ -150,10 +150,9 @@
   virtual bool CanDrop(MenuItemView* menu, const OSExchangeData& data);
 
   // See view for a description of this method.
-  virtual bool GetDropFormats(
-      MenuItemView* menu,
+  virtual bool GetDropFormats(MenuItemView* menu,
       int* formats,
-      std::set<ui::Clipboard::FormatType>* format_types);
+                              std::set<ui::ClipboardFormatType>* format_types);
 
   // See view for a description of this method.
   virtual bool AreDropTypesRequired(MenuItemView* menu);
--- a/ui/views/controls/menu/submenu_view.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/views/controls/menu/submenu_view.cc	2019-01-24 15:43:21.572000000 +0300
@@ -241,7 +241,7 @@
 
 bool SubmenuView::GetDropFormats(
     int* formats,
-    std::set<ui::Clipboard::FormatType>* format_types) {
+    std::set<ui::ClipboardFormatType>* format_types) {
   DCHECK(GetMenuItem()->GetMenuController());
   return GetMenuItem()->GetMenuController()->GetDropFormats(this, formats,
                                                             format_types);
--- a/ui/views/controls/menu/submenu_view.h	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/views/controls/menu/submenu_view.h	2019-01-24 15:43:21.572000000 +0300
@@ -78,9 +78,8 @@
   void PaintChildren(const PaintInfo& paint_info) override;
 
   // Drag and drop methods. These are forwarded to the MenuController.
-  bool GetDropFormats(
-      int* formats,
-      std::set<ui::Clipboard::FormatType>* format_types) override;
+  bool GetDropFormats(int* formats,
+                      std::set<ui::ClipboardFormatType>* format_types) override;
   bool AreDropTypesRequired() override;
   bool CanDrop(const OSExchangeData& data) override;
   void OnDragEntered(const ui::DropTargetEvent& event) override;
--- a/ui/views/controls/textfield/textfield.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/views/controls/textfield/textfield.cc	2019-01-24 15:43:23.236000000 +0300
@@ -914,7 +914,7 @@
 
 bool Textfield::GetDropFormats(
     int* formats,
-    std::set<ui::Clipboard::FormatType>* format_types) {
+    std::set<ui::ClipboardFormatType>* format_types) {
   if (!enabled() || read_only())
     return false;
   // TODO(msw): Can we support URL, FILENAME, etc.?
@@ -926,7 +926,7 @@
 
 bool Textfield::CanDrop(const OSExchangeData& data) {
   int formats;
-  std::set<ui::Clipboard::FormatType> format_types;
+  std::set<ui::ClipboardFormatType> format_types;
   GetDropFormats(&formats, &format_types);
   return enabled() && !read_only() && data.HasAnyFormat(formats, format_types);
 }
--- a/ui/views/controls/textfield/textfield_controller.h	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/views/controls/textfield/textfield_controller.h	2019-01-24 15:43:23.236000000 +0300
@@ -8,6 +8,7 @@
 #include <set>
 
 #include "base/strings/string16.h"
+#include "ui/base/clipboard/clipboard_types.h"
 #include "ui/base/dragdrop/os_exchange_data.h"
 #include "ui/views/views_export.h"
 
@@ -76,7 +77,7 @@
   // Enables the controller to append to the accepted drop formats.
   virtual void AppendDropFormats(
       int* formats,
-      std::set<ui::Clipboard::FormatType>* format_types) {}
+      std::set<ui::ClipboardFormatType>* format_types) {}
 
   // Called when a drop of dragged data happens on the textfield. This method is
   // called before regular handling of the drop. If this returns a drag
--- a/ui/views/controls/textfield/textfield.h	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/views/controls/textfield/textfield.h	2019-01-24 15:43:23.236000000 +0300
@@ -264,9 +264,8 @@
   bool CanHandleAccelerators() const override;
   void AboutToRequestFocusFromTabTraversal(bool reverse) override;
   bool SkipDefaultKeyEventProcessing(const ui::KeyEvent& event) override;
-  bool GetDropFormats(
-      int* formats,
-      std::set<ui::Clipboard::FormatType>* format_types) override;
+  bool GetDropFormats(int* formats,
+                      std::set<ui::ClipboardFormatType>* format_types) override;
   bool CanDrop(const ui::OSExchangeData& data) override;
   int OnDragUpdated(const ui::DropTargetEvent& event) override;
   void OnDragExited() override;
--- a/ui/views/controls/textfield/textfield_unittest.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/views/controls/textfield/textfield_unittest.cc	2019-01-24 15:43:23.240000000 +0300
@@ -1704,7 +1704,7 @@
   base::string16 string(ASCIIToUTF16("string "));
   data.SetString(string);
   int formats = 0;
-  std::set<ui::Clipboard::FormatType> format_types;
+  std::set<ui::ClipboardFormatType> format_types;
 
   // Ensure that disabled textfields do not accept drops.
   textfield_->SetEnabled(false);
@@ -1738,7 +1738,7 @@
   // Ensure that textfields do not accept non-OSExchangeData::STRING types.
   ui::OSExchangeData bad_data;
   bad_data.SetFilename(base::FilePath(FILE_PATH_LITERAL("x")));
-  ui::Clipboard::FormatType fmt = ui::Clipboard::GetBitmapFormatType();
+  ui::ClipboardFormatType fmt = ui::GetBitmapClipboardFormatType();
   bad_data.SetPickledData(fmt, base::Pickle());
   bad_data.SetFileContents(base::FilePath(L"x"), "x");
   bad_data.SetHtml(base::string16(ASCIIToUTF16("x")), GURL("x.org"));
@@ -1802,7 +1802,7 @@
   ui::OSExchangeData data;
   int formats = 0;
   int operations = 0;
-  std::set<ui::Clipboard::FormatType> format_types;
+  std::set<ui::ClipboardFormatType> format_types;
 
   // Start dragging "ello".
   textfield_->SelectRange(gfx::Range(1, 5));
@@ -1853,7 +1853,7 @@
   ui::OSExchangeData data;
   int formats = 0;
   int operations = 0;
-  std::set<ui::Clipboard::FormatType> format_types;
+  std::set<ui::ClipboardFormatType> format_types;
 
   // Start dragging " worl".
   textfield_->SelectRange(gfx::Range(5, 10));
--- a/ui/views/mus/drag_interactive_uitest.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/views/mus/drag_interactive_uitest.cc	2019-01-24 15:43:26.868000000 +0300
@@ -60,7 +60,7 @@
   // views::View overrides:
   bool GetDropFormats(
       int* formats,
-      std::set<ui::Clipboard::FormatType>* format_types) override {
+      std::set<ui::ClipboardFormatType>* format_types) override {
     *formats = ui::OSExchangeData::STRING;
     return true;
   }
--- a/ui/views/test/scoped_views_test_helper.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/views/test/scoped_views_test_helper.cc	2019-01-24 15:43:27.436000000 +0300
@@ -8,8 +8,8 @@
 
 #include "base/memory/ptr_util.h"
 #include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/test/test_clipboard.h"
 #include "ui/base/ime/input_method_initializer.h"
-#include "ui/base/test/test_clipboard.h"
 #include "ui/views/test/platform_test_helper.h"
 #include "ui/views/test/test_views_delegate.h"
 #include "ui/views/test/views_test_helper.h"
--- a/ui/views/view.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/views/view.cc	2019-01-24 15:43:27.456000000 +0300
@@ -1377,7 +1377,7 @@
 // Drag and drop ---------------------------------------------------------------
 
 bool View::GetDropFormats(int* formats,
-                          std::set<ui::Clipboard::FormatType>* format_types) {
+                          std::set<ui::ClipboardFormatType>* format_types) {
   return false;
 }
 
--- a/ui/views/view.h	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/views/view.h	2019-01-24 15:43:27.464000000 +0300
@@ -23,6 +23,7 @@
 #include "ui/accessibility/ax_enums.mojom.h"
 #include "ui/base/accelerators/accelerator.h"
 #include "ui/base/class_property.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/dragdrop/drag_drop_types.h"
 #include "ui/base/dragdrop/drop_target_event.h"
 #include "ui/base/dragdrop/os_exchange_data.h"
@@ -1064,9 +1065,8 @@
   // |formats| is a bitmask of the formats defined bye OSExchangeData::Format.
   // The default implementation returns false, which means the view doesn't
   // support dropping.
-  virtual bool GetDropFormats(
-      int* formats,
-      std::set<ui::Clipboard::FormatType>* format_types);
+  virtual bool GetDropFormats(int* formats,
+                              std::set<ui::ClipboardFormatType>* format_types);
 
   // Override and return true if the data must be available before any drop
   // methods should be invoked. The default is false.
--- a/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.cc	2019-01-24 15:43:28.476000000 +0300
@@ -14,6 +14,7 @@
 #include "ui/platform_window/platform_window_handler/wm_move_resize_handler.h"
 #include "ui/platform_window/platform_window_init_properties.h"
 #include "ui/views/corewm/tooltip_aura.h"
+#include "ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone.h"
 #include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
 #include "ui/views/widget/desktop_aura/window_event_filter.h"
 #include "ui/views/widget/widget_aura_utils.h"
@@ -121,9 +122,9 @@
 std::unique_ptr<aura::client::DragDropClient>
 DesktopWindowTreeHostPlatform::CreateDragDropClient(
     DesktopNativeCursorManager* cursor_manager) {
-  // TODO: needs PlatformWindow support.
-  NOTIMPLEMENTED_LOG_ONCE();
-  return nullptr;
+  ui::WmDragHandler* drag_handler = ui::GetWmDragHandler(*(platform_window()));
+  return std::make_unique<DesktopDragDropClientOzone>(window(), cursor_manager,
+                                                      drag_handler);
 }
 
 void DesktopWindowTreeHostPlatform::Close() {
--- a/ui/views/widget/drop_helper.cc	2018-12-13 00:56:28.000000000 +0300
+++ b/ui/views/widget/drop_helper.cc	2019-01-24 15:43:28.488000000 +0300
@@ -102,7 +102,7 @@
   }
 #else
   int formats = 0;
-  std::set<ui::Clipboard::FormatType> format_types;
+  std::set<ui::ClipboardFormatType> format_types;
   while (view && view != target_view_) {
     if (view->enabled() &&
         view->GetDropFormats(&formats, &format_types) &&
--- a/ui/base/clipboard/BUILD.gn	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/BUILD.gn	2019-01-24 15:42:48.076000000 +0300
@@ -0,0 +1,184 @@
+# Copyright 2018 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/jumbo.gni")
+import("//build/config/ui.gni")
+
+jumbo_source_set("clipboard_util") {
+  sources = []
+  if (is_win) {
+    sources += [
+      "clipboard_util_win.cc",
+      "clipboard_util_win.h",
+    ]
+  } else if (is_ios) {
+    sources += [
+      "clipboard_util_mac.h",
+      "clipboard_util_mac.mm",
+    ]
+  }
+}
+
+jumbo_component("clipboard_types") {
+  output_name = "ui_base_clipboard_types"
+  sources = [
+    "clipboard_format_type.h",
+    "clipboard_types.h",
+    "ui_base_clipboard_types_export.h",
+  ]
+
+  if (use_aura) {
+    if ((use_x11 && is_desktop_linux) || !is_win) {
+      sources += [ "clipboard_format_type_aura.cc" ]
+    }
+  } else if (is_ios) {
+    sources += [ "clipboard_format_type_mac.mm" ]
+  } else if (is_win) {
+    sources += [ "clipboard_format_type_win.cc" ]
+  } else if (is_android) {
+    sources += [ "clipboard_format_type_android.cc" ]
+  }
+
+  if (!is_ios) {
+    sources += [
+      "clipboard_constants.cc",
+      "clipboard_constants.h",
+    ]
+  }
+
+  defines = [ "UI_BASE_CLIPBOARD_TYPES_IMPLEMENTATION" ]
+
+  deps = [
+    "//base",
+  ]
+}
+
+jumbo_component("clipboard") {
+  output_name = "ui_base_clipboard"
+
+  sources = [
+    "clipboard_android.cc",
+    "clipboard_android.h",
+    "clipboard_mac.h",
+    "clipboard_mac.mm",
+    "clipboard_win.cc",
+    "clipboard_win.h",
+    "custom_data_helper_mac.mm",
+    "ui_base_clipboard_export.h",
+  ]
+
+  if (!is_ios) {
+    sources += [
+      "clipboard.cc",
+      "clipboard.h",
+      "clipboard_monitor.cc",
+      "clipboard_monitor.h",
+      "clipboard_observer.h",
+      "custom_data_helper.cc",
+      "custom_data_helper.h",
+      "scoped_clipboard_writer.cc",
+      "scoped_clipboard_writer.h",
+    ]
+  }
+
+  if (use_aura) {
+    # Aura clipboard.
+    if (is_desktop_linux) {
+      if (use_ozone) {
+        sources += [
+          "clipboard_ozone.cc",
+          "clipboard_ozone.h",
+        ]
+      } else if (use_x11) {
+        sources += [
+          "clipboard_aurax11.cc",
+          "clipboard_aurax11.h",
+        ]
+      }
+    } else if (!is_win) {
+      # This file is used for all non-X11, non-Windows aura Builds.
+      sources += [
+        "clipboard_aura.cc",
+        "clipboard_aura.h",
+      ]
+    }
+  }
+
+  defines = [ "UI_BASE_CLIPBOARD_IMPLEMENTATION" ]
+
+  deps = [
+    "//base",
+    "//net",
+    "//skia",
+    "//ui/base",
+    "//ui/events/platform",
+    "//ui/gfx",
+    "//ui/gfx/geometry",
+  ]
+
+  if (use_x11 && is_desktop_linux && use_aura) {
+    deps += [
+      "//ui/base/x",
+      "//ui/gfx/x",
+    ]
+  }
+
+  if (is_android) {
+    deps += [ "//ui/base:ui_base_jni_headers" ]
+  }
+
+  public_deps = [
+    ":clipboard_types",
+    ":clipboard_util",
+  ]
+
+  if (use_ozone) {
+    deps += [ "//ui/ozone" ]
+  }
+}
+
+jumbo_source_set("clipboard_test_support") {
+  testonly = true
+
+  if (!is_ios) {
+    sources = [
+      "test/test_clipboard.cc",
+      "test/test_clipboard.h",
+    ]
+  }
+
+  public_deps = [
+    ":clipboard",
+    "//base",
+    "//skia",
+  ]
+}
+
+jumbo_component("clipboard_test") {
+  testonly = true
+
+  output_name = "ui_base_clipboard_test"
+  sources = [
+    "clipboard_mac_unittest.mm",
+    "clipboard_util_mac_unittest.mm",
+  ]
+
+  if (!is_ios) {
+    sources += [
+      "custom_data_helper_unittest.cc",
+      "test/test_clipboard_unittest.cc",
+    ]
+  }
+
+  defines = [ "UI_BASE_CLIPBOARD_TEST_IMPLEMENTATION" ]
+
+  deps = [
+    ":clipboard_test_support",
+    "//base/test:test_support",
+    "//testing/gmock",
+    "//testing/gtest",
+    "//ui/events/platform",
+    "//ui/gfx:test_support",
+  ]
+}
--- a/ui/base/clipboard/clipboard_constants.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/clipboard_constants.h	2019-01-24 15:42:48.080000000 +0300
@@ -0,0 +1,28 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_CLIPBOARD_CLIPBOARD_CONSTANTS_H_
+#define UI_BASE_CLIPBOARD_CLIPBOARD_CONSTANTS_H_
+
+#include "ui/base/clipboard/ui_base_clipboard_types_export.h"
+
+#include <string>
+
+namespace ui {
+
+// MIME type constants.
+UI_BASE_CLIPBOARD_TYPES_EXPORT extern const char kMimeTypeText[];
+UI_BASE_CLIPBOARD_TYPES_EXPORT extern const char kMimeTypeURIList[];
+UI_BASE_CLIPBOARD_TYPES_EXPORT extern const char kMimeTypeDownloadURL[];
+UI_BASE_CLIPBOARD_TYPES_EXPORT extern const char kMimeTypeMozillaURL[];
+UI_BASE_CLIPBOARD_TYPES_EXPORT extern const char kMimeTypeHTML[];
+UI_BASE_CLIPBOARD_TYPES_EXPORT extern const char kMimeTypeRTF[];
+UI_BASE_CLIPBOARD_TYPES_EXPORT extern const char kMimeTypePNG[];
+UI_BASE_CLIPBOARD_TYPES_EXPORT extern const char kMimeTypeWebCustomData[];
+UI_BASE_CLIPBOARD_TYPES_EXPORT extern const char kMimeTypeWebkitSmartPaste[];
+UI_BASE_CLIPBOARD_TYPES_EXPORT extern const char kMimeTypePepperCustomData[];
+
+}  // namespace ui
+
+#endif  // UI_BASE_CLIPBOARD_CLIPBOARD_H_
--- a/ui/base/clipboard/clipboard_format_type_android.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/clipboard_format_type_android.cc	2019-01-24 15:42:48.080000000 +0300
@@ -0,0 +1,106 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/clipboard/clipboard_format_type.h"
+
+#include "ui/base/clipboard/clipboard_constants.h"
+
+namespace ui {
+
+namespace {
+
+// Various formats we support.
+const char kURLFormat[] = "url";
+const char kPlainTextFormat[] = "text";
+const char kHTMLFormat[] = "html";
+const char kRTFFormat[] = "rtf";
+const char kBitmapFormat[] = "bitmap";
+const char kWebKitSmartPasteFormat[] = "webkit_smart";
+const char kBookmarkFormat[] = "bookmark";
+
+}  // namespace
+
+// ClipboardFormatType implementation.
+ClipboardFormatType::ClipboardFormatType() {}
+
+ClipboardFormatType::ClipboardFormatType(const std::string& native_format)
+    : data_(native_format) {}
+
+ClipboardFormatType::~ClipboardFormatType() {}
+
+std::string ClipboardFormatType::Serialize() const {
+  return data_;
+}
+
+ClipboardFormatType ClipboardFormatType::Deserialize(
+    const std::string& serialization) {
+  return ClipboardFormatType(serialization);
+}
+
+bool ClipboardFormatType::operator<(const ClipboardFormatType& other) const {
+  return data_ < other.data_;
+}
+
+bool ClipboardFormatType::Equals(const ClipboardFormatType& other) const {
+  return data_ == other.data_;
+}
+
+// Various predefined ClipboardFormatTypes.
+
+ClipboardFormatType GetClipboardFormatType(const std::string& format_string) {
+  return ClipboardFormatType::Deserialize(format_string);
+}
+
+const ClipboardFormatType& GetUrlWClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kURLFormat);
+  return *type;
+}
+
+const ClipboardFormatType& GetPlainTextClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kPlainTextFormat);
+  return *type;
+}
+
+const ClipboardFormatType& GetPlainTextWClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kPlainTextFormat);
+  return *type;
+}
+
+const ClipboardFormatType& GetWebKitSmartPasteClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kWebKitSmartPasteFormat);
+  return *type;
+}
+
+const ClipboardFormatType& GetHtmlClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kHTMLFormat);
+  return *type;
+}
+
+const ClipboardFormatType& GetRtfClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kRTFFormat);
+  return *type;
+}
+
+const ClipboardFormatType& GetBitmapClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kBitmapFormat);
+  return *type;
+}
+
+const ClipboardFormatType& GetWebCustomDataClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeWebCustomData);
+  return *type;
+}
+
+const ClipboardFormatType& GetPepperCustomDataClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(
+      kMimeTypePepperCustomData);
+  return *type;
+}
+
+const ClipboardFormatType& GetBookmarkClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kBookmarkFormat);
+  return *type;
+}
+
+}  // namespace ui
--- a/ui/base/clipboard/clipboard_format_type_aura.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/clipboard_format_type_aura.cc	2019-01-24 15:42:48.080000000 +0300
@@ -0,0 +1,114 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/clipboard/clipboard_format_type.h"
+
+#include "ui/base/clipboard/clipboard_constants.h"
+
+namespace ui {
+
+namespace {
+constexpr char kMimeTypeFilename[] = "chromium/filename";
+}
+
+// I would love for the ClipboardFormatType to really be a wrapper around an X11
+// ::Atom, but there are a few problems. Chromeos unit tests spawn a new X11
+// server for each test, so Atom numeric values don't persist across tests. We
+// could still maybe deal with that if we didn't have static accessor methods
+// everywhere.
+ClipboardFormatType::ClipboardFormatType() = default;
+
+ClipboardFormatType::~ClipboardFormatType() = default;
+
+ClipboardFormatType::ClipboardFormatType(const std::string& native_format)
+    : data_(native_format) {}
+
+std::string ClipboardFormatType::Serialize() const {
+  return data_;
+}
+
+// static
+ClipboardFormatType ClipboardFormatType::Deserialize(
+    const std::string& serialization) {
+  return ClipboardFormatType(serialization);
+}
+
+bool ClipboardFormatType::operator<(const ClipboardFormatType& other) const {
+  return data_ < other.data_;
+}
+
+bool ClipboardFormatType::Equals(const ClipboardFormatType& other) const {
+  return data_ == other.data_;
+}
+
+// Various predefined ClipboardFormatTypes.
+ClipboardFormatType GetClipboardFormatType(const std::string& format_string) {
+  return ClipboardFormatType::Deserialize(format_string);
+}
+
+const ClipboardFormatType& GetUrlClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeURIList);
+  return *type;
+}
+
+const ClipboardFormatType& GetUrlWClipboardFormatType() {
+  return GetUrlClipboardFormatType();
+}
+
+const ClipboardFormatType& GetMozUrlClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeMozillaURL);
+  return *type;
+}
+
+const ClipboardFormatType& GetPlainTextClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeText);
+  return *type;
+}
+
+const ClipboardFormatType& GetPlainTextWClipboardFormatType() {
+  return GetPlainTextClipboardFormatType();
+}
+
+const ClipboardFormatType& GetFilenameClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeFilename);
+  return *type;
+}
+
+const ClipboardFormatType& GetFilenameWClipboardFormatType() {
+  return GetFilenameClipboardFormatType();
+}
+
+const ClipboardFormatType& GetHtmlClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeHTML);
+  return *type;
+}
+
+const ClipboardFormatType& GetRtfClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeRTF);
+  return *type;
+}
+
+const ClipboardFormatType& GetBitmapClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypePNG);
+  return *type;
+}
+
+const ClipboardFormatType& GetWebKitSmartPasteClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(
+      kMimeTypeWebkitSmartPaste);
+  return *type;
+}
+
+const ClipboardFormatType& GetWebCustomDataClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kMimeTypeWebCustomData);
+  return *type;
+}
+
+const ClipboardFormatType& GetPepperCustomDataClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(
+      kMimeTypePepperCustomData);
+  return *type;
+}
+
+}  // namespace ui
--- a/ui/base/clipboard/clipboard_format_type.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/clipboard_format_type.h	2019-01-24 15:42:48.080000000 +0300
@@ -0,0 +1,131 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_CLIPBOARD_CLIPBOARD_FORMAT_TYPE_H_
+#define UI_BASE_CLIPBOARD_CLIPBOARD_FORMAT_TYPE_H_
+
+#include <string>
+
+#include "base/no_destructor.h"
+#include "build/build_config.h"
+#include "ui/base/clipboard/ui_base_clipboard_types_export.h"
+
+namespace ui {
+
+class Clipboard;
+
+// Platform neutral holder for native data representation of a clipboard type.
+struct UI_BASE_CLIPBOARD_TYPES_EXPORT ClipboardFormatType {
+  ClipboardFormatType();
+  ~ClipboardFormatType();
+
+  // Serializes and deserializes a ClipboardFormatType for use in IPC messages.
+  std::string Serialize() const;
+  UI_BASE_CLIPBOARD_TYPES_EXPORT static ClipboardFormatType Deserialize(
+      const std::string& serialization);
+
+  // ClipboardFormatType can be used in a set on some platforms.
+  bool operator<(const ClipboardFormatType& other) const;
+
+#if defined(OS_WIN)
+  const FORMATETC& ToFormatEtc() const { return data_; }
+#elif defined(USE_AURA) || defined(OS_ANDROID) || defined(OS_FUCHSIA)
+  const std::string& ToString() const { return data_; }
+#elif defined(OS_MACOSX)
+  NSString* ToNSString() const { return data_; }
+  // Custom copy and assignment constructor to handle NSString.
+  ClipboardFormatType(const ClipboardFormatType& other);
+  ClipboardFormatType& operator=(const ClipboardFormatType& other);
+#endif
+
+  bool Equals(const ClipboardFormatType& other) const;
+
+ private:
+  friend class base::NoDestructor<ClipboardFormatType>;
+  friend class Clipboard;
+
+  // Platform-specific glue used internally by the Clipboard class. Each
+  // plaform should define,at least one of each of the following:
+  // 1. A constructor that wraps that native clipboard format descriptor.
+  // 2. An accessor to retrieve the wrapped descriptor.
+  // 3. A data member to hold the wrapped descriptor.
+  //
+  // Note that in some cases, the accessor for the wrapped descriptor may be
+  // public, as these format types can be used by drag and drop code as well.
+#if defined(OS_WIN)
+  explicit ClipboardFormatType(UINT native_format);
+  ClipboardFormatType(UINT native_format, LONG index);
+  FORMATETC data_;
+#elif defined(USE_AURA) || defined(OS_ANDROID) || defined(OS_FUCHSIA)
+  explicit ClipboardFormatType(const std::string& native_format);
+  std::string data_;
+#elif defined(OS_MACOSX)
+  explicit ClipboardFormatType(NSString* native_format);
+  NSString* data_;
+#else
+#error No ClipboardFormatType definition.
+#endif
+
+  // Copyable and assignable, since this is essentially an opaque value type.
+};
+
+// Gets the ClipboardFormatType corresponding to an arbitrary format string,
+// registering it with the system if needed. Due to Windows/Linux
+// limitiations, |format_string| must never be controlled by the user.
+UI_BASE_CLIPBOARD_TYPES_EXPORT ClipboardFormatType
+GetClipboardFormatType(const std::string& format_string);
+
+// Get format identifiers for various types.
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetUrlClipboardFormatType();
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetUrlWClipboardFormatType();
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetMozUrlClipboardFormatType();
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetPlainTextClipboardFormatType();
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetPlainTextWClipboardFormatType();
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetFilenameClipboardFormatType();
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetFilenameWClipboardFormatType();
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetWebKitSmartPasteClipboardFormatType();
+// Win: MS HTML Format, Other: Generic HTML format
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetHtmlClipboardFormatType();
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetRtfClipboardFormatType();
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetBitmapClipboardFormatType();
+// TODO(raymes): Unify web custom data and pepper custom data:
+// crbug.com/158399.
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetWebCustomDataClipboardFormatType();
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetPepperCustomDataClipboardFormatType();
+
+#if defined(OS_WIN)
+// Firefox text/html
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetTextHtmlClipboardFormatType();
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetCFHDropClipboardFormatType();
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetFileDescriptorClipboardFormatType();
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetFileContentZeroClipboardFormatType();
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetIDListClipboardFormatType();
+#endif
+
+#if defined(OS_ANDROID)
+UI_BASE_CLIPBOARD_TYPES_EXPORT const ClipboardFormatType&
+GetBookmarkClipboardFormatType();
+#endif
+
+}  // namespace ui
+
+#endif  // UI_BASE_CLIPBOARD_CLIPBOARD_FORMAT_TYPE_H_
--- a/ui/base/clipboard/clipboard_format_type_mac.mm	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/clipboard_format_type_mac.mm	2019-01-24 15:42:48.080000000 +0300
@@ -0,0 +1,126 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/clipboard/clipboard_format_type.h"
+
+#import <Cocoa/Cocoa.h>
+
+namespace ui {
+
+namespace {
+
+// Tells us if WebKit was the last to write to the pasteboard. There's no
+// actual data associated with this type.
+NSString* const kWebSmartPastePboardType = @"NeXT smart paste pasteboard type";
+
+// Pepper custom data format type.
+NSString* const kPepperCustomDataPboardType =
+    @"org.chromium.pepper-custom-data";
+
+}  // namespace
+
+// ClipboardFormatType implementation.
+ClipboardFormatType::ClipboardFormatType() : data_(nil) {}
+
+ClipboardFormatType::ClipboardFormatType(NSString* native_format)
+    : data_([native_format retain]) {}
+
+ClipboardFormatType::ClipboardFormatType(const ClipboardFormatType& other)
+    : data_([other.data_ retain]) {}
+
+ClipboardFormatType& ClipboardFormatType::operator=(
+    const ClipboardFormatType& other) {
+  if (this != &other) {
+    [data_ release];
+    data_ = [other.data_ retain];
+  }
+  return *this;
+}
+
+bool ClipboardFormatType::Equals(const ClipboardFormatType& other) const {
+  return [data_ isEqualToString:other.data_];
+}
+
+ClipboardFormatType::~ClipboardFormatType() {
+  [data_ release];
+}
+
+std::string ClipboardFormatType::Serialize() const {
+  return base::SysNSStringToUTF8(data_);
+}
+
+ClipboardFormatType ClipboardFormatType::Deserialize(
+    const std::string& serialization) {
+  return ClipboardFormatType(base::SysUTF8ToNSString(serialization));
+}
+
+bool ClipboardFormatType::operator<(const ClipboardFormatType& other) const {
+  return [data_ compare:other.data_] == NSOrderedAscending;
+}
+
+// Various predefined ClipboardFormatTypes.
+
+ClipboardFormatType GetClipboardFormatType(const std::string& format_string) {
+  return ClipboardFormatType::Deserialize(format_string);
+}
+
+const ClipboardFormatType& GetUrlClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(NSURLPboardType);
+  return *type;
+}
+
+const ClipboardFormatType& GetUrlWClipboardFormatType() {
+  return GetUrlClipboardFormatType();
+}
+
+const ClipboardFormatType& GetPlainTextClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(NSPasteboardTypeString);
+  return *type;
+}
+
+const ClipboardFormatType& GetPlainTextWClipboardFormatType() {
+  return GetPlainTextClipboardFormatType();
+}
+
+const ClipboardFormatType& GetFilenameClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(NSFilenamesPboardType);
+  return *type;
+}
+
+const ClipboardFormatType& GetFilenameWClipboardFormatType() {
+  return GetFilenameClipboardFormatType();
+}
+
+const ClipboardFormatType& GetHtmlClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(NSHTMLPboardType);
+  return *type;
+}
+
+const ClipboardFormatType& GetRtfClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(NSRTFPboardType);
+  return *type;
+}
+
+const ClipboardFormatType& GetBitmapClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(NSTIFFPboardType);
+  return *type;
+}
+
+const ClipboardFormatType& GetWebKitSmartPasteClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kWebSmartPastePboardType);
+  return *type;
+}
+
+const ClipboardFormatType& GetWebCustomDataClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(kWebCustomDataPboardType);
+  return *type;
+}
+
+const ClipboardFormatType& GetPepperCustomDataClipboardFormatType() {
+  static base::NoDestructor<ClipboardFormatType> type(
+      kPepperCustomDataPboardType);
+  return *type;
+}
+
+}  // namespace ui
--- a/ui/base/clipboard/clipboard_format_type_win.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/clipboard_format_type_win.cc	2019-01-24 15:42:48.080000000 +0300
@@ -0,0 +1,188 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/clipboard/clipboard_format_type.h"
+
+#include "ui/base/clipboard/clipboard_utils.h"
+
+namespace ui {
+
+// ClipboardFormatType implementation.
+ClipboardFormatType::ClipboardFormatType() : data_() {}
+
+ClipboardFormatType::ClipboardFormatType(UINT native_format) : data_() {
+  // There's no good way to actually initialize this in the constructor in
+  // C++03.
+  data_.cfFormat = static_cast<CLIPFORMAT>(native_format);
+  data_.dwAspect = DVASPECT_CONTENT;
+  data_.lindex = -1;
+  data_.tymed = TYMED_HGLOBAL;
+}
+
+ClipboardFormatType::ClipboardFormatType(UINT native_format, LONG index)
+    : data_() {
+  // There's no good way to actually initialize this in the constructor in
+  // C++03.
+  data_.cfFormat = static_cast<CLIPFORMAT>(native_format);
+  data_.dwAspect = DVASPECT_CONTENT;
+  data_.lindex = index;
+  data_.tymed = TYMED_HGLOBAL;
+}
+
+ClipboardFormatType::~ClipboardFormatType() {}
+
+std::string ClipboardFormatType::Serialize() const {
+  return base::IntToString(data_.cfFormat);
+}
+
+ClipboardFormatType ClipboardFormatType::Deserialize(
+    const std::string& serialization) {
+  int clipboard_format = -1;
+  if (!base::StringToInt(serialization, &clipboard_format)) {
+    NOTREACHED();
+    return ClipboardFormatType();
+  }
+  return ClipboardFormatType(clipboard_format);
+}
+
+bool ClipboardFormatType::operator<(const ClipboardFormatType& other) const {
+  return data_.cfFormat < other.data_.cfFormat;
+}
+
+bool ClipboardFormatType::Equals(const ClipboardFormatType& other) const {
+  return data_.cfFormat == other.data_.cfFormat;
+}
+
+// Various predefined ClipboardFormatTypes.
+
+ClipboardFormatType GetClipboardFormatType(const std::string& format_string) {
+  return ClipboardFormatType(
+      ::RegisterClipboardFormat(base::ASCIIToUTF16(format_string).c_str()));
+}
+
+// The following formats can be referenced by ClipboardUtilWin::GetPlainText.
+// For reasons (COM), they must be initialized in a thread-safe manner.
+// TODO(dcheng): We probably need to make static initialization of "known"
+// ClipboardFormatTypes thread-safe on all platforms.
+#define CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(name, ...)                        \
+  struct ClipboardFormatTypeArgumentForwarder : public ClipboardFormatType { \
+    ClipboardFormatTypeArgumentForwarder()                                   \
+        : ClipboardFormatType(__VA_ARGS__) {}                                \
+  };                                                                         \
+  static base::LazyInstance<ClipboardFormatTypeArgumentForwarder>::Leaky     \
+      name = LAZY_INSTANCE_INITIALIZER
+
+const ClipboardFormatType& GetUrlClipboardFormatType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type,
+                                     ::RegisterClipboardFormat(CFSTR_INETURLA));
+  return type.Get();
+}
+
+const ClipboardFormatType& GetUrlWClipboardFormatType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type,
+                                     ::RegisterClipboardFormat(CFSTR_INETURLW));
+  return type.Get();
+}
+
+const ClipboardFormatType& GetMozUrlClipboardFormatType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(L"text/x-moz-url"));
+  return type.Get();
+}
+
+const ClipboardFormatType& GetPlainTextClipboardFormatType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type, CF_TEXT);
+  return type.Get();
+}
+
+const ClipboardFormatType& GetPlainTextWClipboardFormatType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type, CF_UNICODETEXT);
+  return type.Get();
+}
+
+const ClipboardFormatType& GetFilenameClipboardFormatType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(CFSTR_FILENAMEA));
+  return type.Get();
+}
+
+const ClipboardFormatType& GetFilenameWClipboardFormatType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(CFSTR_FILENAMEW));
+  return type.Get();
+}
+
+// MS HTML Format
+
+const ClipboardFormatType& GetHtmlClipboardFormatType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type,
+                                     ::RegisterClipboardFormat(L"HTML Format"));
+  return type.Get();
+}
+
+// MS RTF Format
+
+const ClipboardFormatType& GetRtfClipboardFormatType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(L"Rich Text Format"));
+  return type.Get();
+}
+
+const ClipboardFormatType& GetBitmapClipboardFormatType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type, CF_BITMAP);
+  return type.Get();
+}
+
+// Firefox text/html
+
+const ClipboardFormatType& GetTextHtmlClipboardFormatType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type,
+                                     ::RegisterClipboardFormat(L"text/html"));
+  return type.Get();
+}
+
+const ClipboardFormatType& GetCFHDropClipboardFormatType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(type, CF_HDROP);
+  return type.Get();
+}
+
+const ClipboardFormatType& GetFileDescriptorClipboardFormatType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(CFSTR_FILEDESCRIPTOR));
+  return type.Get();
+}
+
+const ClipboardFormatType& GetFileContentZeroClipboardFormatType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(CFSTR_FILECONTENTS), 0);
+  return type.Get();
+}
+
+const ClipboardFormatType& GetIDListClipboardFormatType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(CFSTR_SHELLIDLIST));
+  return type.Get();
+}
+
+const ClipboardFormatType& GetWebKitSmartPasteClipboardFormatType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(L"WebKit Smart Paste Format"));
+  return type.Get();
+}
+
+const ClipboardFormatType& GetWebCustomDataClipboardFormatType() {
+  // TODO(dcheng): This name is temporary. See http://crbug.com/106449.
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(L"Chromium Web Custom MIME Data Format"));
+  return type.Get();
+}
+
+const ClipboardFormatType& GetPepperCustomDataClipboardFormatType() {
+  CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE(
+      type, ::RegisterClipboardFormat(L"Chromium Pepper MIME Data Format"));
+  return type.Get();
+}
+#undef CR_STATIC_UI_CLIPBOARD_FORMAT_TYPE
+
+}  // namespace ui
--- a/ui/base/clipboard/clipboard_ozone.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/clipboard_ozone.cc	2019-01-24 15:42:48.856000000 +0300
@@ -0,0 +1,427 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/clipboard/clipboard_ozone.h"
+
+#include <memory>
+
+#include "base/bind.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/run_loop.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/timer/timer.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/clipboard/clipboard_constants.h"
+#include "ui/base/clipboard/custom_data_helper.h"
+#include "ui/gfx/codec/png_codec.h"
+#include "ui/ozone/public/ozone_platform.h"
+#include "ui/ozone/public/platform_clipboard.h"
+
+namespace ui {
+
+// A helper class, which uses a request pattern to asynchronously communicate
+// with the ozone::PlatformClipboard and fetch clipboard data with mimes
+// specified.
+class ClipboardOzone::AsyncClipboardOzone {
+ public:
+  explicit AsyncClipboardOzone(PlatformClipboard* delegate)
+      : delegate_(delegate), weak_factory_(this) {}
+
+  ~AsyncClipboardOzone() = default;
+
+  std::vector<uint8_t> ReadClipboardDataAndWait(ClipboardType type,
+                                                const std::string& mime_type) {
+    // TODO(tonikitoo): add selection support.
+    if (type == ClipboardType::CLIPBOARD_TYPE_SELECTION)
+      return std::vector<uint8_t>();
+
+    // We can use a fastpath if we are the owner of the selection.
+    if (delegate_->IsSelectionOwner()) {
+      return offered_data_.find(mime_type) != offered_data_.end()
+                 ? offered_data_[mime_type]
+                 : std::vector<uint8_t>();
+    }
+
+    std::unique_ptr<Request> request =
+        std::make_unique<Request>(RequestType::READ);
+    request->requested_mime_type = mime_type;
+    ProcessRequestAndWaitForResult(request.get());
+    return !request->data_map.empty() ? request->data_map[mime_type]
+                                      : std::vector<uint8_t>();
+  }
+
+  std::vector<std::string> RequestMimeTypes() {
+    // We can use a fastpath if we are the owner of the selection.
+    if (delegate_->IsSelectionOwner()) {
+      std::vector<std::string> mime_types;
+      for (const auto& item : offered_data_)
+        mime_types.push_back(item.first);
+      return mime_types;
+    }
+
+    std::unique_ptr<Request> request =
+        std::make_unique<Request>(RequestType::GET_MIME);
+    ProcessRequestAndWaitForResult(request.get());
+    return std::move(request->mime_types);
+  }
+
+  void OfferData() {
+    std::unique_ptr<Request> request =
+        std::make_unique<Request>(RequestType::OFFER);
+    request->data_map = offered_data_;
+    ProcessRequestAndWaitForResult(request.get());
+
+    ++sequence_number_;
+  }
+
+  void InsertData(std::vector<uint8_t> data, const std::string& mime_type) {
+    DCHECK(offered_data_.find(mime_type) == offered_data_.end());
+    offered_data_[mime_type] = std::move(data);
+  }
+
+  void ClearOfferedData() { offered_data_.clear(); }
+
+  uint64_t sequence_number() const { return sequence_number_; }
+
+ private:
+  enum class RequestType {
+    READ = 0,
+    OFFER = 1,
+    GET_MIME = 2,
+  };
+
+  // A structure, which holds request data to process inquiries from
+  // the ClipboardOzone.
+  struct Request {
+    explicit Request(RequestType type) : current_type(type) {}
+    ~Request() = default;
+
+    // Describes the type of the request.
+    RequestType current_type;
+
+    // A closure that is used to signal the request is processed.
+    base::OnceClosure request_closure;
+
+    // A data map that stores the result data or offers clipboard data.
+    PlatformClipboard::DataMap data_map;
+
+    // A requested mime type of the current request.
+    std::string requested_mime_type;
+
+    // A vector of mime types returned as a result to a request to get available
+    // mime types.
+    std::vector<std::string> mime_types;
+
+    // The time when the request should be aborted.
+    base::TimeTicks timeout;
+  };
+
+  void ProcessRequestAndWaitForResult(Request* request) {
+    DCHECK(!abort_timer_.IsRunning());
+    DCHECK(!pending_request_);
+
+    // TODO(https://crbug.com/913422): the implementation is known to be
+    // dangerous, and may cause blocks in ui thread. But base::Clipboard was
+    // designed to have synchrous APIs rather than asynchronous ones that at
+    // least two system clipboards on X11 and Wayland provide.
+    base::RunLoop run_loop(base::RunLoop::Type::kNestableTasksAllowed);
+    // Set a timeout time after which the request will be aborted.
+    base::TimeTicks timeout =
+        base::TimeTicks::Now() + base::TimeDelta::FromMilliseconds(1000);
+    request->request_closure = run_loop.QuitClosure();
+    request->timeout = timeout;
+
+    pending_request_ = request;
+    switch (pending_request_->current_type) {
+      case (RequestType::READ):
+        ProcessReadRequest(request);
+        break;
+      case (RequestType::OFFER):
+        ProcessOfferRequest(request);
+        break;
+      case (RequestType::GET_MIME):
+        ProcessGetMimeRequest(request);
+        break;
+      default:
+        NOTREACHED();
+        break;
+    }
+
+    if (!pending_request_)
+      return;
+    abort_timer_.Start(FROM_HERE, base::TimeDelta::FromMilliseconds(100), this,
+                       &AsyncClipboardOzone::AbortStaledRequest);
+    run_loop.Run();
+  }
+
+  void AbortStaledRequest() {
+    base::TimeTicks now = base::TimeTicks::Now();
+    if (pending_request_ && pending_request_->timeout >= now)
+      std::move(pending_request_->request_closure).Run();
+  }
+
+  void ProcessReadRequest(Request* request) {
+    auto callback = base::BindOnce(&AsyncClipboardOzone::OnTextRead,
+                                   weak_factory_.GetWeakPtr());
+    DCHECK(delegate_);
+    delegate_->RequestClipboardData(request->requested_mime_type,
+                                    &request->data_map, std::move(callback));
+  }
+
+  void ProcessOfferRequest(Request* request) {
+    auto callback = base::BindOnce(&AsyncClipboardOzone::OnOfferDone,
+                                   weak_factory_.GetWeakPtr());
+    DCHECK(delegate_);
+    delegate_->OfferClipboardData(request->data_map, std::move(callback));
+  }
+
+  void ProcessGetMimeRequest(Request* request) {
+    auto callback = base::BindOnce(&AsyncClipboardOzone::OnGotMimeTypes,
+                                   weak_factory_.GetWeakPtr());
+    DCHECK(delegate_);
+    delegate_->GetAvailableMimeTypes(std::move(callback));
+  }
+
+  void OnTextRead(const base::Optional<std::vector<uint8_t>>& data) {
+    CompleteRequest();
+  }
+
+  void OnOfferDone() { CompleteRequest(); }
+
+  void OnGotMimeTypes(const std::vector<std::string>& mime_types) {
+    pending_request_->mime_types = std::move(mime_types);
+    CompleteRequest();
+  }
+
+  void CompleteRequest() {
+    abort_timer_.Stop();
+    auto closure = std::move(pending_request_->request_closure);
+    pending_request_ = nullptr;
+    std::move(closure).Run();
+  }
+
+  // Cached clipboard data, which is pending to be written. Must be cleared on
+  // every new write to the |delegate_|.
+  PlatformClipboard::DataMap offered_data_;
+
+  // A current pending request being processed.
+  Request* pending_request_ = nullptr;
+
+  // Aborts |pending_request| after Request::timeout.
+  base::RepeatingTimer abort_timer_;
+
+  // Provides communication to a system clipboard under ozone level.
+  PlatformClipboard* delegate_ = nullptr;
+
+  uint64_t sequence_number_ = 0;
+
+  base::WeakPtrFactory<AsyncClipboardOzone> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(AsyncClipboardOzone);
+};
+
+// Clipboard factory method.
+Clipboard* Clipboard::Create() {
+  return new ClipboardOzone;
+}
+
+// ClipboardOzone implementation.
+ClipboardOzone::ClipboardOzone() {
+  async_clipboard_ozone_ =
+      std::make_unique<ClipboardOzone::AsyncClipboardOzone>(
+          OzonePlatform::GetInstance()->GetPlatformClipboard());
+}
+
+ClipboardOzone::~ClipboardOzone() = default;
+
+void ClipboardOzone::OnPreShutdown() {}
+
+uint64_t ClipboardOzone::GetSequenceNumber(ClipboardType type) const {
+  return async_clipboard_ozone_->sequence_number();
+}
+
+bool ClipboardOzone::IsFormatAvailable(const ClipboardFormatType& format,
+                                       ClipboardType type) const {
+  DCHECK(CalledOnValidThread());
+  // TODO(tonikitoo): add selection support.
+  if (type == ClipboardType::CLIPBOARD_TYPE_SELECTION)
+    return false;
+
+  auto available_types = async_clipboard_ozone_->RequestMimeTypes();
+  for (auto mime_type : available_types) {
+    if (format.ToString() == mime_type) {
+      return true;
+    }
+  }
+  return false;
+}
+
+void ClipboardOzone::Clear(ClipboardType type) {
+  async_clipboard_ozone_->ClearOfferedData();
+  async_clipboard_ozone_->OfferData();
+}
+
+void ClipboardOzone::ReadAvailableTypes(ClipboardType type,
+                                        std::vector<base::string16>* types,
+                                        bool* contains_filenames) const {
+  DCHECK(CalledOnValidThread());
+  types->clear();
+
+  // TODO(tonikitoo): add selection support.
+  if (type == ClipboardType::CLIPBOARD_TYPE_SELECTION)
+    return;
+
+  auto available_types = async_clipboard_ozone_->RequestMimeTypes();
+  for (auto mime_type : available_types)
+    types->push_back(base::UTF8ToUTF16(mime_type));
+}
+
+void ClipboardOzone::ReadText(ClipboardType type,
+                              base::string16* result) const {
+  DCHECK(CalledOnValidThread());
+
+  auto clipboard_data =
+      async_clipboard_ozone_->ReadClipboardDataAndWait(type, kMimeTypeText);
+  *result = base::UTF8ToUTF16(
+      std::string(clipboard_data.begin(), clipboard_data.end()));
+}
+
+void ClipboardOzone::ReadAsciiText(ClipboardType type,
+                                   std::string* result) const {
+  DCHECK(CalledOnValidThread());
+  auto clipboard_data =
+      async_clipboard_ozone_->ReadClipboardDataAndWait(type, kMimeTypeText);
+  result->assign(clipboard_data.begin(), clipboard_data.end());
+}
+
+void ClipboardOzone::ReadHTML(ClipboardType type,
+                              base::string16* markup,
+                              std::string* b_url,
+                              uint32_t* fragment_start,
+                              uint32_t* fragment_end) const {
+  DCHECK(CalledOnValidThread());
+  markup->clear();
+  if (b_url)
+    b_url->clear();
+  *fragment_start = 0;
+  *fragment_end = 0;
+
+  auto clipboard_data =
+      async_clipboard_ozone_->ReadClipboardDataAndWait(type, kMimeTypeHTML);
+  *markup = base::UTF8ToUTF16(
+      std::string(clipboard_data.begin(), clipboard_data.end()));
+  DCHECK(markup->length() <= std::numeric_limits<uint32_t>::max());
+  *fragment_end = static_cast<uint32_t>(markup->length());
+}
+
+void ClipboardOzone::ReadRTF(ClipboardType type, std::string* result) const {
+  DCHECK(CalledOnValidThread());
+  auto clipboard_data =
+      async_clipboard_ozone_->ReadClipboardDataAndWait(type, kMimeTypeRTF);
+  result->assign(clipboard_data.begin(), clipboard_data.end());
+}
+
+SkBitmap ClipboardOzone::ReadImage(ClipboardType type) const {
+  DCHECK(CalledOnValidThread());
+  auto clipboard_data =
+      async_clipboard_ozone_->ReadClipboardDataAndWait(type, kMimeTypePNG);
+  SkBitmap bitmap;
+  if (gfx::PNGCodec::Decode(&clipboard_data.front(), clipboard_data.size(),
+                            &bitmap))
+    return SkBitmap(bitmap);
+  return SkBitmap();
+}
+
+void ClipboardOzone::ReadCustomData(ClipboardType clipboard_type,
+                                    const base::string16& type,
+                                    base::string16* result) const {
+  DCHECK(CalledOnValidThread());
+  auto custom_data = async_clipboard_ozone_->ReadClipboardDataAndWait(
+      clipboard_type, kMimeTypeWebCustomData);
+  ui::ReadCustomDataForType(&custom_data.front(), custom_data.size(), type,
+                            result);
+}
+
+void ClipboardOzone::ReadBookmark(base::string16* title,
+                                  std::string* url) const {
+  DCHECK(CalledOnValidThread());
+  // TODO(msisov): This was left NOTIMPLEMENTED() in all the Linux platforms.
+  NOTIMPLEMENTED();
+}
+
+void ClipboardOzone::ReadData(const ClipboardFormatType& format,
+                              std::string* result) const {
+  DCHECK(CalledOnValidThread());
+  auto clipboard_data = async_clipboard_ozone_->ReadClipboardDataAndWait(
+      ClipboardType::CLIPBOARD_TYPE_COPY_PASTE, format.ToString());
+  result->assign(clipboard_data.begin(), clipboard_data.end());
+}
+
+void ClipboardOzone::WriteObjects(ClipboardType type,
+                                  const ObjectMap& objects) {
+  DCHECK(CalledOnValidThread());
+  if (type == ClipboardType::CLIPBOARD_TYPE_COPY_PASTE) {
+    async_clipboard_ozone_->ClearOfferedData();
+
+    for (const auto& object : objects)
+      DispatchObject(static_cast<ObjectType>(object.first), object.second);
+
+    async_clipboard_ozone_->OfferData();
+  }
+}
+
+void ClipboardOzone::WriteText(const char* text_data, size_t text_len) {
+  std::vector<uint8_t> data(text_data, text_data + text_len);
+  async_clipboard_ozone_->InsertData(std::move(data), kMimeTypeText);
+}
+
+void ClipboardOzone::WriteHTML(const char* markup_data,
+                               size_t markup_len,
+                               const char* url_data,
+                               size_t url_len) {
+  std::vector<uint8_t> data(markup_data, markup_data + markup_len);
+  async_clipboard_ozone_->InsertData(std::move(data), kMimeTypeHTML);
+}
+
+void ClipboardOzone::WriteRTF(const char* rtf_data, size_t data_len) {
+  std::vector<uint8_t> data(rtf_data, rtf_data + data_len);
+  async_clipboard_ozone_->InsertData(std::move(data), kMimeTypeRTF);
+}
+
+void ClipboardOzone::WriteBookmark(const char* title_data,
+                                   size_t title_len,
+                                   const char* url_data,
+                                   size_t url_len) {
+  // Writes a Mozilla url (UTF16: URL, newline, title)
+  base::string16 bookmark =
+      base::UTF8ToUTF16(base::StringPiece(url_data, url_len)) +
+      base::ASCIIToUTF16("\n") +
+      base::UTF8ToUTF16(base::StringPiece(title_data, title_len));
+
+  std::vector<uint8_t> data(
+      reinterpret_cast<const uint8_t*>(bookmark.data()),
+      reinterpret_cast<const uint8_t*>(bookmark.data() + bookmark.size()));
+  async_clipboard_ozone_->InsertData(std::move(data), kMimeTypeMozillaURL);
+}
+
+void ClipboardOzone::WriteWebSmartPaste() {
+  async_clipboard_ozone_->InsertData(std::vector<uint8_t>(),
+                                     kMimeTypeWebkitSmartPaste);
+}
+
+void ClipboardOzone::WriteBitmap(const SkBitmap& bitmap) {
+  std::vector<unsigned char> output;
+  if (gfx::PNGCodec::FastEncodeBGRASkBitmap(bitmap, false, &output))
+    async_clipboard_ozone_->InsertData(std::move(output), kMimeTypePNG);
+}
+
+void ClipboardOzone::WriteData(const ClipboardFormatType& format,
+                               const char* data_data,
+                               size_t data_len) {
+  std::vector<uint8_t> data(data_data, data_data + data_len);
+  async_clipboard_ozone_->InsertData(data, format.ToString());
+}
+
+}  // namespace ui
--- a/ui/base/clipboard/clipboard_ozone.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/clipboard_ozone.h	2019-01-24 15:42:50.496000000 +0300
@@ -0,0 +1,73 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_CLIPBOARD_CLIPBOARD_OZONE_H_
+#define UI_BASE_CLIPBOARD_CLIPBOARD_OZONE_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include "base/macros.h"
+#include "ui/base/clipboard/clipboard.h"
+
+namespace ui {
+
+class ClipboardOzone : public Clipboard {
+ private:
+  friend class Clipboard;
+
+  ClipboardOzone();
+  ~ClipboardOzone() override;
+
+  // Clipboard overrides:
+  void OnPreShutdown() override;
+  uint64_t GetSequenceNumber(ClipboardType type) const override;
+  bool IsFormatAvailable(const ClipboardFormatType& format,
+                         ClipboardType type) const override;
+  void Clear(ClipboardType type) override;
+  void ReadAvailableTypes(ClipboardType type,
+                          std::vector<base::string16>* types,
+                          bool* contains_filenames) const override;
+  void ReadText(ClipboardType type, base::string16* result) const override;
+  void ReadAsciiText(ClipboardType type, std::string* result) const override;
+  void ReadHTML(ClipboardType type,
+                base::string16* markup,
+                std::string* b_url,
+                uint32_t* fragment_start,
+                uint32_t* fragment_end) const override;
+  void ReadRTF(ClipboardType type, std::string* result) const override;
+  SkBitmap ReadImage(ClipboardType type) const override;
+  void ReadCustomData(ClipboardType clipboard_type,
+                      const base::string16& type,
+                      base::string16* result) const override;
+  void ReadBookmark(base::string16* title, std::string* url) const override;
+  void ReadData(const ClipboardFormatType& format,
+                std::string* result) const override;
+  void WriteObjects(ClipboardType type, const ObjectMap& objects) override;
+  void WriteText(const char* text_data, size_t text_len) override;
+  void WriteHTML(const char* markup_data,
+                 size_t markup_len,
+                 const char* url_data,
+                 size_t url_len) override;
+  void WriteRTF(const char* rtf_data, size_t data_len) override;
+  void WriteBookmark(const char* title_data,
+                     size_t title_len,
+                     const char* url_data,
+                     size_t url_len) override;
+  void WriteWebSmartPaste() override;
+  void WriteBitmap(const SkBitmap& bitmap) override;
+  void WriteData(const ClipboardFormatType& format,
+                 const char* data_data,
+                 size_t data_len) override;
+
+  class AsyncClipboardOzone;
+
+  std::unique_ptr<AsyncClipboardOzone> async_clipboard_ozone_;
+
+  DISALLOW_COPY_AND_ASSIGN(ClipboardOzone);
+};
+
+}  // namespace ui
+
+#endif  // UI_BASE_CLIPBOARD_CLIPBOARD_OZONE_H_
diff -BbuN a/ui/base/clipboard/test/test_clipboard.cc b/ui/base/clipboard/test/test_clipboard.cc
--- a/ui/base/clipboard/test/test_clipboard.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/test/test_clipboard.cc	2019-01-24 15:42:56.840000000 +0300
@@ -0,0 +1,243 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/clipboard/test/test_clipboard.h"
+
+#include <stddef.h>
+#include "base/memory/ptr_util.h"
+#include "base/numerics/safe_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+#include "ui/base/clipboard/clipboard_constants.h"
+#include "ui/base/clipboard/clipboard_monitor.h"
+
+namespace ui {
+
+TestClipboard::TestClipboard()
+    : default_store_type_(CLIPBOARD_TYPE_COPY_PASTE) {
+}
+
+TestClipboard::~TestClipboard() {
+}
+
+Clipboard* TestClipboard::CreateForCurrentThread() {
+  base::AutoLock lock(Clipboard::clipboard_map_lock_.Get());
+  Clipboard* clipboard = new TestClipboard;
+  Clipboard::clipboard_map_.Get()[base::PlatformThread::CurrentId()] =
+      base::WrapUnique(clipboard);
+  return clipboard;
+}
+
+void TestClipboard::SetLastModifiedTime(const base::Time& time) {
+  last_modified_time_ = time;
+}
+
+void TestClipboard::OnPreShutdown() {}
+
+uint64_t TestClipboard::GetSequenceNumber(ClipboardType type) const {
+  return GetStore(type).sequence_number;
+}
+
+bool TestClipboard::IsFormatAvailable(const ClipboardFormatType& format,
+                                      ClipboardType type) const {
+  const DataStore& store = GetStore(type);
+  return store.data.find(format) != store.data.end();
+}
+
+void TestClipboard::Clear(ClipboardType type) {
+  GetStore(type).Clear();
+}
+
+void TestClipboard::ReadAvailableTypes(ClipboardType type,
+                                       std::vector<base::string16>* types,
+                                       bool* contains_filenames) const {
+  types->clear();
+
+  if (IsFormatAvailable(GetPlainTextClipboardFormatType(), type))
+    types->push_back(base::UTF8ToUTF16(kMimeTypeText));
+  if (IsFormatAvailable(GetHtmlClipboardFormatType(), type))
+    types->push_back(base::UTF8ToUTF16(kMimeTypeHTML));
+
+  if (IsFormatAvailable(GetRtfClipboardFormatType(), type))
+    types->push_back(base::UTF8ToUTF16(kMimeTypeRTF));
+  if (IsFormatAvailable(GetBitmapClipboardFormatType(), type))
+    types->push_back(base::UTF8ToUTF16(kMimeTypePNG));
+
+  *contains_filenames = false;
+}
+
+void TestClipboard::ReadText(ClipboardType type, base::string16* result) const {
+  std::string result8;
+  ReadAsciiText(type, &result8);
+  *result = base::UTF8ToUTF16(result8);
+}
+
+void TestClipboard::ReadAsciiText(ClipboardType type,
+                                  std::string* result) const {
+  result->clear();
+  const DataStore& store = GetStore(type);
+  auto it = store.data.find(GetPlainTextClipboardFormatType());
+  if (it != store.data.end())
+    *result = it->second;
+}
+
+void TestClipboard::ReadHTML(ClipboardType type,
+                             base::string16* markup,
+                             std::string* b_url,
+                             uint32_t* fragment_start,
+                             uint32_t* fragment_end) const {
+  markup->clear();
+  b_url->clear();
+  const DataStore& store = GetStore(type);
+  auto it = store.data.find(GetHtmlClipboardFormatType());
+  if (it != store.data.end())
+    *markup = base::UTF8ToUTF16(it->second);
+  *b_url = store.html_b_url;
+  *fragment_start = 0;
+  *fragment_end = base::checked_cast<uint32_t>(markup->size());
+}
+
+void TestClipboard::ReadRTF(ClipboardType type, std::string* result) const {
+  result->clear();
+  const DataStore& store = GetStore(type);
+  auto it = store.data.find(GetRtfClipboardFormatType());
+  if (it != store.data.end())
+    *result = it->second;
+}
+
+SkBitmap TestClipboard::ReadImage(ClipboardType type) const {
+  return GetStore(type).image;
+}
+
+void TestClipboard::ReadCustomData(ClipboardType clipboard_type,
+                                   const base::string16& type,
+                                   base::string16* result) const {
+}
+
+void TestClipboard::ReadBookmark(base::string16* title,
+                                 std::string* url) const {
+  const DataStore& store = GetDefaultStore();
+  auto it = store.data.find(GetUrlWClipboardFormatType());
+  if (it != store.data.end())
+    *url = it->second;
+  *title = base::UTF8ToUTF16(store.url_title);
+}
+
+void TestClipboard::ReadData(const ClipboardFormatType& format,
+                             std::string* result) const {
+  result->clear();
+  const DataStore& store = GetDefaultStore();
+  auto it = store.data.find(format);
+  if (it != store.data.end())
+    *result = it->second;
+}
+
+base::Time TestClipboard::GetLastModifiedTime() const {
+  return last_modified_time_;
+}
+
+void TestClipboard::ClearLastModifiedTime() {
+  last_modified_time_ = base::Time();
+}
+
+void TestClipboard::WriteObjects(ClipboardType type, const ObjectMap& objects) {
+  Clear(type);
+  default_store_type_ = type;
+  for (const auto& kv : objects)
+    DispatchObject(static_cast<ObjectType>(kv.first), kv.second);
+  default_store_type_ = CLIPBOARD_TYPE_COPY_PASTE;
+}
+
+void TestClipboard::WriteText(const char* text_data, size_t text_len) {
+  std::string text(text_data, text_len);
+  GetDefaultStore().data[GetPlainTextClipboardFormatType()] = text;
+  // Create a dummy entry.
+  GetDefaultStore().data[GetPlainTextWClipboardFormatType()];
+  if (IsSupportedClipboardType(CLIPBOARD_TYPE_SELECTION))
+    GetStore(CLIPBOARD_TYPE_SELECTION).data[GetPlainTextClipboardFormatType()] =
+        text;
+  ui::ClipboardMonitor::GetInstance()->NotifyClipboardDataChanged();
+}
+
+void TestClipboard::WriteHTML(const char* markup_data,
+                              size_t markup_len,
+                              const char* url_data,
+                              size_t url_len) {
+  base::string16 markup;
+  base::UTF8ToUTF16(markup_data, markup_len, &markup);
+  GetDefaultStore().data[GetHtmlClipboardFormatType()] =
+      base::UTF16ToUTF8(markup);
+  GetDefaultStore().html_b_url = std::string(url_data, url_len);
+}
+
+void TestClipboard::WriteRTF(const char* rtf_data, size_t data_len) {
+  GetDefaultStore().data[GetRtfClipboardFormatType()] =
+      std::string(rtf_data, data_len);
+}
+
+void TestClipboard::WriteBookmark(const char* title_data,
+                                  size_t title_len,
+                                  const char* url_data,
+                                  size_t url_len) {
+  GetDefaultStore().data[GetUrlWClipboardFormatType()] =
+      std::string(url_data, url_len);
+  GetDefaultStore().url_title = std::string(title_data, title_len);
+}
+
+void TestClipboard::WriteWebSmartPaste() {
+  // Create a dummy entry.
+  GetDefaultStore().data[GetWebKitSmartPasteClipboardFormatType()];
+}
+
+void TestClipboard::WriteBitmap(const SkBitmap& bitmap) {
+  // Create a dummy entry.
+  GetDefaultStore().data[GetBitmapClipboardFormatType()];
+  SkBitmap& dst = GetDefaultStore().image;
+  if (dst.tryAllocPixels(bitmap.info())) {
+    bitmap.readPixels(dst.info(), dst.getPixels(), dst.rowBytes(), 0, 0);
+  }
+}
+
+void TestClipboard::WriteData(const ClipboardFormatType& format,
+                              const char* data_data,
+                              size_t data_len) {
+  GetDefaultStore().data[format] = std::string(data_data, data_len);
+}
+
+TestClipboard::DataStore::DataStore() : sequence_number(0) {
+}
+
+TestClipboard::DataStore::DataStore(const DataStore& other) = default;
+
+TestClipboard::DataStore::~DataStore() {
+}
+
+void TestClipboard::DataStore::Clear() {
+  data.clear();
+  url_title.clear();
+  html_b_url.clear();
+  image = SkBitmap();
+}
+
+const TestClipboard::DataStore& TestClipboard::GetStore(
+    ClipboardType type) const {
+  CHECK(IsSupportedClipboardType(type));
+  return stores_[type];
+}
+
+TestClipboard::DataStore& TestClipboard::GetStore(ClipboardType type) {
+  CHECK(IsSupportedClipboardType(type));
+  DataStore& store = stores_[type];
+  ++store.sequence_number;
+  return store;
+}
+
+const TestClipboard::DataStore& TestClipboard::GetDefaultStore() const {
+  return GetStore(default_store_type_);
+}
+
+TestClipboard::DataStore& TestClipboard::GetDefaultStore() {
+  return GetStore(default_store_type_);
+}
+
+}  // namespace ui
diff -BbuN a/ui/base/clipboard/test/test_clipboard.h b/ui/base/clipboard/test/test_clipboard.h
--- a/ui/base/clipboard/test/test_clipboard.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/test/test_clipboard.h	2019-01-24 15:42:56.840000000 +0300
@@ -0,0 +1,105 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_CLIPBOARD_TEST_TEST_CLIPBOARD_H_
+#define UI_BASE_CLIPBOARD_TEST_TEST_CLIPBOARD_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <string>
+#include <vector>
+
+#include "base/containers/flat_map.h"
+#include "base/macros.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/clipboard/clipboard.h"
+
+namespace ui {
+
+class TestClipboard : public Clipboard {
+ public:
+  TestClipboard();
+  ~TestClipboard() override;
+
+  // Creates and associates a TestClipboard with the current thread. When no
+  // longer needed, the returned clipboard must be freed by calling
+  // Clipboard::DestroyClipboardForCurrentThread() on the same thread.
+  static Clipboard* CreateForCurrentThread();
+
+  // Sets the time to be returned by GetLastModifiedTime();
+  void SetLastModifiedTime(const base::Time& time);
+
+  // Clipboard overrides.
+  void OnPreShutdown() override;
+  uint64_t GetSequenceNumber(ClipboardType type) const override;
+  bool IsFormatAvailable(const ClipboardFormatType& format,
+                         ClipboardType type) const override;
+  void Clear(ClipboardType type) override;
+  void ReadAvailableTypes(ClipboardType type,
+                          std::vector<base::string16>* types,
+                          bool* contains_filenames) const override;
+  void ReadText(ClipboardType type, base::string16* result) const override;
+  void ReadAsciiText(ClipboardType type, std::string* result) const override;
+  void ReadHTML(ClipboardType type,
+                base::string16* markup,
+                std::string* b_url,
+                uint32_t* fragment_start,
+                uint32_t* fragment_end) const override;
+  void ReadRTF(ClipboardType type, std::string* result) const override;
+  SkBitmap ReadImage(ClipboardType type) const override;
+  void ReadCustomData(ClipboardType clipboard_type,
+                      const base::string16& type,
+                      base::string16* result) const override;
+  void ReadBookmark(base::string16* title, std::string* url) const override;
+  void ReadData(const ClipboardFormatType& format,
+                std::string* result) const override;
+  base::Time GetLastModifiedTime() const override;
+  void ClearLastModifiedTime() override;
+  void WriteObjects(ClipboardType type, const ObjectMap& objects) override;
+  void WriteText(const char* text_data, size_t text_len) override;
+  void WriteHTML(const char* markup_data,
+                 size_t markup_len,
+                 const char* url_data,
+                 size_t url_len) override;
+  void WriteRTF(const char* rtf_data, size_t data_len) override;
+  void WriteBookmark(const char* title_data,
+                     size_t title_len,
+                     const char* url_data,
+                     size_t url_len) override;
+  void WriteWebSmartPaste() override;
+  void WriteBitmap(const SkBitmap& bitmap) override;
+  void WriteData(const ClipboardFormatType& format,
+                 const char* data_data,
+                 size_t data_len) override;
+
+ private:
+  struct DataStore {
+    DataStore();
+    DataStore(const DataStore& other);
+    ~DataStore();
+    void Clear();
+    uint64_t sequence_number;
+    base::flat_map<ClipboardFormatType, std::string> data;
+    std::string url_title;
+    std::string html_b_url;
+    SkBitmap image;
+  };
+
+  // The non-const versions increment the sequence number as a side effect.
+  const DataStore& GetStore(ClipboardType type) const;
+  const DataStore& GetDefaultStore() const;
+  DataStore& GetStore(ClipboardType type);
+  DataStore& GetDefaultStore();
+
+  ClipboardType default_store_type_;
+  mutable base::flat_map<ClipboardType, DataStore> stores_;
+  base::Time last_modified_time_;
+
+  DISALLOW_COPY_AND_ASSIGN(TestClipboard);
+};
+
+}  // namespace ui
+
+#endif  // UI_BASE_CLIPBOARD_TEST_TEST_CLIPBOARD_H_
diff -BbuN a/ui/base/clipboard/test/test_clipboard_unittest.cc b/ui/base/clipboard/test/test_clipboard_unittest.cc
--- a/ui/base/clipboard/test/test_clipboard_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/test/test_clipboard_unittest.cc	2019-01-24 15:42:56.840000000 +0300
@@ -0,0 +1,34 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/clipboard/test/test_clipboard.h"
+
+#include "testing/gtest/include/gtest/gtest.h"
+
+#if defined(USE_AURA)
+#include "ui/events/platform/platform_event_source.h"
+#endif
+
+namespace ui {
+
+struct TestClipboardTraits {
+#if defined(USE_AURA)
+  static std::unique_ptr<PlatformEventSource> GetEventSource() {
+    return nullptr;
+  }
+#endif
+
+  static Clipboard* Create() { return TestClipboard::CreateForCurrentThread(); }
+
+  static void Destroy(Clipboard* clipboard) {
+    ASSERT_EQ(Clipboard::GetForCurrentThread(), clipboard);
+    Clipboard::DestroyClipboardForCurrentThread();
+  }
+};
+
+typedef TestClipboardTraits TypesToTest;
+
+}  // namespace ui
+
+#include "ui/base/clipboard/clipboard_test_template.h"
--- a/ui/base/clipboard/ui_base_clipboard_export.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/ui_base_clipboard_export.h	2019-01-24 15:42:56.848000000 +0300
@@ -0,0 +1,32 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_CLIPBOARD_UI_BASE_CLIPBOARD_EXPORT_H_
+#define UI_BASE_CLIPBOARD_UI_BASE_CLIPBOARD_EXPORT_H_
+
+// Defines UI_BASE_CLIPBOARD_EXPORT so that functionality implemented by the
+// base/clipboard module can be exported to consumers.
+
+#if defined(COMPONENT_BUILD)
+#if defined(WIN32)
+
+#if defined(UI_BASE_CLIPBOARD_IMPLEMENTATION)
+#define UI_BASE_CLIPBOARD_EXPORT __declspec(dllexport)
+#else
+#define UI_BASE_CLIPBOARD_EXPORT __declspec(dllimport)
+#endif  // defined(UI_BASE_CLIPBOARD_IMPLEMENTATION)
+
+#else  // defined(WIN32)
+#if defined(UI_BASE_CLIPBOARD_IMPLEMENTATION)
+#define UI_BASE_CLIPBOARD_EXPORT __attribute__((visibility("default")))
+#else
+#define UI_BASE_CLIPBOARD_EXPORT
+#endif
+#endif
+
+#else  // defined(COMPONENT_BUILD)
+#define UI_BASE_CLIPBOARD_EXPORT
+#endif
+
+#endif  // UI_BASE_CLIPBOARD_UI_BASE_CLIPBOARD_EXPORT_H_
--- a/ui/base/clipboard/ui_base_clipboard_types_export.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/base/clipboard/ui_base_clipboard_types_export.h	2019-01-24 15:42:56.848000000 +0300
@@ -0,0 +1,32 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_CLIPBOARD_UI_BASE_CLIPBOARD_TYPES_EXPORT_H_
+#define UI_BASE_CLIPBOARD_UI_BASE_CLIPBOARD_TYPES_EXPORT_H_
+
+// Defines UI_BASE_CLIPBOARD_TYPES_EXPORT so that functionality implemented by
+// the base/clipboard module can be exported to consumers.
+
+#if defined(COMPONENT_BUILD)
+#if defined(WIN32)
+
+#if defined(UI_BASE_CLIPBOARD_TYPES_IMPLEMENTATION)
+#define UI_BASE_CLIPBOARD_TYPES_EXPORT __declspec(dllexport)
+#else
+#define UI_BASE_CLIPBOARD_TYPES_EXPORT __declspec(dllimport)
+#endif  // defined(UI_BASE_CLIPBOARD_TYPES_IMPLEMENTATION)
+
+#else  // defined(WIN32)
+#if defined(UI_BASE_CLIPBOARD_TYPES_IMPLEMENTATION)
+#define UI_BASE_CLIPBOARD_TYPES_EXPORT __attribute__((visibility("default")))
+#else
+#define UI_BASE_CLIPBOARD_TYPES_EXPORT
+#endif
+#endif
+
+#else  // defined(COMPONENT_BUILD)
+#define UI_BASE_CLIPBOARD_TYPES_EXPORT
+#endif
+
+#endif  // UI_BASE_CLIPBOARD_UI_BASE_CLIPBOARD_TYPES_EXPORT_H_
--- a/ui/ozone/public/platform_clipboard.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/ozone/public/platform_clipboard.h	2019-01-24 15:43:16.336000000 +0300
@@ -0,0 +1,78 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PUBLIC_PLATFORM_CLIPBOARD_H_
+#define UI_OZONE_PUBLIC_PLATFORM_CLIPBOARD_H_
+
+#include <string>
+#include <unordered_map>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/optional.h"
+#include "ui/ozone/ozone_base_export.h"
+
+namespace ui {
+
+// PlatformClipboard is an interface that allows Ozone backends to exchange
+// data with other applications on the host system. The most familiar use for
+// it is handling copy and paste operations.
+//
+class OZONE_BASE_EXPORT PlatformClipboard {
+ public:
+  // DataMap is a map from "mime type" to associated data, whereas
+  // the data can be organized differently for each mime type.
+  using Data = std::vector<uint8_t>;
+  using DataMap = std::unordered_map<std::string, Data>;
+
+  // Offers a given clipboard data 'data_map' to the host system clipboard.
+  //
+  // It is common that host clipboard implementations simply get offered
+  // the set of mime types available for the data being shared. In such cases,
+  // the actual clipboard data is only 'transferred' to the consuming
+  // application asynchronously, upon an explicit request for data given a
+  // specific mime type. This is the case of Wayland compositors and MacOS
+  // (NSPasteboard), for example.
+  //
+  // The invoker assumes the Ozone implementation will not free |DataMap|
+  // before |OfferDataClosure| is called.
+  //
+  // OfferDataClosure should be invoked when the host clipboard implementation
+  // acknowledges that the "offer to clipboard" operation is performed.
+  using OfferDataClosure = base::OnceCallback<void()>;
+  virtual void OfferClipboardData(const DataMap& data_map,
+                                  OfferDataClosure callback) = 0;
+
+  // Reads data from host system clipboard given mime type. The data is
+  // stored in 'data_map'.
+  //
+  // RequestDataClosure is invoked to acknowledge that the requested clipboard
+  // data has been read and stored into 'data_map'.
+  using RequestDataClosure =
+      base::OnceCallback<void(const base::Optional<std::vector<uint8_t>>&)>;
+  virtual void RequestClipboardData(const std::string& mime_type,
+                                    DataMap* data_map,
+                                    RequestDataClosure callback) = 0;
+
+  // Gets the mime types of the data available for clipboard operations
+  // in the host system clipboard.
+  //
+  // GetMimeTypesClosure is invoked when the mime types available for clipboard
+  // operations are known.
+  using GetMimeTypesClosure =
+      base::OnceCallback<void(const std::vector<std::string>&)>;
+  virtual void GetAvailableMimeTypes(GetMimeTypesClosure callback) = 0;
+
+  // Returns true if the current application writing data to the host clipboard
+  // data is this one; false otherwise.
+  //
+  // It can be relevant to know this information in case the client wants to
+  // caches the clipboard data, and wants to know if it is possible to use
+  // the cached data in order to reply faster to read-clipboard operations.
+  virtual bool IsSelectionOwner() = 0;
+};
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PUBLIC_PLATFORM_CLIPBOARD_H_
--- a/ui/platform_window/platform_window_handler/wm_drag_handler.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/platform_window/platform_window_handler/wm_drag_handler.cc	2019-01-24 15:43:16.344000000 +0300
@@ -0,0 +1,25 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/platform_window/platform_window_handler/wm_drag_handler.h"
+
+#include "ui/base/class_property.h"
+#include "ui/platform_window/platform_window.h"
+
+DEFINE_UI_CLASS_PROPERTY_TYPE(ui::WmDragHandler*)
+
+namespace ui {
+
+DEFINE_UI_CLASS_PROPERTY_KEY(WmDragHandler*, kWmDragHandlerKey, nullptr);
+
+void SetWmDragHandler(PlatformWindow* platform_window,
+                      WmDragHandler* drag_handler) {
+  platform_window->SetProperty(kWmDragHandlerKey, drag_handler);
+}
+
+WmDragHandler* GetWmDragHandler(const PlatformWindow& platform_window) {
+  return platform_window.GetProperty(kWmDragHandlerKey);
+}
+
+}  // namespace ui
--- a/ui/platform_window/platform_window_handler/wm_drag_handler.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/platform_window/platform_window_handler/wm_drag_handler.h	2019-01-24 15:43:16.344000000 +0300
@@ -0,0 +1,39 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_PLATFORM_WINDOW_PLATFORM_WINDOW_HANDLER_WM_DRAG_HANDLER_H_
+#define UI_PLATFORM_WINDOW_PLATFORM_WINDOW_HANDLER_WM_DRAG_HANDLER_H_
+
+#include "base/bind.h"
+#include "ui/gfx/native_widget_types.h"
+#include "ui/platform_window/platform_window_handler/wm_platform_export.h"
+
+namespace ui {
+class OSExchangeData;
+class PlatformWindow;
+
+class WM_PLATFORM_EXPORT WmDragHandler {
+ public:
+  // Starts dragging with |data| which it wants to deliver to the destination.
+  // |operation| is the suggested operation which is bitmask of DRAG_NONE,
+  // DRAG_MOVE, DRAG_COPY and DRAG_LINK in DragDropTypes::DragOperation to the
+  // destination and the destination sets the final operation when the drop
+  // action is performed.
+  virtual void StartDrag(const OSExchangeData& data,
+                         int operation,
+                         gfx::NativeCursor cursor,
+                         base::OnceCallback<void(int)> callback) = 0;
+
+ protected:
+  virtual ~WmDragHandler() {}
+};
+
+WM_PLATFORM_EXPORT void SetWmDragHandler(PlatformWindow* platform_window,
+                                         WmDragHandler* drag_handler);
+WM_PLATFORM_EXPORT WmDragHandler* GetWmDragHandler(
+    const PlatformWindow& platform_window);
+
+}  // namespace ui
+
+#endif  // UI_PLATFORM_WINDOW_PLATFORM_WINDOW_HANDLER_WM_DRAG_HANDLER_H_
--- a/ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone.cc	2019-01-24 15:43:27.864000000 +0300
@@ -0,0 +1,110 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone.h"
+
+#include "base/bind.h"
+#include "base/run_loop.h"
+#include "ui/aura/client/capture_client.h"
+#include "ui/aura/client/cursor_client.h"
+#include "ui/aura/window.h"
+#include "ui/aura/window_tree_host.h"
+#include "ui/base/dragdrop/os_exchange_data_provider_aura.h"
+#include "ui/platform_window/platform_window_delegate.h"
+#include "ui/platform_window/platform_window_handler/wm_drag_handler.h"
+#include "ui/views/widget/desktop_aura/desktop_native_cursor_manager.h"
+
+namespace views {
+
+DesktopDragDropClientOzone::DesktopDragDropClientOzone(
+    aura::Window* root_window,
+    views::DesktopNativeCursorManager* cursor_manager,
+    ui::WmDragHandler* drag_handler)
+    : root_window_(root_window),
+      cursor_manager_(cursor_manager),
+      drag_handler_(drag_handler) {}
+
+DesktopDragDropClientOzone::~DesktopDragDropClientOzone() {
+  if (in_move_loop_)
+    DragCancel();
+}
+
+int DesktopDragDropClientOzone::StartDragAndDrop(
+    const ui::OSExchangeData& data,
+    aura::Window* root_window,
+    aura::Window* source_window,
+    const gfx::Point& root_location,
+    int operation,
+    ui::DragDropTypes::DragEventSource source) {
+  if (!drag_handler_)
+    return ui::DragDropTypes::DragOperation::DRAG_NONE;
+
+  DCHECK(!in_move_loop_);
+  base::RunLoop run_loop(base::RunLoop::Type::kNestableTasksAllowed);
+  quit_closure_ = run_loop.QuitClosure();
+
+  // Chrome expects starting drag and drop to release capture.
+  aura::Window* capture_window =
+      aura::client::GetCaptureClient(root_window)->GetGlobalCaptureWindow();
+  if (capture_window)
+    capture_window->ReleaseCapture();
+
+  aura::client::CursorClient* cursor_client =
+      aura::client::GetCursorClient(root_window);
+
+  initial_cursor_ = source_window->GetHost()->last_cursor();
+  drag_operation_ = operation;
+  cursor_client->SetCursor(
+      cursor_manager_->GetInitializedCursor(ui::CursorType::kGrabbing));
+
+  drag_handler_->StartDrag(
+      data, operation, cursor_client->GetCursor(),
+      base::BindOnce(&DesktopDragDropClientOzone::OnDragSessionClosed,
+                     base::Unretained(this)));
+  in_move_loop_ = true;
+  run_loop.Run();
+  DragDropSessionCompleted();
+  return drag_operation_;
+}
+
+void DesktopDragDropClientOzone::DragCancel() {
+  QuitRunLoop();
+}
+
+bool DesktopDragDropClientOzone::IsDragDropInProgress() {
+  return in_move_loop_;
+}
+
+void DesktopDragDropClientOzone::AddObserver(
+    aura::client::DragDropClientObserver* observer) {
+  NOTIMPLEMENTED_LOG_ONCE();
+}
+
+void DesktopDragDropClientOzone::RemoveObserver(
+    aura::client::DragDropClientObserver* observer) {
+  NOTIMPLEMENTED_LOG_ONCE();
+}
+
+void DesktopDragDropClientOzone::OnDragSessionClosed(int dnd_action) {
+  drag_operation_ = dnd_action;
+  QuitRunLoop();
+}
+
+void DesktopDragDropClientOzone::DragDropSessionCompleted() {
+  aura::client::CursorClient* cursor_client =
+      aura::client::GetCursorClient(root_window_);
+  if (!cursor_client)
+    return;
+
+  cursor_client->SetCursor(initial_cursor_);
+}
+
+void DesktopDragDropClientOzone::QuitRunLoop() {
+  in_move_loop_ = false;
+  if (quit_closure_.is_null())
+    return;
+  std::move(quit_closure_).Run();
+}
+
+}  // namespace views
--- a/ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone.h	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone.h	2019-01-24 15:43:27.864000000 +0300
@@ -0,0 +1,66 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_WIDGET_DESKTOP_AURA_DESKTOP_DRAG_DROP_CLIENT_OZONE_H_
+#define UI_VIEWS_WIDGET_DESKTOP_AURA_DESKTOP_DRAG_DROP_CLIENT_OZONE_H_
+
+#include "base/callback.h"
+#include "ui/aura/client/drag_drop_client.h"
+#include "ui/base/cursor/cursor.h"
+#include "ui/platform_window/platform_window_handler/wm_drag_handler.h"
+#include "ui/views/views_export.h"
+
+namespace views {
+class DesktopNativeCursorManager;
+
+class VIEWS_EXPORT DesktopDragDropClientOzone
+    : public aura::client::DragDropClient {
+ public:
+  DesktopDragDropClientOzone(aura::Window* root_window,
+                             views::DesktopNativeCursorManager* cursor_manager,
+                             ui::WmDragHandler* drag_handler);
+  ~DesktopDragDropClientOzone() override;
+
+  void OnDragSessionClosed(int operation);
+
+  // Overridden from aura::client::DragDropClient:
+  int StartDragAndDrop(const ui::OSExchangeData& data,
+                       aura::Window* root_window,
+                       aura::Window* source_window,
+                       const gfx::Point& root_location,
+                       int operation,
+                       ui::DragDropTypes::DragEventSource source) override;
+  void DragCancel() override;
+  bool IsDragDropInProgress() override;
+  void AddObserver(aura::client::DragDropClientObserver* observer) override;
+  void RemoveObserver(aura::client::DragDropClientObserver* observer) override;
+
+ private:
+  void DragDropSessionCompleted();
+  void QuitRunLoop();
+
+  aura::Window* const root_window_;
+
+  DesktopNativeCursorManager* cursor_manager_;
+
+  ui::WmDragHandler* const drag_handler_;
+
+  // Cursor in use prior to the move loop starting. Restored when the move loop
+  // quits.
+  gfx::NativeCursor initial_cursor_;
+
+  base::OnceClosure quit_closure_;
+
+  // The operation bitfield.
+  int drag_operation_ = 0;
+
+  //  The flag that controls whether it has a nested run loop.
+  bool in_move_loop_ = false;
+
+  DISALLOW_COPY_AND_ASSIGN(DesktopDragDropClientOzone);
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_WIDGET_DESKTOP_AURA_DESKTOP_DRAG_DROP_CLIENT_OZONE_H_
--- a/ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone_unittest.cc	1970-01-01 03:00:00.000000000 +0300
+++ b/ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone_unittest.cc	2019-01-24 15:43:27.864000000 +0300
@@ -0,0 +1,121 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/widget/desktop_aura/desktop_drag_drop_client_ozone.h"
+
+#include "base/memory/weak_ptr.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "ui/aura/window.h"
+#include "ui/aura/window_tree_host.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/platform_window/platform_window_handler/wm_drag_handler.h"
+#include "ui/views/test/views_test_base.h"
+#include "ui/views/views_delegate.h"
+#include "ui/views/widget/desktop_aura/desktop_native_cursor_manager.h"
+#include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
+#include "ui/views/widget/desktop_aura/desktop_window_tree_host_platform.h"
+
+namespace views {
+
+namespace {
+
+class FakeWmDragHandler;
+
+// A fake handler, which initiates dragging.
+class FakeWmDragHandler : public ui::WmDragHandler {
+ public:
+  FakeWmDragHandler() : weak_ptr_factory_(this) {}
+  ~FakeWmDragHandler() override = default;
+
+  // ui::WmDragHandler
+  void StartDrag(const OSExchangeData& data,
+                 const int operation,
+                 gfx::NativeCursor cursor,
+                 base::OnceCallback<void(int)> callback) override {
+    callback_ = std::move(callback);
+    base::ThreadTaskRunnerHandle::Get()->PostTask(
+        FROM_HERE, base::BindOnce(
+                       [](base::OnceCallback<void(int)> callback) {
+                         std::move(callback).Run(ui::DragDropTypes::DRAG_COPY);
+                       },
+                       std::move(callback_)));
+  }
+
+ private:
+  base::OnceCallback<void(int)> callback_;
+  base::WeakPtrFactory<FakeWmDragHandler> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(FakeWmDragHandler);
+};
+
+}  // namespace
+
+class DesktopDragDropClientOzoneTest : public ViewsTestBase {
+ public:
+  DesktopDragDropClientOzoneTest() = default;
+  ~DesktopDragDropClientOzoneTest() override = default;
+
+  int StartDragAndDrop() {
+    ui::OSExchangeData data;
+    data.SetString(base::ASCIIToUTF16("Test"));
+    SkBitmap drag_bitmap;
+    drag_bitmap.allocN32Pixels(10, 10);
+    drag_bitmap.eraseARGB(0xFF, 0, 0, 0);
+    gfx::ImageSkia drag_image(gfx::ImageSkia::CreateFrom1xBitmap(drag_bitmap));
+    data.provider().SetDragImage(drag_image, gfx::Vector2d());
+
+    return client_->StartDragAndDrop(
+        data, widget_->GetNativeWindow()->GetRootWindow(),
+        widget_->GetNativeWindow(), gfx::Point(),
+        ui::DragDropTypes::DRAG_COPY | ui::DragDropTypes::DRAG_MOVE,
+        ui::DragDropTypes::DRAG_EVENT_SOURCE_MOUSE);
+  }
+
+  // ViewsTestBase:
+  void SetUp() override {
+    ViewsTestBase::SetUp();
+    test_views_delegate()->set_use_desktop_native_widgets(true);
+
+    // Create widget to initiate the drags.
+    widget_ = std::make_unique<Widget>();
+    Widget::InitParams params(Widget::InitParams::TYPE_WINDOW);
+    params.ownership = Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET;
+    params.native_widget = new DesktopNativeWidgetAura(widget_.get());
+    params.bounds = gfx::Rect(100, 100);
+    widget_->Init(params);
+    widget_->Show();
+
+    aura::Window* window = widget_->GetNativeWindow();
+    cursor_manager_ = std::make_unique<DesktopNativeCursorManager>();
+    drag_handler_ = std::make_unique<FakeWmDragHandler>();
+    client_ = std::make_unique<DesktopDragDropClientOzone>(
+        window, cursor_manager_.get(), drag_handler_.get());
+  }
+
+  void TearDown() override {
+    client_.reset();
+    cursor_manager_.reset();
+    drag_handler_.reset();
+    widget_.reset();
+    ViewsTestBase::TearDown();
+  }
+
+ private:
+  std::unique_ptr<DesktopDragDropClientOzone> client_;
+  std::unique_ptr<DesktopNativeCursorManager> cursor_manager_;
+  std::unique_ptr<FakeWmDragHandler> drag_handler_;
+
+  // The widget used to initiate drags.
+  std::unique_ptr<Widget> widget_;
+
+  DISALLOW_COPY_AND_ASSIGN(DesktopDragDropClientOzoneTest);
+};
+
+TEST_F(DesktopDragDropClientOzoneTest, StartDrag) {
+  int result = StartDragAndDrop();
+  EXPECT_EQ(ui::DragDropTypes::DRAG_COPY, result);
+}
+
+}  // namespace views
