diff --git a/auto-static-autocomplete.c b/auto-static-autocomplete.c
index 71feb38..495fb1e 100644
--- a/tgl/auto-static-autocomplete.c
+++ b/tgl/auto-static-autocomplete.c
@@ -43,6 +43,7 @@ int tglf_extf_autocomplete (struct tgl_state *TLS, const char *text, int text_le
 #ifdef DISABLE_EXTF
   (void) free_vars_to_be_freed;
   assert (0);
+  return 0;
 #else
   if (index == -1) {
     buffer_pos = data;
diff --git a/auto-static-fetch.c b/auto-static-fetch.c
index 437fa1b..86d99cb 100644
--- a/tgl/auto-static-fetch.c
+++ b/tgl/auto-static-fetch.c
@@ -106,6 +106,7 @@ static void print_offset (void) {
 char *tglf_extf_fetch (struct tgl_state *TLS, struct paramed_type *T) {
 #ifdef DISABLE_EXTF
   assert (0);
+  return 0;
 #else
   out_buf_pos = 0;
   if (fetch_type_any (T) < 0) { return 0; }
diff --git a/auto-static-store.c b/auto-static-store.c
index 616c49b..f70f077 100644
--- a/tgl/auto-static-store.c
+++ b/tgl/auto-static-store.c
@@ -253,6 +253,7 @@ void tgl_paramed_type_free (struct paramed_type *P);
 struct paramed_type *tglf_extf_store (struct tgl_state *TLS, const char *data, int data_len) { 
 #ifdef DISABLE_EXTF
   assert (0);
+  return 0;
 #else
   buffer_pos = (char *)data;
   buffer_end = (char *)(data + data_len);
diff --git a/binlog.c b/binlog.c
index 5062551..ec29982 100644
--- a/tgl/binlog.c
+++ b/tgl/binlog.c
@@ -105,7 +105,8 @@ void bl_do_set_auth_key (struct tgl_state *TLS, int num, unsigned char *buf) /*
   assert (num > 0 && num <= MAX_DC_ID);
   assert (TLS->DC_list[num]);
 
-  memcpy (TLS->DC_list[num]->auth_key, buf, 256);
+  if (TLS->DC_list[num]->auth_key != (char *)buf)
+    memcpy (TLS->DC_list[num]->auth_key, buf, 256);
   
   static unsigned char sha1_buffer[20];
   TGLC_sha1 ((void *)TLS->DC_list[num]->auth_key, 256, sha1_buffer);
diff --git a/config.h.in b/config.h.in
index b242e93..ff0bf7d 100644
--- a/tgl/config.h.in
+++ b/tgl/config.h.in
@@ -39,8 +39,7 @@
 /* Define to 1 if you have the <mach/mach.h> header file. */
 #undef HAVE_MACH_MACH_H
 
-/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
-   to 0 otherwise. */
+/* Define to 1 if you have the `malloc' function. */
 #undef HAVE_MALLOC
 
 /* Define to 1 if you have the <malloc.h> header file. */
@@ -64,8 +63,7 @@
 /* Define to 1 if you have the <netinet/in.h> header file. */
 #undef HAVE_NETINET_IN_H
 
-/* Define to 1 if your system has a GNU libc compatible `realloc' function,
-   and to 0 otherwise. */
+/* Define to 1 if you have the `realloc' function. */
 #undef HAVE_REALLOC
 
 /* Define to 1 if you have the `select' function. */
@@ -113,9 +111,6 @@
 /* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H
 
-/* Define to 1 if the system has the `__builtin_bswap32' built-in function */
-#undef HAVE___BUILTIN_BSWAP32
-
 /* Define to the address where bug reports for this package should be sent. */
 #undef PACKAGE_BUGREPORT
 
@@ -153,12 +148,6 @@
 #undef inline
 #endif
 
-/* Define to rpl_malloc if the replacement function should be used. */
-#undef malloc
-
-/* Define to rpl_realloc if the replacement function should be used. */
-#undef realloc
-
 /* Define to `unsigned int' if <sys/types.h> does not define. */
 #undef size_t
 
diff --git a/configure b/configure
index afc0c36..701a5d6 100755
--- a/tgl/configure
+++ b/tgl/configure
@@ -620,9 +620,9 @@ ac_includes_default="\
 #endif"
 
 ac_subst_vars='LTLIBOBJS
+LIBOBJS
 EXTRA_OBJECTS
 EXTRA_LIBS
-LIBOBJS
 EGREP
 GREP
 CPP
@@ -630,6 +630,7 @@ OPENSSL_LDFLAGS
 OPENSSL_LIBS
 OPENSSL_INCLUDES
 PKG_CONFIG
+AR
 OBJEXT
 EXEEXT
 ac_ct_CC
@@ -3099,6 +3100,98 @@ ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ar; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_AR+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$AR"; then
+  ac_cv_prog_AR="$AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_AR="${ac_tool_prefix}ar"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+AR=$ac_cv_prog_AR
+if test -n "$AR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
+$as_echo "$AR" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_AR"; then
+  ac_ct_AR=$AR
+  # Extract the first word of "ar", so it can be a program name with args.
+set dummy ar; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_AR+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_AR"; then
+  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_AR="ar"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_AR=$ac_cv_prog_ac_ct_AR
+if test -n "$ac_ct_AR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
+$as_echo "$ac_ct_AR" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_AR" = x; then
+    AR="as_fn_error $? "No ar found.  Huh?" "$LINENO" 5"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    AR=$ac_ct_AR
+  fi
+else
+  AR="$ac_cv_prog_AR"
+fi
+
 
 # BSD locations for headers and libraries from packages, Linux locations for self-compiled stuff.
 CPPFLAGS="$CPPFLAGS -I/usr/local/include"
@@ -4348,141 +4441,7 @@ esac
 
 
 # Checks for library functions.
-for ac_header in stdlib.h
-do :
-  ac_fn_c_check_header_mongrel "$LINENO" "stdlib.h" "ac_cv_header_stdlib_h" "$ac_includes_default"
-if test "x$ac_cv_header_stdlib_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_STDLIB_H 1
-_ACEOF
-
-fi
-
-done
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU libc compatible malloc" >&5
-$as_echo_n "checking for GNU libc compatible malloc... " >&6; }
-if ${ac_cv_func_malloc_0_nonnull+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then :
-  ac_cv_func_malloc_0_nonnull=no
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#if defined STDC_HEADERS || defined HAVE_STDLIB_H
-# include <stdlib.h>
-#else
-char *malloc ();
-#endif
-
-int
-main ()
-{
-return ! malloc (0);
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
-  ac_cv_func_malloc_0_nonnull=yes
-else
-  ac_cv_func_malloc_0_nonnull=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_func_malloc_0_nonnull" >&5
-$as_echo "$ac_cv_func_malloc_0_nonnull" >&6; }
-if test $ac_cv_func_malloc_0_nonnull = yes; then :
-
-$as_echo "#define HAVE_MALLOC 1" >>confdefs.h
-
-else
-  $as_echo "#define HAVE_MALLOC 0" >>confdefs.h
-
-   case " $LIBOBJS " in
-  *" malloc.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS malloc.$ac_objext"
- ;;
-esac
-
-
-$as_echo "#define malloc rpl_malloc" >>confdefs.h
-
-fi
-
-
-for ac_header in stdlib.h
-do :
-  ac_fn_c_check_header_mongrel "$LINENO" "stdlib.h" "ac_cv_header_stdlib_h" "$ac_includes_default"
-if test "x$ac_cv_header_stdlib_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_STDLIB_H 1
-_ACEOF
-
-fi
-
-done
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU libc compatible realloc" >&5
-$as_echo_n "checking for GNU libc compatible realloc... " >&6; }
-if ${ac_cv_func_realloc_0_nonnull+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then :
-  ac_cv_func_realloc_0_nonnull=no
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#if defined STDC_HEADERS || defined HAVE_STDLIB_H
-# include <stdlib.h>
-#else
-char *realloc ();
-#endif
-
-int
-main ()
-{
-return ! realloc (0, 0);
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
-  ac_cv_func_realloc_0_nonnull=yes
-else
-  ac_cv_func_realloc_0_nonnull=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_func_realloc_0_nonnull" >&5
-$as_echo "$ac_cv_func_realloc_0_nonnull" >&6; }
-if test $ac_cv_func_realloc_0_nonnull = yes; then :
-
-$as_echo "#define HAVE_REALLOC 1" >>confdefs.h
-
-else
-  $as_echo "#define HAVE_REALLOC 0" >>confdefs.h
-
-   case " $LIBOBJS " in
-  *" realloc.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS realloc.$ac_objext"
- ;;
-esac
-
-
-$as_echo "#define realloc rpl_realloc" >>confdefs.h
-
-fi
-
-
-for ac_func in alarm endpwent memset memmove mkdir select socket strdup strndup uname
+for ac_func in alarm endpwent malloc memset memmove mkdir realloc select socket strdup strndup uname
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
diff --git a/configure.ac b/configure.ac
index dab47aa..416c550 100644
--- a/tgl/configure.ac
+++ b/tgl/configure.ac
@@ -8,6 +8,7 @@ m4_include([m4_ax_check_zlib.m4])
 
 # Checks for programs.
 AC_PROG_CC
+AC_CHECK_TOOL(AR, ar, [AC_MSG_ERROR([No ar found.  Huh?])])
 
 # BSD locations for headers and libraries from packages, Linux locations for self-compiled stuff.
 CPPFLAGS="$CPPFLAGS -I/usr/local/include"
@@ -83,9 +84,7 @@ AC_TYPE_UID_T
 AC_C_INLINE
 
 # Checks for library functions.
-AC_FUNC_MALLOC
-AC_FUNC_REALLOC
-AC_CHECK_FUNCS([alarm endpwent memset memmove mkdir select socket strdup strndup uname])
+AC_CHECK_FUNCS([alarm endpwent malloc memset memmove mkdir realloc select socket strdup strndup uname])
 
 AC_SUBST(EXTRA_LIBS)
 AC_SUBST(EXTRA_OBJECTS)
diff --git a/crypto/aes.h b/crypto/aes.h
index f0c61aa..2fddc01 100644
--- a/tgl/crypto/aes.h
+++ b/tgl/crypto/aes.h
@@ -23,7 +23,7 @@
 
 #include <stddef.h> /* size_t */
 
-#include "../config.h"
+#include "config.h"
 
 typedef struct TGLC_aes_key {
   char _dummy[
diff --git a/crypto/aes_altern.c b/crypto/aes_altern.c
index 9f42042..e446065 100644
--- a/tgl/crypto/aes_altern.c
+++ b/tgl/crypto/aes_altern.c
@@ -18,7 +18,7 @@
     Copyright Ben Wiederhake 2015
 */
 
-#include "../config.h"
+#include "config.h"
 
 #ifdef TGL_AVOID_OPENSSL
 
diff --git a/crypto/aes_openssl.c b/crypto/aes_openssl.c
index c6c1840..495099e 100644
--- a/tgl/crypto/aes_openssl.c
+++ b/tgl/crypto/aes_openssl.c
@@ -18,7 +18,7 @@
     Copyright Ben Wiederhake 2015
 */
 
-#include "../config.h"
+#include "config.h"
 
 #ifndef TGL_AVOID_OPENSSL
 
diff --git a/crypto/bn_altern.c b/crypto/bn_altern.c
index e1ae412..73dae46 100644
--- a/tgl/crypto/bn_altern.c
+++ b/tgl/crypto/bn_altern.c
@@ -18,7 +18,7 @@
     Copyright Ben Wiederhake 2015
 */
 
-#include "../config.h"
+#include "config.h"
 
 #ifdef TGL_AVOID_OPENSSL
 
diff --git a/crypto/bn_openssl.c b/crypto/bn_openssl.c
index 73f3c69..c5bd374 100644
--- a/tgl/crypto/bn_openssl.c
+++ b/tgl/crypto/bn_openssl.c
@@ -18,7 +18,7 @@
     Copyright Ben Wiederhake 2015
 */
 
-#include "../config.h"
+#include "config.h"
 
 #ifndef TGL_AVOID_OPENSSL
 
diff --git a/crypto/err.h b/crypto/err.h
index ec6c6f6..efee156 100644
--- a/tgl/crypto/err.h
+++ b/tgl/crypto/err.h
@@ -25,4 +25,10 @@
 
 void TGLC_err_print_errors_fp (FILE *fp);
 
+// Don't want to include tgl.h just for this
+struct tgl_state;
+
+// Init crypto backend, log to TLS
+int TGLC_init (struct tgl_state *TLS);
+
 #endif
diff --git a/crypto/err_altern.c b/crypto/err_altern.c
index 219b161..d8ade14 100644
--- a/tgl/crypto/err_altern.c
+++ b/tgl/crypto/err_altern.c
@@ -18,12 +18,14 @@
     Copyright Ben Wiederhake 2015
 */
 
-#include "../config.h"
+#include "config.h"
 
 #ifdef TGL_AVOID_OPENSSL
 
 #include <gcrypt.h>
 
+#include "../tgl.h"
+#include "../tgl-inner.h"
 #include "err.h"
 
 void TGLC_err_print_errors_fp (FILE *fp) {
@@ -31,4 +33,43 @@ void TGLC_err_print_errors_fp (FILE *fp) {
   (void) fp;
 }
 
+int TGLC_init (struct tgl_state *TLS) {
+  vlogprintf (E_NOTICE, "Init gcrypt\n");
+  // https://gnupg.org/documentation/manuals/gcrypt/Initializing-the-library.html
+  // https://lists.gnupg.org/pipermail/gcrypt-devel/2003-August/000458.html
+
+  if (gcry_control (GCRYCTL_INITIALIZATION_FINISHED_P)) {
+    // Someone else already *completed* it.
+    vlogprintf (E_NOTICE, "Init gcrypt: already initialized -- good\n");
+    return 0;
+  }
+
+  if (gcry_control (GCRYCTL_ANY_INITIALIZATION_P)) {
+    // Someone else already *started* it without *completing*.
+    vlogprintf (E_WARNING, "Init gcrypt: already started *but not completed* by third party -- bad\n");
+    vlogprintf (E_WARNING, "Init gcrypt: ... not trying to init gcrypt then.\n");
+    return 0;
+  }
+
+  if (!gcry_check_version (GCRYPT_VERSION)) {
+    vlogprintf (E_ERROR, "Init gcrypt: version mismatch!\n");
+    return -1;
+  }
+
+  gcry_error_t err = gcry_control (GCRYCTL_DISABLE_SECMEM, NULL, 0);
+  if (err != GPG_ERR_NO_ERROR) {
+    vlogprintf (E_ERROR, "Init gcrypt: secmem failed?!\n");
+    return -1;
+  }
+
+  /* Tell Libgcrypt that initialization has completed. */
+  err = gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);
+  if (err != GPG_ERR_NO_ERROR) {
+    vlogprintf (E_ERROR, "Init gcrypt: init failed?!\n");
+    return -1;
+  }
+
+  return 0;
+}
+
 #endif
diff --git a/crypto/err_openssl.c b/crypto/err_openssl.c
index b9dab5c..b0b2271 100644
--- a/tgl/crypto/err_openssl.c
+++ b/tgl/crypto/err_openssl.c
@@ -18,16 +18,24 @@
     Copyright Ben Wiederhake 2015
 */
 
-#include "../config.h"
+#include "config.h"
 
 #ifndef TGL_AVOID_OPENSSL
 
 #include <openssl/err.h>
 
+#include "../tgl.h"
+#include "../tgl-inner.h"
 #include "err.h"
 
 void TGLC_err_print_errors_fp (FILE *fp) {
   ERR_print_errors_fp (fp);
 }
 
+int TGLC_init (struct tgl_state *TLS) {
+  // Doesn't seem to need any initialization.
+  vlogprintf (6, "Init OpenSSL (no-op)\n");
+  return 0;
+}
+
 #endif
diff --git a/crypto/md5_altern.c b/crypto/md5_altern.c
index 30c3018..0c3ae86 100644
--- a/tgl/crypto/md5_altern.c
+++ b/tgl/crypto/md5_altern.c
@@ -18,7 +18,7 @@
     Copyright Ben Wiederhake 2015
 */
 
-#include "../config.h"
+#include "config.h"
 
 #ifdef TGL_AVOID_OPENSSL
 
diff --git a/crypto/md5_openssl.c b/crypto/md5_openssl.c
index 1ba3c9e..8c82235 100644
--- a/tgl/crypto/md5_openssl.c
+++ b/tgl/crypto/md5_openssl.c
@@ -18,7 +18,7 @@
     Copyright Ben Wiederhake 2015
 */
 
-#include "../config.h"
+#include "config.h"
 
 #ifndef TGL_AVOID_OPENSSL
 
diff --git a/crypto/rand_altern.c b/crypto/rand_altern.c
index aca536f..8c201b1 100644
--- a/tgl/crypto/rand_altern.c
+++ b/tgl/crypto/rand_altern.c
@@ -18,7 +18,7 @@
     Copyright Ben Wiederhake 2015
 */
 
-#include "../config.h"
+#include "config.h"
 
 #ifdef TGL_AVOID_OPENSSL
 
diff --git a/crypto/rand_openssl.c b/crypto/rand_openssl.c
index bb2d504..31f455b 100644
--- a/tgl/crypto/rand_openssl.c
+++ b/tgl/crypto/rand_openssl.c
@@ -18,7 +18,7 @@
     Copyright Ben Wiederhake 2015
 */
 
-#include "../config.h"
+#include "config.h"
 
 #ifndef TGL_AVOID_OPENSSL
 
diff --git a/crypto/rsa_pem_altern.c b/crypto/rsa_pem_altern.c
index ad5aecb..4bfa056 100644
--- a/tgl/crypto/rsa_pem_altern.c
+++ b/tgl/crypto/rsa_pem_altern.c
@@ -18,7 +18,7 @@
     Copyright Ben Wiederhake 2015
 */
 
-#include "../config.h"
+#include "config.h"
 
 #ifdef TGL_AVOID_OPENSSL
 
diff --git a/crypto/rsa_pem_openssl.c b/crypto/rsa_pem_openssl.c
index db653f2..be657b3 100644
--- a/tgl/crypto/rsa_pem_openssl.c
+++ b/tgl/crypto/rsa_pem_openssl.c
@@ -18,7 +18,7 @@
     Copyright Ben Wiederhake 2015
 */
 
-#include "../config.h"
+#include "config.h"
 
 #ifndef TGL_AVOID_OPENSSL
 
@@ -31,6 +31,47 @@
 #include "meta.h"
 #include "rsa_pem.h"
 
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || (defined(LIBRESSL_VERSION_NUMBER) && (LIBRESSL_VERSION_NUMBER < 0x2070000fL))
+
+int RSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d)
+{
+   /* If the fields n and e in r are NULL, the corresponding input
+    * parameters MUST be non-NULL for n and e.  d may be
+    * left NULL (in case only the public key is used).
+    */
+   if ((r->n == NULL && n == NULL)
+       || (r->e == NULL && e == NULL))
+       return 0;
+
+   if (n != NULL) {
+       BN_free(r->n);
+       r->n = n;
+   }
+   if (e != NULL) {
+       BN_free(r->e);
+       r->e = e;
+   }
+   if (d != NULL) {
+       BN_free(r->d);
+       r->d = d;
+   }
+
+   return 1;
+}
+
+void RSA_get0_key(const RSA *r,
+		  const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)
+{
+  if (n != NULL)
+    *n = r->n;
+  if (e != NULL)
+    *e = r->e;
+  if (d != NULL)
+    *d = r->d;
+}
+
+#endif
+
 TGLC_WRAPPER_ASSOC(rsa,RSA)
 
 // TODO: Refactor crucial struct-identity into its own header.
@@ -38,19 +79,23 @@ TGLC_WRAPPER_ASSOC(bn,BIGNUM)
 
 TGLC_rsa *TGLC_rsa_new (unsigned long e, int n_bytes, const unsigned char *n) {
   RSA *ret = RSA_new ();
-  ret->e = unwrap_bn (TGLC_bn_new ());
-  TGLC_bn_set_word (wrap_bn (ret->e), e);
-  ret->n = unwrap_bn (TGLC_bn_bin2bn (n, n_bytes, NULL));
+  TGLC_bn* e_tglcbn = TGLC_bn_new ();
+  TGLC_bn_set_word (e_tglcbn, e);
+  RSA_set0_key(ret, unwrap_bn (TGLC_bn_bin2bn (n, n_bytes, NULL)), unwrap_bn(e_tglcbn), NULL); 
   return wrap_rsa (ret);
 }
 
-#define RSA_GETTER(M)                                                          \
-  TGLC_bn *TGLC_rsa_ ## M (TGLC_rsa *key) {                                    \
-    return wrap_bn (unwrap_rsa (key)->M);                                      \
-  }                                                                            \
+TGLC_bn *TGLC_rsa_n (TGLC_rsa * key) {
+  const BIGNUM *n;
+  RSA_get0_key( unwrap_rsa(key),  &n, NULL, NULL);
+  return wrap_bn(n);		
+}
 
-RSA_GETTER(n);
-RSA_GETTER(e);
+TGLC_bn *TGLC_rsa_e (TGLC_rsa * key) {
+  const BIGNUM *e;
+  RSA_get0_key( unwrap_rsa(key),  NULL, &e, NULL);
+  return wrap_bn(e);		
+}
 
 void TGLC_rsa_free (TGLC_rsa *p) {
   RSA_free (unwrap_rsa (p));
diff --git a/crypto/sha_altern.c b/crypto/sha_altern.c
index 7615cfd..c48a60c 100644
--- a/tgl/crypto/sha_altern.c
+++ b/tgl/crypto/sha_altern.c
@@ -18,7 +18,7 @@
     Copyright Ben Wiederhake 2015
 */
 
-#include "../config.h"
+#include "config.h"
 
 #ifdef TGL_AVOID_OPENSSL
 
diff --git a/crypto/sha_openssl.c b/crypto/sha_openssl.c
index eb40467..6f3390a 100644
--- a/tgl/crypto/sha_openssl.c
+++ b/tgl/crypto/sha_openssl.c
@@ -18,7 +18,7 @@
     Copyright Ben Wiederhake 2015
 */
 
-#include "../config.h"
+#include "config.h"
 
 #ifndef TGL_AVOID_OPENSSL
 
diff --git a/generate.c b/generate.c
index 83d1664..2b005b6 100644
--- a/tgl/generate.c
+++ b/tgl/generate.c
@@ -2307,7 +2307,6 @@ void gen_skip_source (void) {
   printf ("#include <assert.h>\n");
 
   printf ("#include \"auto/auto-skip.h\"\n");
-  printf ("#include \"auto-static-skip.c\"\n");
   printf ("#include \"mtproto-common.h\"\n");
 
   int i, j;
diff --git a/mtproto-client.c b/mtproto-client.c
index 30e36a5..c4be958 100644
--- a/tgl/mtproto-client.c
+++ b/tgl/mtproto-client.c
@@ -678,11 +678,12 @@ static double get_server_time (struct tgl_dc *DC) {
 
 static long long generate_next_msg_id (struct tgl_state *TLS, struct tgl_dc *DC, struct tgl_session *S) {
   long long next_id = (long long) (get_server_time (DC) * (1LL << 32)) & -4;
-  if (next_id <= S->last_msg_id) {
-    next_id = S->last_msg_id  += 4;
+  if (next_id <= TLS->last_msg_id) {
+    next_id = TLS->last_msg_id  += 4;
   } else {
-    S->last_msg_id = next_id;
+    TLS->last_msg_id = next_id;
   }
+  S->last_msg_id = next_id; // See tglmp_encrypt_send_message
   return next_id;
 }
 
@@ -754,7 +755,7 @@ long long tglmp_encrypt_send_message (struct tgl_state *TLS, struct connection *
   assert (l > 0);
   rpc_send_message (TLS, c, &enc_msg, l + UNENCSZ);
 
-  return S->last_msg_id;
+  return S->last_msg_id; // Pray that this was set by generate_next_msg_id somehow
 }
 
 int tglmp_encrypt_inner_temp (struct tgl_state *TLS, struct connection *c, int *msg, int msg_ints, int useful, void *data, long long msg_id) {
diff --git a/mtproto-utils.c b/mtproto-utils.c
index 0948bc8..1fea566 100644
--- a/tgl/mtproto-utils.c
+++ b/tgl/mtproto-utils.c
@@ -98,9 +98,7 @@ static unsigned long long BN2ull (TGLC_bn *b) {
   if (sizeof (unsigned long) == 8) {
     return TGLC_bn_get_word (b);
   } else if (sizeof (unsigned long long) == 8) {
-    assert (0); // As long as nobody ever uses this code, assume it is broken.
     unsigned long long tmp;
-    /* Here be dragons, but it should be okay due to be64toh */
     TGLC_bn_bn2bin (b, (unsigned char *) &tmp);
     return be64toh (tmp);
   } else {
@@ -112,9 +110,7 @@ static void ull2BN (TGLC_bn *b, unsigned long long val) {
   if (sizeof (unsigned long) == 8 || val < (1ll << 32)) {
     TGLC_bn_set_word (b, val);
   } else if (sizeof (unsigned long long) == 8) {
-    assert (0); // As long as nobody ever uses this code, assume it is broken.
-    htobe64(val);
-    /* Here be dragons, but it should be okay due to htobe64 */
+    val = htobe64(val);
     TGLC_bn_bin2bn ((unsigned char *) &val, 8, b);
   } else {
     assert (0);
diff --git a/queries.c b/queries.c
index 5c1c528..58f285b 100644
--- a/tgl/queries.c
+++ b/tgl/queries.c
@@ -31,6 +31,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
+#include <wordexp.h>
 #ifndef WIN32
 #include <sys/utsname.h>
 #endif
@@ -314,7 +315,7 @@ int tglq_query_error (struct tgl_state *TLS, long long id) {
   char *error = fetch_str (error_len);
   struct query *q = tglq_query_get (TLS, id);
   if (!q) {
-    vlogprintf (E_WARNING, "error for query '%s' #%" INT64_PRINTF_MODIFIER "d: #%d :%.*s\n", q->methods->name, id, error_code, error_len, error);
+    vlogprintf (E_WARNING, "error for query ?! #%" INT64_PRINTF_MODIFIER "d: #%d :%.*s\n", id, error_code, error_len, error);
     vlogprintf (E_WARNING, "No such query\n");
   } else {
     if (!(q->flags & QUERY_ACK_RECEIVED)) {
@@ -598,6 +599,20 @@ int utf8_len (const char *s, int len) {
   return r;
 }
 
+static inline char ascii_char_norm (char c) {
+  return (c >= 0x41 && c <= 0x5A) ? c + 32 : c;
+}
+
+static int ascii_cmp_nocase (const char *what, const char *with, size_t num) {
+  size_t i;
+  for (i = 0; i < num; i ++) {
+    if (ascii_char_norm (what[i]) != ascii_char_norm (with[i])) {
+      return 1;
+    }
+  }
+  return 0;
+}
+
 static char *process_html_text (struct tgl_state *TLS, const char *text, int text_len, int *ent_size, int **ent) {
   char *new_text = talloc (2 * text_len + 1);
   int stpos[100];
@@ -619,7 +634,7 @@ static char *process_html_text (struct tgl_state *TLS, const char *text, int tex
         return NULL;
       }
       int old_p = *ent_size;
-      if (text_len - p >= 3 && !memcmp (text + p, "<b>", 3)) {
+      if (text_len - p >= 3 && !ascii_cmp_nocase (text + p, "<b>", 3)) {
         increase_ent (ent_size, ent, 3);
         total ++;
         (*ent)[old_p] = CODE_message_entity_bold;
@@ -630,7 +645,7 @@ static char *process_html_text (struct tgl_state *TLS, const char *text, int tex
         p += 2;
         continue;
       }
-      if (text_len - p >= 4 && !memcmp (text + p, "</b>", 4)) {
+      if (text_len - p >= 4 && !ascii_cmp_nocase (text + p, "</b>", 4)) {
         if (stp == 0 || sttype[stp - 1]  != 0) {
           tgl_set_query_error (TLS, EINVAL, "Invalid tag nest");
           tfree (new_text, 2 * text_len + 1);
@@ -641,7 +656,7 @@ static char *process_html_text (struct tgl_state *TLS, const char *text, int tex
         p += 3;
         continue;
       }
-      if (text_len - p >= 3 && !memcmp (text + p, "<i>", 3)) {
+      if (text_len - p >= 3 && !ascii_cmp_nocase (text + p, "<i>", 3)) {
         increase_ent (ent_size, ent, 3);
         total ++;
         (*ent)[old_p] = CODE_message_entity_italic;
@@ -652,7 +667,7 @@ static char *process_html_text (struct tgl_state *TLS, const char *text, int tex
         p += 2;
         continue;
       }
-      if (text_len - p >= 4 && !memcmp (text + p, "</i>", 4)) {
+      if (text_len - p >= 4 && !ascii_cmp_nocase (text + p, "</i>", 4)) {
         if (stp == 0 || sttype[stp - 1]  != 1) {
           tgl_set_query_error (TLS, EINVAL, "Invalid tag nest");
           tfree (new_text, 2 * text_len + 1);
@@ -663,7 +678,7 @@ static char *process_html_text (struct tgl_state *TLS, const char *text, int tex
         p += 3;
         continue;
       }
-      if (text_len - p >= 6 && !memcmp (text + p, "<code>", 6)) {
+      if (text_len - p >= 6 && !ascii_cmp_nocase (text + p, "<code>", 6)) {
         increase_ent (ent_size, ent, 3);
         total ++;
         (*ent)[old_p] = CODE_message_entity_code;
@@ -674,7 +689,7 @@ static char *process_html_text (struct tgl_state *TLS, const char *text, int tex
         p += 5;
         continue;
       }
-      if (text_len - p >= 7 && !memcmp (text + p, "</code>", 7)) {
+      if (text_len - p >= 7 && !ascii_cmp_nocase (text + p, "</code>", 7)) {
         if (stp == 0 || sttype[stp - 1]  != 2) {
           tgl_set_query_error (TLS, EINVAL, "Invalid tag nest");
           tfree (new_text, 2 * text_len + 1);
@@ -685,12 +700,12 @@ static char *process_html_text (struct tgl_state *TLS, const char *text, int tex
         p += 6;
         continue;
       }
-      if (text_len - p >= 9 && !memcmp (text + p, "<a href=\"", 9)) {
+      if (text_len - p >= 9 && !ascii_cmp_nocase (text + p, "<a href=\"", 9)) {
         int pp = p + 9;
         while (pp < text_len && text[pp] != '"') {
           pp ++;
         }
-        if (pp == text_len || pp == text_len - 1 || text[pp + 1] != '>') {
+        if (pp == text_len || pp == text_len - 1) {
           tgl_set_query_error (TLS, EINVAL, "<a> tag did not close");
           tfree (new_text, 2 * text_len + 1);
           return NULL;
@@ -716,10 +731,13 @@ static char *process_html_text (struct tgl_state *TLS, const char *text, int tex
         memcpy (r + 1, text + p + 9, len);
         memset (r + 1 + len, 0, (-len-1) & 3);
 
-        p = pp + 1;
+        while (pp < text_len && text[pp] != '>') {
+          pp ++;
+        }
+        p = pp;
         continue;
       }
-      if (text_len - p >= 4 && !memcmp (text + p, "</a>", 4)) {
+      if (text_len - p >= 4 && !ascii_cmp_nocase (text + p, "</a>", 4)) {
         if (stp == 0 || sttype[stp - 1]  != 3) {
           tgl_set_query_error (TLS, EINVAL, "Invalid tag nest");
           tfree (new_text, 2 * text_len + 1);
@@ -730,7 +748,7 @@ static char *process_html_text (struct tgl_state *TLS, const char *text, int tex
         p += 3;
         continue;
       }
-      if (text_len - p >= 4 && !memcmp (text + p, "<br>", 4)) {
+      if (text_len - p >= 4 && !ascii_cmp_nocase (text + p, "<br>", 4)) {
         new_text[cur_p ++] = '\n';
         p += 3;
         continue;
@@ -738,16 +756,19 @@ static char *process_html_text (struct tgl_state *TLS, const char *text, int tex
       tgl_set_query_error (TLS, EINVAL, "Unknown tag");
       tfree (new_text, 2 * text_len + 1);
       return NULL;
-    } else if (text_len - p >= 4  && !memcmp (text + p, "&gt;", 4)) {
+    } else if (text_len - p >= 4  && !ascii_cmp_nocase (text + p, "&gt;", 4)) {
       p += 3;
       new_text[cur_p ++] = '>';
-    } else if (text_len - p >= 4  && !memcmp (text + p, "&lt;", 4)) {
+    } else if (text_len - p >= 4  && !ascii_cmp_nocase (text + p, "&lt;", 4)) {
       p += 3;
       new_text[cur_p ++] = '<';
-    } else if (text_len - p >= 5  && !memcmp (text + p, "&amp;", 5)) {
+    } else if (text_len - p >= 5  && !ascii_cmp_nocase (text + p, "&amp;", 5)) {
       p += 4;
       new_text[cur_p ++] = '&';
-    } else if (text_len - p >= 6  && !memcmp (text + p, "&nbsp;", 6)) {
+    } else if (text_len - p >= 6  && !ascii_cmp_nocase (text + p, "&quot;", 6)) {
+      p += 5;
+      new_text[cur_p ++] = '"';
+    } else if (text_len - p >= 6  && !ascii_cmp_nocase (text + p, "&nbsp;", 6)) {
       p += 5;
       new_text[cur_p ++] = 0xc2;
       new_text[cur_p ++] = 0xa0;
@@ -1097,6 +1118,7 @@ void tgl_do_send_msg (struct tgl_state *TLS, struct tgl_message *M, void (*callb
       }
     } else {
       out_int (CODE_reply_keyboard_hide);
+      out_int (M->reply_markup->flags);
     }
   }
 
@@ -1449,7 +1471,9 @@ struct get_history_extra {
   tgl_peer_id_t id;
   int limit;
   int offset;
-  int max_id;
+  int offset_id;
+  int min_id;
+  int is_range;
 };
 
 static void _tgl_do_get_history (struct tgl_state *TLS, struct get_history_extra *E, void (*callback)(struct tgl_state *TLS,void *callback_extra, int success, int size, struct tgl_message *list[]), void *callback_extra);
@@ -1493,10 +1517,16 @@ static int get_history_on_answer (struct tgl_state *TLS, struct query *q, void *
     E->limit = count - E->offset;
     if (E->limit < 0) { E->limit = 0; }
   }
-  assert (E->limit >= 0);
 
+  if (E->is_range > 0) {
+    if (n <= 0) {
+      E->limit = 0; // no messages left in the range
+    } else if (E->ML[E->list_offset - 1] && E->ML[E->list_offset - 1]->permanent_id.id <= E->min_id + 1) {
+      E->limit = 0; // offset_id lower than min_id
+    }
+  }
 
-  if (E->limit <= 0 || DS_MM->magic == CODE_messages_messages || DS_MM->magic == CODE_messages_channel_messages) {
+  if (E->limit <= 0 || DS_MM->magic == CODE_messages_messages) {
     if (q->callback) {
       ((void (*)(struct tgl_state *TLS, void *, int, int, struct tgl_message **))q->callback) (TLS, q->callback_extra, 1, E->list_offset, E->ML);
     }
@@ -1507,8 +1537,9 @@ static int get_history_on_answer (struct tgl_state *TLS, struct query *q, void *
     tfree (E->ML, sizeof (void *) * E->list_size);
     tfree (E, sizeof (*E));
   } else {
+    assert (E->list_offset > 0);
     E->offset = 0;
-    E->max_id = E->ML[E->list_offset - 1]->permanent_id.id;
+    E->offset_id = E->ML[E->list_offset - 1]->permanent_id.id;
     _tgl_do_get_history (TLS, E, q->callback, q->callback_extra);
   }
   return 0;
@@ -1587,11 +1618,11 @@ static void _tgl_do_get_history (struct tgl_state *TLS, struct get_history_extra
     out_int (tgl_get_peer_id (E->id));
     out_long (E->id.access_hash);
   }
-  out_int (E->max_id);
+  out_int (E->offset_id);
   out_int (E->offset);
   out_int (E->limit);
   out_int (0);
-  out_int (0);
+  out_int (E->min_id);
   tglq_send_query (TLS, TLS->DC_working, packet_ptr - packet_buffer, packet_buffer, &get_history_methods, E, callback, callback_extra);
 }
 
@@ -1607,6 +1638,18 @@ void tgl_do_get_history (struct tgl_state *TLS, tgl_peer_id_t id, int offset, in
   E->offset = offset;
   _tgl_do_get_history (TLS, E, callback, callback_extra);
 }
+
+void tgl_do_get_history_range (struct tgl_state *TLS, tgl_peer_id_t id, int min_id, int max_id, int limit, void (*callback)(struct tgl_state *TLS, void *callback_extra, int success, int size, struct tgl_message *list[]), void *callback_extra) {
+
+  struct get_history_extra *E = talloc0 (sizeof (*E));
+  E->id = id;
+  E->limit = limit;
+  E->offset_id = max_id;
+  E->min_id = min_id;
+  E->is_range = 1;
+
+  _tgl_do_get_history (TLS, E, callback, callback_extra);
+}
 /* }}} */
 
 /* {{{ Get dialogs */
@@ -1862,7 +1905,6 @@ static void send_avatar_end (struct tgl_state *TLS, struct send_file *f, void *c
     out_int (CODE_input_chat_uploaded_photo);
     break;
   case TGL_PEER_USER:
-    out_int (CODE_photos_upload_profile_photo);
     out_int (CODE_photos_upload_profile_photo);
     break;
   case TGL_PEER_CHANNEL:
@@ -2079,7 +2121,12 @@ static void send_file_thumb (struct tgl_state *TLS, struct send_file *f, const v
 
 
 static void _tgl_do_send_photo (struct tgl_state *TLS, tgl_peer_id_t to_id, const char *file_name, tgl_peer_id_t avatar, int w, int h, int duration, const void *thumb_data, int thumb_len, const char *caption, int caption_len, unsigned long long flags, void (*callback)(struct tgl_state *TLS, void *callback_extra, int success, struct tgl_message *M), void *callback_extra) {
-  int fd = open (file_name, O_RDONLY | O_BINARY);
+  wordexp_t wrdexp;
+  int status = wordexp(file_name,&wrdexp,0);
+  int fd=-1;
+  if(status == 0)
+    fd = open (wrdexp.we_wordv[0], O_RDONLY | O_BINARY);
+  wordfree(&wrdexp);
   if (fd < 0) {
     tgl_set_query_error (TLS, EBADF, "Can not open file: %s", strerror(errno));
     if (!avatar.peer_id) {
@@ -2088,7 +2135,7 @@ static void _tgl_do_send_photo (struct tgl_state *TLS, tgl_peer_id_t to_id, cons
       }
     } else {
       if (callback) {
-        ((void (*)(struct tgl_state *, void *, int))callback) (TLS, callback_extra, 0);
+        ((void (*)(struct tgl_state *, void *, int, struct tgl_message*))callback) (TLS, callback_extra, 0, NULL);
       }
     }
     return;
@@ -2105,7 +2152,7 @@ static void _tgl_do_send_photo (struct tgl_state *TLS, tgl_peer_id_t to_id, cons
       }
     } else {
       if (callback) {
-        ((void (*)(struct tgl_state *, void *, int))callback) (TLS, callback_extra, 0);
+        ((void (*)(struct tgl_state *, void *, int, struct tgl_message*))callback) (TLS, callback_extra, 0, NULL);
       }
     }
     return;
@@ -2138,7 +2185,7 @@ static void _tgl_do_send_photo (struct tgl_state *TLS, tgl_peer_id_t to_id, cons
       }
     } else {
       if (callback) {
-        ((void (*)(struct tgl_state *, void *, int))callback) (TLS, callback_extra, 0);
+        ((void (*)(struct tgl_state *, void *, int, struct tgl_message*))callback) (TLS, callback_extra, 0, NULL);
       }
     }
     return;
@@ -2528,7 +2575,7 @@ void tgl_do_send_contact (struct tgl_state *TLS, tgl_peer_id_t id, const char *p
   out_cstring (last_name, last_name_len);
 
   struct messages_send_extra *E = talloc0 (sizeof (*E));
-  tglt_secure_random (&E->id, 8);
+  E->id = tgl_peer_id_to_random_msg_id (id);
   out_long (E->id.id);
 
   tglq_send_query (TLS, TLS->DC_working, packet_ptr - packet_buffer, packet_buffer, &send_msgs_methods, E, callback, callback_extra);
@@ -2899,6 +2946,9 @@ void _tgl_do_channel_get_members  (struct tgl_state *TLS, struct channel_get_mem
   case 3:
     out_int (CODE_channel_participants_kicked);
     break;
+  case 4:
+    out_int (CODE_channel_participants_bots);
+    break;
   default:
     out_int (CODE_channel_participants_recent);
     break;
@@ -3205,7 +3255,7 @@ static void load_next_part (struct tgl_state *TLS, struct download *D, void *cal
       l = tsnprintf (buf, sizeof (buf), "%s/download_%" INT64_PRINTF_MODIFIER "d_%d.jpg", TLS->downloads_directory, D->volume, D->local_id);
     } else {
       if (D->ext) {
-        l = tsnprintf (buf, sizeof (buf), "%s/download_%" INT64_PRINTF_MODIFIER "d.%s", TLS->downloads_directory, D->id, D->ext);
+	l = tsnprintf (buf, sizeof (buf), "%s/%s" , TLS->downloads_directory, D->name);
       } else {
         l = tsnprintf (buf, sizeof (buf), "%s/download_%" INT64_PRINTF_MODIFIER "d", TLS->downloads_directory, D->id);
       }
@@ -3301,6 +3351,13 @@ void tgl_do_load_file_location (struct tgl_state *TLS, struct tgl_file_location
 }
 
 void tgl_do_load_photo (struct tgl_state *TLS, struct tgl_photo *photo, void (*callback)(struct tgl_state *TLS, void *callback_extra, int success, const char *filename), void *callback_extra) {
+  if (!photo) {
+    tgl_set_query_error (TLS, EINVAL, "Bad photo (invalid)");
+    if (callback) {
+      callback (TLS, callback_extra, 0, 0);
+    }
+    return;
+  }
   if (!photo->sizes_num) {
     tgl_set_query_error (TLS, EINVAL, "Bad photo (no photo sizes");
     if (callback) {
@@ -3331,7 +3388,7 @@ static void _tgl_do_load_document (struct tgl_state *TLS, struct tgl_document *V
   D->id = V->id;
   D->access_hash = V->access_hash;
   D->dc = V->dc_id;
-  D->name = 0;
+  D->name = V->caption;
   D->fd = -1;
   
   if (V->mime_type) {
@@ -3743,13 +3800,14 @@ static int get_difference_on_answer (struct tgl_state *TLS, struct query *q, voi
     }
 
     for (i = 0; i < ml_pos; i++) {
+      // Ignore invalid messages, would cause a null ptr deref otherwise
+      if (ML[i] == NULL) continue;
       bl_do_msg_update (TLS, &ML[i]->permanent_id);
     }
     for (i = 0; i < el_pos; i++) {
       // messages to secret chats that no longer exist are not initialized and NULL
-      if (EL[i]) {
-        bl_do_msg_update (TLS, &EL[i]->permanent_id);
-      }
+      if (EL[i] == NULL) continue;
+      bl_do_msg_update (TLS, &EL[i]->permanent_id);
     }
 
     tfree (ML, ml_pos * sizeof (void *));
diff --git a/scheme.tl b/scheme.tl
index fc1af95..2d89fbc 100644
--- a/tgl/scheme.tl
+++ b/tgl/scheme.tl
@@ -451,7 +451,7 @@ chatInviteEmpty#69df3769 = ExportedChatInvite;
 chatInviteExported#fc2e05bc link:string = ExportedChatInvite;
 
 chatInviteAlready#5a686d7c chat:Chat = ChatInvite;
-chatInvite#93e99b60 flags:# channel:flags.0?true broadcast:flags.1?true public:flags.2?true megagroup:flags.3?true title:string = ChatInvite;
+chatInvite#93e99b60 flags:# channel:flags.0?true broadcast:flags.1?true public_:flags.2?true megagroup:flags.3?true title:string = ChatInvite;
 
 inputStickerSetEmpty#ffb62b95 = InputStickerSet;
 inputStickerSetID#9de7a269 id:long access_hash:long = InputStickerSet;
@@ -720,4 +720,4 @@ channels.leaveChannel#f836aa95 channel:InputChannel = Updates;
 channels.inviteToChannel#199f3a6c channel:InputChannel users:Vector<InputUser> = Updates;
 channels.kickFromChannel#a672de14 channel:InputChannel user_id:InputUser kicked:Bool = Updates;
 channels.exportInvite#c7560885 channel:InputChannel = ExportedChatInvite;
-channels.deleteChannel#c0111fe3 channel:InputChannel = Updates;
+channels.deleteChannel#c0111fe3 channel:InputChannel = Updates;
\ No newline at end of file
diff --git a/structures.c b/structures.c
index 3ccdfc0..290cc18 100644
--- a/tgl/structures.c
+++ b/tgl/structures.c
@@ -1,4 +1,4 @@
-/* 
+/*
     This file is part of tgl-library
 
     This library is free software; you can redistribute it and/or
@@ -173,7 +173,7 @@ tgl_peer_id_t tglf_fetch_peer_id (struct tgl_state *TLS, struct tl_ds_peer *DS_P
     return TGL_MK_CHAT (DS_LVAL (DS_P->chat_id));
   case CODE_peer_channel:
     return TGL_MK_CHANNEL (DS_LVAL (DS_P->channel_id));
-  default: 
+  default:
     assert (0);
     exit (2);
   }
@@ -275,11 +275,11 @@ struct tgl_user *tglf_fetch_alloc_user (struct tgl_state *TLS, struct tl_ds_user
   if (!DS_U) { return 0; }
   if (DS_U->magic == CODE_user_empty) {
     return 0;
-  } 
-  
-  tgl_peer_id_t user_id = TGL_MK_USER (DS_LVAL (DS_U->id));  
+  }
+
+  tgl_peer_id_t user_id = TGL_MK_USER (DS_LVAL (DS_U->id));
   user_id.access_hash = DS_LVAL (DS_U->access_hash);
-  
+
   struct tgl_user *U = (struct tgl_user *)tgl_peer_get (TLS, user_id);
   if (!U) {
     TLS->users_allocated ++;
@@ -289,7 +289,7 @@ struct tgl_user *tglf_fetch_alloc_user (struct tgl_state *TLS, struct tl_ds_user
     increase_peer_size (TLS);
     TLS->Peers[TLS->peer_num ++] = (tgl_peer_t *)U;
   }
-  
+
   int flags = U->flags;
 
   if (DS_LVAL (DS_U->flags) & (1 << 10)) {
@@ -298,34 +298,36 @@ struct tgl_user *tglf_fetch_alloc_user (struct tgl_state *TLS, struct tl_ds_user
   } else {
     flags &= ~TGLUF_SELF;
   }
-  
+
   if (DS_LVAL (DS_U->flags) & (1 << 11)) {
     flags |= TGLUF_CONTACT;
   } else {
     flags &= ~TGLUF_CONTACT;
   }
-  
+
   if (DS_LVAL (DS_U->flags) & (1 << 12)) {
     flags |= TGLUF_MUTUAL_CONTACT;
   } else {
     flags &= ~TGLUF_MUTUAL_CONTACT;
   }
-  
-  
+
+
   if (DS_LVAL (DS_U->flags) & (1 << 14)) {
     flags |= TGLUF_BOT;
+    U->bot = 1;
   } else {
     flags &= ~TGLUF_BOT;
+    U->bot = 0;
   }
   /*
   if (DS_LVAL (DS_U->flags) & (1 << 15)) {
     flags |= TGLUF_BOT_FULL_ACCESS;
   }
-  
+
   if (DS_LVAL (DS_U->flags) & (1 << 16)) {
     flags |= TGLUF_BOT_NO_GROUPS;
   }*/
-  
+
   if (DS_LVAL (DS_U->flags) & (1 << 17)) {
     flags |= TGLUF_OFFICIAL;
   } else {
@@ -336,10 +338,10 @@ struct tgl_user *tglf_fetch_alloc_user (struct tgl_state *TLS, struct tl_ds_user
     flags |= TGLUF_CREATE | TGLUF_CREATED;
   }
 
-  bl_do_user (TLS, tgl_get_peer_id (U->id), 
+  bl_do_user (TLS, tgl_get_peer_id (U->id),
     DS_U->access_hash,
-    DS_STR (DS_U->first_name), 
-    DS_STR (DS_U->last_name), 
+    DS_STR (DS_U->first_name),
+    DS_STR (DS_U->last_name),
     DS_STR (DS_U->phone),
     DS_STR (DS_U->username),
     NULL,
@@ -348,17 +350,17 @@ struct tgl_user *tglf_fetch_alloc_user (struct tgl_state *TLS, struct tl_ds_user
     NULL,
     flags
   );
-  
+
   if (DS_U->status) {
     assert (tglf_fetch_user_status (TLS, &U->status, U, DS_U->status) >= 0);
   }
-  
+
   if (DS_LVAL (DS_U->flags) & (1 << 13)) {
     if (!(U->flags & TGLUF_DELETED)) {
       bl_do_peer_delete (TLS, U->id);
     }
   }
-  
+
   return U;
 }
 
@@ -369,16 +371,16 @@ struct tgl_user *tglf_fetch_alloc_user_full (struct tgl_state *TLS, struct tl_ds
   if (!U) { return NULL; }
 
   int flags = U->flags;
-  
+
   if (DS_BVAL (DS_UF->blocked)) {
     flags |= TGLUF_BLOCKED;
   } else {
     flags &= ~TGLUF_BLOCKED;
   }
 
-  bl_do_user (TLS, tgl_get_peer_id (U->id), 
+  bl_do_user (TLS, tgl_get_peer_id (U->id),
     NULL,
-    NULL, 0, 
+    NULL, 0,
     NULL, 0,
     NULL, 0,
     NULL, 0,
@@ -416,9 +418,9 @@ struct tgl_secret_chat *tglf_fetch_alloc_encrypted_chat (struct tgl_state *TLS,
     return NULL;
   }
 
-  tgl_peer_id_t chat_id = TGL_MK_ENCR_CHAT (DS_LVAL (DS_EC->id));  
+  tgl_peer_id_t chat_id = TGL_MK_ENCR_CHAT (DS_LVAL (DS_EC->id));
   chat_id.access_hash = DS_LVAL (DS_EC->access_hash);
-  
+
   struct tgl_secret_chat *U = (void *)tgl_peer_get (TLS, chat_id);
   if (!U) {
     TLS->encr_chats_allocated ++;
@@ -428,9 +430,9 @@ struct tgl_secret_chat *tglf_fetch_alloc_encrypted_chat (struct tgl_state *TLS,
     increase_peer_size (TLS);
     TLS->Peers[TLS->peer_num ++] = (tgl_peer_t *)U;
   }
-  
+
   int new = !(U->flags & TGLPF_CREATED);
- 
+
   if (DS_EC->magic == CODE_encrypted_chat_discarded) {
     if (new) {
       vlogprintf (E_WARNING, "Unknown chat in deleted state. May be we forgot something...\n");
@@ -449,57 +451,57 @@ struct tgl_secret_chat *tglf_fetch_alloc_encrypted_chat (struct tgl_state *TLS,
     }
 
     str_to_256 (g_key, DS_STR (DS_EC->g_a));
- 
+
     int user_id =  DS_LVAL (DS_EC->participant_id) + DS_LVAL (DS_EC->admin_id) - tgl_get_peer_id (TLS->our_id);
     int r = sc_request;
-    bl_do_encr_chat (TLS, tgl_get_peer_id (U->id), 
+    bl_do_encr_chat (TLS, tgl_get_peer_id (U->id),
       DS_EC->access_hash,
       DS_EC->date,
       DS_EC->admin_id,
       &user_id,
-      NULL, 
+      NULL,
       (void *)g_key,
       NULL,
-      &r, 
-      NULL, NULL, NULL, NULL, NULL, 
-      NULL, 
+      &r,
+      NULL, NULL, NULL, NULL, NULL,
+      NULL,
       TGLECF_CREATE | TGLECF_CREATED,
       NULL, 0
     );
   } else {
     if (DS_EC->magic == CODE_encrypted_chat_waiting) {
       int r = sc_waiting;
-      bl_do_encr_chat (TLS, tgl_get_peer_id (U->id), 
+      bl_do_encr_chat (TLS, tgl_get_peer_id (U->id),
         DS_EC->access_hash,
         DS_EC->date,
         NULL,
         NULL,
-        NULL, 
         NULL,
         NULL,
-        &r, 
-        NULL, NULL, NULL, NULL, NULL, 
-        NULL, 
+        NULL,
+        &r,
+        NULL, NULL, NULL, NULL, NULL,
+        NULL,
         TGL_FLAGS_UNCHANGED,
         NULL, 0
       );
       return U; // We needed only access hash from here
     }
-    
+
     str_to_256 (g_key, DS_STR (DS_EC->g_a_or_b));
-    
+
     //write_secret_chat_file ();
     int r = sc_ok;
-    bl_do_encr_chat (TLS, tgl_get_peer_id (U->id), 
+    bl_do_encr_chat (TLS, tgl_get_peer_id (U->id),
       DS_EC->access_hash,
       DS_EC->date,
       NULL,
       NULL,
-      NULL, 
+      NULL,
       g_key,
       NULL,
-      &r, 
-      NULL, NULL, NULL, NULL, NULL, 
+      &r,
+      NULL, NULL, NULL, NULL, NULL,
       DS_EC->key_fingerprint,
       TGL_FLAGS_UNCHANGED,
       NULL, 0
@@ -511,15 +513,15 @@ struct tgl_secret_chat *tglf_fetch_alloc_encrypted_chat (struct tgl_state *TLS,
 
 struct tgl_chat *tglf_fetch_alloc_chat (struct tgl_state *TLS, struct tl_ds_chat *DS_C) {
   if (!DS_C) { return NULL; }
-  if (DS_C->magic == CODE_chat_empty) { 
+  if (DS_C->magic == CODE_chat_empty) {
     return NULL;
   }
   if (DS_C->magic == CODE_channel || DS_C->magic == CODE_channel_forbidden) {
     return (void *)tglf_fetch_alloc_channel (TLS, DS_C);
   }
-  tgl_peer_id_t chat_id = TGL_MK_CHAT (DS_LVAL (DS_C->id));  
+  tgl_peer_id_t chat_id = TGL_MK_CHAT (DS_LVAL (DS_C->id));
   chat_id.access_hash = 0; // chats don't have access hash
-  
+
   struct tgl_chat *C = (void *)tgl_peer_get (TLS, chat_id);
   if (!C) {
     TLS->chats_allocated ++;
@@ -529,9 +531,9 @@ struct tgl_chat *tglf_fetch_alloc_chat (struct tgl_state *TLS, struct tl_ds_chat
     increase_peer_size (TLS);
     TLS->Peers[TLS->peer_num ++] = (tgl_peer_t *)C;
   }
-  
+
   C->id = chat_id;
-  
+
   int flags = C->flags;
   if (!(flags & TGLCF_CREATED)) {
     flags |= TGLCF_CREATE | TGLCF_CREATED;
@@ -575,7 +577,7 @@ struct tgl_chat *tglf_fetch_alloc_chat (struct tgl_state *TLS, struct tl_ds_chat
 
   bl_do_chat (TLS, tgl_get_peer_id (C->id),
     DS_STR (DS_C->title),
-    DS_C->participants_count, 
+    DS_C->participants_count,
     DS_C->date,
     NULL,
     NULL,
@@ -593,7 +595,7 @@ struct tgl_chat *tglf_fetch_alloc_chat_full (struct tgl_state *TLS, struct tl_ds
   if (DS_MCF->full_chat->magic == CODE_channel_full) {
     return (void *)tglf_fetch_alloc_channel_full (TLS, DS_MCF);
   }
- 
+
   if (DS_MCF->users) {
     int i;
     for (i = 0; i < DS_LVAL (DS_MCF->users->cnt); i++) {
@@ -607,7 +609,7 @@ struct tgl_chat *tglf_fetch_alloc_chat_full (struct tgl_state *TLS, struct tl_ds
       tglf_fetch_alloc_chat (TLS, DS_MCF->chats->data[i]);
     }
   }
-  
+
   struct tl_ds_chat_full *DS_CF = DS_MCF->full_chat;
 
   if (DS_CF->bot_info) {
@@ -618,9 +620,9 @@ struct tgl_chat *tglf_fetch_alloc_chat_full (struct tgl_state *TLS, struct tl_ds
 
       tgl_peer_t *P = tgl_peer_get (TLS, TGL_MK_USER (DS_LVAL (DS_BI->user_id)));
       if (P && (P->flags & TGLCF_CREATED)) {
-        bl_do_user (TLS, tgl_get_peer_id (P->id), 
+        bl_do_user (TLS, tgl_get_peer_id (P->id),
             NULL,
-            NULL, 0, 
+            NULL, 0,
             NULL, 0,
             NULL, 0,
             NULL, 0,
@@ -634,13 +636,13 @@ struct tgl_chat *tglf_fetch_alloc_chat_full (struct tgl_state *TLS, struct tl_ds
     }
   }
 
-  tgl_peer_id_t chat_id = TGL_MK_CHAT (DS_LVAL (DS_CF->id));  
+  tgl_peer_id_t chat_id = TGL_MK_CHAT (DS_LVAL (DS_CF->id));
   struct tgl_chat *C = (void *)tgl_peer_get (TLS, chat_id);
   assert (C);
 
   bl_do_chat (TLS, tgl_get_peer_id (C->id),
     NULL, 0,
-    NULL, 
+    NULL,
     NULL,
     DS_CF->participants->version,
     (struct tl_ds_vector *)DS_CF->participants->participants,
@@ -657,9 +659,9 @@ struct tgl_chat *tglf_fetch_alloc_chat_full (struct tgl_state *TLS, struct tl_ds
 
 struct tgl_channel *tglf_fetch_alloc_channel (struct tgl_state *TLS, struct tl_ds_chat *DS_C) {
   if (!DS_C) { return NULL; }
-  
-  tgl_peer_id_t chat_id = TGL_MK_CHANNEL (DS_LVAL (DS_C->id));  
-  chat_id.access_hash = DS_LVAL (DS_C->access_hash); 
+
+  tgl_peer_id_t chat_id = TGL_MK_CHANNEL (DS_LVAL (DS_C->id));
+  chat_id.access_hash = DS_LVAL (DS_C->access_hash);
 
   struct tgl_channel *C = (void *)tgl_peer_get (TLS, chat_id);
   if (!C) {
@@ -670,14 +672,14 @@ struct tgl_channel *tglf_fetch_alloc_channel (struct tgl_state *TLS, struct tl_d
     increase_peer_size (TLS);
     TLS->Peers[TLS->peer_num ++] = (tgl_peer_t *)C;
   }
-  
+
   C->id = chat_id;
-  
+
   int flags = C->flags;
   if (!(flags & TGLCHF_CREATED)) {
     flags |= TGLCHF_CREATE | TGLCHF_CREATED;
   }
-  
+
   if (DS_LVAL (DS_C->flags) & 1) {
     flags |= TGLCHF_CREATOR;
   } else {
@@ -744,7 +746,7 @@ struct tgl_channel *tglf_fetch_alloc_channel (struct tgl_state *TLS, struct tl_d
 
 struct tgl_channel *tglf_fetch_alloc_channel_full (struct tgl_state *TLS, struct tl_ds_messages_chat_full *DS_MCF) {
   if (!DS_MCF) { return NULL; }
-  
+
   if (DS_MCF->users) {
     int i;
     for (i = 0; i < DS_LVAL (DS_MCF->users->cnt); i++) {
@@ -795,7 +797,7 @@ void tglf_fetch_photo_size (struct tgl_state *TLS, struct tgl_photo_size *S, str
     S->size = DS_PS->bytes->len;
   }
 
-  tglf_fetch_file_location (TLS, &S->loc, DS_PS->location); 
+  tglf_fetch_file_location (TLS, &S->loc, DS_PS->location);
 }
 
 void tglf_fetch_geo (struct tgl_state *TLS, struct tgl_geo *G, struct tl_ds_geo_point *DS_GP) {
@@ -806,7 +808,7 @@ void tglf_fetch_geo (struct tgl_state *TLS, struct tgl_geo *G, struct tl_ds_geo_
 struct tgl_photo *tglf_fetch_alloc_photo (struct tgl_state *TLS, struct tl_ds_photo *DS_P) {
   if (!DS_P) { return NULL; }
   if (DS_P->magic == CODE_photo_empty) { return NULL; }
-  
+
   struct tgl_photo *P = tgl_photo_get (TLS, DS_LVAL (DS_P->id));
   if (P) {
     P->refcnt ++;
@@ -817,7 +819,7 @@ struct tgl_photo *tglf_fetch_alloc_photo (struct tgl_state *TLS, struct tl_ds_ph
   P = talloc0 (sizeof (*P));
   P->id = DS_LVAL (DS_P->id);
   P->refcnt = 1;
-  
+
   tgl_photo_insert (TLS, P);
 
   P->access_hash = DS_LVAL (DS_P->access_hash);
@@ -827,7 +829,7 @@ struct tgl_photo *tglf_fetch_alloc_photo (struct tgl_state *TLS, struct tl_ds_ph
   /*if (DS_P->geo) {
     tglf_fetch_geo (TLS, &P->geo, DS_P->geo);
   }*/
-  
+
   P->sizes_num = DS_LVAL (DS_P->sizes->cnt);
   P->sizes = talloc (sizeof (struct tgl_photo_size) * P->sizes_num);
   int i;
@@ -840,9 +842,9 @@ struct tgl_photo *tglf_fetch_alloc_photo (struct tgl_state *TLS, struct tl_ds_ph
 
 struct tgl_document *tglf_fetch_alloc_video (struct tgl_state *TLS, struct tl_ds_video *DS_V) {
   if (!DS_V) { return NULL; }
-  
+
   if (DS_V->magic == CODE_video_empty) { return NULL; }
-  
+
   struct tgl_document *D = tgl_document_get (TLS, DS_LVAL (DS_V->id));
   if (D) {
     D->refcnt ++;
@@ -853,7 +855,7 @@ struct tgl_document *tglf_fetch_alloc_video (struct tgl_state *TLS, struct tl_ds
   D = talloc0 (sizeof (*D));
   D->id = DS_LVAL (DS_V->id);
   D->refcnt = 1;
-  
+
   tgl_document_insert (TLS, D);
 
   D->flags = TGLDF_VIDEO;
@@ -875,9 +877,9 @@ struct tgl_document *tglf_fetch_alloc_video (struct tgl_state *TLS, struct tl_ds
 
 struct tgl_document *tglf_fetch_alloc_audio (struct tgl_state *TLS, struct tl_ds_audio *DS_A) {
   if (!DS_A) { return NULL; }
-  
+
   if (DS_A->magic == CODE_audio_empty) { return NULL; }
-  
+
   struct tgl_document *D = tgl_document_get (TLS, DS_LVAL (DS_A->id));
   if (D) {
     D->refcnt ++;
@@ -888,11 +890,11 @@ struct tgl_document *tglf_fetch_alloc_audio (struct tgl_state *TLS, struct tl_ds
   D = talloc0 (sizeof (*D));
   D->id = DS_LVAL (DS_A->id);
   D->refcnt = 1;
-  
+
   tgl_document_insert (TLS, D);
-  
+
   D->flags = TGLDF_AUDIO;
-  
+
   D->access_hash = DS_LVAL (DS_A->access_hash);
   //D->user_id = DS_LVAL (DS_A->user_id);
   D->date = DS_LVAL (DS_A->date);
@@ -937,9 +939,9 @@ void tglf_fetch_document_attribute (struct tgl_state *TLS, struct tgl_document *
 
 struct tgl_document *tglf_fetch_alloc_document (struct tgl_state *TLS, struct tl_ds_document *DS_D) {
   if (!DS_D) { return NULL; }
-  
+
   if (DS_D->magic == CODE_document_empty) { return NULL; }
-  
+
   struct tgl_document *D = tgl_document_get (TLS, DS_LVAL (DS_D->id));
   if (D) {
     D->refcnt ++;
@@ -950,7 +952,7 @@ struct tgl_document *tglf_fetch_alloc_document (struct tgl_state *TLS, struct tl
   D = talloc0 (sizeof (*D));
   D->id = DS_LVAL (DS_D->id);
   D->refcnt = 1;
-  
+
   tgl_document_insert (TLS, D);
 
   D->access_hash = DS_LVAL (DS_D->access_hash);
@@ -974,7 +976,7 @@ struct tgl_document *tglf_fetch_alloc_document (struct tgl_state *TLS, struct tl
 
 struct tgl_webpage *tglf_fetch_alloc_webpage (struct tgl_state *TLS, struct tl_ds_web_page *DS_W) {
   if (!DS_W) { return NULL; }
-  
+
   struct tgl_webpage *W = tgl_webpage_get (TLS, DS_LVAL (DS_W->id));
   if (W) {
     W->refcnt ++;
@@ -982,7 +984,7 @@ struct tgl_webpage *tglf_fetch_alloc_webpage (struct tgl_state *TLS, struct tl_d
     W = talloc0 (sizeof (*W));
     W->id = DS_LVAL (DS_W->id);
     W->refcnt = 1;
-  
+
     tgl_webpage_insert (TLS, W);
   }
 
@@ -994,7 +996,7 @@ struct tgl_webpage *tglf_fetch_alloc_webpage (struct tgl_state *TLS, struct tl_d
     W->display_url = DS_STR_DUP (DS_W->display_url);
   }
 
-  if (!W->type) { 
+  if (!W->type) {
     W->type = DS_STR_DUP (DS_W->type);
   }
 
@@ -1037,7 +1039,7 @@ struct tgl_webpage *tglf_fetch_alloc_webpage (struct tgl_state *TLS, struct tl_d
 void tglf_fetch_message_action (struct tgl_state *TLS, struct tgl_message_action *M, struct tl_ds_message_action *DS_MA) {
   if (!DS_MA) { return; }
   memset (M, 0, sizeof (*M));
-  
+
   switch (DS_MA->magic) {
   case CODE_message_action_empty:
     M->type = tgl_message_action_none;
@@ -1055,7 +1057,7 @@ void tglf_fetch_message_action (struct tgl_state *TLS, struct tgl_message_action
     {
       M->type = tgl_message_action_chat_create;
       M->title = DS_STR_DUP (DS_MA->title);
-    
+
       M->user_num = DS_LVAL (DS_MA->users->cnt);
       M->users = talloc (M->user_num * 4);
       int i;
@@ -1100,6 +1102,7 @@ void tglf_fetch_message_action (struct tgl_state *TLS, struct tgl_message_action
     break;
   case CODE_message_action_chat_migrate_to:
     M->type = tgl_message_action_migrated_to;
+    M->channel_id = DS_LVAL (DS_MA->channel_id);
     break;
   case CODE_message_action_channel_migrate_from:
     M->type = tgl_message_action_migrated_from;
@@ -1116,7 +1119,7 @@ struct tgl_message *tglf_fetch_alloc_message_short (struct tgl_state *TLS, struc
     tgl_do_get_difference (TLS, 0, 0, 0);
     return NULL;
   }
-  
+
   tgl_message_id_t msg_id = tgl_peer_id_to_msg_id (P->id, DS_LVAL (DS_U->id));
   struct tgl_message *M = tgl_message_get (TLS, &msg_id);
   if (!M) {
@@ -1129,7 +1132,7 @@ struct tgl_message *tglf_fetch_alloc_message_short (struct tgl_state *TLS, struc
   }
 
   int flags = M->flags & 0xffff;
-  
+
   if (M->flags & TGLMF_PENDING) {
     M->flags ^= TGLMF_PENDING;
   }
@@ -1163,7 +1166,7 @@ struct tgl_message *tglf_fetch_alloc_message_short (struct tgl_state *TLS, struc
     fwd_from_id = TGL_MK_USER (0);
   }
 
-  bl_do_edit_message (TLS, &msg_id, 
+  bl_do_edit_message (TLS, &msg_id,
     (f & 2) ? &our_id : &peer_id,
     (f & 2) ? &peer_id : &our_id,
     DS_U->fwd_from_id ? &fwd_from_id : NULL,
@@ -1173,7 +1176,7 @@ struct tgl_message *tglf_fetch_alloc_message_short (struct tgl_state *TLS, struc
     &A,
     NULL,
     DS_U->reply_to_msg_id,
-    NULL, 
+    NULL,
     (void *)DS_U->entities,
     flags
   );
@@ -1191,7 +1194,7 @@ struct tgl_message *tglf_fetch_alloc_message_short_chat (struct tgl_state *TLS,
     tgl_do_get_difference (TLS, 0, 0, 0);
     return NULL;
   }
-  
+
   tgl_message_id_t msg_id = tgl_peer_id_to_msg_id (T->id, DS_LVAL (DS_U->id));
   struct tgl_message *M = tgl_message_get (TLS, &msg_id);
   if (!M) {
@@ -1202,7 +1205,7 @@ struct tgl_message *tglf_fetch_alloc_message_short_chat (struct tgl_state *TLS,
   }
 
   int flags = M->flags & 0xffff;
-  
+
   if (M->flags & TGLMF_PENDING) {
     M->flags ^= TGLMF_PENDING;
   }
@@ -1303,13 +1306,14 @@ void tglf_fetch_message_media (struct tgl_state *TLS, struct tgl_message_media *
     M->venue.title = DS_STR_DUP (DS_MM->title);
     M->venue.address = DS_STR_DUP (DS_MM->address);
     M->venue.provider = DS_STR_DUP (DS_MM->provider);
-    M->venue.venue_id = DS_STR_DUP (DS_MM->venue_id);   
+    M->venue.venue_id = DS_STR_DUP (DS_MM->venue_id);
     break;
   case CODE_message_media_unsupported:
     M->type = tgl_message_media_unsupported;
     break;
   default:
-    assert (0);
+    M->type = tgl_message_media_unsupported;
+    break;
   }
 }
 
@@ -1329,9 +1333,9 @@ void tglf_fetch_message_media_encrypted (struct tgl_state *TLS, struct tgl_messa
   case CODE_decrypted_message_media_audio:
     //M->type = CODE_decrypted_message_media_video;
     M->type = tgl_message_media_document_encr;
-    
+
     M->encr_document = talloc0 (sizeof (*M->encr_document));
-  
+
     switch (DS_DMM->magic) {
     case CODE_decrypted_message_media_photo:
       M->encr_document->flags = TGLDF_IMAGE;
@@ -1347,13 +1351,13 @@ void tglf_fetch_message_media_encrypted (struct tgl_state *TLS, struct tgl_messa
       M->encr_document->flags = TGLDF_AUDIO;
       break;
     }
-    
+
     M->encr_document->w = DS_LVAL (DS_DMM->w);
     M->encr_document->h = DS_LVAL (DS_DMM->h);
     M->encr_document->size = DS_LVAL (DS_DMM->size);
     M->encr_document->duration = DS_LVAL (DS_DMM->duration);
     M->encr_document->mime_type = DS_STR_DUP (DS_DMM->mime_type);
-   
+
     M->encr_document->key = talloc (32);
     str_to_32 (M->encr_document->key, DS_STR (DS_DMM->key));
     M->encr_document->iv = talloc (32);
@@ -1378,17 +1382,17 @@ void tglf_fetch_message_media_encrypted (struct tgl_state *TLS, struct tgl_messa
 
 void tglf_fetch_message_action_encrypted (struct tgl_state *TLS, struct tgl_message_action *M, struct tl_ds_decrypted_message_action *DS_DMA) {
   if (!DS_DMA) { return; }
-  
+
   switch (DS_DMA->magic) {
   case CODE_decrypted_message_action_set_message_t_t_l:
     M->type = tgl_message_action_set_message_ttl;
     M->ttl = DS_LVAL (DS_DMA->ttl_seconds);
     break;
-  case CODE_decrypted_message_action_read_messages: 
+  case CODE_decrypted_message_action_read_messages:
     M->type = tgl_message_action_read_messages;
-    { 
+    {
       M->read_cnt = DS_LVAL (DS_DMA->random_ids->cnt);
-      
+
       int i;
       for (i = 0; i < M->read_cnt; i++) {
         tgl_message_id_t id;
@@ -1401,16 +1405,16 @@ void tglf_fetch_message_action_encrypted (struct tgl_state *TLS, struct tgl_mess
       }
     }
     break;
-  case CODE_decrypted_message_action_delete_messages: 
+  case CODE_decrypted_message_action_delete_messages:
     M->type = tgl_message_action_delete_messages;
     break;
-  case CODE_decrypted_message_action_screenshot_messages: 
+  case CODE_decrypted_message_action_screenshot_messages:
     M->type = tgl_message_action_screenshot_messages;
-    { 
+    {
       M->screenshot_cnt = DS_LVAL (DS_DMA->random_ids->cnt);
     }
     break;
-  case CODE_decrypted_message_action_notify_layer: 
+  case CODE_decrypted_message_action_notify_layer:
     M->type = tgl_message_action_notify_layer;
     M->layer = DS_LVAL (DS_DMA->layer);
     break;
@@ -1431,14 +1435,14 @@ void tglf_fetch_message_action_encrypted (struct tgl_state *TLS, struct tgl_mess
     break;
   case CODE_decrypted_message_action_request_key:
     M->type = tgl_message_action_request_key;
-    
+
     M->exchange_id = DS_LVAL (DS_DMA->exchange_id);
     M->g_a = talloc (256);
     str_to_256 (M->g_a, DS_STR (DS_DMA->g_a));
     break;
   case CODE_decrypted_message_action_accept_key:
     M->type = tgl_message_action_accept_key;
-    
+
     M->exchange_id = DS_LVAL (DS_DMA->exchange_id);
     M->g_a = talloc (256);
     str_to_256 (M->g_a, DS_STR (DS_DMA->g_b));
@@ -1446,13 +1450,13 @@ void tglf_fetch_message_action_encrypted (struct tgl_state *TLS, struct tgl_mess
     break;
   case CODE_decrypted_message_action_commit_key:
     M->type = tgl_message_action_commit_key;
-    
+
     M->exchange_id = DS_LVAL (DS_DMA->exchange_id);
     M->key_fingerprint = DS_LVAL (DS_DMA->key_fingerprint);
     break;
   case CODE_decrypted_message_action_abort_key:
     M->type = tgl_message_action_abort_key;
-    
+
     M->exchange_id = DS_LVAL (DS_DMA->exchange_id);
     break;
   default:
@@ -1518,11 +1522,11 @@ struct tgl_message *tglf_fetch_alloc_message (struct tgl_state *TLS, struct tl_d
     *new_msg = 0;
   }
   //assert (0);
-  if (!DS_M || DS_M->magic == CODE_message_empty) { 
+  if (!DS_M || DS_M->magic == CODE_message_empty) {
     vlogprintf (E_NOTICE, "empty message\n");
-    return NULL; 
+    return NULL;
   }
-  
+
   tgl_peer_id_t to_id = tglf_fetch_peer_id (TLS, DS_M->to_id);
   tgl_peer_t *T = tgl_peer_get (TLS, to_id);
   if (!T || !(T->flags & TGLPF_CREATED)) {
@@ -1544,7 +1548,7 @@ struct tgl_message *tglf_fetch_alloc_message (struct tgl_state *TLS, struct tl_d
       P = F;
     }
   }
-  
+
   tgl_peer_t *FF = NULL;
 
   if (DS_M->fwd_from_id) {
@@ -1584,14 +1588,14 @@ struct tgl_message *tglf_fetch_alloc_message (struct tgl_state *TLS, struct tl_d
     if (DS_LVAL (DS_M->flags) & 16) {
       flags |= TGLMF_MENTION;
     }
-  
+
     tgl_peer_id_t from_id;
     if (DS_M->from_id) {
       from_id = F->id;
     } else {
       from_id = TGL_MK_USER (0);
     }
-  
+
     tgl_peer_id_t to_id = T->id;
 
     tgl_peer_id_t fwd_from_id;
@@ -1630,7 +1634,7 @@ static int decrypt_encrypted_message (struct tgl_secret_chat *E) {
   static unsigned char sha1b_buffer[20];
   static unsigned char sha1c_buffer[20];
   static unsigned char sha1d_buffer[20];
- 
+
   static unsigned char buf[64];
 
   int *e_key = E->exchange_state != tgl_sce_committed ? E->key : E->exchange_key;
@@ -1638,16 +1642,16 @@ static int decrypt_encrypted_message (struct tgl_secret_chat *E) {
   memcpy (buf, msg_key, 16);
   memcpy (buf + 16, e_key, 32);
   TGLC_sha1 (buf, 48, sha1a_buffer);
-  
+
   memcpy (buf, e_key + 8, 16);
   memcpy (buf + 16, msg_key, 16);
   memcpy (buf + 32, e_key + 12, 16);
   TGLC_sha1 (buf, 48, sha1b_buffer);
-  
+
   memcpy (buf, e_key + 16, 32);
   memcpy (buf + 32, msg_key, 16);
   TGLC_sha1 (buf, 48, sha1c_buffer);
-  
+
   memcpy (buf, msg_key, 16);
   memcpy (buf + 16, e_key + 24, 32);
   TGLC_sha1 (buf, 48, sha1d_buffer);
@@ -1683,7 +1687,7 @@ static int decrypt_encrypted_message (struct tgl_secret_chat *E) {
 
 struct tgl_message *tglf_fetch_encrypted_message (struct tgl_state *TLS, struct tl_ds_encrypted_message *DS_EM) {
   if (!DS_EM) { return NULL; }
-  
+
   tgl_peer_t *P = tgl_peer_get (TLS, TGL_MK_ENCR_CHAT (DS_LVAL (DS_EM->chat_id)));
   if (!P || P->encr_chat.state != sc_ok) {
     vlogprintf (E_WARNING, "Encrypted message to unknown chat. Dropping\n");
@@ -1707,31 +1711,31 @@ struct tgl_message *tglf_fetch_encrypted_message (struct tgl_state *TLS, struct
 
   decr_ptr = (void *)DS_EM->bytes->data;
   decr_end = decr_ptr + (DS_EM->bytes->len / 4);
-  
+
   if (P->encr_chat.exchange_state == tgl_sce_committed && P->encr_chat.key_fingerprint == *(long long *)decr_ptr) {
     tgl_do_confirm_exchange (TLS, (void *)P, 0);
     assert (P->encr_chat.exchange_state == tgl_sce_none);
   }
-  
+
   long long key_fingerprint = P->encr_chat.exchange_state != tgl_sce_committed ? P->encr_chat.key_fingerprint : P->encr_chat.exchange_key_fingerprint;
   if (*(long long *)decr_ptr != key_fingerprint) {
     vlogprintf (E_WARNING, "Encrypted message with bad fingerprint to chat %s\n", P->print_name);
     return M;
   }
-  
+
   decr_ptr += 2;
 
   if (decrypt_encrypted_message (&P->encr_chat) < 0) {
     vlogprintf (E_WARNING, "can not decrypt message\n");
     return M;
   }
-  
+
   int *save_in_ptr = in_ptr;
   int *save_in_end = in_end;
-    
+
   in_ptr = decr_ptr;
   int ll = *in_ptr;
-  in_end = in_ptr + ll / 4 + 1;  
+  in_end = in_ptr + ll / 4 + 1;
   assert (fetch_int () == ll);
 
   if (skip_type_decrypted_message_layer (TYPE_TO_PARAM (decrypted_message_layer)) < 0 || in_ptr != in_end) {
@@ -1767,8 +1771,8 @@ struct tgl_message *tglf_fetch_encrypted_message (struct tgl_state *TLS, struct
     free_ds_type_decrypted_message_layer (DS_DML, TYPE_TO_PARAM(decrypted_message_layer));
     return M;
   }
-  
-  if ((in_seq_no & 1)  != 1 - (P->encr_chat.admin_id == tgl_get_peer_id (TLS->our_id)) || 
+
+  if ((in_seq_no & 1)  != 1 - (P->encr_chat.admin_id == tgl_get_peer_id (TLS->our_id)) ||
       (out_seq_no & 1) != (P->encr_chat.admin_id == tgl_get_peer_id (TLS->our_id))) {
     vlogprintf (E_WARNING, "Bad msg admin\n");
     free_ds_type_decrypted_message_layer (DS_DML, TYPE_TO_PARAM(decrypted_message_layer));
@@ -1808,7 +1812,7 @@ struct tgl_message *tglf_fetch_encrypted_message (struct tgl_state *TLS, struct
     );
     assert (P->encr_chat.in_seq_no == in_seq_no);
   }
-  
+
   free_ds_type_decrypted_message_layer (DS_DML, TYPE_TO_PARAM(decrypted_message_layer));
   return M;
 }
@@ -1899,7 +1903,7 @@ struct tgl_message *tglf_fetch_alloc_encrypted_message (struct tgl_state *TLS, s
       );
     }
     if (M->action.type == tgl_message_action_set_message_ttl) {
-      //bl_do_encr_chat_set_ttl (TLS, E, M->action.ttl);      
+      //bl_do_encr_chat_set_ttl (TLS, E, M->action.ttl);
       bl_do_encr_chat (TLS, tgl_get_peer_id (E->id),
         NULL, NULL, NULL, NULL,
         NULL, NULL, NULL, NULL,
@@ -2041,7 +2045,7 @@ void tgls_free_document (struct tgl_state *TLS, struct tgl_document *D) {
   if (D->mime_type) { tfree_str (D->mime_type);}
   if (D->caption) {tfree_str (D->caption);}
   tgls_free_photo_size (TLS, &D->thumb);
-  
+
   TLS->document_tree = tree_delete_document (TLS->document_tree, D);
   tfree (D, sizeof (*D));
 }
@@ -2061,7 +2065,7 @@ void tgls_free_webpage (struct tgl_state *TLS, struct tgl_webpage *W) {
   if (W->embed_url) { tfree_str (W->embed_url); }
   if (W->embed_type) { tfree_str (W->embed_type); }
   if (W->author) { tfree_str (W->author); }
-  
+
   TLS->webpage_tree = tree_delete_webpage (TLS->webpage_tree, W);
   tfree (W, sizeof (*W));
 }
@@ -2072,7 +2076,7 @@ void tgls_free_message_media (struct tgl_state *TLS, struct tgl_message_media *M
   case tgl_message_media_geo:
     return;
   case tgl_message_media_photo:
-    tgls_free_photo (TLS, M->photo);
+    if (M->photo) { tgls_free_photo (TLS, M->photo); }
     if (M->caption) { tfree_str (M->caption); }
     M->photo = NULL;
     return;
@@ -2181,7 +2185,7 @@ void tgls_clear_message (struct tgl_state *TLS, struct tgl_message *M) {
   tfree (M->entities, M->entities_num * sizeof (struct tgl_message_entity));
 }
 
-void tgls_free_reply_markup (struct tgl_state *TLS, struct tgl_message_reply_markup *R) { 
+void tgls_free_reply_markup (struct tgl_state *TLS, struct tgl_message_reply_markup *R) {
   if (!--R->refcnt) {
     int i;
     for (i = 0; i < R->row_start[R->rows]; i++) {
@@ -2229,7 +2233,7 @@ void tgls_free_user (struct tgl_state *TLS, struct tgl_user *U) {
 
 void tgls_free_encr_chat (struct tgl_state *TLS, struct tgl_secret_chat *U) {
   if (U->print_name) { tfree_str (U->print_name); }
-  if (U->g_key) { tfree (U->g_key, 256); } 
+  if (U->g_key) { tfree (U->g_key, 256); }
   tfree (U, sizeof (tgl_peer_t));
 }
 
@@ -2325,7 +2329,7 @@ void tglm_message_add_peer (struct tgl_state *TLS, struct tgl_message *M) {
         N = N->next;
       }
       if (N) {
-        assert (N->permanent_id.id < M->permanent_id.id); 
+        assert (N->permanent_id.id < M->permanent_id.id);
       }
       M->next = N;
       M->prev = NP;
@@ -2571,11 +2575,22 @@ void tgls_free_message_gw (struct tgl_message *M, void *TLS) {
   tgls_free_message (TLS, M);
 }
 
+void tgls_remove_message_gw (struct tgl_state *TLS, struct tgl_message *M) {
+  if (tree_lookup_message (TLS->message_unsent_tree, M)) {
+      tglm_message_remove_unsent (TLS, M);
+  }
+}
+
+void tgls_remove_and_free_message_gw (struct tgl_message *M, void *TLS) {
+  tgls_remove_message_gw (TLS, M);
+  tgls_free_message (TLS, M);
+}
+
 void tgl_free_all (struct tgl_state *TLS) {
   tree_act_ex_peer (TLS->peer_tree, tgls_free_peer_gw, TLS);
   TLS->peer_tree = tree_clear_peer (TLS->peer_tree);
   TLS->peer_by_name_tree = tree_clear_peer_by_name (TLS->peer_by_name_tree);
-  tree_act_ex_message (TLS->message_tree, tgls_free_message_gw, TLS);
+  tree_act_ex_message (TLS->message_tree, tgls_remove_and_free_message_gw, TLS);
   TLS->message_tree = tree_clear_message (TLS->message_tree);
   tree_act_ex_message (TLS->message_unsent_tree, tgls_free_message_gw, TLS);
   TLS->message_unsent_tree = tree_clear_message (TLS->message_unsent_tree);
@@ -2616,7 +2631,7 @@ void tgl_free_all (struct tgl_state *TLS) {
 }
 
 int tgl_print_stat (struct tgl_state *TLS, char *s, int len) {
-  return tsnprintf (s, len, 
+  return tsnprintf (s, len,
     "users_allocated\t%d\n"
     "chats_allocated\t%d\n"
     "encr_chats_allocated\t%d\n"
@@ -2647,13 +2662,13 @@ void tglf_fetch_int_tuple (int *dst, int **src, int len) {
 
 
 void tgls_messages_mark_read (struct tgl_state *TLS, struct tgl_message *M, int out, int seq) {
-  while (M && M->permanent_id.id > seq) { 
+  while (M && M->permanent_id.id > seq) {
     if ((M->flags & TGLMF_OUT) == out) {
       if (!(M->flags & TGLMF_UNREAD)) {
         return;
       }
     }
-    M = M->next; 
+    M = M->next;
   }
   while (M) {
     if ((M->flags & TGLMF_OUT) == out) {
@@ -2664,10 +2679,10 @@ void tgls_messages_mark_read (struct tgl_state *TLS, struct tgl_message *M, int
         return;
       }
     }
-    M = M->next; 
+    M = M->next;
   }
 }
- 
+
 /*
 void tgls_insert_random2local (struct tgl_state *TLS, long long random_id, tgl_message_id_t *msg_id) {
   struct random2local *X = talloc (sizeof (*X));
@@ -2676,7 +2691,7 @@ void tgls_insert_random2local (struct tgl_state *TLS, long long random_id, tgl_m
 
   struct random2local *R = tree_lookup_random_id (TLS->random_id_tree, X);
   assert (!R);
-  
+
   TLS->random_id_tree = tree_insert_random_id (TLS->random_id_tree, X, rand ());
 }
 
@@ -2684,14 +2699,14 @@ tgl_message_id_t *tgls_get_local_by_random (struct tgl_state *TLS, long long ran
   struct random2local X;
   X.random_id = random_id;
   struct random2local *Y = tree_lookup_random_id (TLS->random_id_tree, &X);
-  if (Y) { 
+  if (Y) {
     //TLS->random_id_tree = tree_delete_random_id (TLS->random_id_tree, Y);
     return &Y->local_id;
   } else {
     return NULL;
   }
 }
-  
+
 void tgls_insert_temp2local (struct tgl_state *TLS, int temp_id, tgl_message_id_t *msg_id) {
   struct random2local *X = talloc (sizeof (*X));
   X->random_id = temp_id;
@@ -2699,7 +2714,7 @@ void tgls_insert_temp2local (struct tgl_state *TLS, int temp_id, tgl_message_id_
 
   struct random2local *R = tree_lookup_random_id (TLS->temp_id_tree, X);
   assert (!R);
-  
+
   TLS->temp_id_tree = tree_insert_random_id (TLS->temp_id_tree, X, rand ());
 }
 }*/
diff --git a/tgl-layout.h b/tgl-layout.h
index c821668..9829b88 100644
--- a/tgl/tgl-layout.h
+++ b/tgl/tgl-layout.h
@@ -1,4 +1,4 @@
-/* 
+/*
     This file is part of tgl-library
 
     This library is free software; you can redistribute it and/or
@@ -120,9 +120,9 @@
 #define TGL_PERMANENT_ID_SIZE 24
 #pragma pack(push,4)
 
-typedef struct { 
-  int peer_type; 
-  int peer_id; 
+typedef struct {
+  int peer_type;
+  int peer_id;
   long long access_hash;
 } tgl_peer_id_t;
 
@@ -144,7 +144,7 @@ enum tgl_dc_state {
 struct tgl_session {
   struct tgl_dc *dc;
   long long session_id;
-  long long last_msg_id;
+  long long last_msg_id; // See tglmp_encrypt_send_message
   int seq_no;
   int received_messages;
   struct connection *c;
@@ -309,7 +309,7 @@ struct tgl_encr_document {
   int size;
   int key_fingerprint;
   int flags;
-  
+
   unsigned char *key;
   unsigned char *iv;
   int w;
@@ -361,7 +361,7 @@ struct tgl_user {
   int blocked;
   char *real_first_name;
   char *real_last_name;
-
+  int bot;
   struct tgl_bot_info *bot_info;
 };
 
@@ -531,6 +531,7 @@ struct tgl_message_action {
     int read_cnt;
     int delete_cnt;
     int screenshot_cnt;
+    int channel_id;
     enum tgl_typing_status typing;
     struct {
       int start_seq_no;
@@ -573,7 +574,7 @@ struct tgl_message_media {
       };
       char *caption;
     };
-    
+
     struct tgl_encr_document *encr_document;
     struct tgl_webpage *webpage;
 
@@ -584,7 +585,7 @@ struct tgl_message_media {
       char *last_name;
       int user_id;
     };
-    
+
     struct {
       void *data;
       int data_size;
@@ -599,13 +600,13 @@ struct tgl_message_media {
   };
 };
 
-struct tgl_message_reply_markup {
+typedef struct tgl_message_reply_markup {
   int refcnt;
   int flags;
   int rows;
   int *row_start;
   char **buttons;
-};
+} tgl_message_reply_markup;
 
 typedef struct tgl_message_id {
   unsigned peer_type;
diff --git a/tgl-queries.h b/tgl-queries.h
index 3921455..0fdd26b 100644
--- a/tgl/tgl-queries.h
+++ b/tgl/tgl-queries.h
@@ -3,6 +3,10 @@
 
 #include "tgl.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 void tgl_do_get_terms_of_service (struct tgl_state *TLS, void (*callback)(struct tgl_state *TLS, void *callback_extra, int success, const char *ans), void *callback_extra);
 
 /* {{{ WORK WITH ACCOUNT */
@@ -121,7 +125,7 @@ void tgl_do_export_chat_link (struct tgl_state *TLS, tgl_peer_id_t id, void (*ca
 // joins to secret chat by link (or hash of this link)
 void tgl_do_import_chat_link (struct tgl_state *TLS, const char *link, int link_len, void (*callback)(struct tgl_state *TLS, void *callback_extra, int success), void *callback_extra);
 
-// upgrades chat to channel. 
+// upgrades chat to channel.
 void tgl_do_upgrade_group (struct tgl_state *TLS, tgl_peer_id_t id, void (*callback)(struct tgl_state *TLS, void *callback_extra, int success), void *callback_extra);
 /* }}} */
 
@@ -236,6 +240,12 @@ void tgl_do_messages_mark_read (struct tgl_state *TLS, tgl_peer_id_t id, int max
 // also marks messages from this chat as read
 void tgl_do_get_history (struct tgl_state *TLS, tgl_peer_id_t id, int offset, int limit, int offline_mode, void (*callback)(struct tgl_state *TLS, void *callback_extra, int success, int size, struct tgl_message *list[]), void *callback_extra);
 
+// like tgl_do_get_history, but will fetch any messages between *min_id* and *max_id*
+// when *limit* is too small, the older messages will not be displayed despite being bigger than *min_id*
+// when *max_id* is 0, all messages newer than *min_id* are fetched
+// when *min_id* is 0, all messages older than *max_id* are fetched
+void tgl_do_get_history_range (struct tgl_state *TLS, tgl_peer_id_t id, int min_id, int max_id, int limit, void (*callback)(struct tgl_state *TLS, void *callback_extra, int success, int size, struct tgl_message *list[]), void *callback_extra);
+
 // sends typing event to chat
 // set status=tgl_typing_typing for default typing event
 void tgl_do_send_typing (struct tgl_state *TLS, tgl_peer_id_t id, enum tgl_typing_status status, void (*callback)(struct tgl_state *TLS, void *callback_extra, int success), void *callback_extra);
@@ -293,4 +303,8 @@ char *tglf_extf_fetch (struct tgl_state *TLS, struct paramed_type *T);
 void tgl_do_start_bot (struct tgl_state *TLS, tgl_peer_id_t bot, tgl_peer_id_t chat, const char *str, int str_len, void (*callback)(struct tgl_state *TLS, void *callback_extra, int success), void *callback_extra);
 /* }}} */
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif
diff --git a/tgl.c b/tgl.c
index 5234747..187f74d 100644
--- a/tgl/tgl.c
+++ b/tgl/tgl.c
@@ -22,6 +22,7 @@
 #include "config.h"
 #endif
 
+#include "crypto/err.h"
 #include "crypto/rsa_pem.h"
 #include "tgl.h"
 #include "tools.h"
@@ -82,10 +83,14 @@ int tgl_init (struct tgl_state *TLS) {
   TLS->message_list.next_use = &TLS->message_list;
   TLS->message_list.prev_use = &TLS->message_list;
 
+  if (TGLC_init (TLS) != 0) {
+    return -1;
+  }
+
   if (tglmp_on_start (TLS) < 0) {
     return -1;
   }
-  
+
   if (!TLS->app_id) {
     TLS->app_id = TG_APP_ID;
     TLS->app_hash = tstrdup (TG_APP_HASH);
diff --git a/tgl.h b/tgl.h
index 3314240..70dab53 100644
--- a/tgl/tgl.h
+++ b/tgl/tgl.h
@@ -210,7 +210,7 @@ struct tgl_state {
   long long rsa_key_fingerprint[TGL_MAX_RSA_KEYS_NUM];
   int rsa_key_num;
 
-  TGLC_bn_ctx *TGLC_bn_ctx;
+  struct TGLC_bn_ctx *TGLC_bn_ctx;
 
   struct tgl_allocator *allocator;
 
@@ -264,6 +264,7 @@ struct tgl_state {
   int is_bot;
 
   int last_temp_id;
+  long long last_msg_id;
 };
 #pragma pack(pop)
 //extern struct tgl_state tgl_state;
